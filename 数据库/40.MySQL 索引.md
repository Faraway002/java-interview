# MySQL 索引

索引是提高 MySQL 查询性能的一个重要途径，但**过多的索引可能会导致过高的磁盘使用率以及过高的内存占用**，从而影响应用程序的整体性能。

应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的 SQL 才能定位到问题所在，而且**后期添加索引的时间肯定是远大于初始添加索引所需要的时间**，可见索引的添加也是非常有技术含量的。

## 索引简介

**索引优化应该是查询性能优化的最有效手段**。

### 索引的优缺点

索引的优点：

- 索引大大减少了服务器需要扫描的数据量，从而加快检索速度。
- 支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。使用索引可以减少访问的行数，从而减少锁的竞争，提高并发。
- 索引可以帮助服务器避免排序和临时表。
- 索引可以将随机 I/O 变为顺序 I/O。
- 唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。

索引的缺点：

- 创建和维护索引要耗费时间，这会随着数据量的增加而增加。
- **索引需要占用额外的物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。
- 写操作（`INSERT` / `UPDATE` / `DELETE`）时很可能需要更新索引，导致数据库的写操作性能降低。

### 何时使用索引

什么情况**适用**索引：

- 表经常进行 `SELECT` 操作。
- 表的数据量比较大。
- 列名经常出现在 `WHERE` 或连接（`JOIN`）条件中。

什么情况**不适用**索引：

- **频繁写操作**（ `INSERT`/`UPDATE`/`DELETE` ），此时需要频繁更新索引空间。
- **非常小的表**，对于非常小的表，大部分情况下简单的全表扫描更高效。
- 列名不经常出现在 `WHERE` 或连接（`JOIN`）条件中，索引就会经常不命中，没有意义，还增加空间开销。
- 对于特大型表，建立和使用索引的代价将随之增长，此时可以考虑使用分区技术或 NoSQL。

## 索引的数据结构

### 哈希索引

Hash 索引只有精确匹配索引所有列的查询才有效。

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。

哈希的思路很简单：**把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置**。

对于每一行数据，对所有的索引列计算一个 `hashcode`。哈希索引将所有的 `hashcode` 存储在索引中，同时在哈希表中保存指向每个数据行的指针。

哈希索引的**优点**：

- 因为索引数据结构紧凑，所以**查询速度非常快**。

哈希索引的**缺点**：

- 哈希索引数据不是按照索引值顺序存储的，所以**无法用于排序**。
- 哈希索引**不支持部分索引匹配查找**。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。
- 哈希索引**只支持等值比较查询**，不支持任何范围查询，如 `WHERE price > 100`。
- 哈希索引有**可能出现哈希冲突**，出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。

### B 树索引

通常我们所说的索引是指 **B 树**索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 就是使用的 B+ 树。

#### 为什么不使用平衡二叉树？

**无论是平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率**。

比如，下面这个平衡二叉查找树的高度为 5，那么在访问最底部的节点时，就需要磁盘 5 次 I/O 操作。

![图片](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/2d26d30c953cd47c6ab637ad0eba2f99.png)

如果把二叉树换为三叉树，树的高度就会变矮，同时变胖：

![图片](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/00fb73de7014a87958f1597345e9ef2f.png)

**当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度**。

#### 为什么 InnoDB 不使用 B 树？

B+ 树也是多路平衡查找树，其与 B 树的区别主要在于：

* B 树中每个节点（包括叶节点和非叶节点）都存储真实的数据，B+ 树中只有叶子节点存储真实的数据，非叶节点只存储键。

  在 MySQL 中，这里所说的真实数据，可能是行的全部数据（如 InnoDB 的聚簇索引），也可能只是行的主键（如 InnoDB 的辅助索引），或者是行所在的地址（如 MyISAM 的非聚簇索引）。

* B 树中一条记录只会出现一次，不会重复出现，而 B+ 树的键则可能重复重现（一定会在叶节点出现，也可能在非叶节点重复出现）。

* B+ 树的叶节点之间通过双向链表链接，便于范围查询。

* B 树中的非叶节点，记录数比子节点个数少 1；而 B+ 树中记录数与子节点个数相同。 

由此，B+ 树与B 树相比，有以下优势：

* 更少的 I/O 次数：B+ 树的非叶节点只包含键，而不包含真实数据，因此每个节点存储的记录个数比 B 数多很多（即阶 m 更大），因此 B+ 树的高度更低，访问时所需要的 IO 次数更少。此外，由于每个节点存储的记录数更多，所以对访问局部性原理的利用更好，缓存命中率更高。
* 更适于范围查询：在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+ 树的范围查询，只需要对链表进行遍历即可。
* 更稳定的查询效率：B 树的查询时间复杂度在 1 到树高之间(分别对应记录在根节点和叶节点)，而 B+ 树的查询复杂度则稳定为树高，因为所有数据都在叶节点。 

#### B+ 树索引的查询原理

InnoDB 里的 B+ 树中的**每个节点都是一个数据页**，结构示意图如下：

![image-20220402121459054](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220402121459054.png)

通过上图，我们看出 B+ 树的特点：

- **只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引**。
- 非叶子节点分为不同层次，通过分层来降低每一层的搜索量；
- **所有节点按照索引键大小排序，构成一个双向链表，便于范围查询**；

#### 聚簇索引

B+ 树索引主要可以分为两种索引，聚集索引和非聚集索引。

* 聚集索引：也就是平常我们说的主键索引，在 B+ 树中叶子节点存的是**整行**数据。
* 非聚集索引：也叫二级索引，也就是一般的普通索引，在 B+ 树中叶子节点**存的是主键的值**。

我们如果直接用主键查找，用的是聚集索引，能找到全部的数据。如果我们是用非聚集索引查找，如果索引里不包含全部要查找的字段，则需要根据索引叶子节点存的主键值，再到聚集索引里查找需要的字段，这个过程也叫做**回表**。

* 聚簇索引优点：聚集索引的查询速度非常的快，因为整个 B+树本身就是一棵多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。
* 聚簇索引缺点：
  * **依赖于有序的数据** ：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
  * **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。

### 全文索引

MyISAM 存储引擎支持全文索引，**用于查找文本中的关键词**，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引一般使用**倒排索引**实现，它记录着**关键词到其所在文档的映射**。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

## 索引类型

### 主键索引（Primary Key）

数据表的主键列使用的就是主键索引。

一张数据表有只能有一个主键，并且主键**不能为 null**，**不能重复**。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6 Byte 的自增主键。

```sql
CREATE TABLE `table` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    ...
    PRIMARY KEY (`id`)
)
```

### 二级索引（辅助索引）

二级索引又称为辅助索引，是因为**二级索引的叶子节点存储的数据是主键**。也就是说，通过二级索引，可以定位主键的位置。

二级索引有如下几类：

* 唯一索引（Unique Key）：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。

* 普通索引（Index）：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**

* 前缀索引（Prefix）：**前缀索引只适用于字符串类型的数据**。前缀索引是**对文本的前几个字符创建索引**，相比普通索引建立的数据更小， 因为只取前几个字符。

* 全文索引（Fulltext）：**全文索引主要是为了检索大文本数据中的关键字的信息**，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。

  值得一提的是，在数据量较大时候，先将数据放入一个没有全文索引的表中，然后再用 `CREATE INDEX` 创建全文索引，要比先为一张表建立全文索引然后再将数据写入的速度快很多。

  目前只有 `CAHR`、`VARCHAR`，`TEXT` 列上可以创建全文索引。

### 联合索引

多个字段上创建的索引，只有在查询条件中使用了创建索引时的**第一个字段**，索引才会被使用，即使用组合索引时需要遵循**最左前缀匹配**的原则。

## 索引的策略

### 基本原则

- **索引不是越多越好，不要为所有列都创建索引**。

  要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。

- 要**尽量避免冗余和重复索引**。

- 要**考虑删除未使用的索引**。

- **尽量的扩展索引，不要新建索引**。

- **频繁作为 `WHERE` 过滤条件的列应该考虑添加索引**。

### 独立的列

独立的列指的是**索引列既不能是表达式的一部分，也不能是函数的参数**。

**对索引字段做函数操作，可能会破坏索引值的有序性，因此 SQL 优化器就决定放弃走树搜索功能。**这意味着如果查询中的列不是独立的列，则数据库不会使用索引。

错误示例：

```sql
SELECT actor_id FROM actor WHERE actor_id + 1 = 5;
SELECT ... WHERE TO_DAYS(current_date) - TO_DAYS(date_col) <= 10;
```

### 覆盖索引

覆盖索引是指**索引上的信息足够满足查询请求，不需要回表查询数据。**

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

### 使用索引排序

MySQL 有两种方式可以生成排序结果：通过排序操作；或者按索引顺序扫描。

**索引最好既满足排序，又用于查找行**。这样，就可以通过命中覆盖索引直接将结果查出来，也就不再需要排序了。

### 最左前缀匹配

不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个**最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符**。

MySQL 会一直向右匹配直到遇到范围查询 `(>, <, BETWEEN, LIKE)` 就停止匹配。

- 索引可以简单如一个列(a)，也可以复杂如多个列 (a, b, c, d)，即**联合索引**。
- 如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否**存在（相等）**，遇到范围查询(>、<、between、like 左匹配)等就**不能进一步匹配**了，后续退化为线性查找。
- 因此，**列的排列顺序决定了可命中索引的列数**。

**不要为每个列都创建独立索引**。

**将选择性高的列或基数大的列优先排在多列索引最前列**。但有时，也需要考虑 `WHERE` 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。

例如：`a = 1 and b = 2 and c > 3 and d = 4`，如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。

#### 最左前缀匹配原理

最左匹配原则都是针对联合索引来说的，所以我们可以从联合索引的原理来了解最左匹配原则。

我们都知道索引的底层是一棵 B+ 树，那么联合索引当然还是一棵 B+ 树，只不过联合索引的键值数量不是一个，而是多个。构建一棵 B+ 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建 B+ 树。例子：假如创建一个 (a,b,c) 的联合索引，那么它的索引树是这样的：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/g3h2lfrw60.png)

注意，(a,b,c) 的联合索引中，a 是有序的，而 b，c 存储都是无序的；但是 a 相同时，b 是有序的；ab 都相同时，c 是有序的。

通过对联合索引的结构的了解，那么就可以很好的了解为什么最左匹配原则中如果遇到范围查询就会停止了。

## 索引失效

索引失效指的是明明建立了索引，在查询时却没有用到索引的情况。主要有以下几个情况：

* 对索引使用左或者左右模糊匹配。也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。

  这是因为根据最左匹配原则，左边有模糊查询的情况下索引是不起作用的。

* 对索引使用函数或进行表达式计算。

  因为索引保存的是索引字段的原始值，而不是经过函数计算或表达式计算后的值，自然就没办法走索引了。

* 对索引进行隐式的类型转换。

  如果**索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，虽然也能成功查询到，但是这个查询是不走索引查询**的。

  而反过来，**如果索引字段是整型，而使用字符串进行查询，则可以走索引**。

  这是因为 MySQL 的类型转换规则是：**MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。

  而第一种情况中，输入参数是整型，就要把索引转换为数字进行查询，就会隐式的调用一个转换函数，根据上面介绍过的第二点，索引就失效了。

* 联合索引中的非最左匹配。

* `WHERE` 中的 `OR`。在 `WHERE` 子句中，如果在 `OR` 前的条件列是索引列，而在 `OR` 后的条件列不是索引列，那么索引会失效。

  这是因为 `OR` 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。
