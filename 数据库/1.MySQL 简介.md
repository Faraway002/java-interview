# MySQL 简介

**MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。**

由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL（General Public License）的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是**3306**。

## MySQL 的客户端/服务器架构

以我们平时使用的微信为例，它其实是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可能有很多种形式，比如手机APP，电脑软件或者是网页版微信，每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器软件，我们平时操作微信其实都是用客户端来和这个服务器来打交道。

MySQL 的使用过程跟这个是一样的，**它的服务器程序直接和我们存储的数据打交道**，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器就响应这些请求，从而操作它维护的数据。MySQL 的每个客户端都需要提供用户名密码才能登录，登录之后才能给服务器发请求来操作某些数据。

我们日常使用 MySQL 的情景一般是这样的：

1. 启动 MySQL 服务器程序。

2. 启动 MySQL 客户端程序并连接到服务器程序。

3. 在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。

## MySQL 的安装

不论我们通过下载源代码自行编译安装的方式还是直接使用官方提供的安装包进行安装之后， MySQL 的服务器程序和客户端程序都会被安装到我们的机器上。不论使用上述两者的哪种安装方式，一定要记住 MySQL 的安装目录。

MySQL 安装目录下的 bin 目录内有很多可执行程序，下面列出一些很常见的：

![image-20220410202818831](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220410202818831.png)

## 启动 MySQL 服务器

可执行程序中，有许多都与 MySQL 服务器有关：

* mysqld：mysqld 这个可执行文件就代表着 MySQL 服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。

* mysqld_safe：mysqld_safe 是一个启动脚本，它会间接的调用 mysqld ，而且还顺便启动了另外一个监控进程，这个监控进程在服务器进程挂了的时候，可以帮助重启它。

  另外，使用 mysqld_safe 启动服务器程序时，它会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生出错日志，这样可以方便我们找出发生错误的原因。

* mysql.server：mysql.server 也是一个启动脚本，它会间接的调用 mysqld_safe ，在调用 mysql.server 时在后边指定 start 参数就可以启动服务器程序了。

  另外，我们还可以使用 mysql.server 命令来关闭正在运行的服务器程序，只要把 start 参数换成 stop 就好了。

* mysqld_multi：一台计算机上也可以运行多个服务器实例，也就是运行多个 MySQL 服务器进程。 mysql_multi 可执行文件可以对每一个服务器进程的启动或停止进行监控。

## 启动 MySQL 客户端

bin 目录下有许多客户端程序，比方说 mysqladmin 、 mysqldump 、 mysqlcheck 等。

mysql 是最常用的客户端程序，通过这个可执行文件可以让我们和服务器程序进程交互。启动这个可执行文件时一般需要一些参数，格式如下：

```shell
mysql -h主机名 -u用户名 -p密码
```

如果我们想断开客户端与服务器的连接并且关闭客户端的话，可以在 mysql> 提示符后输入下边任意一个命令：

* quit
* exit
* \q

## 客户端与服务器连接的过程

我们现在已经知道如何启动 MySQL 的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程。

MySQL 支持下边三种客户端进程和服务器进程的通信方式：

1. TCP/IP。

   真实环境中，数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯。MySQL 采用 TCP 作为服务器和客户端之间的网络通信协议。MySQL 服务器启动的时候会默认申请 3306 端口号。

2. 命名管道或共享内存。

3. 套接字。

## 服务器处理客户端请求

其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：客户端进程向服务器进程发送一段文本（MySQL 语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。

![image-20220410204743230](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220410204743230.png)

整个 MySQL 的架构如下图所示：

![image-20220401205639367](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220401205639367.png)

### 连接管理

每当有一个客户端进程连接到服务器进程时，**服务器进程都会创建一个线程来专门处理与这个客户端的交互**，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端，这样就起到了不频繁创建和销毁线程的效果，从而节省开销。

但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量。

在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了 SSL （安全套接字）的网络连接进行通信，来保证数据传输的安全性。

当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求， MySQL 服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理。

### 解析和优化

到现在为止， MySQL 服务器已经获得了文本形式的请求，接着还要经过多重处理，其中的几个比较重要的部分分别是**查询缓存**、 **语法解析**和**查询优化**。

#### 查询缓存

MySQL 服务器程序处理查询请求的过程中会把刚刚处理过的查询请求和结果缓存起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了。

**查询缓存可以在不同客户端之间共享**，也就是说如果客户端 A 刚刚查询了一个语句，而客户端 B 之后发送了同样的查询请求，那么客户端 B 的这次查询就可以直接使用查询缓存中的数据。

**如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中**。另外，**如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存**。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 `NOW`，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的。

不过既然是缓存，那就有它缓存失效的时候。MySQL 的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了 `INSERT`、`UPDATE`、`DELETE` 、`TRUNCATE TABLE`、`ALTER TABLE`、`DROP TABLE` 或 `DROP DATABASE` 语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。

**不建议使用数据库缓存，因为往往弊大于利**。**查询缓存的失效非常频繁**，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

MySQL 也提供了这种“按需使用”的方式。你可以将参数 `query_cache_type` 设置成 `DEMAND`，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 `SQL_CACHE` 显式指定，像下面这个语句一样：

```mysql
select SQL_CACHE * from T where ID = 10;
```

MySQL 8.0 中已经移除了查询缓存。

#### 语法解析

如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以 MySQL 服务器程序首先要对这段文本做分析，**判断请求的语法是否正确**，然后从文本中将要查询的表、各种查询条件都提取出来放到 MySQL 服务器内部使用的一些数据结构上来。

MySQL 通过关键字对 SQL 语句进行解析，并生成一颗对应的语法解析树。这个过程中，分析器主要通过语法规则来验证和解析，比如 SQL 中是否使用了错误的关键字或者关键字的顺序是否正确等等。

预处理则会根据 MySQL 规则进一步检查解析树是否合法，比如检查要查询的数据表和数据列是否存在等等。

- 分析器先会先做**词法分析**。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的 `select` 这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。
- 接下来要做**语法分析**。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果你的语句不对，就会收到 `You have an error in your SQL syntax` 的错误提醒，比如 `select` 少打了开头的字母 `s`。

#### 查询优化

语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的 MySQL 语句执行起来效率可能并不是很高， **MySQL 的优化程序会对我们的语句做一些优化**，如外连接转换为内连接、表达式简化、子查询转为连接等等。

**优化的结果就是生成一个执行计划**，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们**可以使用 `EXPLAIN` 语句来查看某个语句的执行计划**。

**MySQL 使用基于成本的优化器**，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在 MySQL 可以通过查询当前会话的 `last_query_cost` 的值来得到其计算当前查询的成本。

```mysql
select * from t_message limit 10;

# 省略结果集合

show status like 'last_query_cost';
+-----------------+-------------+
| Variable_name   | Value       |
+-----------------+-------------+
| Last_query_cost | 27.099000   |
+-----------------+-------------+
```

示例中的结果表示优化器认为大概需要做 27 个数据页的随机查找才能完成上面的查询。**这个结果是根据一些列的统计信息计算得来的**，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。

有非常多的原因会导致 MySQL 选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、**MySQL 认为的最优跟我们想的不一样**（我们希望执行时间尽可能短，但 MySQL 值选择它认为成本小的，但成本小并不意味着执行时间短）等等。

MySQL 的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：

- 重新定义表的关联顺序（多张表关联查询时，并不一定按照 SQL 中指定的顺序进行，但有一些技巧可以指定关联顺序）
- 优化 `MIN()` 和 `MAX()` 函数（找某列的最小值，如果该列有索引，只需要查找 B+Tree 索引最左端，反之则可以找到最大值，具体原理见下文）
- 提前终止查询（比如：使用 `limit` 时，查找到满足数量的结果集后会立即终止查询）
- 优化排序（在老版本 MySQL 会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于 I/O 密集型应用，效率会高很多）

随着 MySQL 的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。

### 执行引擎

截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表， **MySQL 服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里**。

我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。

为了实现不同的功能， MySQL 提供了各式各样的存储引擎 ，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。

为了管理方便，人们把**连接管理、查询缓存、语法解析、查询优化**这些并不涉及真实数据存储的功能**划分为 MySQL server 的功能**，把**真实存取数据的功能划分为存储引擎的功能**。各种不同的存储引擎向上边的 MySQL server 层提供统一的调用接口（也就是存储引擎 API），包含了几十个底层函数，像"读取索引第一条内容"、"读取索引下一条内容"、"插入记录"等等。

### 返回结果

最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL 仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。

如果查询缓存被打开且这个查询可以被缓存，MySQL 也会将结果存放到缓存中。

结果集返回客户端是一个**增量且逐步**返回的过程，有可能 MySQL 在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。

需要注意的是，结果集中的每一行都会以一个满足连接时所描述的通信协议的数据包发送，再通过 TCP 协议进行传输，在传输过程中，可能对 MySQL 的数据包进行缓存然后批量发送。

## 常用的存储引擎

MySQL 支持非常多种存储引擎：

![image-20220410222556641](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220410222556641.png)

其实我们最常用的就只有 InnoDB 和 MyISAM ，有时会提一下 Memory。MyISAM 其实也已经很少用了，通常都使用 InnoDB。