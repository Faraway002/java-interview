# MySQL 的底层存储

MySQL 服务器上负责对表中数据的读取和写入工作的部分是存储引擎 ，而服务器又支持不同类型的存储引擎，比如 InnoDB 、 MyISAM 、 Memory 等，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，**真实数据在不同存储引擎中存放的格式一般是不同的**，甚至有的存储引擎（比如 Memory）都不用磁盘来存储数据，也就是说关闭服务器后表中的数据就消失了。

InnoDB 是我们最常用的存储引擎，它的底层存储原理我们是必须要知道的。

## InnoDB 数据页简介

InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而**真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中**，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。

我们知道，读写磁盘的速度其实是非常慢的，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时， InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会很慢，InnoDB 采取的方式是：**将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位**。

**InnoDB 中页的大小一般为 16 KB**，也就是说，在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。 

在介绍数据页的具体格式之前，首先介绍每一条记录的物理存储格式。

## InnoDB 行格式

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为**行格式**或者**记录格式**。InnoDB 存储引擎到现在为止设计了 4 种不同类型的行格式 ，分别是 Compact 、 Redundant 、Dynamic 和 Compressed 行格式，随着时间的推移，可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。

我们可以在建表语句后使用 `ROW_FORMAT` 来指定行格式，比如：

```mysql
CREATE TABLE record_format_demo (
    c1 VARCHAR(10),
    c2 VARCHAR(10) NOT NULL,
    c3 CHAR(10),
    c4 VARCHAR(10)
) ROW_FORMAT=COMPACT;
```

### Compact 格式

Compact 格式如下：

![image-20220411112157839](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411112157839.png)

一条完整的记录其实可以被分为**记录的额外信息**和**记录的真实数据**两大部分，下边我们详细看一下这两部分的组成。

#### 记录的额外信息

这部分信息是服务器**为了描述这条记录而不得不额外添加的一些信息**，这些额外信息分为 3 类，分别是**变长字段长度列表**、**NULL 值列表**和**记录头信息**，我们分别看一下。

* **变长字段长度列表**：

  MySQL 支持一些变长的数据类型，比如 VARCHAR(M) 、 VARBINARY(M) 、各种 TEXT 类型，各种 BLOB 类型，我们也可以把拥有这些数据类型的列称为**变长字段**，变长字段中存储多少字节的数据是不固定的，所以我们**在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来**。

  在 Compact 行格式中，**把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表**，各变长字段数据占用的字节数按照列的顺序**逆序**存放。

  长度要么是两个字节，要么是一个字节，如果该可变字段允许存储的最大字节数超过 255 字节并且真实存储的字节数超过 127 字节，则使用 2 个字节；否则使用 1 个字节。

  >并不是所有记录都有这个变长字段长度列表部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

* **NULL 值列表**：

  把 NULL 值存储到真实数据中会很占地方，所以 Compact 行格式把这些值为 NULL 的列统一管理起来，存储到 NULL 值列表中。将每个允许存储 NULL 的列对应一个**二进制位（为 1 则为 NULL，否则不为 NULL）**，二进制位按照列的顺序**逆序**排列。

  MySQL 还规定 **NULL 值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补 0**。

  > 和变长字段长度列表类似，如果一个表中没有列是允许 NULL 值的，则不会有这个部分。

* **记录头信息**：

  记录头信息是由固定的 5 个字节组成的，也就是 40 位，每个位都有其含义：

  ![image-20220412153357806](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412153357806.png)

  二进制的位含义如下：

  | 名称         | 大小（单位：bit） | 描述                                                         |
  | ------------ | ----------------- | ------------------------------------------------------------ |
  | 预留位1      | 1                 | 没有使用                                                     |
  | 预留位2      | 1                 | 没有使用                                                     |
  | delete_mask  | 1                 | 标记该记录是否被删除                                         |
  | min_rec_mask | 1                 | B+ 树的每层非叶子节点中的最小记录都会添加该标记              |
  | n_owned      | 4                 | 表示当前记录拥有的记录数                                     |
  | heap_no      | 13                | 表示当前记录在记录堆的位置信息                               |
  | record_type  | 3                 | 表示当前记录的类型， 0 表示普通记录， 1 表示 B+ 树非叶子节点记录， 2 表示最小记录， 3 表示最大记录 |
  | next_record  | 16                | 表示下一条记录的相对位置                                     |

  我们之后在讲解 InnoDB 数据页时会详细讲解这个部分，它和 InnoDB 数据页是紧密联系的。

#### 记录的真实数据

MySQL 会为每个表都添加一些隐藏列，一般有如下三个：

| 列名        | 是否必须 | 占用空间 | 描述                    |
| ----------- | -------- | -------- | ----------------------- |
| DB_ROW_ID   | 否       | 6 字节   | 行 ID，唯一标识一条记录 |
| DB_TRX_ID   | 是       | 6 字节   | 事务 ID                 |
| DB_ROLL_PTR | 是       | 7 字节   | 回滚指针                |

我们注意到，**每一个表都会有一个事务 ID 和一个回滚指针，但是不一定会有行 ID**，这就要涉及到 **MySQL 的主键策略**：

1. 优先使用用户自定义主键作为主键
2. 如果用户没有定义主键，则选取一个 Unique 键作为主键
3. 如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为 `DB_ROW_ID` 的隐藏列作为主键。

也就是说，无论如何，**MySQL 的每一个表中都存在主键**。

### Redundant 格式

Redundant 行格式是 MySQL 5.0 之前用的一种行格式，现在已经很少使用，稍微了解一下即可：

![image-20220412154234009](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412154234009.png)

### 行溢出

MySQL 对一条记录占用的最大存储空间是有限制的，**除了 BLOB 或者 TEXT 类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。

65535 字节中，除了真实存储的数据之外，还包括其他的标识数据，比如 VARCHAR 类型就可能有三个部分：

* 真实数据
* 占用字节数
* NULL 标识

这意味着：

* 如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度可能占用 2 个字节， NULL 值标识需要占用 1 个字节。
* 如果该 VARCHAR 类型的列有 NOT NULL 属性，那最多只能存储 65533 个字节的数据，因为真实数据的长度可能占用 2 个字节。

当然，**VARCHAR 存储的最大字符数目还取决于它所用的字符集**，如果使用 GBK，则一个字符就需要 2 个字节，那么在 GBK 的条件下，VARCHAR NOT NULL 的长度就只有 32766。

上述内容都是在描述一个列的最大长度，我们知道 MySQL InnoDB 页的大小是 16 KB，那么如果存储了 65533 个字节，超过了 16 KB，这时就会出现一页装不下的尴尬情况。

在 Compact 和 Reduntant 行格式中，对于占用存储空间非常大的列，**在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用 20 个字节存储指向这些页的地址**（当然这 20 个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。

如图所示：

![image-20220412155039029](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412155039029.png)

如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前 768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫**行溢出** ，存储超出 768 字节的那些页面也被称为**溢出页** 。

### Dynamic 和 Compressed 行格式

Dynamic 是 MySQL 的默认行格式，这俩个格式都**和 Compact 类似**，区别在于**处理行溢出时的行为有差别**：Dynamic 和 Compressed 不会存储前 768 个字节，而是直接存储溢出页的地址。

Compressed 行格式和 Dynamic 不同的一点是：**Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间**。

对这两个格式，我们也只需要简单了解即可。

## InnoDB 数据页结构

数据页的具体结构如下图所示：

![image-20220412155610325](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412155610325.png)

从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。如下表所示：

| 名称                                     | 占用空间 | 描述                     |
| ---------------------------------------- | -------- | ------------------------ |
| File Header（文件头部）                  | 38 字节  | 页的一些通用信息         |
| Page Header（页面头部）                  | 56 字节  | 数据页专有的一些信息     |
| Infimum + Supermum（最小记录和最大记录） | 26 字节  | 两个虚拟的行记录         |
| User Records（用户记录）                 | 不确定   | 实际存储的行记录内容     |
| Free Space（空闲空间）                   | 不确定   | 页中尚未使用的空间       |
| Page Directory（页目录）                 | 不确定   | 页中的某些记录的相对位置 |
| File Trailer（文件尾部）                 | 8 字节   | 校验页是否完整           |

### 记录在页中的存储方式

在页的 7 个组成部分中，**我们自己存储的记录会按照我们指定的行格式存储到 User Records 部分**。

但是在一开始生成页的时候，其实并没有 User Records 这个部分，**每当我们插入一条记录，都会从 Free Space 部分申请一个记录大小的空间划分到 User Records 部分**。

当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。

这个过程的图示如下：

![image-20220412160043030](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412160043030.png)

为了更好的管理在 User Records 中的这些记录，MySQL **行格式中的记录额外信息中的记录头信息**起到了很大的作用。

### 详解行格式的记录头信息

看下面一个例子：

![image-20220412160348437](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412160348437.png)

图中把不用的头信息省略掉了，而且使用十进制表示各个位的数值。

* `delete_mask`：这个属性标记着当前记录是否被删除，占用 1 个二进制位。

  事实上，**MySQL 在删除记录时并不会真正的删除，而是将该标志位置为 0，表示逻辑上被删除了**。

  这些被删除的记录之所以不立即从磁盘上移除，是因为**移除它们之后把其他的记录在磁盘上重新排列需要性能消耗**，所以只是打一个删除标记而已。

  所有被删除掉的记录都会组成一个所谓的垃圾链表 ，在这个链表中的记录占用的空间称之为所谓的**可重用空间**，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

* `min_rec_mask`：B+ 树的每层非叶子节点中的最小记录都会添加该标记，这和聚簇索引有关，我们之后在详细讲述这个。

* `n_owned`：分组中的记录数目，稍后会详细解释。

* `heap_no`：这个属性表示当前记录**在本页中的位置**。

  MySQL 会给每个页默认添加两个记录，也叫做**伪记录**，这两个伪记录一个代表最小记录 ，一个代表最大记录。对于一条记录来说，它们的大小关系就是它们主键的大小关系。

  但是**不管我们向页中插入了多少自己的记录，这两条伪记录都分别为最小记录与最大记录**。

  这两条记录的构造十分简单，都是由5字节大小的记录头信息和 8 字节大小的一个固定的部分组成的，如图所示：

  ![image-20220412164744063](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412164744063.png)

  它们的 `heap_no` 分别是是 0 和 1。

* `record_type`：这个属性表示当前记录的类型，一共有 4 种类型的记录：

  * 0，表示普通记录。
  * 1，表示 B+ 树非叶子节点的记录。
  * 2，表示最小记录
  * 3，表示最大记录

* `next_record`：它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。

  这个部分告诉我们，记录的组织方式是**链表**，可以通过一条记录找到它的下一条记录。

  但是需要注意注意再注意的一点是， **下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录**。而且规定 Infimum 记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum 记录（也就是最大记录）。

  如下图所示：

  ![image-20220412165842962](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412165842962.png)

### Page Directory（页目录）

页目录是用于加快查找而设计的。

我们知道 MySQL 的记录在页中是以链表的形式存放的，**最笨的查找办法是从最小记录开始遍历，时间复杂度是 $O(n)$，在 n 很大的时候这个时间开销是很大的**。

为了加快查找，InnoDB 采用的方式是：

1. **将所有正常的记录（包括最大和最小记录，但是不包括标记为已删除的记录）划分为几个组**。

2. 每个组的**最后一条记录**，也就是组内最大的那条记录，它的**头信息中的 `n_owned` 属性表示该记录拥有多少条记录，也就是该组内共有几条记录**。

3. 将**每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，也就是 Page Directory**。

   页目录中的**这些地址偏移量被称为槽**（slot），所以这个页目录就是由槽组成的。

示意图如下：

![image-20220413150350384](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220413150350384.png)

但是，对于 `n_owned` 的取值，InnoDB 也有要求：

* 对于最小记录所在的分组只能有 1 条记录
* 最大记录所在的分组拥有的记录条数只能在 1~8 条之间
* 剩下的分组中记录的条数范围只能在是 4~8 条之间

所以，分组是按照下边的步骤进行的：

1. 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
2. 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加 1，表示本组内又添加了一条记录，直到该组中的记录数等于 8 个。
3. **在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组**，一个组中 4 条记录，另一个组是 5 条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

有了页目录之后，查找指定主键值的记录就分为两步：

1.  通过**二分法**确定该记录所在的槽，并找到该槽中主键值最小的那条记录。
2. 通过该最小记录的 `next_record` 属性遍历该槽所在的组中的各个记录，找到需要的记录。

### Page Header（页面头）

Page Header 用于**记录各种状态信息**，占用固定的 56 字节，各个部分的含义如下：

| 名称              | 占用空间 | 描述                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | 2 字节   | 在页目录中的槽数量                                           |
| PAGE_HEAP_TOP     | 2 字节   | 还未使用的空间最小地址，也就是说从该地址之后就是 Free Space  |
| PAGE_N_HEAP       | 2 字节   | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
| PAGE_FREE         | 2 字节   | 第一个已经标记为删除的记录地址（各个已删除的记录通过 next_record 也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| PAGE_GARBAGE      | 2 字节   | 已删除记录占用的字节数                                       |
| PAGE_LAST_INSERT  | 2 字节   | 最后插入记录的位置                                           |
| PAGE_DIRECTION    | 2 字节   | 记录插入的方向（如果新插入的比上一条主键大，则是右边；否则是左边） |
| PAGE_N_DIRECTION  | 2 字节   | 一个方向上连续插入的记录条数                                 |
| PAGE_N_RECS       | 2 字节   | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| PAGE_MAX_TRX_ID   | 8 字节   | 修改当前页的最大事务 ID，该值仅在二级索引中定义              |
| PAGE_LEVEL        | 2 字节   | 当前页在 B+ 树中所处的层级                                   |
| PAGE_INDEX_ID     | 8 字节   | 索引 ID，表示当前页属于哪个索引                              |
| PAGE_BTR_SEG_LEAF | 10 字节  | B+ 树叶子节点段的头部信息，仅在 B+ 树的 Root 页定义          |
| PAGE_BTR_SEG_TOP  | 10 字节  | B+ 树非叶子节点段的头部信息，仅在 B+ 树的 Root 页定义        |

### File Header（文件头）

**Page Header 是专门针对数据页记录的各种状态信息**，**File Header 则是所有类型页的通用状态信息**，每一个页都以 File Header 开头。

| 名称                             | 占用空间大小 | 描述                                                         |
| -------------------------------- | ------------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4 字节       | 页的校验和（checksum值）                                     |
| FIL_PAGE_OFFSET                  | 4 字节       | 页号                                                         |
| FIL_PAGE_PREV                    | 4 字节       | 上一个页的页号                                               |
| FIL_PAGE_NEXT                    | 4 字节       | 下一个页的页号                                               |
| FIL_PAGE_LSN                     | 8 字节       | 页面被最后修改时对应的日志序列位置（LSN）                    |
| FIL_PAGE_TYPE                    | 2 字节       | 该页的类型                                                   |
| FIL_PAGE_FILE_FLUSH_LSN          | 8 字节       | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4 字节       | 页属于哪个表空间                                             |

 `FIL_PAGE_TYPE` 表示页的类型，有如下几种类型：

| 类型名称                | 十六进制 | 描述                   |
| ----------------------- | -------- | ---------------------- |
| FIL_PAGE_TYPE_ALLOCATED | 0x0000   | 最新分配，还没使用     |
| FIL_PAGE_UNDO_LOG       | 0x0002   | Undo 日志页            |
| FIL_PAGE_INODE          | 0x0003   | 段信息                 |
| FIL_PAGE_IBUF_FREE_LIST | 0x0004   | Insert Buffer 空闲列表 |
| FIL_PAGE_IBUF_BITMAP    | 0x0005   | Insert Buffer 位图     |
| FIL_PAGE_TYPE_SYS       | 0x0006   | 系统页                 |
| FIL_PAGE_TYPE_TRX_SYS   | 0x0007   | 事务系统数据           |
| FIL_PAGE_TYPE_FSP_HDR   | 0x0008   | 表空间头部信息         |
| FIL_PAGE_TYPE_XDES      | 0x0009   | 扩展描述页             |
| FIL_PAGE_TYPE_BLOB      | 0x000A   | BLOB页                 |
| FIL_PAGE_INDEX          | 0x45BF   | 索引页（数据页）       |

从这个类型定义中我们得知，MySQL InnoDB 中的索引页就是数据页，这是因为 **InnoDB 的一个表就是一个聚簇索引**，我们之后再详细解释这个问题。

`FIL_PAGE_PREV ` 和 `FIL_PAGE_NEXT` 两个指针联系起多个数据页，形成一个双向链表。并不是所有类型的页都有上一个和下一个页的属性。

![image-20220413164432919](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220413164432919.png)

### File Trailer

为了**检测一个页是否完整**，每个页的尾部都有一个 File Trailer 部分，这个部分由 8 个字节组成，可以分成 2 个小部分：

* 校验和（4 个字节）
* 日志序列位置（LSN）

### 页分裂

假设有这样一个表：

```mysql
CREATE TABLE index_demo(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY(c1)
) ROW_FORMAT = Compact;
```

我们执行一条插入语句：

```mysql
INSERT INTO index_demo 
VALUES (1, 4, 'u'), 
	   (3, 9, 'd'), 
	   (5, 3, 'y');
```

我们假设它们都在一页中，那么它应该是这样的：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506201058777.png" alt="image-20220506201058777" style="zoom:50%;" />

现在假设这一页已经满了，那么我们再插入一条：

```mysql
INSERT INTO index_demo VALUES(4, 4, 'a');
```

这个时候，由于一页放不下，所以**不得不分配一个新的页面**：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506201217184.png" alt="image-20220506201217184" style="zoom: 67%;" />

此时，我们发现记录的顺序被破坏了，**不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求**，因此必须把 5 移动到页 28 中，把 4 移动到页 10 中：

![image-20220506201331714](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506201331714.png)

这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值，保证这个性质的过程被称为**页分裂**。