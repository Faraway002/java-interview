[TOC]

# MySQL 的 B+ 树索引

在正式介绍索引之前，我们需要了解一下没有索引的时候是怎么查找记录的。

* 假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：
  * 以主键为搜索条件：此时可以使用页中的页目录通过二分查找加快查找。
  * 以其他列为搜素条件：由于其他列不是主键，因此不存在页目录，也就不能加快查找。
* 假设记录很多，需要很多页才能装下，这时还需要先定位列所在的页，然后在页内查找。

没有索引的情况下，查找是相当耗时的。

## 1. 索引的简单方案

我们可以效仿页目录，为快速定位记录所在的数据页而建立一个别的目录，这个目录必须实现：

* 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。
* 给所有的页建立一个目录项。

示意图如下：

![image-20220414154056115](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220414154056115.png)

> 注意，这个例子中**页号不一定是连续的，同时也不要求是连续的，它们是通过 File Header 的指针连接成双向链表**。

以页 28 为例，它对应目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5。比方说我们想找主键值为 20 的记录，具体查找过程分两步：

* 先从目录项中根据二分法快速确定出主键值为 20 的记录在目录项 3 中（因为 12 < 20 < 209），它对应的页是页 9。
* 再根据前边说的在页中查找记录的方式去页 9 中定位具体的记录。

这样一来，我们的一个简易索引就完成了，实际系统中的索引要比这复杂得多，我们说明这样一个索引方案的目的是为了能够理解索引的思想和作用。

## 2. InnoDB 中的索引方案

我们的简易索引有几个问题：

1. InnoDB 是使用页来作为管理存储空间的基本单位，也就是最多能保证 16KB 的连续存储空间，而**随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的**。

   > 这个问题很像操作系统中的分页机制中页表过大的问题，当然，操作系统的解决方式是多级页表，InnoDB 里是不是也是这样处理的呢？请继续往下看。

2. 我们时常会对记录进行增删，假设我们把页 28 中的记录都删除了， 页 28 也就没有存在的必要了，那意味着目录项 2 也就没有存在的必要了，这就需要把目录项 2 后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意。

InnoDB 采用了 B+ 树作为索引的数据结构，具体来说，**B+ 树索引中最下层的叶子节点存储真实用户记录，而上层的所有其他非叶子节点都是索引节点**。本文将从我们刚刚提出的简单索引方案一步一步来到 B+ 树的索引方案。

在上一章我们提到过，在每一行的额外信息的记录头信息中，有一个 `record_type` 标志位来区分一条记录是索引记录还是数据记录，如果是 1，则是索引记录，同时是 B+ 树的非叶子节点；而在叶子节点中，`record_type` 的值为 0。

我们拓展一下我们的方案，使用一个数据页来保存索引记录，并且使用 `record_type` 来区分，就得到一个这样的结构：

![image-20220506202439310](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506202439310.png)

行格式的记录头信息中，还有一个 `min_rec_mask` 标志，这个标志我们当时给出的含义是：B+ 树非叶子节点中的主键值最小的节点都需要这个标志，这很明显是用于标识索引页中的最小记录的，因为我们的索引页也可以构建页目录，通过二分法进一步加快索引页内的查找。

虽然说索引数据页只存储主键值和页号的对应关系，占用空间小，但是总归会受到一页 16 KB 的限制，那如果表中的数据太多，以至于一个数据页不足以存放所有的索引记录 ，该怎么办？答案当然是和普通数据页一样，**进行页分裂**：

![image-20220506203522075](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506203522075.png)

那么问题又来了，如果我们表中的数据非常多则会产生很多存储索引的页，那我们怎么根据主键值快速定位一个索引页呢？答案当然是再加一层目录项咯，即索引的索引：

![image-20220506203802514](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506203802514.png)

随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：

![image-20220506203821210](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506203821210.png)

这就是 B+ 树，索引和数据的层次分明，最下面一层是真实的数据，上面的结点全部都是索引节点。InnoDB 规定，**存储数据的层（最下面一层）是第 0 层，之后依次往上加**。

之前我们讨论时，都假设一页最多存放 3 到 4 条记录，其实真实环境中一个页存放的记录数量是非常大的，我们知道，InnoDB 一页是 16 KB，假设一页能够放 100 条记录，而由于索引数据页一条记录占用更小，假设能放 1000 条，那么：

1. 如果 B+ 树只存在 1 层，那么可以放 100 条记录。
2. 如果 B+ 树有 2 层，那么可以放 1000 × 100 条记录，也就是 10w 条。
3. 如果 B+ 树有 3 层，最多能存放 1000 × 1000 × 100 =100000000 条记录，也就是 1 亿条记录。
4. 如果 B+ 树有 4 层，那么再翻 1000 倍，也就是 1000 亿条记录！

你的表里能存放 100000000000 条记录吗？所以一般情况下，我们用到的 B+ 树都不会超过 4 层。

### 2.1 聚簇索引

我们上边介绍的 B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1. **使用记录主键值的大小进行记录和页的排序**，这包括三个方面的含义：
   * 页内的记录是按照主键的大小顺序排成一个单向链表。
   * 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
   * 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

2. **B+ 树的叶子节点存储的是完整的用户记录**。所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把**具有这两种特性的 B+ 树称为聚簇索引**，所有完整的用户记录都存放在这个聚簇索引的叶子节点处，因此，**InnoDB 的一个表就是一个聚簇索引**，也就是所谓的索引即数据，数据即索引。

### 2.2 二级索引

**聚簇索引仅适用于主键**，也就是说只有当搜索条件是主键的时候才能发挥作用。但是很多情况下，我们都需要搜索其他列，这时怎么办呢？

很简单，再多建几棵 B+ 树，不同的 B+ 树中的数据根据选择的索引不同而采用不同的排序规则。比如我们选取非主键列作为索引：

![image-20220506211751083](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506211751083.png)

这个 B+ 树与上边介绍的聚簇索引有几处不同：

* 使用记录非索引列的大小进行记录和页的排序，这包括三个方面的含义：
  * 页内的记录是按照非索引列的大小顺序排成一个单向链表。
  * 各个存放用户记录的页也是根据页中记录的非索引列大小顺序排成一个双向链表。
  * 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的非索引列大小顺序排成一个双向链表。

* **B+ 树的叶子节点存储的并不是完整的用户记录**，而只是**存储非索引列 + 主键列**这两个列的值。

* 目录项记录中不再是主键 + 页号的搭配，而变成了非索引列 + 页号的搭配。

那么这就有一个问题，我们查询只能查到主键，想要查到真实数据还需要根据主键**回表**到聚簇索引中查出真实用户数据。所以，这种 B+ 树索引也被称作**二级索引**或者**辅助索引**。

二级索引事实上有一个小问题，看下面的示例：

![image-20220506221822130](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506221822130.png)

c1 是主键，但是我们对 c2 建立一个二级索引，它看起来像这样：

![image-20220506233946327](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506233946327.png)

如果我们再插入一条 (9, 1, 'c') 的记录，其中，c2 又是 1，那么由于页 3 中存储的目录项记录是由 c2 列 + 页号的值构成的，页3 中的两条目录项记录对应的 c2 列的值都是 1 ，而我们新插入的这条记录的 c2 列的值也是 1 ，那我们这条新插入的记录到底应该放到页 4 中，还是应该放到页 5 中？

为了让新插入记录能找到自己在那个页里，我们**需要保证在 B+ 树的同一层内节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

* 索引列值
* **主键值**
* 页号

所以实际上的二级索引是这样子的：

![image-20220506234241270](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506234241270.png)

### 2.3 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比如有三个列 c1、c2 和 c3，其中 c1 是主键，c2 和 c3 是普通列，比方说我们想为 c2 和 c3 建立索引，也就是按照 c2 和 c3 列的大小进行排序，这个包含两层含义：

* 先把各个记录和页按照 c2 列进行排序。
* 在记录的 c2 列相同的情况下，采用 c3 列进行排序。

示意图如下：

![](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220506220848385.png)

**以多个非主键列的大小为排序规则建立的 B+ 树称为联合索引，本质上也是一个二级索引**。

注意，主键索引也可以有多个列，但是它就是主键索引，而不是联合索引。

### 2.4 常见问题解答

#### 2.4.1 MySQL 的索引为什么不使用平衡二叉树？

**无论是平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率**。

比如，下面这个平衡二叉查找树的高度为 5，那么在访问最底部的节点时，就需要磁盘 5 次 I/O 操作。

![图片](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/2d26d30c953cd47c6ab637ad0eba2f99.png)

如果把二叉树换为三叉树，树的高度就会变矮，同时变胖：

![图片](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/00fb73de7014a87958f1597345e9ef2f.png)

**当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度**，这也是 InnoDB 采取多叉树的原因。

#### 2.4.2 为什么不使用 B 树？

B 树也是多路平衡查找树，其与 B+ 树的区别主要在于：

* B 树中每个节点（包括叶节点和非叶节点）都存储真实的数据，B+ 树中只有叶子节点存储真实的数据，非叶节点只存储键。

  这意味着 B 树中一条记录只会出现一次，不会重复出现，而 B+ 树的键则可能重复重现（一定会在叶节点出现，也可能在非叶节点重复出现）。

* B+ 树的叶节点之间通过双向链表链接，便于范围查询。

* B 树中的非叶节点，记录数比子节点个数少 1；而 B+ 树中记录数与子节点个数相同。 

由此，B+ 树与 B 树相比，有以下优势：

* **更少的 I/O 次数**：B+ 树的非叶节点只包含键，而不包含真实数据，因此**每个节点（一页）存储的记录个数比 B 树多很多**，因此 **B+ 树的高度更低**，访问时所需要的 I/O 次数更少。此外，由于每个节点存储的记录数更多，所以**对访问局部性原理的利用更好**，缓存命中率更高。
* **更适于范围查询**：在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+ 树的范围查询，只需要对最后一层的链表进行遍历即可。
* **更稳定的查询效率**：B 树的查询时间复杂度在 1 到树高之间（分别对应记录在根节点和叶节点），而 B+ 树的查询复杂度则**稳定**为树高，因为所有数据都在叶节点。 

## 3. MyISAM 索引简介

MyISAM 的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：

* 将表中的记录**按照记录的插入顺序**单独存储在一个文件中，称之为**数据文件**。

  这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。

  > 由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。

* 使用 MyISAM 存储引擎的表会**把索引信息另外存储**到一个称为**索引文件**的另一个文件中。 

  MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是**主键值 + 行号**的组合，也就是需要回表。这一点和 InnoDB 是完全不相同的，在 InnoDB 存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次回表操作，意味着 **MyISAM 中建立的索引全部都相当于是 InnoDB 中的二级索引**。

## 4. 索引的代价

索引虽好，但是也有一定代价：

1. **空间上的代价**

   这个是显而易见的，**每建立一个索引都要为它建立一棵 B+ 树**，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，需要很多的额外空间。

2. **时间上的代价**

   每次对表中的数据**进行增、删、改操作时，都需要去修改各个 B+ 树索引**；增删改时还有可能破坏 B+ 树最下层链表的顺序，还需要额外的时间进行移位、页分裂等操作，如果我们建了许多索引，每个索引对应的 B+ 树都要进行相关的维护操作。

   这样看下来，虽然查询快了，但是增删改则需要额外的时间开销。

所以说，**索引并不是越多越好，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差**。

## 5. 索引的适用条件

首先我们建一个表，以这个表来展示索引的适用条件：

```mysql
CREATE TABLE person_info(
    id INT NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

对于这个 person_info 表我们需要注意两点：

* 表中的主键是 id 列，它存储一个自动递增的整数。所以 InnoDB 存储引擎会自动为 id 列建立**聚簇索引**。

* 我们额外定义了一个二级索引 idx_name_birthday_phone_number ，它是由 3 个列组成的**联合索引**。

  所以在这个索引对应的 B+ 树的叶子节点处存储的用户记录只保留 name 、 birthday 、 phone_number 这三个列的值以及主键 id 的值，并不会保存 country 列的值。

### 5.1 全值匹配

**如果我们的搜索条件中的列和索引列一致的话，就称为全值匹配**。

比方说下边这个查找语句：

```mysql
SELECT * 
FROM person_info 
WHERE name = 'Ashburn' 
  AND birthday = '1990-09-27' 
  AND phone_number = '15123983239';
```

我们建立的 idx_name_birthday_phone_number 索引包含的3个列在这个查询语句中都展现出来了。

注意我们索引的建立顺序是 name、birthday 以及 phone_number，所以二级索引中也是按这个顺序排的，查询过程如下：

* 因为 B+ 树的数据页和记录先是按照 name 列的值进行排序的，所以先可以很快定位 name 列的值是 Ashburn 的记录位置。
* 在 name 列相同的记录里又是按照 birthday 列的值进行排序的，所以在 name 列的值是 Ashburn 的记录里又可以快速定位 birthday 列的值是 '1990-09-27' 的记录。
* 如果很不幸， name 和 birthday 列的值都是相同的，那记录是按照 phone_number 列的值排序的，所以联合索引中的三个列都可能被用到。

那么就有人要问了：**查询的时候调换一下列的位置，索引还能生效吗？答案是可以的**，MySQL 具有查询优化器，**它会自动分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件**。

### 5.2 最左匹配原则

其实在我们的搜索语句中也**可以不用包含全部联合索引中的列，只包含左边的就行**。比方说下边的查询语句：

```mysql
SELECT * 
FROM person_info 
WHERE name = 'Ashburn';
```

或者包含多个左边的列，比如：

```mysql
SELECT * 
FROM person_info 
WHERE name = 'Ashburn' 
  AND birthday = '1990-09-27';
```

但是，下面这个查询就用不到索引：

```mysql
SELECT * 
FROM person_info 
WHERE birthday = '1990-09-27'
```

这是因为因为 B+ 树的数据页和记录先是按照 name 列的值排序的，在 name 列的值相同的情况下才使用 birthday 列进行排序，也就是说，**name 列的值不同的记录中 birthday 的值可能是无序的**。

如果只想对 birthday 进行搜索，可以单独对 birthday 做一个索引。

**如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列**，这个原则叫做**最左匹配**原则。

### 5.3 最左前缀原则

我们前边说过为某个列建立索引的意思其实就是在对应的 B+ 树的记录中使用该列的值进行排序，比方说 person_info 表上建立的联合索引 idx_name_birthday_phone_number 会先用 name 列的值进行排序，所以这个联合索引对应的 B+ 树中的记录的 name 列的排列就是这样的：

```
Aaron
Aaron
...
Aaron
Asa
Ashburn
...
Ashburn
Baird
Barlow
...
Barlow
```

字符串排序的本质就是比较字典序，用到了该列的字符集和比较规则，**一般的比较规则都是逐个比较字符的字典序大小**，也就是说我们比较两个字符串的大小的过程其实是这样的：

* 先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。
* 如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。
* 如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。

所以，**一个字符串列也有最左匹配的原则**，我们称之为**最左前缀**原则。

所以，对于下面的模糊查询，可以使用索引：

```mysql
SELECT * 
FROM person_info 
WHERE name LIKE 'As%';
```

但是如果前面的字符是模糊查询，则不能用到索引：

```mysql
SELECT * 
FROM person_info 
WHERE name LIKE '%As%';
```

### 5.4 范围匹配

由于所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值**在某个范围内**的记录。比如：

```mysql
SELECT * 
FROM person_info 
WHERE name > 'Asa' 
  AND name < 'Barlow';
```

由于 B+ 树中的数据页和记录是先按 name 列排序的，所以我们上边的查询过程其实是这样的：

* 找到 name 值为 Asa 的记录
* 找到 name 值为 Barlow 的记录
* 由于记录之间都是由链表连起来的，所以这些都是很容易取出来的

**如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+ 树索引**。比如：

```mysql
SELECT * 
FROM person_info 
WHERE name > 'Asa' 
  AND name < 'Barlow' 
  AND birthday > '1980-01-01';
```

上边这个查询可以分成两个部分：

1. 通过条件 name > 'Asa' AND name < 'Barlow' 来对 name 进行范围，查找的结果可能有多条 name 值不同的记录

2. 对这些 name 值不同的记录继续通过 birthday > '1980-01-01' 条件继续过滤。

因为只有 name 值相同的情况下才能用 birthday 列的值进行排序，而这个查询中通过 name 进行范围查找的记录中可能并不是按照 birthday 列进行排序的，所以在搜索条件中继续以 birthday 列进行查找时是用不到这个 B+ 树索引的。

### 5.5 精确匹配某一列并范围匹配另外一列

对于一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是**如果左边的列是精确查找，则右边的列可以进行范围查找**。

比如：

```mysql
SELECT * 
FROM person_info 
WHERE name = 'Ashburn' 
  AND birthday > '1980-01-01' 
  AND birthday < '2000-12-31' 
  AND phone_number > '15100000000';
```

这个查询的条件可以分为 3 个部分：

* name = 'Ashburn'，这里是对 name 进行一个精确的查找，可以使用索引。
* birthday > '1980-01-01' AND birthday < '2000-12-31'，由于 name 列是精确查找，所以通过 name = 'Ashburn' 条件查找后得到的结果的 name 值都是相同的，它们会再按照 birthday 的值进行排序，因此可以使用索引。
* phone_number > '15100000000'，这里就和上一次介绍的情况一样了，不能使用索引。

当然，这也是因为我们的联合索引是 name, birthday 的顺序才能让 birthday 用到索引。

### 5.6 用于排序

我们在写查询时经常可能会使用 `ORDER BY` 子句对查询出的结果进行一个排序。

一般情况下，我们只能把记录都加载到内存中，再使用一些排序算法，比如快速排序、归并排序等，在内存中对这些记录进行排序。有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果。在 MySQL 中把这种在内存中或者磁盘中的排序统称为**文件排序**。

排序是需要耗费时间的，但是**如果在  `ORDER BY` 子句里使用到了索引，那么就有可能省去排序的步骤，进一步节省时间**。

比如：

```mysql
SELECT * 
FROM person_info 
ORDER BY name, birthday, phone_number 
LIMIT 10;
```

这个 SQL 中要求先按 name，再按 birthday，最后按 phone_number 排序，而我们索引里就是这么排的，因此可以直接省略排序过程。

### 5.7 用于分组

有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如：

```mysql
SELECT name, birthday, phone_number, COUNT(*) 
FROM person_info 
GROUP BY name, birthday, phone_number
```

这个查询其实相当于做了三次分组操作：

1. 先把记录按照 name 值进行分组，所有 name 值相同的记录划分为一组。

2. 将每个 name 值相同的分组里的记录再按照 birthday 的值进行分组，将 birthday 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又划分了好多小分组。

3. 再将上一步中产生的小分组按照 phone_number 的值分成更小的分组，得到小小分组。

   最后，我们是在针对小小分组进行 `COUNT(*)` 的统计。

如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的 B+ 树中的索引列的顺序是一致的，而我们的 B+ 树索引又是按照索引列排好序的，这正好可以直接使用 B+ 树索引进行分组。

## 6. 回表的代价

本节依旧使用上一节的例子，看下面的查询语句：

```mysql
SELECT * 
FROM person_info
WHERE name > 'Asa' 
  AND name < 'Barlow';
```

我们已经清楚的知道，这条语句可以走索引，取出 name 值在 Asa ～ Barlow 之间的用户记录。但是，由于这里的查询需要的列是 *，而 name 所在的索引只有三列，少了一个 country，这时需要把从上一步中获取到的每一条记录的 id 字段都到聚簇索引对应的 B+ 树中找到完整的用户记录，也就是回表 ，然后把完整的用户记录返回给查询用户。

我们注意一个问题，虽然这个索引按照 name 进行排序了，但是**二级索引查出来的是主键 id，id 并不一定是有序的**，这就导致回表时，是一个随机的访问，这种读取方式我们称为**随机 I/O**；相反，直接能够按照索引顺序拿到的数据我们就称之为**顺序 I/O**。

使用二级索引有两个特点：

1. 会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引。
2. 使用二级索引时是顺序 I/O，而使用聚簇索引时是随机 I/O。

**需要回表的记录越多，使用二级索引的性能就越低，甚至某些查询宁愿使用全表扫描也不使用二级索引**。至于到底使用全表扫描还是二级索引，这是由查询优化器决定的：查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，**需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引 + 回表的方式**。

### 6.1 覆盖索引

为了**彻底消除**回表操作带来的性能损耗，我们建议：**最好在查询列表里只包含索引列**，这种情况叫做**覆盖索引**。

比如：

```mysql
SELECT name, birthday, phone_number 
FROM person_info 
WHERE name > 'Asa' 
  AND name < 'Barlow'
```

因为我们只查询 name , birthday , phone_number 这三个索引列的值，所以在通过二级索引得到结果后就不必到聚簇索引中再查找记录的剩余列，也就是不用回表。

正因如此，**我们在实际业务中十分不推荐使用 * 进行查询，要查询哪些列就直接写明白**。

## 7. 索引的注意事项

1. **只为用于搜索、排序或分组的列创建索引**。也就是说，只为出现在 `WHERE` 子句中的列、连接子句中的连接列，或者出现在 `ORDER BY` 或 `GROUP BY` 子句中的列创建索引，而出现在查询列表中的列就没必要建立索引了。

2. **考虑列的基数**。列的基数指的是某一列中不重复数据的个数，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。

3. **索引列的类型所占字节数尽可能少**。这是因为在数据类型越小的时候，查询时进行比较操作时也越快，占用的空间也更小，在一个数据页内就可以放下更多的记录，减少磁盘 I/O 的次数。

4. **索引字符串的前缀**。假设我们需要索引的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的 B+ 树中有这么两个问题：

   * B+ 树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。
   * 如果 B+ 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。

   我们知道字符串的索引符合最左前缀匹配的原则，因此只对字符串的前几个字符进行索引，这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置。既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题。

   要让只索引前缀，我们可以这样建索引：

   ```mysql
   CREATE TABLE person_info(
       name VARCHAR(100) NOT NULL,
       birthday DATE NOT NULL,
       phone_number CHAR(11) NOT NULL,
       country varchar(100) NOT NULL,
       KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
   );
   ```

   > 注意，如果你使用了索引前缀，那么对该列排序就无法应用到索引，只能使用文件排序。

5. **不要对索引进行额外的表达式计算或调用函数**。

   假设表中有一个整数列 my_col ，我们为这个列建立了索引。下边的两个 WHERE 子句虽然语义是一致的，但是在

   效率上却有差别：

   1. WHERE my_col * 2 < 4
   2. WHERE my_col < 4 / 2

   第1个 WHERE 子句中 my_col 列并不是以单独列的形式出现的，而是以 my_col * 2 这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于 4，所以这种情况下是使用不到为 my_col 列建立的 B+ 树索引的。

   > 下面这个情况必须提一下：
   >
   > 假设我们有一个 user 表中的 phone（电话号码）字段，并对其做了索引，存储的类型是 `VARCHAR`，但是在查询时，我这么写 SQL：
   >
   > ```mysql
   > SELECT * 
   > FROM `user`
   > WHERE phone = 1300000001;
   > ```
   >
   > 这时候是不会走索引的，这是因为**字符串要被隐式转换为整数**。
   >
   > 反过来，如果 phone 是整数，我查询时给定字符串，这时还会走索引，原因我们上面说过了，这里索引就不会插入一条隐式转换，因此走索引。
   >
   > 如果不确定 MySQL 的转换规则，你可以执行这样一条 SQL：
   >
   > ```mysql
   > SELECT "10" > 9
   > ```
   >
   > - 如果规则是 MySQL 会将自动字符串转换成数字，就相当于 select 10 > 9，这个就是数字比较，所以结果应该是 1；
   > - 如果规则是 MySQL 会将自动数字转换成字符串，就相当于 select "10" > "9"，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个通过字典序比较 ，那么 "10" 字符串相当于 “1” 和 “0” 字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。

6. **主键插入顺序**。我们知道，聚簇索引是以主键值排序的，而且是存储着我们的完整的数据，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插；但是，而**如果我们插入的主键值忽大忽小的话，就很有可能发生页分裂和记录移位**。

   **建议：让主键具有 `AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入**。

7. **冗余和重复索引**。有时候，我们会无意间为同一列创建了多个索引，比如：

   ```mysql
   CREATE TABLE repeat_index_demo (
       c1 INT PRIMARY KEY,
       c2 INT,
       UNIQUE uidx_c1 (c1),
       INDEX idx_c1 (c1)
   );
   ```

   这里我们想让 c1 `UNIQUE`，但是也想对 c1 建立索引，但是实际上，`UNIQUE` 就会默认建立一个索引，因此这里实际上建立了两个索引。
