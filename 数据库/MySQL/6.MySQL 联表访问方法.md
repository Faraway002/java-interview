[TOC]

# MySQL 联表访问方法

数据库一个避不开的概念就是 JOIN，翻译成中文就是连接，也叫联表查询。相信很多人在初学连接的时候有些一脸懵逼，理解了连接的语义之后又可能不明白各个表中的记录到底是怎么连起来的，以至于在使用的时候常常陷入下边两种误区：

* 误区一：业务至上，管他三七二十一，再复杂的查询也用在一个连接语句中搞定。
* 误区二：敬而远之，上次 DBA 那给报过来的慢查询就是因为使用了连接导致的，以后再也不敢用了。

本章将介绍 MySQL 连接的原理。

## 1. 连接简介

首先，我们需要两张示例表和一些数据：

```MYSQL
CREATE TABLE t1 (
    m1 int, 
    n1 char(1)
);

CREATE TABLE t2 (
    m2 int, 
    n2 char(1)
);

INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');

INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');
```

### 1.1 连接的本质

**连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户**。

所以我们把 t1 和 t2 两个表连接起来的过程如下图所示：

![image-20220530160918261](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220530160918261.png)

连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为**笛卡尔积**。

### 1.2 连接过程简介

如果我们乐意，是可以连接任意数量张表的，但是如果没有任何限制条件的话，这些表连接起来产生的笛卡尔积可能是非常巨大的。

比方说 3 个 100 行记录的表连接起来产生的笛卡尔积就有 100×100×100=1000000 行数据，所以在连接的时候过滤掉特定记录组合是有必要的，在连接查询中的过滤条件可以分成两种：

* 涉及单表的条件
* 涉及两表的条件

比如：

```mysql
SELECT * 
FROM t1, t2 
WHERE t1.m1 > 1 
  AND t1.m1 = t2.m2 
  AND t2.n2 < 'd';
```

在这个查询中我们指明了这三个过滤条件：

* t1.m1 > 1
* t1.m1 = t2.m2
* t2.n2 < 'd'

这个连接查询的过程如下：

1. 首先**确定第一个需要查询的表，这个表称之为驱动表**。

   这个确定的过程我们在上一章讲过了：只需要选取代价最小的那种访问方法去执行单表查询语句就好了，也就是说从 const、ref、ref_or_null、range、index、all 这些执行方法中选取代价最小的去执行查询。

   此处假设使用 t1 作为驱动表，那么就需要到 t1 表中找满足 t1.m1 > 1 的记录，因为表中的数据太少，我们也没在表上建立二级索引，所以此处查询 t1 表的访问方法就设定为 all 吧，也就是采用全表扫描的方式执行单表查询。

   所以查询过程就如下图所示：

   ![image-20220601193045393](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220601193045393.png)

2. 针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到 t2 表中查找匹配的记录，所谓匹配的记录，指的是符合过滤条件的记录。因为是根据 t1 表中的记录去找 t2 表中的记录，所以 t2 表也可以被称之为**被驱动表**。

   上一步骤从驱动表中得到了 2 条记录，所以需要查询 2 次 t2 表。此时涉及两个表的列的过滤条件 t1.m1 = t2.m2 就派上用场了：

   * 当 t1.m1 = 2 时，过滤条件 t1.m1 = t2.m2 就相当于 t2.m2 = 2 ，所以此时 t2 表相当于有了 t2.m2 = 2、t2.n2 < 'd' 这两个过滤条件，然后到 t2 表中执行单表查询。
   * 当 t1.m1 = 3 时，过滤条件 t1.m1 = t2.m2 就相当于 t2.m2 = 3 ，所以此时 t2 表相当于有了 t2.m2 = 3、t2.n2 < 'd' 这两个过滤条件，然后到 t2 表中执行单表查询。

   所以整个连接查询的执行过程就如下图所示：

   ![image-20220601193455776](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220601193455776.png)

最后的结果只有两条符合过滤条件的记录：

```text
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
| 2    | b    | 2    | b    |
| 3    | c    | 3    | c    |
+------+------+------+------+
```

**在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次**。

### 1.3 内连接和外连接

首先创建两个示例表，并且插入一些数据：

```mysql
CREATE TABLE student (
    number INT NOT NULL AUTO_INCREMENT COMMENT '学号',
    name VARCHAR(5) COMMENT '姓名',
    major VARCHAR(30) COMMENT '专业',
    PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8 COMMENT '学生信息表';

CREATE TABLE score (
    number INT COMMENT '学号',
    subject VARCHAR(30) COMMENT '科目',
    score TINYINT COMMENT '成绩',
    PRIMARY KEY (number, score)
) Engine=InnoDB CHARSET=utf8 COMMENT '学生成绩表';

INSERT INTO student(number, name, major) 
VALUES (20180101, '杜子腾', '软件学院'), 
       (20180102, '范统', '计算机科学与工程'),
       (20180103, '史珍香', '计算机科学与工程');

INSERT INTO score(number, subject, score) 
VALUES (20180101, '母猪的产后护理', 78), 
       (20180101, '论萨达姆的战争准备', 88),
       (20180102, '论萨达姆的战争准备', 98),
       (20180102, '母猪的产后护理', 100);
```

现在我们的目的是查出每个学生的考试成绩，这时候就需要进行连接了，查询语句如下：

```mysql
SELECT s1.number, s1.name, s2.subject, s2.score 
FROM student AS s1, score AS s2 
WHERE s1.number = s2.number;
```

![image-20220601194326086](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220601194326086.png)

结果有一些问题：史珍香同学，也就是学号为 20180103 的同学因为某些原因没有参加考试，所以在 score 表中没有对应的成绩记录。那如果老师想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的连接查询是无法完成这样的需求的。

这个需求的本质是：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。

为了解决这个问题，外连接和内连接就出现了：

* 对于**内连接（INNER JOIN）**的两个表，**驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集**。

  我们之前使用的连接全部都是内连接。

* 对于**外连接（OUTER JOIN）**的两个表，**驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集**。

  那么根据选取的驱动表不同，外连接又分为**左外连接（LEFT OUTER JOIN）**和**右外连接（RIGHT OUTER JOIN）**。

外连接也需要进行过滤，MySQL 提供了 ON 子句用于过滤，它和 WHERE 不同之处在于：

* WHERE 子句中，不论是内连接还是外连接，凡是不符合 WHERE 子句中的过滤条件的记录都不会被加入最后的结果集。
* ON 子句中，对于外连接的驱动表的记录来说，**如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充**。

需要注意的是，这个 **ON 子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的**，所以如果把 ON 子句放到内连接中，MySQL 会把它和 WHERE 子句一样对待，也就是说：**内连接中的 WHERE 子句和 ON 子句是等价的**。

一般情况下，**我们都把只涉及单表的过滤条件放到 WHERE 子句中，把涉及两表的过滤条件都放到 ON 子句中**，我们也一般把**放到 ON 子句中的过滤条件也称之为连接条件**。

## 2. 连接的原理

### 2.1 嵌套循环连接

我们前面提到：对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。

对于内连接来说，选取哪个表为驱动表都没关系，但是外连接不同，**外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表**。流程如下：

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220601203410876.png" alt="image-20220601203410876" style="zoom:67%;" />

如果有 3 个表进行连接的话，那么步骤 2 中得到的结果集就像是新的驱动表，然后第 3 个表就成为了被驱动表，重复上边过程，也就是步骤 2 中得到的结果集中的每一条记录都需要到 t3 表中找一找有没有匹配的记录。那么更多的表连接也是类似的，用伪代码表示一下这个过程就是一个多重循环：

```python
for each row in t1 { # 此处表示遍历满足对 t1 单表查询结果集中的每一条记录
    for each row in t2 { #此处表示对于某条 t1 表的记录来说，遍历满足对 t2 单表查询结果集中的每一条记录
				for each row in t3 { #此处表示对于某条 t1 和 t2 表的记录组合来说，对 t3 表进行单表查询
 						if row satisfies join conditions, send to client
 				}
 		}
}
```

这种**驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为嵌套循环连接（Nested-Loop Join）**，这是最简单，也是最笨拙的一种连接查询算法。

### 2.2 使用索引加快连接速度

如果访问被驱动表的方式都是全表扫描的话，那得要扫描好多次，但是其实**扫描被驱动表也是一次单表访问，我们可以利用索引来加快查询速度**。

以最开始的这个例子为例：

```mysql
SELECT * 
FROM t1, t2 
WHERE t1.m1 > 1 
  AND t1.m1 = t2.m2 
  AND t2.n2 < 'd';
```

我们使用的其实是嵌套循环连接算法执行的连接查询，查询驱动表 t1 后的结果集中有两条记录， 嵌套循环连接算法需要对被驱动表查询 2 次。

下面我们对 t2 表中的字段建立索引：

* 如果我们对 m2 建立索引，因为对 m2 列的条件是等值查找，比如 t2.m2 = 2、t2.m2 = 3 等，所以可能使用到 ref 的访问方法，假设使用 ref 的访问方法去执行对 t2 表的查询的话，需要回表之后再判断 t2.n2 < d 这个条件是否成立。

  如果 m2 是主键或唯一二级索引，那么使用 t2.m2 = 常数值这样的条件从 t2 表中查找记录的访问方法就是 const，是常数级别的，而在被驱动表中，这种方式叫做 `eq_ref`。

* 如果我们对 n2 建立索引，涉及到的条件是 t2.n2 < 'd' ，可能用到 range 的访问方法，假设使用 range 的访问方法对 t2 表的查询的话，需要回表之后再判断在 m2 列上的条件是否成立。

* 假设 m2 和 n2 列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对 t2 表的查询。当然，建立了索引不一定使用索引，只有在二级索引 + 回表的代价比全表扫描的代价更低时才会使用索引。

### 2.3 基于块的嵌套循环连接（Block Nested-Loop Join）

当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。

其实，我们**可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配**，这样就可以大大减少重复从磁盘上加载被驱动表的代价。

所以 MySQL 提出了一个 join buffer 的概念，**join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 join buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的多条驱动表记录做匹配**，因为匹配的过程都是在内存中完成的，所以这样可以显著**减少被驱动表的 I/O 代价**。

使用 join buffer 的过程如下图所示：

![image-20220601231157865](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220601231157865.png)

最好的情况是 join buffer 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。

**MySQL 把这种加入了 join buffer 的嵌套循环连接算法称之为基于块的嵌套连接（Block Nested-Loop Join）**。

这个 join buffer 的大小是可以通过启动参数或者系统变量 join_buffer_size 进行配置，默认大小为 262144 字节（也就是 256KB），最小可以设置为 128 个字节。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大 join_buffer_size 的值来对连接查询进行优化。

另外需要注意的是，**驱动表的记录并不是所有列都会被放到 join buffer 中，只有查询列表中的列和过滤条件中的列才会被放到 join buffer 中**，这再次提醒我们最好不要把 * 作为查询列表，只需要把我们关心的列放到查询列表就好了，这样可以在 join buffer 中放置更多的记录。