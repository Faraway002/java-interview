[TOC]

#  MySQL 查询优化

## 1. MySQL 基于成本的优化

在 MySQL 中一条查询语句的执行成本是由这两个方面组成的：

* **I/O 成本**：存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。
* **CPU 成本**：读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 CPU 成本。

对于 InnoDB 存储引擎来说，页是磁盘和内存之间交互的基本单位，**MySQL 规定读取一个页面花费的成本默认是 1.0**，**读取以及检测一条记录是否符合搜索条件的成本默认是 0.2**。1.0、0.2 这些数字称之为**成本常数**，这两个成本常数我们最常用到，其余的成本常数我们之后再说。

### 1.1 单表查询的成本

我们还是需要一个表作为例子，就拿前两章的单表访问方法中的例子拿过来吧：

```mysql
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

我们假设这表里有 10000 条数据，除 id 列自增外其余的列都是插入的随机值。

#### 1.1.1 基于成本的优化步骤

在一条单表查询语句真正执行之前，**MySQL 的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查询**，这个过程总结一下就是这样:

1. **根据搜索条件，找出所有可能使用的索引**。
2. **计算全表扫描的代价**。
3. **计算使用不同索引执行查询的代价**。
4. **对比各种执行方案的代价，找出成本最低的那一个**。

以下面这条查询语句为例：

```mysql
SELECT * FROM single_table 
WHERE key1 IN ('a', 'b', 'c') 
AND key2 > 10 
AND key2 < 1000 
AND key3 > key2 
AND key_part1 LIKE '%hello%' 
AND common_field = '123';
```

下面按照上面介绍的步骤一一分析：

1. **根据搜索条件，找出所有可能使用的索引**。

   还记得我们在单表查询一章中讲到的范围吗？对于 B+ 树索引来说，只要索引列和常数使用 =、<=>、IN、NOT IN、IS NULL、IS NOT NULL、\>、\<、\>=、\<=、BETWEEN、!=（不等于也可以写成 <>）或者 LIKE 操作符连接起来，就可以产生一个所谓的区间，也就是说这些搜索条件都可能使用到索引，MySQL 把这些涉及到的列叫做 possible keys。

   我们分析一下上边查询中涉及到的几个搜索条件：

   * key1 IN ('a', 'b', 'c') ，这个搜索条件可以使用二级索引 idx_key1 。
   * key2 > 10 AND key2 < 1000 ，这个搜索条件可以使用二级索引 idx_key2 。
   * key3 > key2 ，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。
   * key_part1 LIKE '%hello%'  key_part1 通过 LIKE 操作符和以通配符开头的字符串做比较，不符合最左前缀原则，不可以用索引。
   * common_field = '123' ，由于该列上压根儿没有索引，所以不会用到索引。

   经过这一通分析，我们发现它只可能走二级索引 idx_key1 或 idx_key2。

2.  **计算全表扫描的代价**。

   对于 InnoDB 存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。

   由于查询成本 = I/O 成本 + CPU 成本，所以计算全表扫描的代价需要两个信息：

   * **聚簇索引占用的页面数**
   * **该表中的记录数**

   这两个信息从哪里获取？**MySQL 为每个表维护了一系列的统计信息**，这些统计信息是如何收集的我们之后再提，现在你只需要知道使用 `SHOW TABLE STATUS` 就可以查看这些统计信息了，如下图所示：

   ![image-20220712221939706](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712221939706.png)

   我们目前只关心两个：

   * Rows：本选项表示表中的记录条数。对于使用 MyISAM 存储引擎的表来说，该值是准确的；**对于使用 InnoDB 存储引擎的表来说，该值是一个估计值**。

   * Data_Length：本选项表示表占用的存储空间字节数。对于使用 MyISAM 存储引擎的表来说，该值就是数据文件的大小；对于使用 InnoDB 存储引擎的表来说，该值就相当于**聚簇索引占用的存储空间大小**。

     也就是说，在 InnoDB 中，可以这样计算该值的大小：`Data_Length = 聚簇索引的页面数量 x 每个页面的大小`，本实例使用的是默认 16KB 的页面大小，而上边查询结果显示 Data_Length 的值是 1589248 ，所以我们可以反向来推导出聚簇索引的页面数量为 1589248 ÷ 16 ÷ 1024 = 97。

   得到这两个值之后，怎么算成本呢？

   * I/O 成本 = 页数 * I/O 成本常数 + 微调值 = 97 * 1.0 + 1.1 = 98.1（微调值为什么是 1.1 我们不必在意）
   * CPU 成本 = 记录数 * CPU 成本常数 + 微调值 =  9693 * 0.2 + 1.0 = 1939.6（微调值为什么是 1.0 我们不必在意）

   总成本就是这俩加起来也就是 2037.7 了。

3. **计算使用不同索引执行查询的代价**。

   * idx_key2：使用该索引的搜索条件是：key2 > 10 AND key2 < 1000，范围就是 (10, 1000)。

     由于它是二级索引，因此是范围查找二级索引 + 回表的方式，成本依赖于以下两方面数据：

     * **范围区间数量**：不论某个范围区间的二级索引到底占用了多少页面，**查询优化器粗暴的认为读取索引的一个范围区间的 I/O 成本和读取一个页面是相同的**。

       那么这个成本就是 1.0。

     * **需要回表的记录数**：优化器需要计算二级索引的某个范围区间到底包含多少条记录。

       本例就是要计算 (10, 1000) 这个范围内包含多少二级索引记录，步骤如下：

       * 先根据 key2 > 10 这个条件访问一下 idx_key2 对应的 B+ 树索引，找到满足 key2 > 10 这个条件的第一条记录，我们把这条记录称之为**区间最左记录**。

       * 再根据 key2 < 1000 这个条件继续从 idx_key2 对应的 B+ 树索引中找出第一条满足这个条件的记录，我们把这条记录称之为**区间最右记录**。

       * 如果区间最左记录和区间最右记录相隔不太远（一般是 10 个页面），那就可以精确统计出满足 key2 > 10 AND key2 < 1000 条件的二级索引记录条数；否则只沿着区间最左记录向右读 10 个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量就可以了。

         求这个页面之间隔了多远也很简单，直接统计它们的父节点（索引节点）这两条记录之间隔了多少条记录就可以了。

       根据上述方法，计算出大概有 95 条需要回表的记录，CPU 成本为：95 x 0.2 + 0.01 = 19.01，0.01 是微调值。

     那么回表的成本怎么算呢？MySQL 认为一条记录回表就相当于访问一次页面，因此 I/O 成本为 95 * 1.0 = 95；CPU 成本就是 95 * 0.2 = 19.0

     本例中总 I/O 成本就是 1.0 + 95 = 96，总 CPU 成本就是 19.01 + 19 = 38.01，总成本就是 134.01。

   * idx_key1：对应的搜索条件是： key1 IN ('a', 'b', 'c') ，也就是说相当于 3 个单点区间。

     * **范围区间数量**：三个区间，就是 3 * 1.0 = 3
     * **需要回表的记录数**：由于是三个点，直接统计即可，最后发现 a 对应 35 条，b 对应 44 条，c 对应 39 条，总共 118 条。

     成本计算略，最后总成本为 3 + 118 * 0.2 + 0.01 + 118 * 1.0 + 118 * 0.2 = 168.21。

4. **对比各种执行方案的代价，找出成本最低的那一个**。

   毫无疑问，这里使用 idx_key2 成本更低，且远低于全表扫描，因此使用 idx_key2。

### 1.2 多表连接查询的成本

为了方便，我们直接新建一个 single_table2 表，除了表名不一样，其他都和 single_table 一样。

#### 1.2.1 Conditional Filtering

MySQL 通常采用的是嵌套循环连接算法，**驱动表会被访问一次，被驱动表可能会被访问多次**，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：

* 单次查询驱动表的成本
* 多次查询被驱动表的成本

我们把对驱动表进行查询后得到的记录条数称之为**驱动表的扇出**（fanout）。很显然，**驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低**。

扇出值的计算基本需要靠猜：

* 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。
* 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

MySQL 把这个猜的过程叫做 Condition Filtering。

#### 1.2.2 两表连接成本分析

连接查询的成本计算公式是这样的，很直观：连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本。

对于左外连接和右外连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要分别为驱动表和被驱动表选择成本最低的访问方法。

可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：

* 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。
* 然后分别为驱动表和被驱动表选择成本最低的访问方法。

很显然，**计算内连接查询成本的方式更麻烦一些**，下边我们就以内连接为例。

以下面这个查询为例：

```mysql
SELECT * FROM single_table AS s1 
	INNER JOIN single_table2 AS s2 
ON s1.key1 = s2.common_field 
WHERE s1.key2 > 10 
  AND s1.key2 < 1000 
  AND s2.key2 > 1000 
  AND s2.key2 < 2000;
```

可以选择的连接顺序有两种：

* s1 作为驱动表， s2 作为被驱动表。
* s2 作为驱动表， s1 作为被驱动表。

查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。

分析过程这里就不赘述了，总体来说就是先分析 s1 作为驱动表单表的访问的最低成本，然后把 s1 得出的条件作为已知量带入到 s2 的条件中，进行分析；反过来也是类似的。

#### 1.2.3 多表连接的成本分析

首先要考虑一下多表连接时可能产生出多少种连接顺序：

* 对于两表连接，只有 AB、BA这两种连接顺序。其实相当于 2 × 1 = 2 种连接顺序。
* 对于三表连接，有 ABC、ACB、BAC、BCA、CAB、CBA 这么 6 种连接顺序。其实相当于 3 × 2 × 1 = 6 种连接顺序。
* 对于四表连接的话，则会有 4 × 3 × 2 × 1 = 24 种连接顺序。
* ......
* 对于 n 表连接的话，则有 n × (n-1) × (n-2) × ··· × 1 种连接顺序，也就是 n! 种连接顺序。

那么如果有 n 个表进行连接， MySQL 查询优化器要每一种连接顺序的成本都计算一遍么？这个时间复杂度可是 $O(n!)$。

MySQL 当然不会这么愚蠢，它有一些减少计算的方法：

* **提前结束某种顺序的成本评估**：MySQL 在计算各种链接顺序的成本之前，会**维护一个全局的变量，这个变量表示当前最小的连接查询成本**。

  如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就不对该连接顺序继续往下分析了。

* **系统变量 optimizer_search_depth**：为了防止无穷无尽的分析各种连接顺序的成本，MySQL 提出了 optimizer_search_depth 系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与 optimizer_search_depth 值相同数量的表进行穷举分析。

  很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。

* **根据某些规则压根儿就不考虑某些连接顺序**：即使是有上两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以设计 MySQL 干脆提出了一些所谓的启发式规则 （就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序就根本不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。

  MySQL 提供了一个系统变量 optimizer_prune_level 来控制到底是不是用这些启发式规则。

### 1.3 调节成本常数

我们前面介绍了两个成本常数 ：

* 读取一个页面花费的成本默认是 1.0
* 检测一条记录是否符合搜索条件的成本默认是 0.2

其实除了这两个常数，在 MySQL 中还存在很多常数，它们被存储到了名字为 `mysql` 的数据库中（不是递归，这是一个系统数据库的名字，我们之前介绍过了），我们可以这样查看：

```MYSQL
mysql> SHOW TABLES FROM mysql LIKE '%cost%';
+--------------------------+
| Tables_in_mysql (%cost%) |
+--------------------------+
| engine_cost |
| server_cost |
+--------------------------+
2 rows in set (0.00 sec)
```

我们早在第一章中就说过，一条语句的执行其实是分为两层的：

* server 层
* 存储引擎层

在 server 层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。

也就是说，一条语句在 server 层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的成本常数就存储在了 server_cost 表中；而依赖于存储引擎的一些操作对应的成本常数就存储在了 engine_cost 表中。

#### 1.3.1 server_cost

server_cost 表中在 server 层进行的一些操作对应的成本常数，具体内容如下：

```mysql
mysql> SELECT * FROM mysql.server_cost;
+------------------------------+------------+---------------------+---------+
| cost_name | cost_value | last_update | comment |
+------------------------------+------------+---------------------+---------+
| disk_temptable_create_cost | NULL | 2018-01-20 12:03:21 | NULL |
| disk_temptable_row_cost | NULL | 2018-01-20 12:03:21 | NULL |
| key_compare_cost | NULL | 2018-01-20 12:03:21 | NULL |
| memory_temptable_create_cost | NULL | 2018-01-20 12:03:21 | NULL |
| memory_temptable_row_cost | NULL | 2018-01-20 12:03:21 | NULL |
| row_evaluate_cost | NULL | 2018-01-20 12:03:21 | NULL |
+------------------------------+------------+---------------------+---------+
6 rows in set (0.05 sec)
```

* cost_name：成本常数的名称。
* cost_value：成本常数对应的值。如果该列的值为 NULL 的话，意味着对应的成本常数会采用默认值。
* last_update：最后更新的时间。
* comment：注释。

从 server_cost 中的内容可以看出来，目前在 server 层的一些操作对应的成本常数有以下几种：

| 成本常数名称                 | 默认值 | 描述                                                         |
| ---------------------------- | ------ | ------------------------------------------------------------ |
| disk_temptable_create_cost   | 40.0   | **创建基于磁盘的临时表的成本**，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。 |
| disk_temptable_row_cost      | 1.0    | 向基于**磁盘的临时表写入或读取一条记录的成本**，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。 |
| key_compare_cost             | 0.1    | **两条记录做比较操作的成本**，多用在排序操作上，如果增大这个值的话会提升 filesort 的成本，让优化器可能更倾向于使用索引完成排序而不是 filesort 。 |
| memory_temptable_create_cost | 2.0    | **创建基于内存的临时表的成本**，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。 |
| memory_temptable_row_cost    | 0.2    | **向基于内存的临时表写入或读取一条记录的成本**，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。 |
| row_evaluate_cost            | 0.2    | 这个就是我们之前一直使用的**检测一条记录是否符合搜索条件的成本**，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。 |

#### 1.3.2 engine_cost

engine_cost 表中在存储引擎层进行的一些操作对应的成本常数，具体内容如下：

```mysql
mysql> SELECT * FROM mysql.engine_cost;
+-------------+-------------+------------------------+------------+---------------------+---------+
| engine_name | device_type | cost_name | cost_value | last_update | comment |
+-------------+-------------+------------------------+------------+---------------------+---------+
| default | 0 | io_block_read_cost | NULL | 2018-01-20 12:03:21 | NULL |
| default | 0 | memory_block_read_cost | NULL | 2018-01-20 12:03:21 | NULL |
+-------------+-------------+------------------------+------------+---------------------+---------+
2 rows in set (0.05 sec)
```

与 server_cost 相比， engine_cost 多了两个列：

* engine_name：指成本常数适用的存储引擎名称。如果该值为 default ，意味着对应的成本常数适用于所有的存储引擎。
* device_type：指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘。

从 engine_cost 表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：

| 成本常数名称           | 默认值 | 描述                                                         |
| ---------------------- | ------ | ------------------------------------------------------------ |
| io_block_read_cost     | 1.0    | 从磁盘上读取一个块对应的成本（请注意这里使用的是块 ，而不是页）。<BR>对于InnoDB 存储引擎来说，一个页就是一个块，不过对于 MyISAM 存储引擎来说，默认是以 4096 字节作为一个块。<BR>增大这个值会加重 I/O 成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。 |
| memory_block_read_cost | 1.0    | 与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本 |

> 大家看完这两个的默认值应该有一些疑惑，为什么从内存读取能和从磁盘读取的成本常数一样，显然内存更快吧？
>
> 这主要是因为在 **MySQL 目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上**，所以 MySQL 很粗暴的认为不管这个块有没有加载到内存中，使用的成本都是 1.0。
>
> 不过随着 MySQL 的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改一改吧。

## 2. MySQL 基于规则的优化

MySQL 本质上是一个软件，并不能强制要求使用这个软件的人每一个都是数据库高手，所以难免有些人会写出一些执行起来十分耗费性能的语句。即使是这样， **MySQL 还是依据一些规则，竭尽全力的把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作查询重写**。

### 2.1 条件化简

我们编写的查询语句的搜索条件本质上是一个表达式，这些表达式可能比较繁杂，或者不能高效的执行， MySQL 的查询优化器会为我们简化这些表达式。

#### 2.1.1 移除不必要的括号

有时候表达式里有许多无用的括号，比如这样：

```mysql
((a = 5 AND b = c) OR ((a > c) AND (c < 5)))
```

优化器会把那些用不到的括号给干掉，就是这样：

```mysql
(a = 5 and b = c) OR (a > c AND c < 5)
```

#### 2.1.2 常量传递

有时候某个表达式是某个列和某个常量做等值匹配，比如这样：`a = 5`，当这个表达式和其他涉及列 a 的表达式**使用 AND 连接起来时**，可以将其他表达式中的 a 的值替换为 5 ，比如这样：

````mysql
a = 5 AND b > a
````

就可以被转换为：

```MYSQL
a = 5 AND b > 5
```

#### 2.1.3 等值传递

有时候多个列之间存在等值匹配的关系，比如这样：

```mysql
a = b and b = c and c = 5
```

这个表达式可以被简化为：

```mysql
a = 5 and b = 5 and c = 5
```

#### 2.1.4  移除没用的条件

对于一些明显永远为 TRUE 或者 FALSE 的表达式，优化器会移除掉它们，比如这个表达式：

```mysql
(a < 1 and b = b) OR (a = 6 OR 5 != 5)
```

很明显， b = b 这个表达式永远为 TRUE ， 5 != 5 这个表达式永远为 FALSE ，所以简化后的表达式就是这样的：

```mysql
(a < 1 and TRUE) OR (a = 6 OR FALSE)
```

可以继续被简化为：

```mysql
a < 1 OR a = 6
```

#### 2.1.5 表达式计算

在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：

```mysql
a = 5 + 1
```

因为 5 + 1 这个表达式只包含常量，所以就会被化简成：

```mysql
a = 6
```

但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：

```mysql
ABS(a) > 5
```

或者：

```mysql
-a < -8
```

优化器是不会尝试对这些表达式进行化简的。我们前边说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中。

#### 2.1.6 HAVING 子句和 WHERE 子句的合并

如果查询语句中没有出现诸如 SUM 、 MAX 等等的聚集函数以及 GROUP BY 子句，优化器就把 HAVING 子句和 WHERE 子句合并起来。

#### 2.1.7 常量表检测

MySQL 认为下面这两种查询特别快：

* 查询的表中一条记录都没有，或者只有一条记录。

  > 这是依赖统计数据的，而 InnoDB 的统计数据是不准确的，因此本条适用于 MyISAM 或 Memory。

* 使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。

所以也把通过这两种方式查询的表称之为**常量表**，优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。

比如：

```mysql
SELECT * FROM table1 
	INNER JOIN table2
ON table1.column1 = table2.column2 
WHERE table1.primary_key = 1;
```

这个查询可以使用主键和常量值的等值匹配来查询 table1 表，也就是在这个查询中 table1 表相当于常量表 ，**在分析对 table2 表的查询成本之前，就会执行对 table1 表的查询**，并把查询中涉及 table1 表的条件都替换掉，也就是上边的语句会被转换成这样：

```MYSQL
SELECT table1表记录的各个字段的常量值, table2.* FROM table1 INNER JOIN table2 
 ON table1表column1列的常量值 = table2.column2;
```

### 2.2 外连接消除

我们曾经说过，内连接的驱动表和被驱动表的位置可以相互转换，而 左（外）连接 和 右（外）连接 的驱动表和被驱动表是固定的。这就导致**内连接可能通过优化表的连接顺序来降低整体的查询成本，而外连接却无法优化表的连接顺序**。

为了故事的顺利发展，我们还是把之前介绍连接原理时用过的 t1 和 t2 表请出来，为了防止大家早就忘掉了，我们再看一下这两个表的结构：

```mysql
CREATE TABLE t1 (
    m1 int, 
    n1 char(1)
) Engine=InnoDB, CHARSET=utf8;

CREATE TABLE t2 (
    m2 int, 
    n2 char(1)
) Engine=InnoDB, CHARSET=utf8;
```

我们之前说过，**外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记录会被舍弃**。

那么查询的效果可能是这样的：

```mysql
mysql> SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
+------+------+------+------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
| 1 | a | NULL | NULL |
+------+------+------+------+
3 rows in set (0.00 sec)
```

对于上边例子中的左外连接来说，由于驱动表 t1 中 m1=1, n1='a' 的记录无法在被驱动表 t2 中找到符合 ON 子句条件 t1.m1 = t2.m2 的记录，所以就直接把这条记录加入到结果集，对应的 t2 表的 m2 和 n2 列的值都设置为 NULL 。

我们知道在连接查询中 WHERE 子句的杀伤力比较大，凡是不符合 WHERE 子句中条件的记录都不会参与连接。**只要我们在搜索条件中指定关于被驱动表相关列的值不为 NULL ，那么外连接中在被驱动表中找不到符合 ON 子句条件的驱动表记录也就被排除出最后的结果集了**，也就是说在这种情况下：外连接和内连接也就没有什么区别了。

比方说这个查询：

```mysql
mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.n2 IS NOT NULL;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
+------+------+------+------+
2 rows in set (0.01 sec)
```

由于指定了被驱动表 t2 的 n2 列不允许为 NULL ，所以上边的 t1 和 t2 表的左外连接查询和内连接查询是一样一样的。

当然，我们也可以不用显式的指定被驱动表的某个列 IS NOT NULL ，只要隐含的有这个意思就行了，比方说这样：

```mysql
mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
+------+------+------+------+
1 row in set (0.00 sec)
```

在这个例子中，我们在 WHERE 子句中指定了被驱动表 t2 的 m2 列等于 2 ，也就相当于间接的指定了 m2 列不为 NULL 值，所以上边的这个左外连接查询其实和下边这个内连接查询是等价的：

```mysql
mysql> SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
+------+------+------+------+
1 row in set (0.00 sec)
```

我们把这种在外连接查询中，指定的 WHERE 子句中包含被驱动表中的列不为 NULL 值的条件称之为 空值拒绝（reject-NULL）。在**被驱动表的 WHERE 子句符合空值拒绝的条件后，外连接和内连接可以相互转换**。

这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。

### 2.3 子查询优化

#### 2.3.1 子查询简介

子查询就是查询里的查询，外层的查询就叫外层查询，子查询可以在外层查询里的多个地方出现，比如：

* SELECT 子句中：例如 `SELECT (SELECT m1 FROM t1 LIMIT 1)`

* FROM 子句中：例如 ` SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 > 2) AS t`

  这里可以把子查询 `SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 > 2` 的结果看作是一个新的表 t，MySQL 把这种子查询的结果集组成的表称之为**派生表**。

* WHERE 或 ON 子句中：例如 `SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2)`

* ORDER BY 和 GROUP BY 子句中，也能使用子查询，但是意义不大，不做介绍。

子查询根据其特点，可以以不同的标准分类。

##### 2.3.1.1 按返回的结果集分类

* 标量子查询：只返回一个单一值的子查询，比如 ` SELECT (SELECT m1 FROM t1 LIMIT 1)`
* 行子查询：只返回一条记录的子查询，比如 ` SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1)`
* 列子查询：查询出一个列的数据的子查询，比如 ` SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2)`
* 表子查询：子查询的结果既包含很多条记录，又包含很多个列，比如 ` SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2)`

##### 2.3.1.2 按与外层查询关系分类

* 不相关子查询：如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为不相关子查询。

  迄今为止我们列举的例子都是不相关子查询。

* 相关子查询：如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为相关子查询。

  比如：` SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2)`，例子中的子查询是 (SELECT m2 FROM t2 WHERE n1 = n2) ，可是这个查询中有一个搜索条件是 n1 = n2 ，别忘了 n1 是表 t1 的列，也就是外层查询的列，也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个相关子查询 。

#### 2.3.2 子查询注意事项

* 子查询必须用小括号扩起来。

* 在 SELECT 子句中的子查询必须是标量子查询。

* 在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用 LIMIT 1 语句来限制记录数量。

* 对于 [NOT] IN/ANY/SOME/ALL 子查询来说，子查询中不允许有 LIMIT 语句。

  为啥不合法？我也不知道，MySQL 就这么规定的。

  正因为 [NOT] IN/ANY/SOME/ALL 子查询不支持 LIMIT 语句，所以子查询中的这些语句也就是多余的了：

  * ORDER BY
  * DISTINCT
  * 没有聚集函数以及 HAVING 子句的 GROUP BY

* 不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。

#### 2.3.3 子查询的执行方式

本节依然使用我们的 single_table 表，同时，依旧有 s1 s2 两个表的内容和 single_table 相同。

直观上看，大家可能是这么想的：

* 不相关子查询：`SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2)`

  * 先单独执行 `SELECT common_field FROM s2`
  * 然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询 `SELECT * FROM s1 WHERE key1 IN (...) `

* 相关子查询：`SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE s1.key2 = s2.key2)`

  这个查询中的子查询中出现了 s1.key2 = s2.key2 这样的条件，意味着该子查询的执行依赖着外层查询的值，所以：

  * 先从外层查询中获取一条记录，本例中也就是先从 s1 表中获取一条记录。
  * 然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从 s1 表中获取的那条记录中找出 s1.key2 列的值，然后执行子查询。
  * 最后根据子查询的查询结果来检测外层查询 WHERE 子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。
  * 再次执行第一步，获取第二条外层查询中的记录，以此类推

MySQL 内子查询**差不多**是按照**上述方式**执行的，但是事实上，根据类型的不同，MySQL 执行子查询的方式也不同。

##### 2.3.3.1 标量子查询与行子查询的执行方式

对于包含**不相关的标量子查询或者行子查询**的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就**当作两个单表查询**就好了，所以方式就和我们上面说的差不多。

而对于相关标量子查询或者行子查询来说，它们的执行方式也和我们刚刚说的一样。

所以，**这两种子查询的查询方式就和我们上面讲的一样**。

##### 2.3.3.2 IN 子查询优化

IN 子查询是们日常生活中最常用的子查询类型，所以 MySQL 为了优化它花了很多心思，执行过程也就和我们刚刚的不太一样了。

###### 2.3.3.2.1 物化表

如果数据量比较小，那么使用上面所说的方式是没问题的，但是如果单独执行子查询后的结果集太多的话，就会导致这些问题：

* 结果集太多，可能内存中都放不下
* 对于外层查询来说，如果子查询的结果集太多，那就意味着 IN 子句中的参数特别多，就会导致无法使用索引，而转而使用全表扫描。

于是，**MySQL 不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里**。写入的过程如下：

* 该临时表的列就是子查询结果集中的列。

* 写入临时表的记录会被去重。

* 一般情况下子查询结果集不会大的离谱，所以会为它建立**基于内存的 Memory 存储引擎的临时表**，而且会为该表建立**哈希索引**。

  如果子查询的结果集非常大，超过了系统变量 tmp_table_size 或者 max_heap_table_size ，临时表会转而使用**基于磁盘的存储引擎**来保存结果集中的记录，索引类型也对应转变为 **B+ 树索引**。

MySQL 把这个子查询结果集中的记录保存到临时表的过程称为**物化（Materialize）**，那个临时表就叫做**物化表**。

**有了物化表以后，我们就可以使用连接的方式进行查询了**，而 MySQL 会像对待一个普通连接一样对待它，也就是会由查询优化器分析，选取一个驱动表，这个过程我们就不再叙述了。

###### 2.3.3.2.2 semi-join

虽然物化是一种很好的方式，但是有没有一种方法能够不进行物化操作，直接转换为连接查询呢？

我们看看这个 SQL：

```mysql
SELECT * FROM s1
WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
```

我们可以把这个查询理解成：对于 s1 表中的某条记录，如果我们能在 s2 表（准确的说是执行完 WHERE s2.key3 = 'a' 之后的结果集）中找到一条或多条记录，这些记录的 common_field 的值等于 s1 表记录的 key1 列的值，那么该条 s1 表的记录就会被加入到最终的结果集。

这个过程其实和把 s1 和 s2 两个表连接起来的效果很像：

```mysql
SELECT s1.* FROM s1 INNER JOIN s2
ON s1.key1 = s2.common_field
WHERE s2.key3 = 'a';
```

只不过我们不能保证对于 s1 表的某条记录来说，在 s2 表（准确的说是执行完 WHERE s2.key3 = 'a' 之后的结果集）中有多少条记录满足 s1.key1 = s2.common_field 这个条件。也就是说，这个连接查询只能从 s1 查出至多一条有关记录。

这就是 MySQL 半连接（semi-join）的概念：**对于 s1 表的某条记录来说，我们只关心在 s2 表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留 s1 表的记录**。

MySQL 对于半连接有五种实现策略：

* **Table pullout （子查询中的表上拉）**：当子查询的查询列表处只有**主键或者唯一索引列**时，可以直接把子查询中的表上拉到外层查询的 FROM 子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中。

  比如：

  ```mysql
  SELECT * FROM s1 
  WHERE key2 IN (SELECT key2 FROM s2 WHERE key3 = 'a');
  ```

  上拉后：

  ```mysql
  SELECT s1.* FROM s1 INNER JOIN s2 
  ON s1.key2 = s2.key2 
  WHERE s2.key3 = 'a';
  ```

  唯一索引或主键意味着记录只有一条，因此可以实现半连接。

* **DuplicateWeedout（重复值消除）**：对于这个查询来说：

  ```mysql
  SELECT * FROM s1 
  WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
  ```

  转换为半连接查询后， s1 表中的某条记录可能在 s2 表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中，为了消除重复，我们可以建立一个临时表，比方说这个临时表长这样：

  ```mysql
  CREATE TABLE tmp (
  	id PRIMARY KEY
  );
  ```

  这样在执行连接查询的过程中，每当某条 s1 表中的记录要加入结果集时，就首先把这条记录的 id 值加入到这个临时表里，如果添加成功，说明之前这条 s1 表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，说明这条之前这条 s1 表中的记录已经加入过最终的结果集，这里直接把它丢弃就好了。

  这种**使用临时表消除 semi-join 结果集中的重复值**的方式称之为 DuplicateWeedout。

* **LooseScan（松散索引扫描）**：这个查询：

  ```mysql
  SELECT * FROM s1 
  WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 > 'a' AND key1 < 'b');
  ```

  在子查询中，对于 s2 表的访问可以使用到 key1 列的索引，而恰好子查询的查询列表处就是 key1 列，这样在将该查询转换为半连接查询后，如果将 s2 作为驱动表执行查询的话，那么执行过程就是这样：

  ![image-20220713235721790](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713235721790.png)

  如图所示，在 s2 表的 idx_key1 索引中，值为 'aa' 的二级索引记录一共有3条，那么只需要取第一条的值到 s1 表中查找 s1.key3 = 'aa' 的记录，如果能在 s1 表中找到对应的记录，那么就把对应的记录加入到结果集。依此类推，其他值相同的二级索引记录，也只需要取第一条记录的值到 s1 表中找匹配的记录，这种**虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为松散索引扫描**。

* **Semi-join Materialization（物化）**：我们之前介绍的先把外层查询的 IN 子句中的不相关子查询进行**物化**，然后再进行外层查询的表和物化表的连接本质上**也是一种 semi-join**，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。

* **FirstMatch（首次匹配）**：FirstMatch 是一种最原始的半连接执行方式，就是我们最开始说的那种执行方式，先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。

最后我们讲一下 semi-join 的适用条件，只有形如这样的查询才可以被转换为 semi-join：

```mysql
SELECT ... FROM outer_tables 
WHERE expr IN (SELECT ... FROM inner_tables ...) AND ...
```

或者这样的形式也可以：

```mysql
SELECT ... FROM outer_tables 
WHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...
```

文字描述为：

* 该**子查询必须是和 IN 语句组成的布尔表达式**，并且**在外层查询的 WHERE 或者 ON 子句中出现**。
* **外层查询也可以有其他的搜索条件**，只不过**和 IN 子查询的搜索条件必须使用 AND 连接起来**。
* 该**子查询必须是一个单一的查询**，不能是由若干查询由 UNION 连接起来的形式。
* 该子查询**不能包含 GROUP BY 或者 HAVING 语句或者聚集函数**。

##### 2.3.3.3 派生表优化

前边说过把子查询放在外层查询的 FROM 子句后，那么这个子查询的结果相当于一个派生表。

对于含有派生表的查询， MySQL 提供了两种执行策略：

* **派生表物化**，这个比较好理解，这里就不重复叙述了。

* **将派生表和外层的表合并**，也就是将查询重写为没有派生表的形式。

  首先看一个简单的例子：

  ```mysql
  SELECT * FROM (SELECT * FROM s1 WHERE key1 = 'a') AS derived_s1;
  ```

  这个查询本质上就是想查看 s1 表中满足 key1 = 'a' 条件的的全部记录，所以和下边这个语句是等价的：

  ```mysql
  SELECT * FROM s1 WHERE key1 = 'a'
  ```

  这样我们就消除了派生表。

  但是复杂一点的情况又怎么样呢？

  ```mysql
  SELECT * FROM (
      SELECT * FROM s1 WHERE key1 = 'a'
  ) AS derived_s1 INNER JOIN s2
  ON derived_s1.key1 = s2.key1
  WHERE s2.key2 = 1;
  ```

  我们可以将派生表与外层查询的表合并，然后将派生表中的搜索条件放到外层查询的搜索条件中，就像这样：

  ```mysql
  SELECT * FROM s1 INNER JOIN s2 
  ON s1.key1 = s2.key1
  WHERE s1.key1 = 'a' AND s2.key2 = 1;
  ```

  这样通过将外层查询和派生表合并的方式成功的消除了派生表。

  不过，派生表消除适用条件比较苛刻，下面这些情况都不行：

  * 聚集函数，比如 MAX()、MIN()、SUM()
  * DISTINCT
  * GROUP BY
  * HAVING
  * LIMIT
  * UNION 或 UNION ALL
  * 派生表对应的子查询的 SELECT 子句中含有另一个子查询

MySQL 在执行带有派生表的时候，**优先尝试把派生表和外层查询合并掉，如果不行的话，再把派生表物化掉执行查询**。

##### 2.3.3.4 ANY/ALL 子查询优化

如果 ANY/ALL 子查询是不相关子查询的话，它们在很多场合都能转换成我们熟悉的方式去执行。

> **复习**
>
> * ANY 子查询的含义是子查询结果集中只要有一条满足条件即可。
>
>   比如：`SELECT * FROM t1 WHERE m1 > ANY(SELECT m2 FROM t2)`，这里就是只要 t2 里查出来的 m2 有一个能满足 m1 > m2，那么就会被加入到最后的结果集中。
>
> * ALL 子查询的含义是子查询结果集中全部都要满足条件。
>
>   比如：`SELECT * FROM t1 WHERE m1 > ALL(SELECT m2 FROM t2)`，这里就是只要 t2 里查出来的 m2 必须全部能满足 m1 > m2，那么就会被加入到最后的结果集中。

但是实际上，ANY/ALL 就相当于调用聚集函数 MIN 和 MAX，因此只要能使用这俩聚集函数的地方都可以代替 ANY/ALL。

![image-20220714182736264](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714182736264.png)

## 3. Explain 详解

一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的**执行计划**，这个**执行计划展示了接下来具体执行查询的方式**，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。

MySQL 专门为我们提供了 `EXPLAIN` 语句来帮助我们查看某个查询语句的具体执行计划，要使用它页很简单，只需要在查询语句前添加一个 `EXPLAIN`，比如：

![image-20220713181459362](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713181459362.png)

这个就是所谓的执行计划了，没有文档指引的话，这个东西很难看懂，本节我们就来介绍一下 `EXPLAIN` 输出的各列的含义，以及在这个输出下我们该如何优化 SQL。

>其实除了以 SELECT 开头的查询语句，其余的 DELETE 、 INSERT 、 REPLACE 以及 UPDATE 语句前边都可以加上 `EXPLAIN` 用来查看这些语句的执行计划。

下表列出了 EXPLAIN 的输出列：

| 列名          | 描述                                                      |
| ------------- | --------------------------------------------------------- |
| id            | 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id |
| select_type   | SELECT 关键字对应的那个查询的类型                         |
| table         | 表名                                                      |
| partitions    | 匹配的分区信息                                            |
| type          | 针对单表的访问方法                                        |
| possible_keys | 可能用到的索引                                            |
| key           | 实际使用的索引                                            |
| key_len       | 实际使用到的索引长度                                      |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息    |
| rows          | 预估的需要读取的记录条数                                  |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比              |
| Extra         | 一些额外的信息                                            |

本节中，涉及的单表一律默认为 single_table 表，多表一律认为是和 single_table 表一模一样的表。

### 3.1 执行计划各列详解

#### 3.1.1 table

不论我们的查询语句有多复杂，里面包含了多少个表，到最后也是需要对每个表进行单表访问的，所以 MySQL 规定 EXPLAIN 语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table 列代表着该表的表名。

我们看一个简单的查询：

![image-20220713175136116](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713175136116.png)

这个查询语句只涉及对 s1 表的单表查询，所以 EXPLAIN 输出中只有一条记录，其中的 table 列的值是 s1 ，表明这条记录是用来说明对 s1 表的单表访问方法的。

下边我们看一个连接查询的执行计划：

![image-20220713175338555](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713175338555.png)

可以看到这个连接查询的执行计划中有两条记录，这两条记录的 table 列分别是 s1 和 s2 ，这两条记录用来分别说明对 s1 表和 s2 表的访问方法是什么。

#### 3.1.2 id

我们知道我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比如下边这个查询语句：

```mysql
SELECT * 
FROM s1 
WHERE key1 = 'a';
```

稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如:

```mysql
SELECT * FROM s1 INNER JOIN s2
ON s1.key1 = s2.key1
WHERE s1.common_field = 'a';
```

但是下边两种情况下在一条查询语句中会出现多个 SELECT 关键字：

* 子查询的情况
* 包含 `UNION` 语句的情况

查询语句中每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id 值，这个 id 值就是 EXPLAIN 语句的第一个列。

比如下边这个查询中只有一个 SELECT 关键字，所以 EXPLAIN 的结果中也就只有一条 id 列为 1 的记录：

![image-20220713175136116](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713175136116.png)

对于连接查询来说，一个 SELECT 关键字后边的 FROM 子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的 id 值都相同。

![image-20220713175338555](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713175338555.png)

对于刚刚说到的那两种情况，id 值就会出现不一样了，比如：

![image-20220713180019021](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713180019021.png)

s1 表在外层查询中，外层查询有一个独立的 SELECT 关键字，所以第一条记录的 id 值就是 1，s2 表在子查询中，子查询有一个独立的 SELECT 关键字，所以第二条记录的 id 值就是 2。

> 需要特别注意的是，查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。

对于 UNION 来说，情况也类似，但是有点不一样：

![image-20220713180150227](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713180150227.png)

第三条记录 id 为 NULL，table 也是一个奇怪的名字。这是因为 **UNION 会把多个查询的结果集合并起来并对结果集中的记录进行去重，去重是靠在内部创建一个临时表实现的**，所以这个 `<union1,2>` 是一个临时表，id 为 NULL 表明这个临时表是为了合并两个查询的结果集而创建的。

和 UNION 比起来，UNION ALL 就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录 合并成一个并返回给用户，所以也就不需要使用临时表。如下图所示：

![image-20220713180406129](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713180406129.png)

#### 3.1.3 select_type

MySQL 为每一个 SELECT 关键字代表的小查询都定义了一个称之为 select_type 的属性，我们还是先介绍一下 select_type 都能取哪些值：

| 名称                 | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| SIMPLE               | 查询语句中不包含 UNION 或者子查询的查询都算作是 SIMPLE 类型  |
| PRIMARY              | 对于包含 UNION 、 UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type 就是 PRIMARY |
| UNION                | 对于包含 UNION 或者 UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是 UNION |
| UNION RESULT         | MySQL 选择使用临时表来完成 UNION 查询的去重工作，针对该临时表的查询的 select_type 就是 UNION RESULT |
| SUBQUERY             | 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 SUBQUERY |
| DEPENDENT SUBQUERY   | 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 DEPENDENT SUBQUERY |
| DEPENDENT UNION      | 在包含 UNION 或者 UNION ALL 的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的 select_type 的值就是 DEPENDENT UNION |
| DERIVED              | 对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的 select_type 就是 DERIVED |
| MATERIALIZED         | 当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就是 MATERIALIZED |
| UNCACHEABLE SUBQUERY | 不常用，这里不再叙述，可以从名称推断其含义                   |
| UNCACHEABLE UNION    | 不常用，这里不再叙述，可以从名称推断其含义                   |

#### 3.1.4 partitions

我们根本没有在任何地方看到过这个概念，且之前举过的例子这个列都是 NULL，因此我们不关注这个列。

#### 3.1.5 type

我们之前说过执行计划的一条记录就代表着 MySQL 对某个表的执行查询时的访问方法，其中的 type 列就表明了这个访问方法是什么。

比如：

![image-20220713181533619](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713181533619.png)

可以看到 type 列的值是 ref ，表明 MySQL 即将使用 ref 访问方法来执行对 s1 表的查询。

我们之前完整的说过单表的访问方法，分别是：const、ref、ref_or_null、index、range、all，实际上，MySQL 还有以下访问方法，这些访问方法通常不是针对单表的访问的：system、eq_ref、fulltext、index_merge、unique_subquery、index_subquery。

我们再来回顾一下，同时也包括对新出现的访问方法的介绍：

* system：当**表中只有一条记录**并且**该表使用的存储引擎的统计数据是精确的**（MyISAM 或 Memory 引擎），那么对该表的访问就是 system。
* const：当我们根据**主键**或者**唯一二级索引**列与**常量进行等值匹配**时，对单表的访问方法就是 const。
* eq_ref：在连接查询时，如果**被驱动表**是**通过主键或者唯一二级索引**列**等值匹配**的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是 eq_ref（相当于多表里把驱动表的扇出转换为多个常量，因此每次被驱动表都使用 const）。
* ref：当通过**普通的二级索引**列与**常量进行等值匹配**时来查询某个表，那么对该表的访问方法就可能是 ref。
* fulltext：当创建了全文索引的字段查询时，访问方法就是 fulltext。
* ref_or_null：当对**普通二级索引**进行**等值匹配查询**，该索引列的值也**可以是 NULL 值**时，那么对该表的访问方法就可能是 ref_or_null。
* index_merge：使用索引合并的方式来执行查询时，对该表的访问方法就是 index_merge。
* unique_subquery：类似于两表连接中被驱动表的 eq_ref 访问方法， unique_subquery 是针对在一些**包含 IN 子查询**的查询语句中，如果查询优化器决定**将 IN 子查询转换为 EXISTS 子查询**，而且**子查询可以使用到主键进行等值匹配**的话，那么该子查询执行计划的 type 列的值就是 unique_subquery。
* index_subquery：index_subquery 与 unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引。
* range：如果使用**索引**获取某些**范围区间**的记录，那么就可能使用到 range 访问方法。
* index：可以使用**索引覆盖**，但需要**扫描全部的索引记录**时（通常是不符合最左匹配原则才会导致这种情况，如果是最左匹配，一般会是 ref），该表的访问方法就是 index。
* all：全表扫描时，访问方法就是 all。

通常来说，这些访问方法按照上面的顺序性能依次变差。

#### 3.1.6 possible_keys 和 key

possible_keys 列表示在某个查询语句中，对某个表执行单表查询时**可能用到的索引**有哪些， key 列表示**实际用到的索引**有哪些。

比如：

![image-20220713183632320](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713183632320.png)

这个查询中，涉及到 idx_key1 和 idx_key3 两个索引，但是最终选择了 idx_key3 进行查询。

有一点比较特别，就是**在使用 index 访问方法来查询某个表时， possible_keys 列是空的，而 key 列展示的是实际使用到的索引：

![image-20220713183818679](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713183818679.png)

另外需要注意的一点是，**possible_keys 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间**，所以如果可以的话，尽量删除那些用不到的索引。

#### 3.1.7 key_len

key_len 列表示**当优化器决定使用某个索引执行查询时，该索引记录的最大长度**，它是由这三个部分构成的:

* 对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的 变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100)，使用的字符集是 utf8，那么该列实际占用的最大存储空间就是 100 × 3 = 300 个字节。
* 如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多 1 个字节。 
* 对于变长字段来说，都会有 2 个字节的空间来存储该变长列的实际长度。

我们在介绍行格式的时候就介绍过了，这里应该很容易理解。

比如：

![image-20220713184040482](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184040482.png)

由于 id 列的类型是 INT ，并且不可以存储 NULL 值，所以在使用该列的索引时 key_len 大小就是 4。

再比如：

![image-20220713184309208](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184309208.png)

Key2 是 INT，可以存储 NULL 值，所以 key_len 就是 4 + 1 = 5。

再比如：

![image-20220713184404826](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184404826.png)

key1 是 VARCHAR(100)，而字符编码是 UTF-8，则实际占用就是 300 字节，而可以存储 NULL，并且可变长，所以再 + 3，最后就是 303。

MySQL 设计该列的目的是让我们区分到底使用了几个索引列，比如：

![image-20220713184641772](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184641772.png)

对于这个符合最左匹配的联合索引，使用一个列就是 303，而使用两个就是 606。

#### 3.1.8 ref

当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery 其中之一时， ref 列展示的就是与索引列作等值匹配的东西是什么，比如只是一个常数或者是某个列。

举个例子：

![image-20220713184851011](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184851011.png)

这个查询走的是普通索引，且是等值匹配，因此是 ref 的访问方法，而和列作等值匹配的又是一个常量，因此 ref 列的值就是 const。

看个稍微复杂一点的例子：

![image-20220713185017929](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713185017929.png)

可以看到对被驱动表 s2 的访问方法是 eq_ref，而对应的 ref 列的值是 test.s2.id，这说明在对被驱动表进行访问时会用到主键索引与一个列进行等值匹配的条件。

有的时候与索引列进行等值匹配的对象是一个函数，比方说下边这个查询：

![image-20220713185336972](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713185336972.png)

可以看到，这里 ref 的值是 func，表示一个函数。

#### 3.1.9 rows

如果查询优化器决定使用**全表扫描**的方式对某个表执行查询时，执行计划的 rows 列就代表**预计需要扫描的行数**；如果使用**索引**来执行查询时，执行计划的 rows 列就代表**预计扫描的索引记录行数**。

比如：

![image-20220713190803069](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713190803069.png)

#### 3.1.10 filtered

之前在分析连接查询的成本时提出过一个 condition filtering 的概念，就是 MySQL 在计算驱动表扇出时采用的一个策略：

* 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。
* 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

比如：

![image-20220713193528944](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713193528944.png)

从执行计划的 key 列中可以看出来，该查询使用 idx_key1 索引来执行查询，从 rows 列可以看出满足 key1 > 'z' 的记录有 323 条。执行计划的 filtered 列就代表查询优化器预测在这 323 条记录中，有多少条记录满足其余的搜索条件，也就是 common_field = 'a' 这个条件的百分比。

此处 filtered 列的值是 10.00 ，说明查询优化器预测在 323 条记录中有 10.00% 的记录满足 common_field = 'a' 这个条件。

对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 filtered 值，这反映了被驱动表将会被大概查询多少次，比方说下边这个查询：

![image-20220713193708691](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713193708691.png)

从执行计划中可以看出来，查询优化器打算把 s1 当作驱动表，s2 当作被驱动表。我们可以看到驱动表 s1 表的执行计划的 rows 列为 9887，filtered 列为 10.00，这意味着驱动表 s1 的扇出值就是 9688 × 10.00% = 968.8，这说明还要对被驱动表执行大约 968 次查询。

#### 3.1.11 Extra

Extra 列是用来说明一些额外信息的，我们**可以通过这些额外信息来更准确的理解 MySQL 到底将如何执行给定的查询语句**。

Extra 列实在是比较多，我们就挑几个常见的讲讲：

* **No tables used**：当查询语句的没有 FROM 子句时将会提示该额外信息。

  比如：

  ![image-20220713194241247](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713194241247.png)

* **Impossible WHERE**：查询语句的 WHERE 子句永远为 FALSE 时将会提示该额外信息。

  比如：

  ![image-20220713194527205](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713194527205.png)

* **No matching min/max row**：当查询列表处有 MIN 或者 MAX 聚集函数，但是并没有符合 WHERE 子句中的搜索条件的记录时，将会提示该额外信息。

  比如：

  ![image-20220713194642782](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713194642782.png)

* **Using index**：索引覆盖的情况下，在 Extra 列将会提示该额外信息。

  比如：

  ![image-20220713194739623](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713194739623.png)

* **Using index condition**：有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：

  ```mysql
  SELECT * FROM s1 
  WHERE key1 > 'z' 
    AND key1 LIKE '%a';
  ```

  其中的 key1 > 'z' 可以使用到索引，但是 key1 LIKE '%a' 却无法使用到索引，在以前版本的 MySQL 中，是按照下边步骤来执行这个查询的：

  * 先根据 key1 > 'z' 这个条件，从二级索引 idx_key1 中获取到对应的二级索引记录
  * 根据上一步骤得到的二级索引记录中的主键值**进行回表，找到完整的用户记录再检测该记录是否符合 key1 LIKE '%a' 这个条件**，将符合条件的记录加入到最后的结果集。

  但是虽然 key1 LIKE '%a' 不能组成范围区间参与 range 访问方法的执行，但这个条件毕竟只涉及到了 key1 列，所以 MySQL 把上边的步骤改进了一下：

  * 第一步不变：先根据 key1 > 'z' 这个条件，定位到二级索引 idx_key1 中对应的二级索引记录。
  * 对于指定的二级索引记录，**先不着急回表，而是先检测一下该记录是否满足 key1 LIKE '%a' 这个条件，如果这个条件不满足，则该二级索引记录根本就没必要回表**。
  * 对于满足 key1 LIKE '%a' 这个条件的二级索引记录执行回表操作。

  这个改动虽然只改进了一点点，但是对于性能提升还是有帮助的，MySQL 把这个改进叫做**索引下推**。

  **如果在查询中使用了索引下推，在 Extra 列将会提示该额外信息**。

  比如：

  ![image-20220713223938320](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713223938320.png)

* **Using where**：当我们使用全表扫描来执行对某个表的查询，并且该语句的 WHERE 子句中有针对该表的搜索条件时，在 Extra 列中会提示上述额外信息。

  比如：

  ![image-20220713224037332](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713224037332.png)

  当使用索引访问来执行对某个表的查询，并且该语句的 WHERE 子句中有除了该索引包含的列之外的其他搜索条件时，在 Extra 列中也会提示上述额外信息。

  比如：

  ![image-20220713224207044](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713224207044.png)

* Using join buffer (Block Nested Loop)：在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度， MySQL 一般会为其分配一块名叫 join buffer 的内存块来加快查询速度，也就是我们所讲的**基于块的嵌套循环算法**。

  比如：

  ![image-20220713224307920](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713224307920.png)

* **Not exists**：当我们使用左（外）连接时，如果 WHERE 子句中包含要求被驱动表的某个列等于 NULL 值的搜索条件，而且那个列又是不允许存储 NULL 值的，那么在该表的执行计划的 Extra 列就会提示 Not exists 额外信息。

  比如：

  ![image-20220713224418069](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713224418069.png)

* **Using intersect(...) 、 Using union(...) 和 Using sort_union(...)**：如果执行计划的 Extra 列出现了 Using intersect(...) 提示，说明准备使用 Intersect 索引合并的方式执行查询，括号中的 ... 表示需要进行索引合并的索引名称；如果出现了 Using union(...) 提示，说明准备使用 Union 索引合并的方式执行查询；出现了 Using sort_union(...) 提示，说明准备使用 Sort-Union 索引合并的方式执行查询。

  总之，出现索引合并的情况就会有这些提示。

  比如：

  ![image-20220713230212993](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713230212993.png)

* **Zero limit**：当我们的 LIMIT 子句的参数为 0 时，表示根本不打算从表中读出任何记录，将会提示该额外信息。

  比如：

  ![image-20220713224809178](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713224809178.png)

* **Using filesort**：有一些情况下对结果集中的记录进行排序是可以使用到索引的；但是大多数情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，MySQL 把这种在内存中或者磁盘上进行排序的方式统称为**文件排序**（filesort）。

  如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的 Extra 列中显示 Using filesort 提示。

  比如：

  ![image-20220713224931497](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713224931497.png)

  如果查询中需要使用 filesort 的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用文件排序的执行方式**改为使用索引**进行排序。

* **Using temporary**：在许多查询的执行过程中， MySQL 可能会**借助临时表来完成一些功能**，比如去重、排序之类的，比如我们在执行许多包含 DISTINCT 、 GROUP BY 、 UNION 等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL 很有可能寻求通过建立内部的临时表来执行查询。

  如果查询中使用到了内部的临时表，在执行计划的 Extra 列将会显示 Using temporary 提示。

  比如：

  ![image-20220713225025085](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713225025085.png)

  执行计划中出现 Using temporary 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能**使用索引**来替代掉使用临时表。

### 3.2 JSON 格式的查询计划

我们上边介绍的 EXPLAIN 语句输出中缺少了一个衡量执行计划好坏的重要属性——成本。不过 MySQL 贴心的为我们提供了一种查看某个执行计划花费的成本的方式：在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT=JSON，这样我们就可以得到一个 JSON 格式的执行计划，里面包含该计划花费的成本。

比如：

![image-20220713201051372](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713201051372.png)

输出实在是太长了，这里就不再详细赘述，有关 cost 的就是成本，其中：

* read_cost：I/O 成本 + 检测 rows × (1 - filter) 条记录的 CPU 成本。
* eval_cost：检测 rows × filter 条记录的成本。
* prefix_cost：read_cost + eval_cost
* data_read_per_join：在此次查询中需要读取的数据量

注意，连接中被驱动表可能被查询多次，所以被驱动表的 prefix_cost  = 驱动表的 prefix_cost + 被驱动表的 read_cost + 被驱动表的 eval_cost。

### 3.3 Extented EXPLAIN

MySQL 还为 EXPLAIN 做了一些拓展，在我们使用 EXPLAIN 语句查看了某个查询的执行计划后，紧接着 还可以使用 SHOW WARNINGS 语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：

![image-20220713201006323](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713201006323.png)

大家可以看到 SHOW WARNINGS 展示出来的信息有三个字段，分别是 Level、Code、Message。

我们最常见的就是 Code 为 1003 的信息，当 Code 值为 1003 时，Message 字段展示的信息类似于**查询优化器将我们的查询语句重写后的语句**。

比如我们上边的查询本来是一个左连接查询，但是有一个 s2.common_field IS NOT NULL 的条件，这就会导致查询优化器**把左连接查询优化为内连接查询**，从 SHOW WARNINGS 的 Message 字段也可以看出来，原本的 LEFT JOIN 已经变成了 JOIN。

但是大家一定要注意，我们说 Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句，**并不是等价于**，也就是说 Message 字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到 MySQL 中运行，它只能作为帮助我们理解查 MySQL 将如何执行查询语句的**一个参考依据而已**。

## 4. Buffer Pool

通过之前的学习我们知道，对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。

但是大家都知道，磁盘 I/O 速度是很慢的，所以 InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。

将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘 I/O 的开销了。

这个数据页的缓存就是我们即将要介绍的 Buffer Pool。

### 4.1 什么是 Buffer Pool

**InnoDB 为了缓存磁盘中的页，在 MySQL 服务器启动的时候就向操作系统申请了一片连续的内存，叫做 Buffer Pool**。

默认情况下，Buffer Pool 只有 128M 的大小，不过可以在 mysqld 的配置中配置这个大小。

配置项如下：

```text
[server]
innodb_buffer_pool_size = xxx字节	
```

但是最低不得低于 5MB。

### 4.2 Buffer Pool 的内部组成

Buffer Pool 中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是 16KB。

为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一些所谓的**控制信息**，这些控制信息包括：该页所属的表空间编号、页号、缓存页在 Buffer Pool 中的地址、链表节点信息、一些锁信息以及 LSN 信息 (锁和 LSN 我们之后会具体唠叨，现在可以先忽略)，当然还有一些别的控制信息，但是不是很重要，所以我们就不全部列举了。

**每个缓存页对应的控制信息占用的内存大小是相同的**，每个页对应的控制信息占用的一块内存称为一个**控制块**，**控制块和缓存页是一一对应的**，它们都被存放到 Buffer Pool 中，其中**控制块被存放到 Buffer Pool 的前面，缓存页被存放到 Buffer Pool 后面**，所以整个 Buffer Pool 对应的内存空间看起来就是这样的：

![image-20220714184333069](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714184333069.png)

当控制块和缓存也足够多时，中间或多或少有一点内存用不到了，因此这块就叫碎片。当然，如果你把 Buffer Pool 的大小设置的刚刚好的话，也可能不会产生碎片。

> **提示**
>
> 每个控制块大约占用缓存页大小的 5%，而我们设置的 `innodb_buffer_pool_size` 并不包含这部分控制块占用的内存空间大小，这意味着 InnoDB 在为 Buffer Pool 向操作系统申请连续的内存空间时，这片连续的内存空间一般会比 `innodb_buffer_pool_size` 的值大 5% 左右。 

### 4.3 free 链表管理

最开始申请下来 Buffer Pool 之后，此时由于没有执行任何查询，因此并没有真实的磁盘页被缓存到 Buffer Pool 中，之后随着程序的运行，会不断的有磁盘上的页被缓存到 Buffer Pool 中。

那么问题就来了，从磁盘上读取一个页到 Buffer Pool 中的时候该放到哪个缓存页的位置呢？怎么区分哪些缓存页正在使用，哪些没在使用呢？

和表空间组织区的方法类似，我们可以用链表，**可以把空闲的缓存页对应的控制块作为一个节点放到一个双向链表中，这个链表就称作 free 链表**。

最开始时，所有的缓存页都没被使用，因此链表长这样：

![image-20220714185340322](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714185340322.png)

为了管理好这个 free 链表，MySQL 还特意为这个链表定义了一个基节点，它不仅保存了链表的头尾，还保存了当前链表节点数目。

**链表的基节点占用的内存空间并不包含在为 Buffer Pool 申请的一大片连续内存空间之内，而是单独申请的一块内存空间**，后面介绍的许多种链表都是这么放的，因为一个节点的空间占用着实不是很大。 

### 4.4 Hash 处理

为了快速知道一个页有没有在 Buffer Pool 中，MySQL 为缓存页维护了一个哈希表，根据**表空间号 + 页号**来定位一个页的，也就是表空间号 + 页号作为 key，缓存页作为值。

### 4.5 flush 链表管理

**如果我们修改了 Buffer Pool 中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为脏页（dirty page）**。

这也就是所谓的缓存一致性问题：缓存里的数据和实际保存的数据不一致。

要想解决缓存一致性问题，最容易想到的就是**更改缓存页后直接同步到磁盘上**，但是频繁的磁盘 I/O 会严重影响性能，所以每次修改缓存页后，我们**并不着急立即把修改同步到磁盘上，而是在未来的某个时间点进行同步，这叫做写回策略**（操作系统教程里讲过了，不记得的可以去回顾一下）。

这样其实有几个问题：

1. 什么时候写回到磁盘上？
2. 如何区分哪些是 dirty page？

对于第一个问题，我们稍后再谈，现在我们主要谈谈第二个问题。

MySQL 为脏页维护了一个 flush 链表，链表的构造和 free 链表差不多，假设某个时间点，脏页数量为 n，那么链表可能长这样：

![image-20220714190508829](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714190508829.png)

### 4.6 LRU 机制

缓存大小终究是有上限的，那么当新的一个页要被放入 Buffer Pool 中时，Buffer Pool 已经满了，这时候怎么办呢？

这也是所有缓存机制都会遇到的一个问题，一般有两种解决办法：

1. 扩容。
2. 替换一些页出去，把新页加进去。

扩容暂时不考虑，因为内存的资源是有限的，那我们就考虑替换一些页。

那么替换哪些页呢？这也涉及到一些策略，常见的策略有：

1. 随机替换
2. 替换最近最少使用的页（LRU）
3. 替换使用频率最低的页（LFU）

MySQL 采用的就是 LRU 机制。

#### 4.6.1 简单的 LRU 链表

为了区分哪些缓存页最近频繁使用，哪些最近很少使用，我们可以再创建一个链表，由于这个链表是为了按照 LRU 的原则去淘汰缓存页的，所以这个链表可以被称为  LRU 链表。当我们需要访问某个页时，可以这样处理 LRU 链表 :

* 如果该页不在 Buffer Pool 中，在把该页从磁盘加载到 Buffer Pool 中的缓存页时，就把该缓存页对应的控制块作为节点塞到链表的头部。
* 如果该页已经缓存在 Buffer Pool 中，则直接把该页对应的控制块移动到 LRU 链表的头部。

也就是说：只要我们使用到某个缓存页，就把该缓存页调整到 LRU 链表的头部，这样 LRU 链表尾部就是最近最少使用的缓存页，所以当 Buffer Pool 中的空闲缓存页使用完时，到 LRU 链表的尾部找缓存页淘汰就完成了。

#### 4.6.2 划分区域的 LRU 链表

上面这种方案有些缺陷：

1. InnoDB 提供了**预读机制**，即 InnoDB 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到 Buffer Pool 中。

   预读分为以下两种：

   * 线性预读：InnoDB 提供了一个系统变量 `innodb_read_ahead_threshold`，如果顺序访问了某个区的页面超过这个系统变量的值，就会触发一次**异步读取下一个区中全部的页面到 Buffer Pool 的请求**。

     注意是异步的，这意味着不会影响工作线程的执行。

     这个变量默认是 56，而一个区是 64 页，这意味着已经读取了这个区 $\frac{7}{8}$ 的页面，剩下的 $\frac{1}{8}$ 也有很大概率会被读取，因此这个值的设置是很合理的。

   * 随机预读：如果 Buffer Pool 中已经缓存了某个区的 13 个连续的页面，不论这些页面是不是顺序读取的，都会触发一次异步读取本区中所有其的页面到 Buffer Pool 的请求。

     InnoDB 同时提供了 `innodb_random_read_ahead` 系统变量，它的默认值为 OFF，也就意味着 InnoDB 并不会默认开启随机预读的功能。

   预读机制的设计意图是好的，如果预读到 Buffer Pool 中的页成功的被使用到，那就可以极大的提高语句执行的效率。可是如果用不到呢？这些预读的页都会放到 LRU 链表的头部，但是如果此时 Buffer Pool 的容量不太大而且很多预读的页面都没有用到的话，这就会导致处在 LRU 链表尾部的一些缓存页会很快的被淘汰掉，会大大降低缓存命中率。

2. 有时候，MySQL 不得不执行一些全表查询的语句（可能是没有合适的索引，或者没有 WHERE 子句），这意味着所有页都会被访问到。

   假设这个表中记录非常多的话，那该表会占用特别多的页，当需要访问这些页时，会把它们统统都加载到 Buffer Pool 中，这也就意味着 **Buffer Pool 中的所有页都被一次性替换掉了**，其他查询语句在执行时又得执行一次从磁盘加载到 Buffer Pool 的操作。

   而这种全表扫描的语句执行的频率也不高，每次执行都要把 Buffer Pool 中的缓存页全部换掉，这严重的影响到其他查询对 Buffer Pool 的使用，从而大大降低了缓存命中率。

因为这两种情况的存在，InnoDB 把这个 LRU 链表按照一定比例分成两截：

* 一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做热数据，也叫 young 区域。
* 另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做冷数据，或者称 old 区域 。

下面是一个示意图：

![image-20220714193642234](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714193642234.png)

请注意，我们是按照某个比例将 LRU 链表分成两半的，不是某些节点固定是 young 区域的，某些节点固定是 old 区域的，**随着程序的运行，某个节点所属的区域也可能发生变化**。

我们可以通过查看 `innodb_old_blocks_pct` 的值来确定这个比例，比如：

![image-20220714193830917](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714193830917.png)

区域划分之后，InnoDB 就可以对上述的两种情况做一定优化了：

* **针对预读的页面可能不进行后续访问的情况的优化**：InnoDB 规定，当磁盘上的某个页面在**初次加载**到 Buffer Pool 中的某个缓存页时，该缓存页对应的控制块会被**放到 old 区域的头部**。

  这样一来，如果它进来了，但是不被经常访问，那就淘汰掉。

* **针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的情况的优化**：在进行全表扫描时，按照上一条规则，首次被加载到 Buffer Pool 的页被放到了 old 区域的头部。但是后续会被马上访问到，每次进行访问的时候又会把该页放到 young 区域的头部，这样仍然会把那些使用频率比较高的页面给顶下去。

  我们要关注**全表扫描的特点，那就是它的执行频率非常低**，而且在执行全表扫描的过程中，即使某个页面中有很多条记录，也就是去多次访问这个页面所花费的时间也是非常少的。

  因此，InnoDB 规定：在对某个处在 old 区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，**如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从 old 区域移动到 young 区域的头部**，否则将它移动到 young 区域的头部。

#### 4.6.3 进一步优化 LRU 链表

对于 young 区域的缓存页来说，我们每次访问一个缓存页就要把它移动到 LRU 链表的头部，这样的开销累积下来是比较大的，毕竟在 young 区域的缓存页都是热点数据，也就是可能被经常访问的，这样频繁的对 LRU 链表进行节点移动操作是不太好的。

为了解决这个问题，其实我们还可以提出一些优化策略，比如只有被访问的缓存页位于 young 区域的 1/4 的后边，才会被移动到 LRU 链表头部，这样就可以降低调整 LRU 链表的频率，从而提升性能。

除此之外，MySQL 还有一些优化机制，这里就不展开篇幅了，感兴趣的同学可以去看 MySQL LRU 链表的源码。

### 4.7 其他链表

除了我们上边提到的一些措施，InnoDB 还引进了其他的一些链表 ，比如 unzip LRU 链表用于管理解压页；zip clean 链表用于管理没有被解压的压缩页；zip free 数组中每一个元素都代表一个链表，它们组成所谓的**伙伴系统**来为压缩页提供内存空间等等。

反正是为了更好的管理这个 Buffer Pool 引入了各种链表或其他数据结构，具体细节就不啰嗦了，大家有兴趣深究直接看源代码吧。

### 4.8 脏页的刷新时机

后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。

主要有两种刷新路径：

* **从 LRU 链表的冷数据中刷新一部分页面到磁盘**：**后台线程会定时从 LRU 链表尾部开始扫描一些页面**，扫描的页面数量可以通过系统变量 `innodb_lru_scan_depth` 来指定，**如果发现脏页，会把它们刷新到磁盘**。

  这种刷新页面的方式被称之为 BUF_FLUSH_LRU。 

* **从 flush 链表中刷新一部分页面到磁盘**：**后台线程也会定时从 flush 链表中刷新一部分页面到磁盘**，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为 BUF_FLUSH_LIST。

* 有时候**后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到 Buffer Pool 时没有可用的缓存页**，这时就会尝试看看 LRU 链表尾部有没有可以直接释放掉的未修改页面，如果没有的话会**不得不将 LRU 链表尾部的一个脏页同步刷新到磁盘**（和磁盘交互是很慢的，这会降低处理用户请求的速度）。

  这种刷新单个页面到磁盘中的刷新方式被称之为 BUF_FLUSH_SINGLE_PAGE 。

当然，有时候系统特别繁忙时，也可能出现用户线程批量的从 flush 链表中刷新脏页的情况，很显然在处理用户请求过程中去刷新脏页是一种严重降低处理速度的行为（毕竟磁盘的速度满的要死），这属于一种迫不得已的情况，不过这得放在后边 redo log 的 checkpoint 时说了。

### 4.9 多个 Buffer Pool

 Buffer Pool 本质是 InnoDB 向操作系统申请的一块连续的内存空间，在多线程环境下，访问 Buffer Pool 中的各种链表都需要加锁处理，在 Buffer Pool 特别大而且多线程并发访问特别高的情况下，单一的 Buffer Pool 可能会影响请求的处理速度。

所以当 Buffer Pool 特别大时，我们可以把它们拆分成若干个小的 Buffer Pool ，每个 Buffer Pool 都称为一个**实例**，它们都是独立的，独立的去申请内存空间，独立的管理各种链表等等。所以在**多线程并发访问时并不会相互影响，从而提高并发处理能力**。

可以设置：

```text
[server]
innodb_buffer_pool_instances = x
```

表明我们要创建 x 个 Buffer Pool 实例。

不过也不是说 Buffer Pool 实例创建的越多越好，分别管理各个 Buffer Pool 也是需要性能开销的，InnoDB 规定：当 `innodb_buffer_pool_size` 的值小于 1G 的时候设置多个实例是无效的，InnoDB会默认把 `innodb_buffer_pool_instances` 的值修改为 1。

### 4.10 `innodb_buffer_pool_chunk_size`

在 MySQL 5.7.5 之前， Buffer Pool 的大小只能在服务器启动时通过配置 `innodb_buffer_pool_size` 启动参数来调整大小，**在服务器运行过程中是不允许调整该值的**。

不过 MySQL 在 5.7.5 以及之后的版本中支持了在服务器运行过程中调整 Buffer Pool 大小的功能，但是有一个问题，就是**每次当我们要重新调整 Buffer Pool 大小时，都需要重新向操作系统申请一块连续的内存空间，然后将旧的 Buffer Pool 中的内容复制到这一块新空间**，这是极其耗时的。

所以 **MySQL 决定不再一次性为某个 Buffer Pool 实例向操作系统申请一大片连续的内存空间，而是以一个所谓的 chunk 为单位向操作系统申请空间**。也就是说**一个 Buffer Pool 实例其实是由若干个 chunk 组成的**，一个 chunk 就代表一片连续的内存空间，里边儿包含了若干缓存页与其对应的控制块。

画个图表示就是这样：

![image-20220714232822520](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714232822520.png)

上图代表的 Buffer Pool 就是由 2 个实例组成的，每个实例中又包含 2 个 chunk。

有了 chunk 之后，**在服务器运行期间调整 Buffer Pool 的大小时就是以 chunk 为单位增加或者删除内存空间**，而不需要重新向操作系统申请一片大的内存，然后进行缓存页的复制。

chunk 大小是通过 `innodb_buffer_pool_chunk_size` 指定的，默认为 128M。

### 4.11 配置 Buffer Pool 时的注意事项

* `innodb_buffer_pool_size` 必须是 `innodb_buffer_pool_chunk_size` × `innodb_buffer_pool_instances` 的倍数。

  如果不是倍数，则 MySQL 会向上调整为最接近的倍数。

* 如果在服务器启动时，`innodb_buffer_pool_chunk_size` × `innodb_buffer_pool_instances` 的值已经大于 `innodb_buffer_pool_size` 的值，那么 `innodb_buffer_pool_chunk_size` 的值会被服务器自动设置为 `innodb_buffer_pool_size/innodb_buffer_pool_instances` 的值。

### 4.12 查看 Buffer Pool 的状态信息

MySQL 提供了 `SHOW ENGINE INNODB STATUS` 来查看关于 InnoDB 存储引擎运行过程 中的一些状态信息，其中就包括 Buffer Pool 的一些信息。

比如（省略其他非 Buffer Pool 的信息）：

![image-20220714195817924](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714195817924.png)

* **Total memory allocated**：代表 Buffer Pool 向操作系统申请的**连续内存空间大小**，包括全部控制块、缓存页、以及碎片的大小。
* Dictionary memory allocated：为数据字典信息分配的内存空间大小，注意这个内存空间和 Buffer Pool 没啥关系，不包括在 Total memory allocated 中。
* **Buffer pool size**：代表该 Buffer Pool **可以容纳多少缓存页** ，注意单位是页。
* **Free buffers**：代表当前 **Buffer Pool 还有多少空闲缓存页**，也就是 free 链表中还有多少个节点。
* **Database pages**：代表 **LRU 链表中的页的数量**，包含 young 和 old 两个区域的节点数量。
* **Old database pages**：代表 **LRU 链表 old 区域的节点数量**。
* **Modified db pages**：代表**脏页数量**，也就是 flush 链表中节点的数量。
* Pending reads：正在等待从磁盘上加载到 Buffer Pool 中的页面数量。
* Pending writes LRU：即将从 LRU 链表中刷新到磁盘中的页面数量。
* Pending writes flush list：即将从 flush 链表中刷新到磁盘中的页面数量。
* Pending writes single page：即将以单个页面的形式刷新到磁盘中的页面数量。
* Pages made young：代表 LRU 链表中曾经从 old 区域移动到 young 区域头部的节点数量。
* Page made not young：在将 innodb_old_blocks_time 设置的值大于 0 时，首次访问或者后续访问某个处在 old 区域的节点时由于不符合时间间隔的限制而不能将其移动到 young 区域头部时， Page made not young 的值会加 1。
* youngs/s：代表每秒从 old 区域被移动到 young 区域头部的节点数量。
* non-youngs/s：代表每秒由于不满足时间限制而不能从 old 区域移动到 young 区域头部的节点数量。
* Pages read 、created 、written：代表读取，创建，写入了多少页。后边跟着读取、创建、写入的速率。
* Buffer pool hit rate：表示在过去某段时间，平均访问1000次页面，有多少次该页面已经被缓存到 Buffer Pool 了。
* young-making rate：表示在过去某段时间，平均访问1000次页面，有多少次访问使页面移动到 young 区域的头部了
* not (young-making rate)：表示在过去某段时间，平均访问 1000 次页面，有多少次访问没有使页面移动到 young 区域的头部。
* LRU len：代表 LRU 链表中节点的数量。
* unzip_LRU ：代表 unzip_LRU 链表中节点的数量（由于我们没有具体说过这个链表，可以忽略它的值）。
* I/O sum：最近 50s 读取磁盘页的总数。
* I/O cur：现在正在读取的磁盘页数量。
* I/O unzip sum：最近 50s 解压的页面数量。
* I/O unzip cur：正在解压的页面数量。
