#  MySQL 查询优化

## 1. MySQL 基于成本的优化

在 MySQL 中一条查询语句的执行成本是由这两个方面组成的：

* **I/O 成本**：存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。
* **CPU 成本**：读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 CPU 成本。

对于 InnoDB 存储引擎来说，页是磁盘和内存之间交互的基本单位，**MySQL 规定读取一个页面花费的成本默认是 1.0**，**读取以及检测一条记录是否符合搜索条件的成本默认是 0.2**。1.0、0.2 这些数字称之为**成本常数**，这两个成本常数我们最常用到，其余的成本常数我们之后再说。

### 1.1 单表查询的成本

我们还是需要一个表作为例子，就拿前两章的单表访问方法中的例子拿过来吧：

```mysql
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

我们假设这表里有 10000 条数据，除 id 列自增外其余的列都是插入的随机值。

#### 1.1.1 基于成本的优化步骤

在一条单表查询语句真正执行之前，**MySQL 的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查询**，这个过程总结一下就是这样:

1. **根据搜索条件，找出所有可能使用的索引**。
2. **计算全表扫描的代价**。
3. **计算使用不同索引执行查询的代价**。
4. **对比各种执行方案的代价，找出成本最低的那一个**。

以下面这条查询语句为例：

```mysql
SELECT * FROM single_table 
WHERE key1 IN ('a', 'b', 'c') 
AND key2 > 10 
AND key2 < 1000 
AND key3 > key2 
AND key_part1 LIKE '%hello%' 
AND common_field = '123';
```

下面按照上面介绍的步骤一一分析：

1. **根据搜索条件，找出所有可能使用的索引**。

   还记得我们在单表查询一章中讲到的范围吗？对于 B+ 树索引来说，只要索引列和常数使用 =、<=>、IN、NOT IN、IS NULL、IS NOT NULL、\>、\<、\>=、\<=、BETWEEN、!=（不等于也可以写成 <>）或者 LIKE 操作符连接起来，就可以产生一个所谓的区间，也就是说这些搜索条件都可能使用到索引，MySQL 把这些涉及到的列叫做 possible keys。

   我们分析一下上边查询中涉及到的几个搜索条件：

   * key1 IN ('a', 'b', 'c') ，这个搜索条件可以使用二级索引 idx_key1 。
   * key2 > 10 AND key2 < 1000 ，这个搜索条件可以使用二级索引 idx_key2 。
   * key3 > key2 ，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。
   * key_part1 LIKE '%hello%'  key_part1 通过 LIKE 操作符和以通配符开头的字符串做比较，不符合最左前缀原则，不可以用索引。
   * common_field = '123' ，由于该列上压根儿没有索引，所以不会用到索引。

   经过这一通分析，我们发现它只可能走二级索引 idx_key1 或 idx_key2。

2.  **计算全表扫描的代价**。

   对于 InnoDB 存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。

   由于查询成本 = I/O 成本 + CPU 成本，所以计算全表扫描的代价需要两个信息：

   * **聚簇索引占用的页面数**
   * **该表中的记录数**

   这两个信息从哪里获取？**MySQL 为每个表维护了一系列的统计信息**，这些统计信息是如何收集的我们之后再提，现在你只需要知道使用 `SHOW TABLE STATUS` 就可以查看这些统计信息了，如下图所示：

   ![image-20220712221939706](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712221939706.png)

   我们目前只关心两个：

   * Rows：本选项表示表中的记录条数。对于使用 MyISAM 存储引擎的表来说，该值是准确的；**对于使用 InnoDB 存储引擎的表来说，该值是一个估计值**。

   * Data_Length：本选项表示表占用的存储空间字节数。对于使用 MyISAM 存储引擎的表来说，该值就是数据文件的大小；对于使用 InnoDB 存储引擎的表来说，该值就相当于**聚簇索引占用的存储空间大小**。

     也就是说，在 InnoDB 中，可以这样计算该值的大小：`Data_Length = 聚簇索引的页面数量 x 每个页面的大小`，本实例使用的是默认 16KB 的页面大小，而上边查询结果显示 Data_Length 的值是 1589248 ，所以我们可以反向来推导出聚簇索引的页面数量为 1589248 ÷ 16 ÷ 1024 = 97。

   得到这两个值之后，怎么算成本呢？

   * I/O 成本 = 页数 * I/O 成本常数 + 微调值 = 97 * 1.0 + 1.1 = 98.1（微调值为什么是 1.1 我们不必在意）
   * CPU 成本 = 记录数 * CPU 成本常数 + 微调值 =  9693 * 0.2 + 1.0 = 1939.6（微调值为什么是 1.0 我们不必在意）

   总成本就是这俩加起来也就是 2037.7 了。

3. **计算使用不同索引执行查询的代价**。

   * idx_key2：使用该索引的搜索条件是：key2 > 10 AND key2 < 1000，范围就是 (10, 1000)。

     由于它是二级索引，因此是范围查找二级索引 + 回表的方式，成本依赖于以下两方面数据：

     * **范围区间数量**：不论某个范围区间的二级索引到底占用了多少页面，**查询优化器粗暴的认为读取索引的一个范围区间的 I/O 成本和读取一个页面是相同的**。

       那么这个成本就是 1.0。

     * **需要回表的记录数**：优化器需要计算二级索引的某个范围区间到底包含多少条记录。

       本例就是要计算 (10, 1000) 这个范围内包含多少二级索引记录，步骤如下：

       * 先根据 key2 > 10 这个条件访问一下 idx_key2 对应的 B+ 树索引，找到满足 key2 > 10 这个条件的第一条记录，我们把这条记录称之为**区间最左记录**。

       * 再根据 key2 < 1000 这个条件继续从 idx_key2 对应的 B+ 树索引中找出第一条满足这个条件的记录，我们把这条记录称之为**区间最右记录**。

       * 如果区间最左记录和区间最右记录相隔不太远（一般是 10 个页面），那就可以精确统计出满足 key2 > 10 AND key2 < 1000 条件的二级索引记录条数；否则只沿着区间最左记录向右读 10 个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量就可以了。

         求这个页面之间隔了多远也很简单，直接统计它们的父节点（索引节点）这两条记录之间隔了多少条记录就可以了。

       根据上述方法，计算出大概有 95 条需要回表的记录，CPU 成本为：95 x 0.2 + 0.01 = 19.01，0.01 是微调值。

     那么回表的成本怎么算呢？MySQL 认为一条记录回表就相当于访问一次页面，因此 I/O 成本为 95 * 1.0 = 95；CPU 成本就是 95 * 0.2 = 19.0

     本例中总 I/O 成本就是 1.0 + 95 = 96，总 CPU 成本就是 19.01 + 19 = 38.01，总成本就是 134.01。

   * idx_key1：对应的搜索条件是： key1 IN ('a', 'b', 'c') ，也就是说相当于 3 个单点区间。

     * **范围区间数量**：三个区间，就是 3 * 1.0 = 3
     * **需要回表的记录数**：由于是三个点，直接统计即可，最后发现 a 对应 35 条，b 对应 44 条，c 对应 39 条，总共 118 条。

     成本计算略，最后总成本为 3 + 118 * 0.2 + 0.01 + 118 * 1.0 + 118 * 0.2 = 168.21。

4. **对比各种执行方案的代价，找出成本最低的那一个**。

   毫无疑问，这里使用 idx_key2 成本更低，且远低于全表扫描，因此使用 idx_key2。

### 1.2 多表连接查询的成本

为了方便，我们直接新建一个 single_table2 表，除了表名不一样，其他都和 single_table 一样。

#### 1.2.1 Conditional Filtering

MySQL 通常采用的是嵌套循环连接算法，**驱动表会被访问一次，被驱动表可能会被访问多次**，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：

* 单次查询驱动表的成本
* 多次查询被驱动表的成本

我们把对驱动表进行查询后得到的记录条数称之为**驱动表的扇出**（fanout）。很显然，**驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低**。

扇出值的计算基本需要靠猜：

* 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。
* 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

MySQL 把这个猜的过程叫做 Condition Filtering。

#### 1.2.2 两表连接成本分析

连接查询的成本计算公式是这样的，很直观：连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本。

对于左外连接和右外连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要分别为驱动表和被驱动表选择成本最低的访问方法。

可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：

* 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。
* 然后分别为驱动表和被驱动表选择成本最低的访问方法。

很显然，**计算内连接查询成本的方式更麻烦一些**，下边我们就以内连接为例。

以下面这个查询为例：

```mysql
SELECT * FROM single_table AS s1 
	INNER JOIN single_table2 AS s2 
ON s1.key1 = s2.common_field 
WHERE s1.key2 > 10 
  AND s1.key2 < 1000 
  AND s2.key2 > 1000 
  AND s2.key2 < 2000;
```

可以选择的连接顺序有两种：

* s1 作为驱动表， s2 作为被驱动表。
* s2 作为驱动表， s1 作为被驱动表。

查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。

分析过程这里就不赘述了，总体来说就是先分析 s1 作为驱动表单表的访问的最低成本，然后把 s1 得出的条件作为已知量带入到 s2 的条件中，进行分析；反过来也是类似的。

#### 1.2.3 多表连接的成本分析

首先要考虑一下多表连接时可能产生出多少种连接顺序：

* 对于两表连接，只有 AB、BA这两种连接顺序。其实相当于 2 × 1 = 2 种连接顺序。
* 对于三表连接，有 ABC、ACB、BAC、BCA、CAB、CBA 这么 6 种连接顺序。其实相当于 3 × 2 × 1 = 6 种连接顺序。
* 对于四表连接的话，则会有 4 × 3 × 2 × 1 = 24 种连接顺序。
* ......
* 对于 n 表连接的话，则有 n × (n-1) × (n-2) × ··· × 1 种连接顺序，也就是 n! 种连接顺序。

那么如果有 n 个表进行连接， MySQL 查询优化器要每一种连接顺序的成本都计算一遍么？这个时间复杂度可是 $O(n!)$。

MySQL 当然不会这么愚蠢，它有一些减少计算的方法：

* **提前结束某种顺序的成本评估**：MySQL 在计算各种链接顺序的成本之前，会**维护一个全局的变量，这个变量表示当前最小的连接查询成本**。

  如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就不对该连接顺序继续往下分析了。

* **系统变量 optimizer_search_depth**：为了防止无穷无尽的分析各种连接顺序的成本，MySQL 提出了 optimizer_search_depth 系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与 optimizer_search_depth 值相同数量的表进行穷举分析。

  很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。

* **根据某些规则压根儿就不考虑某些连接顺序**：即使是有上两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以设计 MySQL 干脆提出了一些所谓的启发式规则 （就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序就根本不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。

  MySQL 提供了一个系统变量 optimizer_prune_level 来控制到底是不是用这些启发式规则。

### 1.3 调节成本常数

我们前面介绍了两个成本常数 ：

* 读取一个页面花费的成本默认是 1.0
* 检测一条记录是否符合搜索条件的成本默认是 0.2

其实除了这两个常数，在 MySQL 中还存在很多常数，它们被存储到了名字为 `mysql` 的数据库中（不是递归，这是一个系统数据库的名字，我们之前介绍过了），我们可以这样查看：

```MYSQL
mysql> SHOW TABLES FROM mysql LIKE '%cost%';
+--------------------------+
| Tables_in_mysql (%cost%) |
+--------------------------+
| engine_cost |
| server_cost |
+--------------------------+
2 rows in set (0.00 sec)
```

我们早在第一章中就说过，一条语句的执行其实是分为两层的：

* server 层
* 存储引擎层

在 server 层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。

也就是说，一条语句在 server 层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的成本常数就存储在了 server_cost 表中；而依赖于存储引擎的一些操作对应的成本常数就存储在了 engine_cost 表中。

#### 1.3.1 server_cost

server_cost 表中在 server 层进行的一些操作对应的成本常数，具体内容如下：

```mysql
mysql> SELECT * FROM mysql.server_cost;
+------------------------------+------------+---------------------+---------+
| cost_name | cost_value | last_update | comment |
+------------------------------+------------+---------------------+---------+
| disk_temptable_create_cost | NULL | 2018-01-20 12:03:21 | NULL |
| disk_temptable_row_cost | NULL | 2018-01-20 12:03:21 | NULL |
| key_compare_cost | NULL | 2018-01-20 12:03:21 | NULL |
| memory_temptable_create_cost | NULL | 2018-01-20 12:03:21 | NULL |
| memory_temptable_row_cost | NULL | 2018-01-20 12:03:21 | NULL |
| row_evaluate_cost | NULL | 2018-01-20 12:03:21 | NULL |
+------------------------------+------------+---------------------+---------+
6 rows in set (0.05 sec)
```

* cost_name：成本常数的名称。
* cost_value：成本常数对应的值。如果该列的值为 NULL 的话，意味着对应的成本常数会采用默认值。
* last_update：最后更新的时间。
* comment：注释。

从 server_cost 中的内容可以看出来，目前在 server 层的一些操作对应的成本常数有以下几种：

| 成本常数名称                 | 默认值 | 描述                                                         |
| ---------------------------- | ------ | ------------------------------------------------------------ |
| disk_temptable_create_cost   | 40.0   | **创建基于磁盘的临时表的成本**，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。 |
| disk_temptable_row_cost      | 1.0    | 向基于**磁盘的临时表写入或读取一条记录的成本**，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。 |
| key_compare_cost             | 0.1    | **两条记录做比较操作的成本**，多用在排序操作上，如果增大这个值的话会提升 filesort 的成本，让优化器可能更倾向于使用索引完成排序而不是 filesort 。 |
| memory_temptable_create_cost | 2.0    | **创建基于内存的临时表的成本**，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。 |
| memory_temptable_row_cost    | 0.2    | **向基于内存的临时表写入或读取一条记录的成本**，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。 |
| row_evaluate_cost            | 0.2    | 这个就是我们之前一直使用的**检测一条记录是否符合搜索条件的成本**，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。 |

#### 1.3.2 engine_cost

engine_cost 表中在存储引擎层进行的一些操作对应的成本常数，具体内容如下：

```mysql
mysql> SELECT * FROM mysql.engine_cost;
+-------------+-------------+------------------------+------------+---------------------+---------+
| engine_name | device_type | cost_name | cost_value | last_update | comment |
+-------------+-------------+------------------------+------------+---------------------+---------+
| default | 0 | io_block_read_cost | NULL | 2018-01-20 12:03:21 | NULL |
| default | 0 | memory_block_read_cost | NULL | 2018-01-20 12:03:21 | NULL |
+-------------+-------------+------------------------+------------+---------------------+---------+
2 rows in set (0.05 sec)
```

与 server_cost 相比， engine_cost 多了两个列：

* engine_name：指成本常数适用的存储引擎名称。如果该值为 default ，意味着对应的成本常数适用于所有的存储引擎。
* device_type：指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘。

从 engine_cost 表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：

| 成本常数名称           | 默认值 | 描述                                                         |
| ---------------------- | ------ | ------------------------------------------------------------ |
| io_block_read_cost     | 1.0    | 从磁盘上读取一个块对应的成本（请注意这里使用的是块 ，而不是页）。<BR>对于InnoDB 存储引擎来说，一个页就是一个块，不过对于 MyISAM 存储引擎来说，默认是以 4096 字节作为一个块。<BR>增大这个值会加重 I/O 成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。 |
| memory_block_read_cost | 1.0    | 与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本 |

> 大家看完这两个的默认值应该有一些疑惑，为什么从内存读取能和从磁盘读取的成本常数一样，显然内存更快吧？
>
> 这主要是因为在 **MySQL 目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上**，所以 MySQL 很粗暴的认为不管这个块有没有加载到内存中，使用的成本都是 1.0。
>
> 不过随着 MySQL 的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改一改吧。

## 2. MySQL 基于规则的优化

MySQL 本质上是一个软件，并不能强制要求使用这个软件的人每一个都是数据库高手，所以难免有些人会写出一些执行起来十分耗费性能的语句。即使是这样， **MySQL 还是依据一些规则，竭尽全力的把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作查询重写**。

### 2.1 条件化简

我们编写的查询语句的搜索条件本质上是一个表达式，这些表达式可能比较繁杂，或者不能高效的执行， MySQL 的查询优化器会为我们简化这些表达式。

#### 2.1.1 移除不必要的括号

有时候表达式里有许多无用的括号，比如这样：

```mysql
((a = 5 AND b = c) OR ((a > c) AND (c < 5)))
```

优化器会把那些用不到的括号给干掉，就是这样：

```mysql
(a = 5 and b = c) OR (a > c AND c < 5)
```

#### 2.1.2 常量传递

有时候某个表达式是某个列和某个常量做等值匹配，比如这样：`a = 5`，当这个表达式和其他涉及列 a 的表达式**使用 AND 连接起来时**，可以将其他表达式中的 a 的值替换为 5 ，比如这样：

````mysql
a = 5 AND b > a
````

就可以被转换为：

```MYSQL
a = 5 AND b > 5
```

#### 2.1.3 等值传递

有时候多个列之间存在等值匹配的关系，比如这样：

```mysql
a = b and b = c and c = 5
```

这个表达式可以被简化为：

```mysql
a = 5 and b = 5 and c = 5
```

#### 2.1.4  移除没用的条件

对于一些明显永远为 TRUE 或者 FALSE 的表达式，优化器会移除掉它们，比如这个表达式：

```mysql
(a < 1 and b = b) OR (a = 6 OR 5 != 5)
```

很明显， b = b 这个表达式永远为 TRUE ， 5 != 5 这个表达式永远为 FALSE ，所以简化后的表达式就是这样的：

```mysql
(a < 1 and TRUE) OR (a = 6 OR FALSE)
```

可以继续被简化为：

```mysql
a < 1 OR a = 6
```

#### 2.1.5 表达式计算

在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：

```mysql
a = 5 + 1
```

因为 5 + 1 这个表达式只包含常量，所以就会被化简成：

```mysql
a = 6
```

但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：

```mysql
ABS(a) > 5
```

或者：

```mysql
-a < -8
```

优化器是不会尝试对这些表达式进行化简的。我们前边说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中。

#### 2.1.6 HAVING 子句和 WHERE 子句的合并

如果查询语句中没有出现诸如 SUM 、 MAX 等等的聚集函数以及 GROUP BY 子句，优化器就把 HAVING 子句和 WHERE 子句合并起来。

#### 2.1.7 常量表检测

MySQL 认为下面这两种查询特别快：

* 查询的表中一条记录都没有，或者只有一条记录。

  > 这是依赖统计数据的，而 InnoDB 的统计数据是不准确的，因此本条适用于 MyISAM 或 Memory。

* 使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。

所以也把通过这两种方式查询的表称之为**常量表**，优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。

比如：

```mysql
SELECT * FROM table1 
	INNER JOIN table2
ON table1.column1 = table2.column2 
WHERE table1.primary_key = 1;
```

这个查询可以使用主键和常量值的等值匹配来查询 table1 表，也就是在这个查询中 table1 表相当于常量表 ，**在分析对 table2 表的查询成本之前，就会执行对 table1 表的查询**，并把查询中涉及 table1 表的条件都替换掉，也就是上边的语句会被转换成这样：

```MYSQL
SELECT table1表记录的各个字段的常量值, table2.* FROM table1 INNER JOIN table2 
 ON table1表column1列的常量值 = table2.column2;
```

### 2.2 外连接消除

我们曾经说过，内连接的驱动表和被驱动表的位置可以相互转换，而 左（外）连接 和 右（外）连接 的驱动表和被驱动表是固定的。这就导致**内连接可能通过优化表的连接顺序来降低整体的查询成本，而外连接却无法优化表的连接顺序**。

为了故事的顺利发展，我们还是把之前介绍连接原理时用过的 t1 和 t2 表请出来，为了防止大家早就忘掉了，我们再看一下这两个表的结构：

```mysql
CREATE TABLE t1 (
    m1 int, 
    n1 char(1)
) Engine=InnoDB, CHARSET=utf8;

CREATE TABLE t2 (
    m2 int, 
    n2 char(1)
) Engine=InnoDB, CHARSET=utf8;
```

我们之前说过，**外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记录会被舍弃**。

那么查询的效果可能是这样的：

```mysql
mysql> SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
+------+------+------+------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
| 1 | a | NULL | NULL |
+------+------+------+------+
3 rows in set (0.00 sec)
```

对于上边例子中的左外连接来说，由于驱动表 t1 中 m1=1, n1='a' 的记录无法在被驱动表 t2 中找到符合 ON 子句条件 t1.m1 = t2.m2 的记录，所以就直接把这条记录加入到结果集，对应的 t2 表的 m2 和 n2 列的值都设置为 NULL 。

我们知道在连接查询中 WHERE 子句的杀伤力比较大，凡是不符合 WHERE 子句中条件的记录都不会参与连接。**只要我们在搜索条件中指定关于被驱动表相关列的值不为 NULL ，那么外连接中在被驱动表中找不到符合 ON 子句条件的驱动表记录也就被排除出最后的结果集了**，也就是说在这种情况下：外连接和内连接也就没有什么区别了。

比方说这个查询：

```mysql
mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.n2 IS NOT NULL;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
+------+------+------+------+
2 rows in set (0.01 sec)
```

由于指定了被驱动表 t2 的 n2 列不允许为 NULL ，所以上边的 t1 和 t2 表的左外连接查询和内连接查询是一样一样的。

当然，我们也可以不用显式的指定被驱动表的某个列 IS NOT NULL ，只要隐含的有这个意思就行了，比方说这样：

```mysql
mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
+------+------+------+------+
1 row in set (0.00 sec)
```

在这个例子中，我们在 WHERE 子句中指定了被驱动表 t2 的 m2 列等于 2 ，也就相当于间接的指定了 m2 列不为 NULL 值，所以上边的这个左外连接查询其实和下边这个内连接查询是等价的：

```mysql
mysql> SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
+------+------+------+------+
1 row in set (0.00 sec)
```

我们把这种在外连接查询中，指定的 WHERE 子句中包含被驱动表中的列不为 NULL 值的条件称之为 空值拒绝（reject-NULL）。在**被驱动表的 WHERE 子句符合空值拒绝的条件后，外连接和内连接可以相互转换**。

这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。

### 2.3 子查询优化

TODO:待补充

## 3. Explain 详解

一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的**执行计划**，这个**执行计划展示了接下来具体执行查询的方式**，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。

MySQL 专门为我们提供了 `EXPLAIN` 语句来帮助我们查看某个查询语句的具体执行计划，要使用它页很简单，只需要在查询语句前添加一个 `EXPLAIN`，比如：

![image-20220713181459362](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713181459362.png)

这个就是所谓的执行计划了，没有文档指引的话，这个东西很难看懂，本节我们就来介绍一下 `EXPLAIN` 输出的各列的含义，以及在这个输出下我们该如何优化 SQL。

>其实除了以 SELECT 开头的查询语句，其余的 DELETE 、 INSERT 、 REPLACE 以及 UPDATE 语句前边都可以加上 `EXPLAIN` 用来查看这些语句的执行计划。

下表列出了 EXPLAIN 的输出列：

| 列名          | 描述                                                      |
| ------------- | --------------------------------------------------------- |
| id            | 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id |
| select_type   | SELECT 关键字对应的那个查询的类型                         |
| table         | 表名                                                      |
| partitions    | 匹配的分区信息                                            |
| type          | 针对单表的访问方法                                        |
| possible_keys | 可能用到的索引                                            |
| key           | 实际使用的索引                                            |
| key_len       | 实际使用到的索引长度                                      |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息    |
| rows          | 预估的需要读取的记录条数                                  |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比              |
| Extra         | 一些额外的信息                                            |

本节中，涉及的单表一律默认为 single_table 表，多表一律认为是和 single_table 表一模一样的表。

### 3.1 执行计划各列详解

#### 3.1.1 table

不论我们的查询语句有多复杂，里面包含了多少个表，到最后也是需要对每个表进行单表访问的，所以 MySQL 规定 EXPLAIN 语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table 列代表着该表的表名。

我们看一个简单的查询：

![image-20220713175136116](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713175136116.png)

这个查询语句只涉及对 s1 表的单表查询，所以 EXPLAIN 输出中只有一条记录，其中的 table 列的值是 s1 ，表明这条记录是用来说明对 s1 表的单表访问方法的。

下边我们看一个连接查询的执行计划：

![image-20220713175338555](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713175338555.png)

可以看到这个连接查询的执行计划中有两条记录，这两条记录的 table 列分别是 s1 和 s2 ，这两条记录用来分别说明对 s1 表和 s2 表的访问方法是什么。

#### 3.1.2 id

我们知道我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比如下边这个查询语句：

```mysql
SELECT * 
FROM s1 
WHERE key1 = 'a';
```

稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如:

```mysql
SELECT * FROM s1 INNER JOIN s2
ON s1.key1 = s2.key1
WHERE s1.common_field = 'a';
```

但是下边两种情况下在一条查询语句中会出现多个 SELECT 关键字：

* 子查询的情况
* 包含 `UNION` 语句的情况

查询语句中每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id 值，这个 id 值就是 EXPLAIN 语句的第一个列。

比如下边这个查询中只有一个 SELECT 关键字，所以 EXPLAIN 的结果中也就只有一条 id 列为 1 的记录：

![image-20220713175136116](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713175136116.png)

对于连接查询来说，一个 SELECT 关键字后边的 FROM 子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的 id 值都相同。

![image-20220713175338555](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713175338555.png)

对于刚刚说到的那两种情况，id 值就会出现不一样了，比如：

![image-20220713180019021](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713180019021.png)

s1 表在外层查询中，外层查询有一个独立的 SELECT 关键字，所以第一条记录的 id 值就是 1，s2 表在子查询中，子查询有一个独立的 SELECT 关键字，所以第二条记录的 id 值就是 2。

> 需要特别注意的是，查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。

对于 UNION 来说，情况也类似，但是有点不一样：

![image-20220713180150227](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713180150227.png)

第三条记录 id 为 NULL，table 也是一个奇怪的名字。这是因为 **UNION 会把多个查询的结果集合并起来并对结果集中的记录进行去重，去重是靠在内部创建一个临时表实现的**，所以这个 `<union1,2>` 是一个临时表，id 为 NULL 表明这个临时表是为了合并两个查询的结果集而创建的。

和 UNION 比起来，UNION ALL 就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录 合并成一个并返回给用户，所以也就不需要使用临时表。如下图所示：

![image-20220713180406129](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713180406129.png)

#### 3.1.3 select_type

MySQL 为每一个 SELECT 关键字代表的小查询都定义了一个称之为 select_type 的属性，我们还是先介绍一下 select_type 都能取哪些值：

| 名称                 | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| SIMPLE               | 查询语句中不包含 UNION 或者子查询的查询都算作是 SIMPLE 类型  |
| PRIMARY              | 对于包含 UNION 、 UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type 就是 PRIMARY |
| UNION                | 对于包含 UNION 或者 UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是 UNION |
| UNION RESULT         | MySQL 选择使用临时表来完成 UNION 查询的去重工作，针对该临时表的查询的 select_type 就是 UNION RESULT |
| SUBQUERY             | 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 SUBQUERY |
| DEPENDENT SUBQUERY   | 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 DEPENDENT SUBQUERY |
| DEPENDENT UNION      | 在包含 UNION 或者 UNION ALL 的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的 select_type 的值就是 DEPENDENT UNION |
| DERIVED              | 对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的 select_type 就是 DERIVED |
| MATERIALIZED         | 当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就是 MATERIALIZED |
| UNCACHEABLE SUBQUERY | 不常用，这里不再叙述，可以从名称推断其含义                   |
| UNCACHEABLE UNION    | 不常用，这里不再叙述，可以从名称推断其含义                   |

#### 3.1.4 partitions

我们根本没有在任何地方看到过这个概念，且之前举过的例子这个列都是 NULL，因此我们不关注这个列。

#### 3.1.5 type

我们之前说过执行计划的一条记录就代表着 MySQL 对某个表的执行查询时的访问方法，其中的 type 列就表明了这个访问方法是什么。

比如：

![image-20220713181533619](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713181533619.png)

可以看到 type 列的值是 ref ，表明 MySQL 即将使用 ref 访问方法来执行对 s1 表的查询。

我们之前完整的说过单表的访问方法，分别是：const、ref、ref_or_null、index、range、all，实际上，MySQL 还有以下访问方法，这些访问方法通常不是针对单表的访问的：system、eq_ref、fulltext、index_merge、unique_subquery、index_subquery。

我们再来回顾一下，同时也包括对新出现的访问方法的介绍：

* system：当**表中只有一条记录**并且**该表使用的存储引擎的统计数据是精确的**（MyISAM 或 Memory 引擎），那么对该表的访问就是 system。
* const：当我们根据**主键**或者**唯一二级索引**列与**常量进行等值匹配**时，对单表的访问方法就是 const。
* eq_ref：在连接查询时，如果**被驱动表**是**通过主键或者唯一二级索引**列**等值匹配**的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是 eq_ref（相当于多表里把驱动表的扇出转换为多个常量，因此每次被驱动表都使用 const）。
* ref：当通过**普通的二级索引**列与**常量进行等值匹配**时来查询某个表，那么对该表的访问方法就可能是 ref。
* fulltext：当创建了全文索引的字段查询时，访问方法就是 fulltext。
* ref_or_null：当对**普通二级索引**进行**等值匹配查询**，该索引列的值也**可以是 NULL 值**时，那么对该表的访问方法就可能是 ref_or_null。
* index_merge：使用索引合并的方式来执行查询时，对该表的访问方法就是 index_merge。
* unique_subquery：类似于两表连接中被驱动表的 eq_ref 访问方法， unique_subquery 是针对在一些**包含 IN 子查询**的查询语句中，如果查询优化器决定**将 IN 子查询转换为 EXISTS 子查询**，而且**子查询可以使用到主键进行等值匹配**的话，那么该子查询执行计划的 type 列的值就是 unique_subquery。
* index_subquery：index_subquery 与 unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引。
* range：如果使用**索引**获取某些**范围区间**的记录，那么就可能使用到 range 访问方法。
* index：可以使用**索引覆盖**，但需要**扫描全部的索引记录**时（通常是不符合最左匹配原则才会导致这种情况，如果是最左匹配，一般会是 ref），该表的访问方法就是 index。
* all：全表扫描时，访问方法就是 all。

通常来说，这些访问方法按照上面的顺序性能依次变差。

#### 3.1.6 possible_keys 和 key

possible_keys 列表示在某个查询语句中，对某个表执行单表查询时**可能用到的索引**有哪些， key 列表示**实际用到的索引**有哪些。

比如：

![image-20220713183632320](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713183632320.png)

这个查询中，涉及到 idx_key1 和 idx_key3 两个索引，但是最终选择了 idx_key3 进行查询。

有一点比较特别，就是**在使用 index 访问方法来查询某个表时， possible_keys 列是空的，而 key 列展示的是实际使用到的索引：

![image-20220713183818679](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713183818679.png)

另外需要注意的一点是，**possible_keys 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间**，所以如果可以的话，尽量删除那些用不到的索引。

#### 3.1.7 key_len

key_len 列表示**当优化器决定使用某个索引执行查询时，该索引记录的最大长度**，它是由这三个部分构成的:

* 对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的 变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100)，使用的字符集是 utf8，那么该列实际占用的最大存储空间就是 100 × 3 = 300 个字节。
* 如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多 1 个字节。 
* 对于变长字段来说，都会有 2 个字节的空间来存储该变长列的实际长度。

我们在介绍行格式的时候就介绍过了，这里应该很容易理解。

比如：

![image-20220713184040482](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184040482.png)

由于 id 列的类型是 INT ，并且不可以存储 NULL 值，所以在使用该列的索引时 key_len 大小就是 4。

再比如：

![image-20220713184309208](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184309208.png)

Key2 是 INT，可以存储 NULL 值，所以 key_len 就是 4 + 1 = 5。

再比如：

![image-20220713184404826](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184404826.png)

key1 是 VARCHAR(100)，而字符编码是 UTF-8，则实际占用就是 300 字节，而可以存储 NULL，并且可变长，所以再 + 3，最后就是 303。

MySQL 设计该列的目的是让我们区分到底使用了几个索引列，比如：

![image-20220713184641772](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184641772.png)

对于这个符合最左匹配的联合索引，使用一个列就是 303，而使用两个就是 606。

#### 3.1.8 ref

当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery 其中之一时， ref 列展示的就是与索引列作等值匹配的东西是什么，比如只是一个常数或者是某个列。

举个例子：

![image-20220713184851011](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713184851011.png)

这个查询走的是普通索引，且是等值匹配，因此是 ref 的访问方法，而和列作等值匹配的又是一个常量，因此 ref 列的值就是 const。

看个稍微复杂一点的例子：

![image-20220713185017929](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713185017929.png)

可以看到对被驱动表 s2 的访问方法是 eq_ref，而对应的 ref 列的值是 test.s2.id，这说明在对被驱动表进行访问时会用到主键索引与一个列进行等值匹配的条件。

有的时候与索引列进行等值匹配的对象是一个函数，比方说下边这个查询：

![image-20220713185336972](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713185336972.png)

可以看到，这里 ref 的值是 func，表示一个函数。

#### 3.1.9 rows

如果查询优化器决定使用**全表扫描**的方式对某个表执行查询时，执行计划的 rows 列就代表**预计需要扫描的行数**；如果使用**索引**来执行查询时，执行计划的 rows 列就代表**预计扫描的索引记录行数**。

比如：

![image-20220713190803069](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713190803069.png)

#### 3.1.10 filtered

之前在分析连接查询的成本时提出过一个 condition filtering 的概念，就是 MySQL 在计算驱动表扇出时采用的一个策略：

* 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。
* 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

比如：

![image-20220713193528944](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713193528944.png)

从执行计划的 key 列中可以看出来，该查询使用 idx_key1 索引来执行查询，从 rows 列可以看出满足 key1 > 'z' 的记录有 323 条。执行计划的 filtered 列就代表查询优化器预测在这 323 条记录中，有多少条记录满足其余的搜索条件，也就是 common_field = 'a' 这个条件的百分比。

此处 filtered 列的值是 10.00 ，说明查询优化器预测在 323 条记录中有 10.00% 的记录满足 common_field = 'a' 这个条件。

对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 filtered 值，这反映了被驱动表将会被大概查询多少次，比方说下边这个查询：

![image-20220713193708691](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713193708691.png)

从执行计划中可以看出来，查询优化器打算把 s1 当作驱动表，s2 当作被驱动表。我们可以看到驱动表 s1 表的执行计划的 rows 列为 9887，filtered 列为 10.00，这意味着驱动表 s1 的扇出值就是 9688 × 10.00% = 968.8，这说明还要对被驱动表执行大约 968 次查询。

#### 3.1.11 Extra

Extra 列是用来说明一些额外信息的，我们**可以通过这些额外信息来更准确的理解 MySQL 到底将如何执行给定的查询语句**。

Extra 列实在是比较多，我们就挑几个常见的讲讲：

* No tables used：当查询语句的没有 FROM 子句时将会提示该额外信息。

  比如：

  ![image-20220713194241247](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713194241247.png)

* Impossible WHERE：查询语句的 WHERE 子句永远为 FALSE 时将会提示该额外信息。

  比如：

  ![image-20220713194527205](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713194527205.png)

* No matching min/max row：当查询列表处有 MIN 或者 MAX 聚集函数，但是并没有符合 WHERE 子句中的搜索条件的记录时，将会提示该额外信息。

  比如：

  ![image-20220713194642782](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713194642782.png)

* Using index：索引覆盖的情况下，在 Extra 列将会提示该额外信息。

  比如：

  ![image-20220713194739623](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713194739623.png)

* Using index condition：

* Using where

* Using join buffer (Block Nested Loop)

* Not exists

* Using intersect(...) 、 Using union(...) 和 Using sort_union(...)

* Zero limit

* Using filesort

* Using temporary

* Start temporary, End temporary

### 3.2 JSON 格式的查询计划

我们上边介绍的 EXPLAIN 语句输出中缺少了一个衡量执行计划好坏的重要属性——成本。不过 MySQL 贴心的为我们提供了一种查看某个执行计划花费的成本的方式：在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT=JSON，这样我们就可以得到一个 JSON 格式的执行计划，里面包含该计划花费的成本。

比如：

![image-20220713201051372](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713201051372.png)

输出实在是太长了，这里就不再详细赘述，有关 cost 的就是成本，其中：

* read_cost：I/O 成本 + 检测 rows × (1 - filter) 条记录的 CPU 成本。
* eval_cost：检测 rows × filter 条记录的成本。
* prefix_cost：read_cost + eval_cost
* data_read_per_join：在此次查询中需要读取的数据量

注意，连接中被驱动表可能被查询多次，所以被驱动表的 prefix_cost  = 驱动表的 prefix_cost + 被驱动表的 read_cost + 被驱动表的 eval_cost。

### 3.3 Extented EXPLAIN

MySQL 还为 EXPLAIN 做了一些拓展，在我们使用 EXPLAIN 语句查看了某个查询的执行计划后，紧接着 还可以使用 SHOW WARNINGS 语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：

![image-20220713201006323](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713201006323.png)

大家可以看到 SHOW WARNINGS 展示出来的信息有三个字段，分别是 Level、Code、Message。

我们最常见的就是 Code 为 1003 的信息，当 Code 值为 1003 时，Message 字段展示的信息类似于**查询优化器将我们的查询语句重写后的语句**。

比如我们上边的查询本来是一个左连接查询，但是有一个 s2.common_field IS NOT NULL 的条件，这就会导致查询优化器**把左连接查询优化为内连接查询**，从 SHOW WARNINGS 的 Message 字段也可以看出来，原本的 LEFT JOIN 已经变成了 JOIN。

但是大家一定要注意，我们说 Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句，**并不是等价于**，也就是说 Message 字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到 MySQL 中运行，它只能作为帮助我们理解查 MySQL 将如何执行查询语句的**一个参考依据而已**。

## 4. Buffer Pool