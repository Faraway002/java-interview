#  MySQL 查询优化

## 1. MySQL 基于成本的优化

在 MySQL 中一条查询语句的执行成本是由这两个方面组成的：

* **I/O 成本**：存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。
* **CPU 成本**：读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 CPU 成本。

对于 InnoDB 存储引擎来说，页是磁盘和内存之间交互的基本单位，**MySQL 规定读取一个页面花费的成本默认是 1.0**，**读取以及检测一条记录是否符合搜索条件的成本默认是 0.2**。1.0、0.2 这些数字称之为**成本常数**，这两个成本常数我们最常用到，其余的成本常数我们之后再说。

### 1.1 单表查询的成本

我们还是需要一个表作为例子，就拿前两章的单表访问方法中的例子拿过来吧：

```mysql
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

我们假设这表里有 10000 条数据，除 id 列自增外其余的列都是插入的随机值。

#### 1.1.1 基于成本的优化步骤

在一条单表查询语句真正执行之前，**MySQL 的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查询**，这个过程总结一下就是这样:

1. **根据搜索条件，找出所有可能使用的索引**。
2. **计算全表扫描的代价**。
3. **计算使用不同索引执行查询的代价**。
4. **对比各种执行方案的代价，找出成本最低的那一个**。

以下面这条查询语句为例：

```mysql
SELECT * FROM single_table 
WHERE key1 IN ('a', 'b', 'c') 
AND key2 > 10 
AND key2 < 1000 
AND key3 > key2 
AND key_part1 LIKE '%hello%' 
AND common_field = '123';
```

下面按照上面介绍的步骤一一分析：

1. **根据搜索条件，找出所有可能使用的索引**。

   还记得我们在单表查询一章中讲到的范围吗？对于 B+ 树索引来说，只要索引列和常数使用 =、<=>、IN、NOT IN、IS NULL、IS NOT NULL、\>、\<、\>=、\<=、BETWEEN、!=（不等于也可以写成 <>）或者 LIKE 操作符连接起来，就可以产生一个所谓的区间，也就是说这些搜索条件都可能使用到索引，MySQL 把这些涉及到的列叫做 possible keys。

   我们分析一下上边查询中涉及到的几个搜索条件：

   * key1 IN ('a', 'b', 'c') ，这个搜索条件可以使用二级索引 idx_key1 。
   * key2 > 10 AND key2 < 1000 ，这个搜索条件可以使用二级索引 idx_key2 。
   * key3 > key2 ，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。
   * key_part1 LIKE '%hello%'  key_part1 通过 LIKE 操作符和以通配符开头的字符串做比较，不符合最左前缀原则，不可以用索引。
   * common_field = '123' ，由于该列上压根儿没有索引，所以不会用到索引。

   经过这一通分析，我们发现它只可能走二级索引 idx_key1 或 idx_key2。

2.  **计算全表扫描的代价**。

   对于 InnoDB 存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。

   由于查询成本 = I/O 成本 + CPU 成本，所以计算全表扫描的代价需要两个信息：

   * **聚簇索引占用的页面数**
   * **该表中的记录数**

   这两个信息从哪里获取？**MySQL 为每个表维护了一系列的统计信息**，这些统计信息是如何收集的我们之后再提，现在你只需要知道使用 `SHOW TABLE STATUS` 就可以查看这些统计信息了，如下图所示：

   ![image-20220712221939706](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712221939706.png)

   我们目前只关心两个：

   * Rows：本选项表示表中的记录条数。对于使用 MyISAM 存储引擎的表来说，该值是准确的；**对于使用 InnoDB 存储引擎的表来说，该值是一个估计值**。

   * Data_Length：本选项表示表占用的存储空间字节数。对于使用 MyISAM 存储引擎的表来说，该值就是数据文件的大小；对于使用 InnoDB 存储引擎的表来说，该值就相当于**聚簇索引占用的存储空间大小**。

     也就是说，在 InnoDB 中，可以这样计算该值的大小：`Data_Length = 聚簇索引的页面数量 x 每个页面的大小`，本实例使用的是默认 16KB 的页面大小，而上边查询结果显示 Data_Length 的值是 1589248 ，所以我们可以反向来推导出聚簇索引的页面数量为 1589248 ÷ 16 ÷ 1024 = 97。

   得到这两个值之后，怎么算成本呢？

   * I/O 成本 = 页数 * I/O 成本常数 + 微调值 = 97 * 1.0 + 1.1 = 98.1（微调值为什么是 1.1 我们不必在意）
   * CPU 成本 = 记录数 * CPU 成本常数 + 微调值 =  9693 * 0.2 + 1.0 = 1939.6（微调值为什么是 1.0 我们不必在意）

   总成本就是这俩加起来也就是 2037.7 了。

3. **计算使用不同索引执行查询的代价**。

   * idx_key2：使用该索引的搜索条件是：key2 > 10 AND key2 < 1000，范围就是 (10, 1000)。

     由于它是二级索引，因此是范围查找二级索引 + 回表的方式，成本依赖于以下两方面数据：

     * **范围区间数量**：不论某个范围区间的二级索引到底占用了多少页面，**查询优化器粗暴的认为读取索引的一个范围区间的 I/O 成本和读取一个页面是相同的**。

       那么这个成本就是 1.0。

     * **需要回表的记录数**：优化器需要计算二级索引的某个范围区间到底包含多少条记录。

       本例就是要计算 (10, 1000) 这个范围内包含多少二级索引记录，步骤如下：

       * 先根据 key2 > 10 这个条件访问一下 idx_key2 对应的 B+ 树索引，找到满足 key2 > 10 这个条件的第一条记录，我们把这条记录称之为**区间最左记录**。

       * 再根据 key2 < 1000 这个条件继续从 idx_key2 对应的 B+ 树索引中找出第一条满足这个条件的记录，我们把这条记录称之为**区间最右记录**。

       * 如果区间最左记录和区间最右记录相隔不太远（一般是 10 个页面），那就可以精确统计出满足 key2 > 10 AND key2 < 1000 条件的二级索引记录条数；否则只沿着区间最左记录向右读 10 个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量就可以了。

         求这个页面之间隔了多远也很简单，直接统计它们的父节点（索引节点）这两条记录之间隔了多少条记录就可以了。

       根据上述方法，计算出大概有 95 条需要回表的记录，CPU 成本为：95 x 0.2 + 0.01 = 19.01，0.01 是微调值。

     那么回表的成本怎么算呢？MySQL 认为一条记录回表就相当于访问一次页面，因此 I/O 成本为 95 * 1.0 = 95；CPU 成本就是 95 * 0.2 = 19.0

     本例中总 I/O 成本就是 1.0 + 95 = 96，总 CPU 成本就是 19.01 + 19 = 38.01，总成本就是 134.01。

   * idx_key1：对应的搜索条件是： key1 IN ('a', 'b', 'c') ，也就是说相当于 3 个单点区间。

     * **范围区间数量**：三个区间，就是 3 * 1.0 = 3
     * **需要回表的记录数**：由于是三个点，直接统计即可，最后发现 a 对应 35 条，b 对应 44 条，c 对应 39 条，总共 118 条。

     成本计算略，最后总成本为 3 + 118 * 0.2 + 0.01 + 118 * 1.0 + 118 * 0.2 = 168.21。

4. **对比各种执行方案的代价，找出成本最低的那一个**。

   毫无疑问，这里使用 idx_key2 成本更低，且远低于全表扫描，因此使用 idx_key2。

### 1.2 多表连接查询的成本

为了方便，我们直接新建一个 single_table2 表，除了表名不一样，其他都和 single_table 一样。

#### 1.2.1 Conditional Filtering

MySQL 通常采用的是嵌套循环连接算法，**驱动表会被访问一次，被驱动表可能会被访问多次**，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：

* 单次查询驱动表的成本
* 多次查询被驱动表的成本

我们把对驱动表进行查询后得到的记录条数称之为**驱动表的扇出**（fanout）。很显然，**驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低**。

扇出值的计算基本需要靠猜：

* 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。
* 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

MySQL 把这个猜的过程叫做 Condition Filtering。

#### 1.2.2 两表连接成本分析

连接查询的成本计算公式是这样的，很直观：连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本。

对于左外连接和右外连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要分别为驱动表和被驱动表选择成本最低的访问方法。

可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：

* 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。
* 然后分别为驱动表和被驱动表选择成本最低的访问方法。

很显然，**计算内连接查询成本的方式更麻烦一些**，下边我们就以内连接为例。

以下面这个查询为例：

```mysql
SELECT * FROM single_table AS s1 
	INNER JOIN single_table2 AS s2 
ON s1.key1 = s2.common_field 
WHERE s1.key2 > 10 
  AND s1.key2 < 1000 
  AND s2.key2 > 1000 
  AND s2.key2 < 2000;
```

可以选择的连接顺序有两种：

* s1 作为驱动表， s2 作为被驱动表。
* s2 作为驱动表， s1 作为被驱动表。

查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。

分析过程这里就不赘述了，总体来说就是先分析 s1 作为驱动表单表的访问的最低成本，然后把 s1 得出的条件作为已知量带入到 s2 的条件中，进行分析；反过来也是类似的。

#### 1.2.3 多表连接的成本分析

首先要考虑一下多表连接时可能产生出多少种连接顺序：

* 对于两表连接，只有 AB、BA这两种连接顺序。其实相当于 2 × 1 = 2 种连接顺序。
* 对于三表连接，有 ABC、ACB、BAC、BCA、CAB、CBA 这么 6 种连接顺序。其实相当于 3 × 2 × 1 = 6 种连接顺序。
* 对于四表连接的话，则会有 4 × 3 × 2 × 1 = 24 种连接顺序。
* ......
* 对于 n 表连接的话，则有 n × (n-1) × (n-2) × ··· × 1 种连接顺序，也就是 n! 种连接顺序。

那么如果有 n 个表进行连接， MySQL 查询优化器要每一种连接顺序的成本都计算一遍么？这个时间复杂度可是 $O(n!)$。

MySQL 当然不会这么愚蠢，它有一些减少计算的方法：

* **提前结束某种顺序的成本评估**：MySQL 在计算各种链接顺序的成本之前，会**维护一个全局的变量，这个变量表示当前最小的连接查询成本**。

  如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就不对该连接顺序继续往下分析了。

* **系统变量 optimizer_search_depth**：为了防止无穷无尽的分析各种连接顺序的成本，MySQL 提出了 optimizer_search_depth 系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与 optimizer_search_depth 值相同数量的表进行穷举分析。

  很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。

* **根据某些规则压根儿就不考虑某些连接顺序**：即使是有上两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以设计 MySQL 干脆提出了一些所谓的启发式规则 （就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序就根本不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。

  MySQL 提供了一个系统变量 optimizer_prune_level 来控制到底是不是用这些启发式规则。

### 1.3 调节成本常数

我们前面介绍了两个成本常数 ：

* 读取一个页面花费的成本默认是 1.0
* 检测一条记录是否符合搜索条件的成本默认是 0.2

其实除了这两个常数，在 MySQL 中还存在很多常数，它们被存储到了名字为 `mysql` 的数据库中（不是递归，这是一个系统数据库的名字，我们之前介绍过了），我们可以这样查看：

```MYSQL
mysql> SHOW TABLES FROM mysql LIKE '%cost%';
+--------------------------+
| Tables_in_mysql (%cost%) |
+--------------------------+
| engine_cost |
| server_cost |
+--------------------------+
2 rows in set (0.00 sec)
```

我们早在第一章中就说过，一条语句的执行其实是分为两层的：

* server 层
* 存储引擎层

在 server 层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。

也就是说，一条语句在 server 层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的成本常数就存储在了 server_cost 表中；而依赖于存储引擎的一些操作对应的成本常数就存储在了 engine_cost 表中。

#### 1.3.1 server_cost

server_cost 表中在 server 层进行的一些操作对应的成本常数，具体内容如下：

```mysql
mysql> SELECT * FROM mysql.server_cost;
+------------------------------+------------+---------------------+---------+
| cost_name | cost_value | last_update | comment |
+------------------------------+------------+---------------------+---------+
| disk_temptable_create_cost | NULL | 2018-01-20 12:03:21 | NULL |
| disk_temptable_row_cost | NULL | 2018-01-20 12:03:21 | NULL |
| key_compare_cost | NULL | 2018-01-20 12:03:21 | NULL |
| memory_temptable_create_cost | NULL | 2018-01-20 12:03:21 | NULL |
| memory_temptable_row_cost | NULL | 2018-01-20 12:03:21 | NULL |
| row_evaluate_cost | NULL | 2018-01-20 12:03:21 | NULL |
+------------------------------+------------+---------------------+---------+
6 rows in set (0.05 sec)
```

* cost_name：成本常数的名称。
* cost_value：成本常数对应的值。如果该列的值为 NULL 的话，意味着对应的成本常数会采用默认值。
* last_update：最后更新的时间。
* comment：注释。

从 server_cost 中的内容可以看出来，目前在 server 层的一些操作对应的成本常数有以下几种：

| 成本常数名称                 | 默认值 | 描述                                                         |
| ---------------------------- | ------ | ------------------------------------------------------------ |
| disk_temptable_create_cost   | 40.0   | **创建基于磁盘的临时表的成本**，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。 |
| disk_temptable_row_cost      | 1.0    | 向基于**磁盘的临时表写入或读取一条记录的成本**，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。 |
| key_compare_cost             | 0.1    | **两条记录做比较操作的成本**，多用在排序操作上，如果增大这个值的话会提升 filesort 的成本，让优化器可能更倾向于使用索引完成排序而不是 filesort 。 |
| memory_temptable_create_cost | 2.0    | **创建基于内存的临时表的成本**，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。 |
| memory_temptable_row_cost    | 0.2    | **向基于内存的临时表写入或读取一条记录的成本**，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。 |
| row_evaluate_cost            | 0.2    | 这个就是我们之前一直使用的**检测一条记录是否符合搜索条件的成本**，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。 |

#### 1.3.2 engine_cost

engine_cost 表中在存储引擎层进行的一些操作对应的成本常数，具体内容如下：

```mysql
mysql> SELECT * FROM mysql.engine_cost;
+-------------+-------------+------------------------+------------+---------------------+---------+
| engine_name | device_type | cost_name | cost_value | last_update | comment |
+-------------+-------------+------------------------+------------+---------------------+---------+
| default | 0 | io_block_read_cost | NULL | 2018-01-20 12:03:21 | NULL |
| default | 0 | memory_block_read_cost | NULL | 2018-01-20 12:03:21 | NULL |
+-------------+-------------+------------------------+------------+---------------------+---------+
2 rows in set (0.05 sec)
```

与 server_cost 相比， engine_cost 多了两个列：

* engine_name：指成本常数适用的存储引擎名称。如果该值为 default ，意味着对应的成本常数适用于所有的存储引擎。
* device_type：指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘。

从 engine_cost 表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：

| 成本常数名称           | 默认值 | 描述                                                         |
| ---------------------- | ------ | ------------------------------------------------------------ |
| io_block_read_cost     | 1.0    | 从磁盘上读取一个块对应的成本（请注意这里使用的是块 ，而不是页）。<BR>对于InnoDB 存储引擎来说，一个页就是一个块，不过对于 MyISAM 存储引擎来说，默认是以 4096 字节作为一个块。<BR>增大这个值会加重 I/O 成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。 |
| memory_block_read_cost | 1.0    | 与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本 |

> 大家看完这两个的默认值应该有一些疑惑，为什么从内存读取能和从磁盘读取的成本常数一样，显然内存更快吧？
>
> 这主要是因为在 **MySQL 目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上**，所以 MySQL 很粗暴的认为不管这个块有没有加载到内存中，使用的成本都是 1.0。
>
> 不过随着 MySQL 的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改一改吧。

## 2. MySQL 基于规则的优化

MySQL 本质上是一个软件，并不能强制要求使用这个软件的人每一个都是数据库高手，所以难免有些人会写出一些执行起来十分耗费性能的语句。即使是这样， **MySQL 还是依据一些规则，竭尽全力的把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作查询重写**。

### 2.1 条件化简

我们编写的查询语句的搜索条件本质上是一个表达式，这些表达式可能比较繁杂，或者不能高效的执行， MySQL 的查询优化器会为我们简化这些表达式。

#### 2.1.1 移除不必要的括号

有时候表达式里有许多无用的括号，比如这样：

```mysql
((a = 5 AND b = c) OR ((a > c) AND (c < 5)))
```

优化器会把那些用不到的括号给干掉，就是这样：

```mysql
(a = 5 and b = c) OR (a > c AND c < 5)
```

#### 2.1.2 常量传递

有时候某个表达式是某个列和某个常量做等值匹配，比如这样：`a = 5`，当这个表达式和其他涉及列 a 的表达式**使用 AND 连接起来时**，可以将其他表达式中的 a 的值替换为 5 ，比如这样：

````mysql
a = 5 AND b > a
````

就可以被转换为：

```MYSQL
a = 5 AND b > 5
```

#### 2.1.3 等值传递

有时候多个列之间存在等值匹配的关系，比如这样：

```mysql
a = b and b = c and c = 5
```

这个表达式可以被简化为：

```mysql
a = 5 and b = 5 and c = 5
```

#### 2.1.4  移除没用的条件

对于一些明显永远为 TRUE 或者 FALSE 的表达式，优化器会移除掉它们，比如这个表达式：

```mysql
(a < 1 and b = b) OR (a = 6 OR 5 != 5)
```

很明显， b = b 这个表达式永远为 TRUE ， 5 != 5 这个表达式永远为 FALSE ，所以简化后的表达式就是这样的：

```mysql
(a < 1 and TRUE) OR (a = 6 OR FALSE)
```

可以继续被简化为：

```mysql
a < 1 OR a = 6
```

#### 2.1.5 表达式计算

在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：

```mysql
a = 5 + 1
```

因为 5 + 1 这个表达式只包含常量，所以就会被化简成：

```mysql
a = 6
```

但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：

```mysql
ABS(a) > 5
```

或者：

```mysql
-a < -8
```

优化器是不会尝试对这些表达式进行化简的。我们前边说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中。

#### 2.1.6 HAVING 子句和 WHERE 子句的合并

如果查询语句中没有出现诸如 SUM 、 MAX 等等的聚集函数以及 GROUP BY 子句，优化器就把 HAVING 子句和 WHERE 子句合并起来。

#### 2.1.7 常量表检测

MySQL 认为下面这两种查询特别快：

* 查询的表中一条记录都没有，或者只有一条记录。

  > 这是依赖统计数据的，而 InnoDB 的统计数据是不准确的，因此本条适用于 MyISAM 或 Memory。

* 使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。

所以也把通过这两种方式查询的表称之为**常量表**，优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。

比如：

```mysql
SELECT * FROM table1 
	INNER JOIN table2
ON table1.column1 = table2.column2 
WHERE table1.primary_key = 1;
```

这个查询可以使用主键和常量值的等值匹配来查询 table1 表，也就是在这个查询中 table1 表相当于常量表 ，**在分析对 table2 表的查询成本之前，就会执行对 table1 表的查询**，并把查询中涉及 table1 表的条件都替换掉，也就是上边的语句会被转换成这样：

```MYSQL
SELECT table1表记录的各个字段的常量值, table2.* FROM table1 INNER JOIN table2 
 ON table1表column1列的常量值 = table2.column2;
```

### 2.2 外连接消除

我们曾经说过，内连接的驱动表和被驱动表的位置可以相互转换，而 左（外）连接 和 右（外）连接 的驱动表和被驱动表是固定的。这就导致**内连接可能通过优化表的连接顺序来降低整体的查询成本，而外连接却无法优化表的连接顺序**。

为了故事的顺利发展，我们还是把之前介绍连接原理时用过的 t1 和 t2 表请出来，为了防止大家早就忘掉了，我们再看一下这两个表的结构：

```mysql
CREATE TABLE t1 (
    m1 int, 
    n1 char(1)
) Engine=InnoDB, CHARSET=utf8;

CREATE TABLE t2 (
    m2 int, 
    n2 char(1)
) Engine=InnoDB, CHARSET=utf8;
```

我们之前说过，**外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记录会被舍弃**。

那么查询的效果可能是这样的：

```mysql
mysql> SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
+------+------+------+------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
| 1 | a | NULL | NULL |
+------+------+------+------+
3 rows in set (0.00 sec)
```

对于上边例子中的左外连接来说，由于驱动表 t1 中 m1=1, n1='a' 的记录无法在被驱动表 t2 中找到符合 ON 子句条件 t1.m1 = t2.m2 的记录，所以就直接把这条记录加入到结果集，对应的 t2 表的 m2 和 n2 列的值都设置为 NULL 。

我们知道在连接查询中 WHERE 子句的杀伤力比较大，凡是不符合 WHERE 子句中条件的记录都不会参与连接。**只要我们在搜索条件中指定关于被驱动表相关列的值不为 NULL ，那么外连接中在被驱动表中找不到符合 ON 子句条件的驱动表记录也就被排除出最后的结果集了**，也就是说在这种情况下：外连接和内连接也就没有什么区别了。

比方说这个查询：

```mysql
mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.n2 IS NOT NULL;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
+------+------+------+------+
2 rows in set (0.01 sec)
```

由于指定了被驱动表 t2 的 n2 列不允许为 NULL ，所以上边的 t1 和 t2 表的左外连接查询和内连接查询是一样一样的。

当然，我们也可以不用显式的指定被驱动表的某个列 IS NOT NULL ，只要隐含的有这个意思就行了，比方说这样：

```mysql
mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
+------+------+------+------+
1 row in set (0.00 sec)
```

在这个例子中，我们在 WHERE 子句中指定了被驱动表 t2 的 m2 列等于 2 ，也就相当于间接的指定了 m2 列不为 NULL 值，所以上边的这个左外连接查询其实和下边这个内连接查询是等价的：

```mysql
mysql> SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
+------+------+------+------+
1 row in set (0.00 sec)
```

我们把这种在外连接查询中，指定的 WHERE 子句中包含被驱动表中的列不为 NULL 值的条件称之为 空值拒绝（reject-NULL）。在**被驱动表的 WHERE 子句符合空值拒绝的条件后，外连接和内连接可以相互转换**。

这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。

### 2.3 子查询优化

TODO:待补充

## 3. Explain 详解

一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的**执行计划**，这个**执行计划展示了接下来具体执行查询的方式**，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。

MySQL 专门为我们提供了 `EXPLAIN` 语句来帮助我们查看某个查询语句的具体执行计划，要使用它页很简单，只需要在查询语句前添加一个 `EXPLAIN`，比如：

![image-20220713091707282](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220713091707282.png)

这个就是所谓的执行计划了，没有文档指引的话，这个东西很难看懂，本节我们就来介绍一下 `EXPLAIN` 输出的各列的含义，以及在这个输出下我们该如何优化 SQL。

>其实除了以 SELECT 开头的查询语句，其余的 DELETE 、 INSERT 、 REPLACE 以及 UPDATE 语句前边都可以加上 `EXPLAIN` 用来查看这些语句的执行计划。

下表列出了 EXPLAIN 的输出列：

| 列名          | 描述                                                      |
| ------------- | --------------------------------------------------------- |
| id            | 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id |
| select_type   | SELECT 关键字对应的那个查询的类型                         |
| table         | 表名                                                      |
| partitions    | 匹配的分区信息                                            |
| type          | 针对单表的访问方法                                        |
| possible_keys | 可能用到的索引                                            |
| key           | 实际使用的索引                                            |
| key_len       | 实际使用到的索引长度                                      |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息    |
| rows          | 预估的需要读取的记录条数                                  |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比              |
| Extra         | 一些额外的信息                                            |

本节中，涉及的单表一律默认为 single_table 表，多表一律认为是和 single_table 表一模一样的表。

### 3.1 执行计划各列详解

#### 3.1.1 table

不论我们的查询语句有多复杂，里面包含了多少个表，到最后也是需要对每个表进行单表访问的，所以 MySQL 规定 EXPLAIN 语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table 列代表着该表的表名。



## 4. Buffer Pool