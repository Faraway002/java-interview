# MySQL 事务

## 1. 什么是事务？

### 1.1 事务的起源

对于大部分程序员来说，他们的任务就是把现实世界的业务场景映射到数据库世界。比如银行为了存储人们的账户信息会建立一个 account 表：

```mysql
CREATE TABLE account (
    id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',
    name VARCHAR(100) COMMENT '客户名称',
    balance INT COMMENT '余额',
    PRIMARY KEY (id)
) Engine=InnoDB CHARSET=utf8;
```

在某个特定时刻，人们在在银行所拥有的资产是一个特定的值，这些特定的值也可以被描述为账户在这个特定的时刻现实世界的一个状态。随着时间的流逝，人们可能陆续进行向账户中存钱、取钱或者向别人转账等操作，这样他们账户中的余额就可能发生变动，每一个操作都相当于现实世界中账户的一次状态转换。

数据库世界作为现实世界的一个映射，自然也要进行相应的变动。但是，现实世界中一些看似很简单的状态转换，映射到数据库世界却不是那么容易的。比方说有一次小明在赌博输了钱，急忙打电话给小刚要借 10 块钱。现实世界中的小刚走向了ATM机，输入了小明的账号以及 10 元的转账金额，然后按下确认，小刚就拔卡走人了，现实世界中转账就成功了。

但是对于数据库世界来说，可没有那么简单。在数据库里，相当于执行了下边这两条语句：

```MYSQL
UPDATE account SET balance = balance - 10 WHERE id = 1;

UPDATE account SET balance = balance + 10 WHERE id = 2;
```

但是这里有个问题，上述两条语句如果只执行了一条时忽然服务器断电了咋办？把小刚的钱扣了，但是没给小明转过去，那小明还是处于紧急缺钱的状态，而且小刚的钱也就这么消失了。

除此之外，由于 MySQL 还有 Buffer Pool，在对某个页面进行读写访问时，都会先把这个页面加载到 Buffer Pool 中，之后如果修改了某个页面，也不会立即把修改同步到磁盘，而只是把这个修改了的页面加到 Buffer Pool 的 flush 链表中，在之后的某个时间点才会刷新到磁盘。

如果在将修改过的页刷新到磁盘之前系统崩溃了会怎么样？或者在刷新磁盘的过程中（只刷新部分数据到磁盘上）系统奔溃了又会怎么样？

怎么才能保证这笔钱完好无损呢？其实再仔细想想，我们只是想**让某些数据库操作符合现实世界中状态转换的规则**而已。

现实世界中状态转换的规则有好几条，下面我们一一介绍。

#### 1.1.1 原子性（Atomicity）

现实世界中转账操作是一个**不可分割的操作**，也就是说要么压根就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。

数据库把这种要么全做，要么全不做的规则称之为**原子性** 。

但是在**现实世界中的一个不可分割的操作却可能对应着数据库若干条不同的操作，数据库中的一条操作也可能被分解成若干个步骤**（比如先修改缓存页，之后再刷新到磁盘等），最要命的是**在任何一个可能的时间都可能发生意想不到的错误**（可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的）而使操作执行不下去。

为了保证在数据库世界中某些操作的原子性，数据库需要一些机制来保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子，我们后面会详细讲述。

> 在 MySQL 中，原子性由 InnoDB 存储引擎的 undo log 保证，在下一章我们会详细讲解。

#### 1.1.2 隔离性（Isolation）

现实世界中的两次状态转换应该是互不影响的，比如说小刚向小明同时进行的两次金额为 5 元的转账（假设可以在两个 ATM 机上同时操作）。那么最后小刚的账户里肯定会少 10 元，小明的账户里肯定多了 10 元。

但是到对应的数据库中，事情又变的复杂了一些。

为了简化问题，我们粗略的假设小刚向小明转账 5 元的过程是由下边几个步骤组成的：

* 步骤一：读取小刚账户的余额到变量 A 中，这一步骤简写为 read(A)
* 步骤二：将小刚账户的余额减去转账金额，这一步骤简写为 A = A - 5
* 步骤三：将小刚账户修改过的余额写到磁盘里，这一步骤简写为 write(A)
* 步骤四：读取小明账户的余额到变量 B，这一步骤简写为 read(B)
* 步骤五：将小明账户的余额加上转账金额，这一步骤简写为 B = B + 5
* 步骤六：将小明账户修改过的余额写到磁盘里，这一步骤简写为 write(B)

我们将小刚向小明同时进行的两次转账操作分别称为 T1 和 T2 ，在现实世界中 T1 和 T2 是应该没有关系的，可以先执行完 T1，再执行 T2，或者先执行完 T2，再执行 T1，对应的数据库操作就像这样：

![image-20220717221130464](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220717221130464.png)

但是，真实的数据库实现里这些操作是可以交替执行的，因为它们是两个线程：

![image-20220717221220112](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220717221220112.png)

如果按照上图中的执行顺序来进行两次转账的话，最终小刚的账户里还剩 6 元钱，相当于只扣了 5 元钱，但是小明的账户里却成了 12 元钱，相当于多了 10 元钱，这银行岂不是要亏死了?

所以对于现实世界中状态转换对应的某些数据库操作来说，**不仅要保证这些操作以原子性的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换**，这个规则被称之为隔离性。数据库就需要采取一些措施来让访问相同数据（上例中的 A 账户和 B 账户）的不同状态转换（上例中的 T1 和 T2）对应的数据库操作的执行顺序有一定规律，我们后面会详细讲解这一问题。

> 在 MySQL 中，隔离性由 MVCC 机制以及锁来保证，我们等会就会在事务的隔离级别一节中介绍。

#### 1.1.3 一致性（Consistency）

我们生活的这个世界存在着形形色色的约束，比如身份证号不能重复，性别只能是男或者女，高考的分数只能在 0～750 之间，人民币面值最大只能是 100，红绿灯只有 3 种颜色，房价不能为负的等等等等。

数据库只是现实世界的一个映射，**现实世界中存在的约束当然也要在数据库中有所体现，如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的，或者说符合一致性的**。

如何保证数据库中数据的一致性呢？这其实有两个方面：

* **数据库本身能为我们保证一部分一致性需求**。

  大部分数据库中都存在主键、外键、NOT NULL 约束，UNIQUE 约束等等。当你使用约束创建表之后，比如对身份证字段创建一个 UNIQUE 约束，如果你再插入一个已经在表里的身份证，那么就会遭到数据库的拒绝。这些约束都是数据库为我们保证的。

  除此之外，MySQL 还提供了 CHECK 语法可以自定义约束，比如：

  ```mysql
  CREATE TABLE account (
      id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',
      name VARCHAR(100) COMMENT '客户名称',
      balance INT COMMENT '余额',
      PRIMARY KEY (id),
      CHECK (balance >= 0) 
  );
  ```

   这条 CHECK 语句意思是规定 balance 列不能存储小于0的数字，对应的现实世界的意思就是银行账户余额不能小于 0。

  但是很遗憾，**MySQL 只是支持 CHECK 语法，但是并没有实现 CHECK**，也就是说如果你写了 CHECK 语法是可以的，不算语法错误，但是 MySQL 执行时会忽略它。

  > 相比于 MySQL，SQL Server 和 Oracle 都是实实在在支持 CHECK 语法的。
  >
  > 不过，你依然可以在 MySQL 中使用触发器来进行插入或更新之前的检查，也算是弥补了 CHECK 没有实现的遗憾。

* **更多的一致性需求需要靠程序员自己保证**。

  为建立现实世界和数据库的对应关系，理论上应该把现实世界中的所有约束都反应到数据库中，但是很不幸，**在更改数据库数据时进行一致性检查是一个耗费性能的工作**。

  比方说我们为 account 表建立了一个触发器，每当插入或者更新记录时都会校验一下 balance 列的值是不是大于0，这就会影响到插入或更新的速度。

  仅仅是校验一行记录符不符合一致性需求倒也不是什么大问题，但是有的一致性需求太复杂了。

  比方说银行会建立一张代表账单的表，里边儿记录了每个账户的每笔交易，每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。如果在数据库层面实现这个一致性需求的话，每次发生交易时，都需要将所有的收入加起来减去所有的支出，再将所有的账户余额加起来，看看两个值相不相等。

  如果账单表里有几亿条记录，光是这个校验的过程可能就要跑好几个小时，也就是说你在煎饼摊买个煎饼，使用银行卡付款之后要等好几个小时才能提示付款成功，这样的性能代价是完全承受不起的。

  现实生活中复杂的一致性需求比比皆是，而**由于性能问题把一致性需求交给数据库去解决是不现实的**，所以这个任务就落在了业务端程序员身上。

  比方说我们的 account 表，我们也可以不建立触发器，只要**编写业务的程序员在自己的业务代码里判断一下**，当某个操作会将 balance 列的值更新为小于 0 的值时，就不执行该操作就好了。

我们前边提到的**原子性和隔离性都会对一致性产生影响**。

比如我们现实世界中转账操作完成后，有一个一致性需求就是参与转账的账户的总的余额是不变的。如果数据库不遵循原子性要求，也就是转了一半就不转了，那最后就是不符合一致性需求的；类似的，如果数据库不遵循隔离性要求，就像我们讲隔离性时举的例子中所说的，最终源账户中扣的钱和对方账户中涨的钱可不一样，也就是说不符合一致性需求了。

所以说，**数据库某些操作的原子性和隔离性都是保证一致性的一种手段**，在操作执行完成后保证符合所有既定的约束则是一种结果。

> 在 MySQL 中，如果持久性、隔离性、原子性都被保证了，那么一致性就保证了。

#### 1.1.4 持久性（Durability）

**当现实世界的一个状态转换完成后，这个转换的结果将永久的保留，这个规则被称为持久性**。

比方说小刚向小明转账，当 ATM 机提示转账成功了，就意味着这次账户的状态转换完成了，小刚就可以拔卡走人了。如果当小刚走掉之后，银行又把这次转账操作给撤销掉，恢复到没转账之前的样子，那小明就没有收到钱了，所以这个持久性也是非常重要的。

当把现实世界的状态转换映射到数据库世界时，**持久性意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来**，不论之后发生了什么事故，本次转换造成的影响都不应该被丢失掉。

> 在 MySQL 中，持久性由 InnoDB 存储引擎的 redo log 保证，在下一章我们会详细讲解。

### 1.2 事务的概念

我们把刚刚介绍的四个特性的首字母提取出来，也就是人们常说的 ACID 四大特性。

数据库把需要保证原子性、隔离性、一致性和持久性的一个或者多个数据库操作称之为一个**事务（Transaction）**。

数据库根据这些操作所执行的不同阶段把事务划分成了以下几个状态：

* 活动的（active）：事务对应的数据库操作正在执行过程中，我们就说该事务处于活动的状态。

* 部分提交的（partially committed）：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处于部分提交的状态。

* 失败的（failed）：当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。

* 中止的（aborted）：如果事务执行了半截而变为失败的状态，那么就需要撤销失败事务对当前数据库造成的影响，我们把这个撤销的过程称之为回滚。

  当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。

* 提交的（committed）：当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。

随着事务对应的数据库操作执行到不同阶段，事务的状态也在不断变化，一个基本的状态转换图如下所示：

![image-20220717231943023](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220717231943023.png)

从图中大家也可以看出了，只**有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了**。

对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。

### 1.3 MySQL 中事务的使用

#### 1.3.1 开启事务

我们可以使用下面两种语句之一来开启一个事务：

* `BEGIN [WORK]`：BEGIN 语句代表开启一个事务，后边的单词 WORK 可有可无。

  开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。

* `START TRANSACTION`：START TRANSACTION 语句和 BEGIN 语句有着相同的功效，都标志着开启一个事务。

  不过，这个比 BEGIN 功能要多一些，因为它后面可以跟一些选项：

  * `READ ONLY`：标识当前事务是一个**只读事务**，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。

  * `READ WRITE`：标识当前事务是一个**读写事务**，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。

    不加任何选项的事务就属于此类。

  * `WITH CONSISTENT SNAPSHOT`：启动一致性读（后面再说）。

  一个事务的访问模式不能同时既设置为只读的也设置为读写的，所以我们不能同时把 READ ONLY 和 READ WRITE 放到 START TRANSACTION 语句后边。

#### 1.3.2 提交事务

开启事务之后就可以继续写需要放到该事务中的语句了，当最后一条语句写完了之后，我们就可以提交该事务了，提交的语句也很简单：`COMMIT [WORK]`。

COMMIT 语句就代表提交一个事务，后边的 WORK 可有可无。

#### 1.3.3 中止（回滚）事务

如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事务执行之前的样子：`ROLLBACK [WORK]`。

ROLLBACK 语句就代表中止并回滚一个事务，后边的 WORK 可有可无类似的。

这里需要强调一下，**ROLLBACK 语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚**。

#### 1.3.4 支持事务的存储引擎

MySQL 中并不是所有存储引擎都支持事务的功能，**目前只有 InnoDB 和 NDB 存储引擎支持事务**（NDB 存储引擎不是我们的重点，因此我们并不关注它）。

如果某个事务中包含了修改使用不支持事务的存储引擎的表，那么对该使用不支持事务的存储引擎的表所做的修改将无法进行回滚。

#### 1.3.5 自动提交

MySQL 中有一个系统变量 `autocommit`，可以使用 `SHOW VARIABLES LIKE 'autocommit'` 查看。

它的默认值为 `ON`，也就是说，MySQL 默认采用**自动提交策略（`autocommit`）**，**把单条语句当成一个事务然后进行提交**。

通过 `set autocommit = 0（或者 'OFF'）` 可以取消自动提交。

#### 1.3.6 隐式提交

当我们使用 START TRANSACTION 或者 BEGIN 语句开启了一个事务，或者把系统变量 autocommit 的值设置为 OFF 时，事务就不会进行自动提交。

但是如果我们输入了某些语句之后 MySQL 还是会悄悄的提交掉，就像我们输入了 COMMIT 语句了一样，这种**因为某些特殊的语句而导致事务提交的情况称为隐式提交**，这些会导致事务隐式提交的语句包括：

* 定义或修改数据库对象的数据定义语言（DDL），比如 CREATE TABLE、DROP TABLE 等。

* 隐式使用或修改 `mysql` 系统数据库中的表，比如 ALTER USER、CREATE USER 等。

* 事务控制或关于锁定的语句，当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。

  或者当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会隐式的提交前边语句所属的事务。

  或者使用 LOCK TABLES、UNLOCK TABLES 等关于锁定的语句也会隐式的提交前边语句所属的事务。

* 加载数据的语句，比如我们用 LOAD DATA 来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。

* 关于 MySQL 主从复制的一些语句，比如使用 START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO 等语句时也会隐式的提交前边语句所属的事务。

* 其它的一些语句。使用 ANALYZE TABLE、CACHE INDEX、CHECK TABLE、FLUSH、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET 等语句也会隐式的提交前边语句所属的事务。

#### 1.3.7 保存点

如果你开启了一个事务，并且已经敲了很多语句，忽然发现上一条语句有点问题，你只好使用 ROLLBACK 语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，总有一种一夜回到解放前的感觉。

所以数据库提出了一个保存点的概念 (savepoint)，就是在事务对应的数据库语句中做一下记号，我们在调用 ROLLBACK 语句时可以指定会滚到哪个记号，而不是回到最初的原点。

定义保存点的语法如下：`SAVEPOINT 保存点名称`，当我们想回滚到某个保存点时，可以使用 `ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称`。

如果 ROLLBACK 语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。

如果我们想删除某个保存点，可以使用这个语句：`RELEASE SAVEPOINT 保存点名称`。

## 2. 事务的隔离级别

我们知道 MySQL 是一个 C/S 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接。

每个客户端与服务器连接上之后，就可以称之为一个会话。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是**对于服务器来说可能同时处理多个事务**。

我们知道事务拥有隔离性的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样子的话对性能影响太大，**我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高**。

但是很遗憾，鱼和熊掌不可得兼。于是**数据库提出了事务的隔离级别，不同的隔离级别隔离性不同，但是性能也不同，需要根据实际的业务合理选择**。

### 2.1 并发事务可能导致的问题

在正式介绍事务隔离级别之前，我们还必须清楚并发事务会导致什么问题，才能更好的理解隔离级别。

#### 2.1.1 脏写（Dirty Write）

如果**一个事务修改了另一个未提交事务修改过的数据**，那就意味着发生了**脏写**。

示意图如下：

![image-20220725145215419](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725145215419.png)

如上图，Session A 和 Session B 各开启了一个事务，Session B 中的事务先将 number 列为 1 的记录的 name 列更新为 '关羽'，然后 Session A 中的事务接着又把这条 number 列为 1 的记录的 name 列更新为张飞。

此时 Session A 马上就提交了，而 Session B 的事务还没结束，如果在那之后 Session B 中的事务进行了回滚，那么 Session A 中的更新也将不复存在，这种现象就称之为脏写。

这时 Session A 就会认为：我明明把数据更新了，最后也提交事务了，怎么到自己什么都没做?

#### 2.1.2 脏读（Dirty Read）

如果一个事务**读到了另一个未提交事务修改过的数据**，就意味着发生了**脏读**。

示意图如下：

![image-20220725145542986](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725145542986.png)

如上图， Session A 和 Session B 各开启了一个事务，Session B 中的事务先将 number 列为 1 的记录的 name 列更新为 '关羽'，然后 Session A 中的事务再去查询这条 number 为 1 的记录，如果读到列 name 的值为 '关羽'，而 Session B 中的事务稍后进行了回滚，那么 **Session A 中的事务相当于读到了一个不存在的数据**，这种现象就称之为脏读。

#### 2.1.3 不可重复读（Non-Repeatable Read）

如果**一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值**，那就意味着发生了**不可重复读**。

示意图如下：

![image-20220725145925786](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725145925786.png)

如上图，我们在 Session B 中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了 number 列为 1 的记录的列 name 的值，每次事务提交之后，如果 Session A 中的事务都可以查看到最新的值，这种现象也被称之为不可重复读。

#### 2.1.4 幻读（Phantom read）

如果**一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来**，那就意味着发生了**幻读**。

示意图如下：

![image-20220725150859872](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725150859872.png)

如上图， Session A 中的事务先根据条件 number > 0 这个条件查询表 hero，得到了 name 列值为 '刘备' 的记录；之后 Session B 中提交了一个隐式事务，该事务向表 hero 中插入了一条新记录；之后 Session A 中的事务再根据相同的条件 number > 0 查询表 hero，得到的结果集中包含 Session B 中的事 务新插入的那条记录，这种现象也被称之为幻读。

有的同学会有疑问，那如果 Session B 中是删除了一些符合 number > 0 的记录而不是插入新记录，那 Session A 中之后再根据 number > 0 的条件读取的记录变少了，这种现象算不算幻读呢？明确说一下，这种现象不属于幻读，**幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录，仿佛发生了幻觉**。而上面所说的删除的情况属于不可重复读。

### 2.2 事务的隔离级别

我们上边介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题也有严重程度之分，我们给这些问题按照严重性来排一下序：脏写 > 脏读 > 不可重复读 > 幻读。

我们之前所说的用一部分隔离性交换性能就体现在这里：**隔离级别越低，越严重的问题就越可能发生**。

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（READ UNCOMMITTED）**：指一个事务还没提交时，它做的变更就能被其他事务看到。
- **读已提交（RAED COMMITTED）**：指一个事务提交之后，它做的变更才能被其他事务看到。
- **可重复读（REPEATABLE READ）**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，这是**MySQL InnoDB 引擎的默认隔离级别**。
- **可串行化（SERIALIZABLE）**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

SQL 标准规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：

| 隔离级别         | 脏读   | 不可重复读 | 幻读   |
| ---------------- | ------ | ---------- | ------ |
| READ UNCOMMITTED | 可能   | 可能       | 可能   |
| RAED COMMITTED   | 不可能 | 可能       | 可能   |
| REPEATABLE READ  | 不可能 | 不可能     | 可能   |
| SERIALIZABLE     | 不可能 | 不可能     | 不可能 |

为什么表格里没有脏写呢？这是因为**脏写是最严重的，因此任何一种隔离级别都不允许发生**。

### 2.3 MySQL 中的事务隔离级别

不同的数据库厂商对 SQL 标准中规定的四种隔离级别支持不一样，MySQL 是四种隔离级别全部支持的，但与 SQL 标准中所规定的各级隔离级别允许发生的问题却有些出入，**MySQL 在 REPEATABLE READ 隔离级别下，也是可以禁止幻读问题的发生的**，之后我们再说这是如何实现的。

MySQL 的默认隔离级别就是 REPEATABLE READ，我们可以使用下面的 SQL 语句来修改：

```mysql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
```

其中的 level 可选值有 4 个，就是那四种隔离级别的英文。

在设置事务的隔离级别的语句中，在 SET 关键字后可以放置 GLOBAL 关键字、SESSION 关键字或者什么都不放，这样会对不同范围的事务产生不同的影响：

* GLOBAL：
  * 只对执行完该语句之后产生的会话起作用
  * 当前已经存在的会话无效
* SESSION：
  * 对当前会话的所有后续的事务有效
  * 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务
  * 如果在事务之间执行，则对后续的事务有效
* 什么都不加：
  * 只对当前会话中下一个即将开启的事务有效
  * 下一个事务执行完后，后续事务将恢复到之前的隔离级别
  * 该语句不能在已经开启的事务中间执行，会报错的

如果我们在服务器启动时想改变事务的默认隔离级别，可以修改启动参数 `transaction-isolation` 的值，比方说 我们在启动服务器时指定了 `--transaction-isolation=SERIALIZABLE` ，那么事务的默认隔离级别就从原来的 REPEATABLE READ 变成了 SERIALIZABLE。

想要查看当前会话默认的隔离级别可以通过查看系统变量 transaction_isolation 的值来确定：

![image-20220725153512102](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725153512102.png)

MySQL 对于各个隔离级别的实现是这样的：

- 对于**读未提交**隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以**直接读取**最新的数据就好了；

- 对于**可串行化**隔离级别的事务来说，通过**加读写锁**的方式来避免并行访问；

- 对于**读已提交**和**可重复读**隔离级别的事务来说，它们是通过 MVCC 的 **Read View** 来实现的，它们的区别在于创建 Read View 的时机不同。

我们马上介绍 MVCC。

### 2.4 MVCC 原理

为了顺利讲解，我们建立一个表：

```mysql
CREATE TABLE hero (
  	number INT,
  	name VARCHAR(100),
  	country varchar(100),
  	PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8;
```

#### 2.4.1 版本链

我们前边说过，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：

* trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给 trx_id 隐藏列。
* roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo log 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

比方说我们的表 hero 现在只包含一条记录：

```mysql
mysql> SELECT * FROM hero; 
+--------+--------+---------+ 
| number | name | country | 
+--------+--------+---------+ 
| 1 | 刘备 | 蜀 | 
+--------+--------+---------+ 
1 row in set (0.07 sec)
```

假设插入该记录的事务 id 为 80，那么此刻该条记录的示意图如下所示：

![image-20220725165500543](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725165500543.png)

假设之后两个事务 id 分别为 100、200 的事务对这条记录进行 UPDATE 操作，操作流程如下：

![image-20220725165547489](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725165547489.png)

每次对记录进行改动，都会记录一条 undo log，每条 undo log 也都有一个 roll_pointer 属性（INSERT 操作对应的 undo log 没有该属性，因为该记录并没有更早的版本），可以将这些 undo log 都连起来，串成一个链表，所以现在的情况就像下图一样：

![image-20220725165634422](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725165634422.png)

对该记录每次更新后，都会将旧值放到一条 undo log 中，就算是该记录的一个旧版本，**随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为版本链**。

版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务 id，这个信息很重要，我们稍后就会用到。

#### 2.4.2 ReadView

对于使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，InnoDB 提出了一个 ReadView 的概念，这个 ReadView 中主要包含 4 个比较重要的内容:

- **m_ids**：表示在生成 ReadView 时当前系统中**活跃的读写事务**的事务 id 列表。
- **min_trx_id**：表示在生成 ReadView 时当前系统中活跃的读写事务中**最小的事务 id**，也就是 **m_ids 中的最小值**。
- **max_trx_id**：表示生成 ReadView 时系统中应该分配给**下一个事务的 id**，也就是 m_ids 的最大值 + 1。
- **creator_trx_id**：表示**生成该 ReadView 的事务的事务 id**。

示意图如下：

![image-20220513101022482](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220513101022482.png)



在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220513101708865.png" alt="image-20220513101708865" style="zoom:80%;" />

有了这个 ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

* 如果**被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同**，意味着**当前事务在访问它自己修改过的记录**，所以该版本可以被当前事务访问。
* 如果**被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值**，表明生成**该版本的事务在当前事务生成 ReadView 前已经提交**，所以该版本可以被当前事务访问。
* 如果**被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值**，表明**生成该版本的事务在当前事务生成 ReadView 后才开启**，所以该版本不可以被当前事务访问。
* 如果被访问版本的 trx_id 属性值**在 ReadView 的 min_trx_id 和 max_trx_id 之间**，那就需要**判断一下 trx_id 属性值是不是在 m_ids 列表中**：
  * 如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问。
  * 如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

#### 2.4.3 READ COMMITTED 的实现

READ COMMITTED 是**在每次读取数据前都生成一个 ReadView**。

以下使用一个示例来说明：

现在系统里有两个事务 id 分别为 100、200 的事务在执行：

```mysql
# Transaction 100
BEGIN;
UPDATE hero SET name = '关羽' WHERE number = 1;
UPDATE hero SET name = '张飞' WHERE number = 1;

# Transaction 200
BEGIN;
# 更新了一些别的表的记录
```

此刻，表 hero 中 number 为 1 的记录得到的版本链表如下所示：

![image-20220725173857147](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725173857147.png)

假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行：

```mysql
# 使用 REPEATABLE READ 隔离级别的事务
BEGIN;

# SELECT1，此时 事务 ID 为 100、200 的事务均未提交
SELECT * FROM hero WHERE number = 1; # 查询得到的列 name 的值为 '刘备'
```

这个 SELECT1 的执行过程如下：

* 在执行 SELECT 语句时会先生成一个 ReadView，ReadView 的 m_ids 列表的内容就是 [100, 200]，min_trx_id 为 100，max_trx_id 为 201，creator_trx_id 为 0。
* 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 '张飞'，该版本的 trx_id 值为 100，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。
* 下一个版本的列 name 的内容是 '关羽'，该版本的 trx_id 值也为 100，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。
* 下一个版本的列 name 的内容是 '刘备'，该版本的 trx_id 值为 80，小于 ReadView 中的 min_trx_id 值 100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 '刘备' 的记录。

之后，我们把 事务id 为 100 的事务提交一下，就像这样:

```mysql
# Transaction 100
BEGIN;
UPDATE hero SET name = '关羽' WHERE number = 1;
UPDATE hero SET name = '张飞' WHERE number = 1;
COMMIT;
```

然后再到 事务 id 为 200 的事务中更新一下表 hero 中 number 为 1 的记录：

```MYSQL
# Transaction 200
BEGIN;
# 更新了一些别的表的记录 ...
UPDATE hero SET name = '赵云' WHERE number = 1; 
UPDATE hero SET name = '诸葛亮' WHERE number = 1;
```

此刻，表 hero 中 number 为 1 的记录的版本链就长这样：

![image-20220725174251332](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725174251332.png)

到现在为止，都还和 READ COMMITTED 一样，注意接下来的步骤。

再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 number 为 1 的记录，如下：

```mysql
# 使用 READ COMMITTED 隔离级别的事务
BEGIN;

# SELECT1，此时 事务 ID 为 100、200 的事务均未提交
SELECT * FROM hero WHERE number = 1; # 得到的列 name 的值为 '刘备'

# SELECT2，此时 事务 ID 为 100 的事务提交了，但是事务 ID 为 200 的事务未提交
SELECT * FROM hero WHERE number = 1; # 得到的列 name 的值为 '刘备'
```

SELECT2 的执行流程如下：

* 由于使用的隔离级别是 REPEATABLE READ，**已经生成了一个 ReadView**，ReadView 的 m_ids 列表的内容就是 [100, 200]，min_trx_id 为 100，max_trx_id 为 201，creator_trx_id 为 0。
* 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 '诸葛亮'，该版本的 trx_id 值为 200，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。
* 下一个版本的列 name 的内容是 '赵云'，该版本的 trx_id 值也为 200，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。
* 下一个版本的列 name 的内容是 '张飞'，该版本的 trx_id 值为 100，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。
* 下一个版本的列 name 的内容是 '刘备'，该版本的 trx_id 值为 80，在 m_ids 列表内，小于 ReadView 中的 min_trx_id 值 100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 '刘备' 的记录。

#### 2.4.4 REPEATABLE READ 的实现

REPEATABLE READ **只会在第一次执行查询语句时生成一个 ReadView**，之后的查询就不会重复生成了。

还是举一个例子：

现在系统里有两个事务 id 分别为 100、200 的事务在执行：

```mysql
# Transaction 100
BEGIN;
UPDATE hero SET name = '关羽' WHERE number = 1;
UPDATE hero SET name = '张飞' WHERE number = 1;

# Transaction 200
BEGIN;
# 更新了一些别的表的记录
```

此刻，表 hero 中 number 为 1 的记录得到的版本链表如下所示：

![image-20220725173857147](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725173857147.png)

假设现在有一个使用 READ COMMITTED 隔离级别的事务开始执行：

```mysql
# 使用READ COMMITTED隔离级别的事务
BEGIN;

# SELECT1，此时 事务 ID 为 100、200 的事务均未提交
SELECT * FROM hero WHERE number = 1; # 查询得到的列 name 的值为 '刘备'
```

这个 SELECT1 的执行过程如下：

* 在执行 SELECT 语句时会先生成一个 ReadView，ReadView 的 m_ids 列表的内容就是 [100, 200]，min_trx_id 为 100，max_trx_id 为 201，creator_trx_id 为 0。
* 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 '张飞'，该版本的 trx_id 值为 100，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。
* 下一个版本的列 name 的内容是 '关羽'，该版本的 trx_id 值也为 100，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。
* 下一个版本的列 name 的内容是 '刘备'，该版本的 trx_id 值为 80，小于 ReadView 中的 min_trx_id 值 100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 '刘备' 的记录。

之后，我们把 事务id 为 100 的事务提交一下，就像这样:

```mysql
# Transaction 100
BEGIN;
UPDATE hero SET name = '关羽' WHERE number = 1;
UPDATE hero SET name = '张飞' WHERE number = 1;
COMMIT;
```

然后再到 事务 id 为 200 的事务中更新一下表 hero 中 number 为 1 的记录：

```MYSQL
# Transaction 200
BEGIN;
# 更新了一些别的表的记录 ...
UPDATE hero SET name = '赵云' WHERE number = 1; 
UPDATE hero SET name = '诸葛亮' WHERE number = 1;
```

此刻，表 hero 中 number 为 1 的记录的版本链就长这样：

![image-20220725174251332](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725174251332.png)

然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 number 为 1 的记录，如下：

```mysql
# 使用 READ COMMITTED 隔离级别的事务
BEGIN;

# SELECT1，此时 事务 ID 为 100、200 的事务均未提交
SELECT * FROM hero WHERE number = 1; # 得到的列 name 的值为 '刘备'

# SELECT2，此时 事务 ID 为 100 的事务提交了，但是事务 ID 为 200 的事务未提交
SELECT * FROM hero WHERE number = 1; # 得到的列 name 的值为 '张飞'
```

SELECT2 的执行流程如下：

* 在执行 SELECT 语句时会先生成一个 ReadView，ReadView 的 m_ids 列表的内容就是 [200]，min_trx_id 为 200，max_trx_id 为 201，creator_trx_id 为 0。
* 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 '诸葛亮'，该版本的 trx_id 值为 200，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。
* 下一个版本的列 name 的内容是 '赵云'，该版本的 trx_id 值也为 200，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。
* 下一个版本的列 name 的内容是 '张飞'，该版本的 trx_id 值为 100，小于 ReadView 中的 min_trx_id 值 200，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 '张飞' 的记录。

