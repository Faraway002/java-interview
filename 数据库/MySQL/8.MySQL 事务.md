# MySQL 事务

## 1. 什么是事务？

### 1.1 事务的起源

对于大部分程序员来说，他们的任务就是把现实世界的业务场景映射到数据库世界。比如银行为了存储人们的账户信息会建立一个 account 表：

```mysql
CREATE TABLE account (
    id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',
    name VARCHAR(100) COMMENT '客户名称',
    balance INT COMMENT '余额',
    PRIMARY KEY (id)
) Engine=InnoDB CHARSET=utf8;
```

在某个特定时刻，人们在在银行所拥有的资产是一个特定的值，这些特定的值也可以被描述为账户在这个特定的时刻现实世界的一个状态。随着时间的流逝，人们可能陆续进行向账户中存钱、取钱或者向别人转账等操作，这样他们账户中的余额就可能发生变动，每一个操作都相当于现实世界中账户的一次状态转换。

数据库世界作为现实世界的一个映射，自然也要进行相应的变动。但是，现实世界中一些看似很简单的状态转换，映射到数据库世界却不是那么容易的。比方说有一次小明在赌博输了钱，急忙打电话给小刚要借 10 块钱。现实世界中的小刚走向了ATM机，输入了小明的账号以及 10 元的转账金额，然后按下确认，小刚就拔卡走人了，现实世界中转账就成功了。

但是对于数据库世界来说，可没有那么简单。在数据库里，相当于执行了下边这两条语句：

```MYSQL
UPDATE account SET balance = balance - 10 WHERE id = 1;

UPDATE account SET balance = balance + 10 WHERE id = 2;
```

但是这里有个问题，上述两条语句如果只执行了一条时忽然服务器断电了咋办？把小刚的钱扣了，但是没给小明转过去，那小明还是处于紧急缺钱的状态，而且小刚的钱也就这么消失了。

除此之外，由于 MySQL 还有 Buffer Pool，在对某个页面进行读写访问时，都会先把这个页面加载到 Buffer Pool 中，之后如果修改了某个页面，也不会立即把修改同步到磁盘，而只是把这个修改了的页面加到 Buffer Pool 的 flush 链表中，在之后的某个时间点才会刷新到磁盘。

如果在将修改过的页刷新到磁盘之前系统崩溃了会怎么样？或者在刷新磁盘的过程中（只刷新部分数据到磁盘上）系统奔溃了又会怎么样？

怎么才能保证这笔钱完好无损呢？其实再仔细想想，我们只是想**让某些数据库操作符合现实世界中状态转换的规则**而已。

现实世界中状态转换的规则有好几条，下面我们一一介绍。

#### 1.1.1 原子性（Atomicity）

现实世界中转账操作是一个**不可分割的操作**，也就是说要么压根就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。

数据库把这种要么全做，要么全不做的规则称之为**原子性** 。

但是在**现实世界中的一个不可分割的操作却可能对应着数据库若干条不同的操作，数据库中的一条操作也可能被分解成若干个步骤**（比如先修改缓存页，之后再刷新到磁盘等），最要命的是**在任何一个可能的时间都可能发生意想不到的错误**（可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的）而使操作执行不下去。

为了保证在数据库世界中某些操作的原子性，数据库需要一些机制来保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子，我们后面会详细讲述。

#### 1.1.2 隔离性

#### 1.1.3 一致性（Consistency）

我们生活的这个世界存在着形形色色的约束，比如身份证号不能重复，性别只能是男或者女，高考的分数只能在 0～750 之间，人民币面值最大只能是 100，红绿灯只有 3 种颜色，房价不能为负的等等等等。

数据库只是现实世界的一个映射，**现实世界中存在的约束当然也要在数据库中有所体现，如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的，或者说符合一致性的**。

如何保证数据库中数据的一致性呢？这其实有两个方面：

* **数据库本身能为我们保证一部分一致性需求**。

  大部分数据库中都存在主键、外键、NOT NULL 约束，UNIQUE 约束等等。当你使用约束创建表之后，比如对身份证字段创建一个 UNIQUE 约束，如果你再插入一个已经在表里的身份证，那么就会遭到数据库的拒绝。这些约束都是数据库为我们保证的。

  除此之外，MySQL 还提供了 CHECK 语法可以自定义约束，比如：

  ```mysql
  CREATE TABLE account (
      id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',
      name VARCHAR(100) COMMENT '客户名称',
      balance INT COMMENT '余额',
      PRIMARY KEY (id),
      CHECK (balance >= 0) 
  );
  ```

   这条 CHECK 语句意思是规定 balance 列不能存储小于0的数字，对应的现实世界的意思就是银行账户余额不能小于 0。

  但是很遗憾，**MySQL 只是支持 CHECK 语法，但是并没有实现 CHECK**，也就是说如果你写了 CHECK 语法是可以的，不算语法错误，但是 MySQL 执行时会忽略它。

  > 相比于 MySQL，SQL Server 和 Oracle 都是实实在在支持 CHECK 语法的。
  >
  > 不过，你依然可以在 MySQL 中使用触发器来进行插入或更新之前的检查，也算是弥补了 CHECK 没有实现的遗憾。

* **更多的一致性需求需要靠程序员自己保证**。

  为建立现实世界和数据库的对应关系，理论上应该把现实世界中的所有约束都反应到数据库中，但是很不幸，**在更改数据库数据时进行一致性检查是一个耗费性能的工作**。

  比方说我们为 account 表建立了一个触发器，每当插入或者更新记录时都会校验一下 balance 列的值是不是大于0，这就会影响到插入或更新的速度。

  仅仅是校验一行记录符不符合一致性需求倒也不是什么大问题，但是有的一致性需求太复杂了。

  比方说银行会建立一张代表账单的表，里边儿记录了每个账户的每笔交易，每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。如果在数据库层面实现这个一致性需求的话，每次发生交易时，都需要将所有的收入加起来减去所有的支出，再将所有的账户余额加起来，看看两个值相不相等。

  如果账单表里有几亿条记录，光是这个校验的过程可能就要跑好几个小时，也就是说你在煎饼摊买个煎饼，使用银行卡付款之后要等好几个小时才能提示付款成功，这样的性能代价是完全承受不起的。

  现实生活中复杂的一致性需求比比皆是，而**由于性能问题把一致性需求交给数据库去解决是不现实的**，所以这个任务就落在了业务端程序员身上。

  比方说我们的 account 表，我们也可以不建立触发器，只要**编写业务的程序员在自己的业务代码里判断一下**，当某个操作会将 balance 列的值更新为小于 0 的值时，就不执行该操作就好了。

我们前边提到的**原子性和隔离性都会对一致性产生影响**。

比如我们现实世界中转账操作完成后，有一个一致性需求就是参与转账的账户的总的余额是不变的。如果数据库不遵循原子性要求，也就是转了一半就不转了，那最后就是不符合一致性需求的；类似的，如果数据库不遵循隔离性要求，就像我们讲隔离性时举的例子中所说的，最终源账户中扣的钱和对方账户中涨的钱可不一样，也就是说不符合一致性需求了。

所以说，**数据库某些操作的原子性和隔离性都是保证一致性的一种手段**，在操作执行完成后保证符合所有既定的约束则是一种结果。

#### 1.1.4 持久性

### 1.2 事务的概念

### 1.3 MySQL 中事务的使用

MySQL 中，使用 `START TRANSACTION` 语句开始一个事务；使用 `COMMIT` 语句提交所有的修改；使用 `ROLLBACK` 语句撤销所有的修改。

不能回退 `SELECT` 语句，回退 `SELECT` 语句也没意义，也不能回退 `CREATE` 和 `DROP` 语句。

- `START TRANSACTION`：指令用于标记事务的起始点。
- `SAVEPOINT`：指令用于创建保留点。
- `ROLLBACK TO`：指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 `START TRANSACTION` 语句处。
- `COMMIT`：提交事务。

#### AUTOCOMMIT

MySQL 默认采用**隐式提交策略（`autocommit`）**：每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。

通过 `set autocommit = 0` 可以取消自动提交，直到 `set autocommit = 1` 才会提交；`autocommit` 标记是针对每个连接而不是针对服务器的。

## 事务的 ACID 特性

ACID 是四个单词的缩写：

* **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；

* **一致性（Consistency）**：数据库的完整性不会因为事务的执行而受到破坏。

  比如表中有一个字段为姓名，它有唯一约束，也就是表中姓名不能重复，如果一个事务对姓名字段进行了修改，但是在事务提交后，表中的姓名变得非唯一性了，这就破坏了事务的一致性要求，这时数据库就要撤销该事务，返回初始化的状态。

* **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

  并发事务是十分常见的，数据库专门为该特性设置了**隔离级别**。

* **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？

- 持久性是通过 redo log（重做日志）来保证的。
- 原子性是通过 undo log（回滚日志）来保证的。
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的。
- **一致性则是通过持久性 + 原子性 + 隔离性来保证**，也就是说 A I D 是手段，C 是目的。

## 并发事务带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）:** 如果一个事务**读到了另一个未提交事务修改过的数据**，就意味着发生了脏读现象。

  如下图所示：

  ![image-20220402182142665](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220402182142665.png)

- **不可重复读（Unrepeatableread）:** 在一个事务内多次读取同一个数据，如果出现**前后两次读到的数据不一样的情况**，就意味着发生了不可重复读现象。

  如下图所示：

  ![image-20220402182225635](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220402182225635.png)

- **幻读（Phantom read）:** 在一个事务内多次查询某个符合查询条件的记录数量，如果出现**前后两次查询到的记录数量不一样的情况**，就意味着发生了幻读现象。

  ![image-20220402182715453](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220402182715453.png)

这三个现象的严重性排序如下：

![图片](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/d37bfa1678eb71ae7e33dc8f211d1ec1.png)

## 事务的隔离级别

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（read uncommitted）**：指一个事务还没提交时，它做的变更就能被其他事务看到。
- **读提交（read committed）**：指一个事务提交之后，它做的变更才能被其他事务看到。
- **可重复读（repeatable read）**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，这是**MySQL InnoDB 引擎的默认隔离级别**。
- **串行化（serializable）**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

按隔离水平高低排序如下：

![图片](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/cce766a69dea725cd8f19b90db2d0430.png)

针对不同的隔离级别，并发事务时可能发生的现象也会不同。

![图片](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/4e98ea2e60923b969790898565b4d643.png)

InnoDB 引擎的默认隔离级别虽然是可重复读，但是它通过 next-key lock（行锁和间隙锁的组合）来锁住记录之间的间隙和记录本身，**防止其他事务在这个记录之间插入新的记录**，这样就避免了幻读现象。

### 隔离级别的实现

- 对于**读未提交**隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以**直接读取**最新的数据就好了；

- 对于**串行化**隔离级别的事务来说，通过**加读写锁**的方式来避免并行访问；

- 对于读提交和可重复读隔离级别的事务来说，它们是通过 MVCC 的 **Read View** 来实现的，它们的区别在于创建 Read View 的时机不同。

  Read View 可以被理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。

  * 读已提交隔离级别是在每个语句执行前都会重新生成一个 Read View。
  * 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。

### Read View 与 MVCC

Read View 是一个数据快照，它有四个重要的字段：

- m_ids ：指的是在创建 Read View 时，当前数据库中**活跃事务的事务 id 列表**，注意是一个列表。

  活跃事务指的是**启动了但还没提交的事务**。

- min_trx_id ：指的是在创建 Read View 时，当前数据库中**活跃事务中事务 id 最小的事务**，也就是 m_ids 的最小值。

- max_trx_id ：这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大的事务 id 值 + 1；

- creator_trx_id ：指的是**创建该 Read View 的事务的事务 id**。

![image-20220513101022482](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220513101022482.png)

而我们知道，MySQL 的每一个记录都有三个隐藏列：

| 列名        | 是否必须 | 占用空间 | 描述                    |
| ----------- | -------- | -------- | ----------------------- |
| DB_ROW_ID   | 否       | 6 字节   | 行 ID，唯一标识一条记录 |
| DB_TRX_ID   | 是       | 6 字节   | 事务 ID                 |
| DB_ROLL_PTR | 是       | 7 字节   | 回滚指针                |

在这里我们需要使用到 `DB_TRX_ID` 以及 `DB_ROLL_PTR`。现在假设在账户余额表插入一条小林余额为 100 万的记录，然后我把这两个隐藏列也画出来，该记录的整个示意图如下：

![image-20220513101423845](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220513101423845.png)

这两个隐藏列更详细的作用是：

- trx_id：当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；
- roll_ptr：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。

在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220513101708865.png" alt="image-20220513101708865" style="zoom:80%;" />

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的 `min_trx_id`和 `max_trx_id`之间，需要判断 trx_id 是否在 m_ids 列表中：
  - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
  - 如果记录的 trx_id **不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。

**这种通过版本链来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）**。

### 可重复读的实现

**可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View**。

假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：

![image-20220513102308897](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220513102308897.png)

事务 A 和 事务 B 的 Read View 具体内容如下：

- 在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。
- 在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，**活跃的事务 id 中最小的事务 id 是事务 A**，下一个事务 id 应该是 53。

接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：

- 事务 B 读取小林的账户余额记录，读到余额是 100 万；
- 事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；
- 事务 B 读取小林的账户余额记录，读到余额还是 100 万；
- 事务 A 提交事务；
- 事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；

接下来是具体分析：

* 事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时**发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的**，也就是事务 B 可以获取到这条记录。

* 接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成**版本链**，如下图：

  ![image-20220513103044614](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220513103044614.png)

* 可以在上图中看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id = 51）。

* 然后事务 B 第二次去读取该记录，**发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录，而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 小于事务 B 的 Read View 中的 min_trx_id 值的第一条记录**，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。

* 最后，当事物 A 提交事务后，**由于隔离级别是可重复读，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事务 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录**。

### 读提交的实现

**读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**。

这意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。

我们还是以前面的例子，事务 A（事务 id 为 51）和事务 B 按顺序执行了以下操作，和可重复读的不同会特别说明：

- 事务 B 读取小林的账户余额记录（创建 Read View），读到余额是 100 万；

  本次创建的 Read View 如下：

  <img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220513103714736.png" alt="image-20220513103714736" style="zoom:80%;" />

- 事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；

  本次将生成版本链：

  <img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220513103742152.png" alt="image-20220513103742152" style="zoom:80%;" />

- 事务 B 读取小林的账户余额记录（又创建一个新的 Read View），读到余额还是 100 万；

  这里创建了一个新的 Read View：

  <img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220513103835278.png" alt="image-20220513103835278" style="zoom:80%;" />

  由于版本链最新的 id 是 51，在 m_ids 之间，于是此时顺着版本链找到最早的，也就是 100 万这条记录。

- 事务 A 提交事务；

- 事务 B 读取小林的账户余额记录（又创建一个新的 Read View），**小林的账户余额为 200 万**；

  此时，又创建了一个新的 Read View：

  ![image-20220513104021327](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220513104021327.png)

  这里由于最小事务 id 都是 52，说明能读 51 的记录，也就是 200 万的记录了。

### 解决幻读

