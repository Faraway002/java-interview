[TOC]

# MySQL 锁

## 1. 解决并发事务问题的两种基本方式

在事务一章中我们了解到了并发事务可能带来的一些问题，其实，并发事务访问相同记录的情况大致可以划分为 3 种：

* 读-读：即并发事务相继读取相同的记录。

  这种情况下不会有任何问题，反正没对数据做修改，一律允许。

* 写-写：即并发事务相继对相同的记录做出改动。

  我们前边说过，**在这种情况下会发生脏写的问题，任何一种隔离级别都不允许脏写问题的发生**。

  所以**在多个未提交事务相继对一条记录做改动时，需要让它们排队执行**，这个排队的过程其实是**通过锁来实现的**。

  这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725175536023.png" alt="image-20220725175536023" style="zoom:50%;" />

  **当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联**。

  比方说事务 T1 要对这条记录做改动，就需要生成一个锁结构与之关联：

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725175609443.png" alt="image-20220725175609443" style="zoom:50%;" />

  其实在锁结构里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：

  * trx 信息：代表这个锁结构是哪个事务生成的。
  * is_waiting：代表当前事务是否在等待。

  如图所示，当事务 T1 改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以 is_waiting 属性就是 false，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了。

  在事务 T1 提交之前，另一个事务 T2 也想对该记录做改动，那么先去看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过这个锁结构的 is_waiting 属性值为 true，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁。

  画个图表示就是这样：

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725175809401.png" alt="image-20220725175809401" style="zoom:50%;" />

  **在事务 T1 提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁**。此时发现了事务 T2 还在等待获取锁，所以把事务 T2 对应的锁结构的 is_waiting 属性设置为 false，然后 把该事务对应的线程唤醒，让它继续执行，此时事务 T2 就算获取到锁了。

  效果图就是这样：

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725180552471.png" alt="image-20220725180552471" style="zoom:50%;" />

* 读-写/写-读：也就是一个事务进行读取操作，另一个进行改动操作。我们前边说过，这种情况下可能发生**脏读、不可重复读、幻读**的问题。

  那么根据事务隔离级别的不同，处理这些问题的方式也不一样。

  * READ UNCOMMITTED：不处理，直接读；写操作则加锁。

  * READ COMMITTED：读操作采取 MVCC（每次查询前生成一次 ReadView），解决了脏读问题；写操作加锁。

  * REPEATABLE READ：读操作采取 MVCC（仅事务开始前生成一次 ReadView），解决了不可重复读问题；写操作加锁。

    > 注意，MVCC 和写操作不冲突，写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突。

  * SERIALIZABLE：读写都加锁，解决了幻读问题。

    加锁要解决幻读其实有一些麻烦，因为幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。

    采用加锁的方式解决幻读问题为什么麻烦一些呢？因为**当前事务在第一次读取记录时那些幻影记录并不存在，所以读取的时候你并不知道给谁加锁**。MySQL 很好的解决了这个问题，我们之后会详细介绍的。

### 1.1 一致性读

**事务利用 MVCC 进行的读取操作称之为一致性读**，或者**一致性无锁读**，有的地方也称之为**快照读** 。

**所有普通的 SELECT 语句在 READ COMMITTED、REPEATABLE READ 隔离级别下都算是一致性读**。

比方说:

```mysql
SELECT * FROM t;
SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2
```

**一致性读并不会对表中的任何记录做加锁操作，其他事务可以自由的对表中的记录做改动**。

### 1.2 锁定读

#### 1.2.1 共享锁和独占锁

在使用加锁的方式解决问题时，由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以 MySQL 给锁分了类：

* **共享锁（Shared Locks）**：简称 S 锁。在事务要读取一条记录时，需要先获取该记录的 S 锁。
* **独占锁（Exclusive Locks）**：也常称排他锁，简称 X 锁。在事务要改动一条记录时，需要先获取该记录的 X 锁。

假如事务 T1 首先获取了一条记录的 S 锁之后，事务 T2 接着也要访问这条记录:

* 如果事务 T2 想要再获取一个记录的 S 锁 ，那么事务 T2 也会获得该锁，也就意味着**事务 T1 和 T2 在该记录上同时持有 S 锁**。
* 如果事务 T2 想要再获取一个记录的 X 锁 ，那么此操作会被阻塞，直到事务 T1 提交之后将 S 锁释放掉。

也就是说，S 锁和 S 锁可以由多个事务获取，是兼容的；而 S 锁和 X 锁是不兼容的；X 锁和 X 锁也是如此。如下表所示：

| 兼容性 | X 锁 | S 锁 |
| ------ | ---- | ---- |
| X 锁   | No   | No   |
| S 锁   | No   | Yes  |

#### 1.2.2 锁定读的使用方法

MySQL 提供两种比较特殊的 SELECT 语句格式用于加锁：

* `SELECT ... LOCK IN SHARE MODE`：即在一条 SELECT 语句后加上 `LOCK IN SHARE MODE`，如果当前事务执行了该语句，那么它会为读取到的记录加 S 锁，这样允许别的事务继续获取这些记录的 S 锁，但是不能获取这些记录的 X 锁。

  如果别的事务想要获取这些记录的 X 锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的 S 锁释放掉。

* `SELECT ... FOR UPDATE`：即在一条 SELECT 语句后加上 `FOR UPDATE`，如果当前事务执行了该语句，那么它会为读取到的记录加 X 锁，这样既不允许别的事务继续获取这些记录的 X 锁，也不允许获取这些记录的 S 锁。

  如果别的事务想要获取这些记录的 S 锁或者 X 锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的 X 锁释放掉。

### 1.3 写操作

平常所用到的写操作无非是 DELETE、UPDATE、INSERT 这三种：

* DELETE：对一条记录做 DELETE 操作的过程其实是先在 B+ 树中定位到这条记录的位置，然后获取一下这条记录的 X 锁，然后再执行 delete mark 操作。

  我们也可以把这个定位待删除记录在 B+ 树中位置的过程看成是一个**获取 X 锁的锁定读**。

* INSERT :一般情况下，**新插入一条记录的操作并不加锁**，InnoDB 通过一种称之为**隐式锁**的特殊锁来保护这条新插入的记录在本事务提交前不被别的事务访问。

* UPDATE：在对一条记录做 UPDATE 操作时分为三种情况：

  * 如果**未修改该记录的主键值**并且**被更新的列占用的存储空间在修改前后未发生变化**，则先在 B+ 树中定位到这条记录的位置，然后再获取一下记录的 X 锁，最后在原记录的位置进行修改操作。

    其实我们也可以把这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X 锁的锁定读。

  * 如果**未修改该记录的主键值**并且**至少有一个被更新的列占用的存储空间在修改前后发生变化**，则先在 B+ 树中定位到这条记录的位置，然后获取一下记录的 X 锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。

    这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X 锁的锁定读，新插入的记录由 INSERT 操作提供的隐式锁进行保护。

  * 如果**修改了该记录的主键值**，则相当于在原记录上做 DELETE 操作之后再来一次 INSERT 操作，加锁操作就需要按照 DELETE 和 INSERT 的规则进行了。

## 2. 多粒度锁

我们前边提到的锁都是**针对记录的锁，也可以被称之为行级锁或者行锁**，对一条记录加锁影响的也只是这条记录而已，我们就说这个**锁的粒度比较细**。

其实一个事务也可以在表级别进行加锁，自然就被称之为表级锁或者表锁，**对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗**。

给表加的锁也可以分为 S 锁和 X 锁：

* 给表加 S 锁：
  * 其他事务可以继续对表加 S 锁。
  * 其他事务可以继续对表中的某些记录加 S 锁。
  * 其他事务不可以对表加 X 锁。
  * 其他事务不可以对表中的某些记录加 X 锁。
* 给表加 X 锁：
  * 其他事务不可以继续对表加 S 锁。
  * 其他事务不可以继续对表中的某些记录加 S 锁。
  * 其他事务不可以继续对表加 X 锁。
  * 其他事务不可以继续对表中的某些记录加 X 锁。

## 3. MySQL 中的行锁和表锁
