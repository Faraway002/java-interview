[TOC]

# MySQL 锁

## 1. 解决并发事务问题的基本方式

在事务一章中我们了解到了并发事务可能带来的一些问题，其实，并发事务访问相同记录的情况大致可以划分为 3 种：

* 读-读：即并发事务相继读取相同的记录。

  这种情况下不会有任何问题，反正没对数据做修改，一律允许。

* 写-写：即并发事务相继对相同的记录做出改动。

  我们前边说过，**在这种情况下会发生脏写的问题，任何一种隔离级别都不允许脏写问题的发生**。

  所以**在多个未提交事务相继对一条记录做改动时，需要让它们排队执行**，这个排队的过程其实是**通过锁来实现的**。

  这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725175536023.png" alt="image-20220725175536023" style="zoom:50%;" />

  **当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联**。

  比方说事务 T1 要对这条记录做改动，就需要生成一个锁结构与之关联：

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725175609443.png" alt="image-20220725175609443" style="zoom:50%;" />

  其实在锁结构里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：

  * trx 信息：代表这个锁结构是哪个事务生成的。
  * is_waiting：代表当前事务是否在等待。

  如图所示，当事务 T1 改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以 is_waiting 属性就是 false，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了。

  在事务 T1 提交之前，另一个事务 T2 也想对该记录做改动，那么先去看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过这个锁结构的 is_waiting 属性值为 true，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁。

  画个图表示就是这样：

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725175809401.png" alt="image-20220725175809401" style="zoom:50%;" />

  **在事务 T1 提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁**。此时发现了事务 T2 还在等待获取锁，所以把事务 T2 对应的锁结构的 is_waiting 属性设置为 false，然后 把该事务对应的线程唤醒，让它继续执行，此时事务 T2 就算获取到锁了。

  效果图就是这样：

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725180552471.png" alt="image-20220725180552471" style="zoom:50%;" />

* 读-写/写-读：也就是一个事务进行读取操作，另一个进行改动操作。我们前边说过，这种情况下可能发生**脏读、不可重复读、幻读**的问题。

  那么根据事务隔离级别的不同，处理这些问题的方式也不一样。

  * READ UNCOMMITTED：不处理，直接读；写操作则加锁。

  * READ COMMITTED：读操作采取 MVCC（每次查询前生成一次 ReadView），解决了脏读问题；写操作加锁。

  * REPEATABLE READ：读操作采取 MVCC（仅事务开始前生成一次 ReadView），解决了不可重复读问题；写操作加锁。

    > 注意，MVCC 和写操作不冲突，写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突。

  * SERIALIZABLE：读写都加锁，解决了幻读问题。

    加锁要解决幻读其实有一些麻烦，因为幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。

    采用加锁的方式解决幻读问题为什么麻烦一些呢？因为**当前事务在第一次读取记录时那些幻影记录并不存在，所以读取的时候你并不知道给谁加锁**。MySQL 很好的解决了这个问题，我们之后会详细介绍的。

### 1.1 一致性读

**事务利用 MVCC 进行的读取操作称之为一致性读**，或者**一致性无锁读**，有的地方也称之为**快照读** 。

**所有普通的 SELECT 语句在 READ COMMITTED、REPEATABLE READ 隔离级别下都算是一致性读**。

比方说:

```mysql
SELECT * FROM t;
SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2
```

**一致性读并不会对表中的任何记录做加锁操作，其他事务可以自由的对表中的记录做改动**。

### 1.2 锁定读

#### 1.2.1 共享锁和独占锁

在使用加锁的方式解决问题时，由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以 MySQL 给锁分了类：

* **共享锁（Shared Locks）**：简称 S 锁。在事务要读取一条记录时，需要先获取该记录的 S 锁。
* **独占锁（Exclusive Locks）**：也常称排他锁，简称 X 锁。在事务要改动一条记录时，需要先获取该记录的 X 锁。

假如事务 T1 首先获取了一条记录的 S 锁之后，事务 T2 接着也要访问这条记录:

* 如果事务 T2 想要再获取一个记录的 S 锁 ，那么事务 T2 也会获得该锁，也就意味着**事务 T1 和 T2 在该记录上同时持有 S 锁**。
* 如果事务 T2 想要再获取一个记录的 X 锁 ，那么此操作会被阻塞，直到事务 T1 提交之后将 S 锁释放掉。

也就是说，S 锁和 S 锁可以由多个事务获取，是兼容的；而 S 锁和 X 锁是不兼容的；X 锁和 X 锁也是如此。如下表所示：

| 兼容性 | X 锁 | S 锁 |
| ------ | ---- | ---- |
| X 锁   | No   | No   |
| S 锁   | No   | Yes  |

#### 1.2.2 锁定读的使用方法

MySQL 提供两种比较特殊的 SELECT 语句格式用于加锁：

* `SELECT ... LOCK IN SHARE MODE`：即在一条 SELECT 语句后加上 `LOCK IN SHARE MODE`，如果当前事务执行了该语句，那么它会为读取到的记录加 S 锁，这样允许别的事务继续获取这些记录的 S 锁，但是不能获取这些记录的 X 锁。

  如果别的事务想要获取这些记录的 X 锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的 S 锁释放掉。

* `SELECT ... FOR UPDATE`：即在一条 SELECT 语句后加上 `FOR UPDATE`，如果当前事务执行了该语句，那么它会为读取到的记录加 X 锁，这样既不允许别的事务继续获取这些记录的 X 锁，也不允许获取这些记录的 S 锁。

  如果别的事务想要获取这些记录的 S 锁或者 X 锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的 X 锁释放掉。

### 1.3 写操作

平常所用到的写操作无非是 DELETE、UPDATE、INSERT 这三种：

* DELETE：对一条记录做 DELETE 操作的过程其实是先在 B+ 树中定位到这条记录的位置，然后获取一下这条记录的 X 锁，然后再执行 delete mark 操作。

  我们也可以把这个定位待删除记录在 B+ 树中位置的过程看成是一个**获取 X 锁的锁定读**。

* INSERT :一般情况下，**新插入一条记录的操作并不加锁**，InnoDB 通过一种称之为**隐式锁**的特殊锁来保护这条新插入的记录在本事务提交前不被别的事务访问。

* UPDATE：在对一条记录做 UPDATE 操作时分为三种情况：

  * 如果**未修改该记录的主键值**并且**被更新的列占用的存储空间在修改前后未发生变化**，则先在 B+ 树中定位到这条记录的位置，然后再获取一下记录的 X 锁，最后在原记录的位置进行修改操作。

    其实我们也可以把这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X 锁的锁定读。

  * 如果**未修改该记录的主键值**并且**至少有一个被更新的列占用的存储空间在修改前后发生变化**，则先在 B+ 树中定位到这条记录的位置，然后获取一下记录的 X 锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。

    这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X 锁的锁定读，新插入的记录由 INSERT 操作提供的隐式锁进行保护。

  * 如果**修改了该记录的主键值**，则相当于在原记录上做 DELETE 操作之后再来一次 INSERT 操作，加锁操作就需要按照 DELETE 和 INSERT 的规则进行了。

## 2. 多粒度锁

我们前边提到的锁都是**针对记录的锁，也可以被称之为行级锁或者行锁**，对一条记录加锁影响的也只是这条记录而已，我们就说这个**锁的粒度比较细**。

其实一个事务也可以在表级别进行加锁，自然就被称之为表级锁或者表锁，**对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗**。

给表加的锁也可以分为 S 锁和 X 锁：

* 给表加 S 锁：
  * 其他事务可以继续对表加 S 锁。
  * 其他事务可以继续对表中的某些记录加 S 锁。
  * 其他事务不可以对表加 X 锁。
  * 其他事务不可以对表中的某些记录加 X 锁。
* 给表加 X 锁：
  * 其他事务不可以继续对表加 S 锁。
  * 其他事务不可以继续对表中的某些记录加 S 锁。
  * 其他事务不可以继续对表加 X 锁。
  * 其他事务不可以继续对表中的某些记录加 X 锁。

假设你想给表上 S 锁，首先需要确保的就是没有其他 X 锁，包括记录锁以及表锁；同理，你想给表上 X 锁，则也需要确保没有其他 X 锁以及 S 锁，包括记录锁以及表锁。

这里就存在一个问题：**在上表锁时，怎么知道有没有记录已经被上行锁了呢？**

最简单的方法当然是遍历，毫无疑问这种方法效率很低，于是 InnoDB 提出了一种称之为**意向锁**的东西：

* **意向共享锁（Intention Shared Lock）**：简称 IS 锁。**当事务准备在某条记录上加 S 锁时，需要先在表级别加一个 IS 锁**。
* **意向独占锁（Intention Exclusive Lock）**：简称 IX 锁。**当事务准备在某条记录上加 X 锁时，需要先在表级别加一个 IX 锁**。

**IS、IX 锁是表级锁，它们的提出仅仅为了在之后加表级别的 S 锁和 X 锁时可以快速判断表中的记录是否被上锁**，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实 IS 锁和 IX 锁是兼容的，IX 锁和 IX 锁是兼容的。

各个锁的兼容性如下表所示：

| 兼容性 | X    | IX   | S    | IS   |
| ------ | ---- | ---- | ---- | ---- |
| X      | No   | No   | No   | No   |
| IX     | No   | Yes  | No   | Yes  |
| S      | No   | No   | Yes  | Yes  |
| IS     | No   | Yes  | Yes  | Yes  |

## 3. MySQL 中的行锁和表锁

InnoDB 存储引擎既支持行锁，也支持表锁。

### 3.1 表锁

#### 3.1.1 表级别的 S 锁、X 锁

在对某个表执行 SELECT 、 INSERT 、 DELETE 、 UPDATE 语句时， InnoDB 存储引擎是不会为这个表添加表级别的 S 锁或者 X 锁的。

另外，在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执行诸如 SELECT 、 INSERT 、 DELETE 、 UPDATE 的语句会发生阻塞，同理，某个事务中对某个表执行 SELECT 、 INSERT 、 DELETE 、 UPDATE 语句时，在其他会话中对这个表执行 DDL 语句也会发生阻塞。

这个过程其实是通过在 server 层使用一种称之为**元数据锁 （Metadata Locks，MDL）**实现的，一般情况下也不会使用 InnoDB 存储引擎自己提供的表级别的 S 锁和 X 锁。

其实这个 InnoDB 存储引擎提供的表级 S 锁或者 X 锁是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。不过我们还是可以手动获取的，比方说在系统变量 autocommit=0，innodb_table_locks = 1 时，手动获取 InnoDB 存储引擎提供的表 t 的 S 锁或者 X 锁可以这么写：

* LOCK TABLES t READ：InnoDB 存储引擎会对表 t 加表级别的 S 锁 。
* LOCK TABLES t WRITE：InnoDB 存储引擎会对表 t 加表级别的 X 锁 。

不过**请尽量避免在使用 InnoDB 存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句**，它们并不会提供什么额外的保护，只是会降低并发能力而已。 InnoDB 的厉害之处还是实现了更细粒度的行锁，关于表级别的 S 锁和 X 锁大家了解一下就罢了。

#### 3.1.2 表级别的 IS 锁、IX 锁

当我们在对使用 InnoDB 存储引擎的表的某些记录加 S 锁之前，那就需要先在表级别加一个 IS 锁；当我们在对使用 InnoDB 存储引擎的表的某些记录加 X 锁之前，那就需要先在表级别加一个 IX 锁。 

IS 锁 和 IX 锁的使命只是为了后续在加表级别的 S 锁和 X 锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。更多关于 IS 锁和 IX 锁的解释我们上边都讲解过了，就不赘述了。

#### 3.1.3 表级别的 AUTO-INC 锁

在使用 MySQL 过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值。想必这一点大家都知道。

系统实现这种自动给 AUTO_INCREMENT 修饰的列递增赋值的原理主要是两个：

* **采用 AUTO-INC 锁**，也就是在执行插入语句时就在表级别加一个 AUTO-INC 锁，然后为每条待插入记录的 AUTO_INCREMENT 修饰的列分配递增的值，在该语句执行结束后，再把 AUTO-INC 锁释放掉。

  这样**一个事务在持有 AUTO-INC 锁的过程中，其他事务的插入语句都要被阻塞**，可以保证一个语句中分配的递增值是连续的。

* **采用一个轻量级的锁**，在为插入语句生成 AUTO_INCREMENT 修饰的列的值时获取一下这个轻量级锁，然后**生成本次插入语句需要用到的 AUTO_INCREMENT 列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁**。

  如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比方说有一个表 t，在语句执行前就可以确定要插入 2 条记录，那么一般采用轻量级锁的方式对 AUTO_INCREMENT 修饰的列进行赋值。这种方式可以避免锁定表，可以提升插入性能。

  InnoDB 提供了 `innodb_autoinc_lock_mode` 来控制到底使用哪种方式来实现 AUTO_INCREMENT。

### 3.2 行锁

行锁，也称为记录锁，顾名思义就是在记录上加的锁。不过 **InnoDB 设计了多种类型的行锁，换句话说即使对同一条记录加行锁 ，如果类型不同，起到的功效也是不同的**。

我们还是使用介绍 MVCC 时使用的 hero 表，然后插入几条记录：

```mysql
CREATE TABLE hero (
    number INT,
    name VARCHAR(100),
    country varchar(100),
    PRIMARY KEY (number),
    KEY idx_name (name)
) Engine=InnoDB CHARSET=utf8;

INSERT INTO hero 
VALUES
	(1, 'l刘备', '蜀'),
	(3, 'z诸葛亮', '蜀'),
	(8, 'c曹操', '魏'),
	(15, 'x荀彧', '魏'),
	(20, 's孙权', '吴');
```

在聚簇索引中是这样存储的：

![image-20220725215012695](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725215012695.png)

这里做了一个简化，大家能看懂就好。

#### 3.2.1 Record Lock（记录锁）

官方类型名称叫做 LOCK_REC_NOT_GAP，我们之前一直提到的记录锁就是这种类型。

比方说，我们把 number 值为 8 的那条记录加一个记录锁，示意图如下：

![image-20220725215334210](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725215334210.png)

记录锁是有 S 锁和 X 锁之分的，分别称之为 S 型记录锁和 X 型记录锁。

#### 3.2.2 Gap Locks（间隙锁）

我们说 MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种：可以使用 MVCC 方案解决；也可以采用加锁方案解决。

但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。

为此，InnoDB 提出了一种称之为 Gap Locks 的锁，官方的类型名称为： LOCK_GAP，间隙锁。

比方说我们把 number 值为 8 的那条记录加一个间隙锁的示意图如下：

![image-20220725215903271](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725215903271.png)

如图中为 number 值为 8 的记录加了间隙锁，意味着不允许别的事务在 number 值为 8 的记录前边的间隙插入新记录，其实就是 number 列的值 `(3, 8)` 这个区间的新记录是不允许立即插入的。

比方说有另外一个事务再想插入一条 number 值为 4 的新记录，它定位到该条新记录的下一条记录的 number 值为 8，而这条记录上又有一个间隙锁，所以就会阻塞插入操作，直到拥有这个间隙锁的事务提交了之后， number 列的值在区间 `(3, 8)` 中的新记录才可以被插入。

这个**间隙锁的提出仅仅是为了防止插入幻影记录而提出的**，虽然有共享间隙锁和独占间隙锁这样的说法，但是它们起到的作用都是相同的。而且如果你**对一条记录加了间隙锁 ，并不会限制其他事务对这条记录加记录锁或者继续加间隙锁**。

再强调一遍， 间隙锁的作用仅仅是为了防止插入幻影记录的而已。

不知道大家发现了没有，给某条记录上间隙锁仅仅是锁住当前记录和他之前一条记录的间隙，那么**开头的记录之前的间隙**和**结尾的记录之后的间隙**该怎么锁呢？

还记得数据页有两条特殊的记录吗？

* Infimum 记录，表示该页面中**最小的记录**。
* Supremum 记录，表示该页面中**最大的记录**。

由于这两条是最值了，因此它们之外不会再有间隙了，这样就可以很方便的锁住刚刚所说的间隙了。

比如：

![image-20220725221358559](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725221358559.png)

#### 3.2.3 Next-Key Locks（记录锁 + 间隙锁）

有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以 InnoDB 就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为/：LOCK_ORDINARY。

比方说我们把 number 值为 8 的那条记录加一个 next-key 锁，示意图如下：

![image-20220725221702286](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725221702286.png)

#### 3.2.4 Insert Intention Locks（插入意向锁）

**一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了间隙锁** （注意，next-key 锁也包含间隙锁），如果有的话，插入操作需要等待，直到拥有间隙锁的那个事务提交。

但是 InnoDB 规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB 就把这种类型的锁命名为 Insert Intention Locks（插入意向锁），官方的类型名称为：LOCK_INSERT_INTENTION。

比方说我们把 number 值为 8 的那条记录加一个插入意向锁的示意图如下：

![image-20220725224236859](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725224236859.png)

为了让大家彻底理解这个插入意向锁的功能，我们还是举个例子然后画个图表示一下。

比方说现在 T1 为 number 值为 8 的记录加了一个间隙锁，然后 T2 和 T3 分别想向 hero 表中插入 number 值分别为 4、5 的两条记录，所以现在为 number 值为 8 的记录加的锁的示意图就如下所示：

![image-20220725224533124](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220725224533124.png)

#### 3.2.5 隐式锁

我们前边说一个事务在执行 INSERT 操作时，如果即将插入的间隙已经被其他事务加了间隙锁，那么本次 INSERT 操作会阻塞，并且当前事务会在该间隙上加一个插入意向锁，否则**一般情况下 INSERT 操作是不加锁的**。

那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务：

* 立即使用 SELECT ... LOCK IN SHARE MODE 语句读取这条事务，也就是在要获取这条记录的 S 锁 ，或者使用 SELECT ... FOR UPDATE 语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的 X 锁 ，该咋办？

  如果允许这种情况，那么可能产生脏读问题。

* 立即修改这条记录，也就是要获取这条记录的 X 锁，该咋办？

  如果允许这种情况的发生，那么可能产生脏写问题。

这时候我们前边提到的 事务 id 又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：

* 情景一：对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的事务 id。

  那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是当前事务的事务 id，如果其他事务此时想对该记录添加 S 锁或者 X 锁时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X锁 （也就是为当前事务创建一个锁结构，is_waiting 属性是 false），然后自己进入等待状态（也就是为自己也创建一个锁结构， is_waiting 属性是 true）。

* 情景二：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的事务 id ，如果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃事务 id ，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复情景一的做法。

经过上面的讨论我们可以看到，**由于事务 ID 的存在，相当于加了一个隐式锁**。**别的事务在对这条记录加 S 锁或者 X 锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态**。
