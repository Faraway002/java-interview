[TOC]

# MySQL 日志

## 1. redo log（重做日志）

### 1.1 redo log 介绍

InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。

我们讲 Buffer Pool 的时候说过，在真正访问页面之前，需要把**在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问**；但是在介绍**事务**的时候又强调过一个称之为**持久性的特性**，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。

但是如果我们只在内存的 Buffer Pool 中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的。

那么如何保证这个持久性呢？一个很简单的做法就是**在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题**：

* **刷新一个完整的数据页太浪费了**：有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在 InnoDB 中是以页为单位来进行磁盘 I/O 的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是 16KB 大小，只修改一个字节就要刷新 16KB 的数据到磁盘上显然是太浪费了。
* **随机 I/O 刷起来比较慢**：一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，更倒霉的是**该事务修改的这些页面可能并不相邻**，这就意味着在将某个事务修改的 Buffer Pool 中的页面刷新到磁盘时，需要进行很多的随机 I/O，随机 I/O 比顺序 I/O 要慢，尤其对于传统的机械硬盘来说。

那么我们到底怎么办呢？再次回到我们的初心：**我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来**。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，**只需要把修改了哪些东西记录一下就好**。

比方说某个事务将系统表空间中的第 100 号页面中偏移量为 1000 处的那个字节的值 1 改成 2 我们只需要记录一下：

```text
将第 0 号表空间的 100 号页面的偏移量为 1000 处的值更新为 2
```

这样我们**在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足了持久性的要求**。

因为这是在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为**重做日志（redo log）**。

![image-20220513104333243](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220513104333243.png)

redo log 有什么好处呢？

* **redo log 占用的空间非常小**：存储表空间 ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于 redo 日志的格式我们稍后会详细介绍，现在只要知道一条 redo 日志占用的空间不是很大就好了。
* **redo log 是顺序写入磁盘的**：在执行事务的过程中，每执行一条语句，就可能产生若干条 redo 日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序 I/O。 

### 1.2 redo log 格式

redo log 本质上只是记录了一下事务对数据库做了哪些修改，InnoDB 针对事务对数据库的不同修改场景定义了多种类型的 redo log，但是绝大部分类型的 redo log 都有下面这种通用的结构：

![image-20220718201406184](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718201406184.png)

* **type**：该条 redo log 的类型。
* **space ID**：表空间 ID。
* **page number**：页号。
* **data**：redo log 的具体内容。

#### 1.2.1 简单的 redo log 类型

我们举个 MySQL 中实际的例子吧：

我们前边介绍 InnoDB 的记录行格式的时候说过，如果我们没有为某个表显式的定义主键，并且表中也没有定义 Unique 键，那么 InnoDB 会自动的为表添加一个称之为 row_id 的隐藏列作为主键。为这个 row_id 隐藏列赋值的方式如下：

* 服务器会在内存中维护一个全局变量，每当向某个包含隐藏的 row_id 列的表中插入一条记录时，就会把该变量的值当作新记录的 row_id 列的值，并且把该变量自增 1。
* 每当这个变量的值为 256 的倍数时，就会将该变量的值刷新到系统表空间的页号为 7 的页面中一个称之为 Max Row ID 的属性处（我们前边介绍表空间结构时详细说过）。
* 当系统启动时，会将上边提到的 Max Row ID 属性加载到内存中，将该值加上 256 之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于 Max Row ID 属性值）。

这个 Max Row ID 属性占用的存储空间是 8 个字节，当某个事务向某个包含 row_id 隐藏列的表插入一条记录，并且为该记录分配的 row_id 值为 256 的倍数时，就会向系统表空间页号为 7 的页面的相应偏移量处写入 8 个字节的值。

但是我们要知道，这个写入实际上是在 Buffer Pool 中完成的，我们需要为这个页面的修改记录一条 redo log，以便在系统奔溃后能将已经提交的该事务对该页面所做的修改恢复出来。这种情况下对页面的修改是极其简单的，**redo log 中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是什么就好了，InnoDB 把这种极其简单的 redo log 称之为物理日志** ，并且**根据在页面中写入数据的多少划分了几种不同的 redo 日志类型**：

* MLOG_1BYTE（type 字段的值为 1）：表示在页面的某个偏移量处写入 1 个字节的 redo log 类型。
* MLOG_2BYTE（type 字段的值为 2）：表示在页面的某个偏移量处写入 2 个字节的 redo log 类型。
* MLOG_4BYTE（type 字段的值为 4）：表示在页面的某个偏移量处写入 4 个字节的 redo log 类型。
* MLOG_8BYTE（type 字段的值为 8）：表示在页面的某个偏移量处写入 8 个字节的 redo log 类型。
* MLOG_WRITE_STRING（type 字段的值为 30）：表示在页面的某个偏移量处写入一串数据。

我们刚刚提到的 Max Row ID 为 8 个字节，说明它会使用一个 MLOG_8BYTE 的 redo log 类型。其实，MLOG_1/2/4/8BYTE 的结构都差不多，示意图如下：

![image-20220718213802750](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718213802750.png)

唯一不同的只有 MLOG_WRITE_STRING，它多了一个字符串的长度：

![image-20220718213746801](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718213746801.png)

> **为什么要 redo log 要分这么细，而不是直接用一个 MLOG_WRITE_STRING 把这些情况全部包含进去？**
>
> 答案当然是为了**省空间**，能不写 len 字段就不写，把空间压缩到极致。

#### 1.2.2 复杂的 redo log 类型

有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的 B+ 树）。

以一条 INSERT 语句为例，我们通常需要知道的是：

* 表中包含多少个索引，一条 INSERT 语句就可能更新多少棵 B+ 树。
* 针对某一棵 B+ 树来说，既可能更新叶子节点页面，也可能更新非叶子节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在非叶子节点页面中添加目录项记录 ）。

在语句执行过程中， INSERT 语句对所有页面的修改都得保存到 redo log 中去。这句话说起来轻巧，做起来可就比较麻烦了，比方说将记录插入到聚簇索引中时，如果定位到的叶子节点的剩余空间足够存储该记录时，那么只更新该叶子节点页面就好，那么只记录一条 MLOG_WRITE_STRING 类型的 redo log，表明在页面的某个偏移量处增加了哪些数据就完成了吗？那就太肤浅了，别忘了，一个数据页中除了存储实际的记录之后，还有 File Header、Page Header、Page Directory 等等存储元数据的部分需要连锁更新，所以**每往叶子节点代表的数据页里插入一条记录时，还有其他很多地方会跟着更新**。

如果你非要使用物理日志，这时候有两种解决方案：

* 方案一：对每一个修改的地方都记录一个 redo log。这其实不可行，因为被修改的地方实在太多了，可能最后你记录出来的 redo log 的大小都超过了你修改的整个页面的大小。

* 方案二：既然方案一产生的 log 可能太大，我们不如直接**把第一个被修改的字节到最后一个修改的字节之间所有的数据当成是一条物理 redo log 中的具体数据**。

  但是这也很浪费，因为这个区间内实际上还是有很多没有修改过的地方的。

所以，两种方案都不能解决的情况下，只能创造新的 redo log 类型：

* MLOG_REC_INSERT（type 字段的值为 9）：表示插入一条使用**非紧凑行格式**的记录时的 redo log 类型。
* MLOG_COMP_REC_INSERT（type 字段的值为 38）：表示插入一条使用**紧凑行格式**的记录时的 redo log 类型。
* MLOG_COMP_PAGE_CREATE（type 字段的值为 58）：表示创建一个存储**紧凑行格式**记录的页面的 redo log 类型。
* MLOG_COMP_REC_DELETE（type 字段的值为 42）：表示删除一条使用**紧凑行格式**记录的 redo log 类型。
* MLOG_COMP_LIST_START_DELETE（type 字段对应的十进制数字为 44）：表示从某条给定记录开始删除页面中的一系列使用**紧凑行格式**记录的 redo log 类型。
* MLOG_COMP_LIST_END_DELETE（type 字段对应的十进制数字为 43）：与 MLOG_COMP_LIST_START_DELETE 类型的 redo log 呼应，表示删除一系列记录直到 MLOG_COMP_LIST_END_DELETE 类型的 redo log 对应的记录为止。

> 我们之前介绍过四种行格式，其中，Redundant 是一种比较原始的行格式，它就是非紧凑的。而 Compact、Dynamic 以及 Compressed 行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。

除此之外，还有很多，这里就不说了。

这些类型的 redo 日志既包含物理层面的意思，也包含逻辑层面的意思，具体指：

* 物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。
* 逻辑层面看，在系统奔溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子。

因为 compact 行格式是最常用的行格式，所以我们有必要介绍一下它的具体结构，我们以插入为例，看看它的具体格式：

![image-20220718215547621](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718215547621.png)

### 1.3 Mini-Transaction

#### 1.3.1 以组的形式写入 redo log

语句在执行过程中可能修改若干个页面。比如我们前边说的一条 INSERT 语句可能修改系统表空间页号为 7 的页面的 Max Row ID 属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会更新聚簇索引和二级索引对应 B+ 树中的页面。由于对这些页面的更改都发生在 Buffer Pool 中，所以在修改完页面之后，需要记录一下相应的 redo log。

**在执行语句的过程中产生的 redo log 被 InnoDB 划分成了若干个不可分割的组**，比如：

* 更新 Max Row ID 属性时产生的 redo 日志是不可分割的。
* 向聚簇索引对应 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。
* 向某个二级索引对应 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。
* 还有其他的一些对页面的访问操作时产生的 redo 日志是不可分割的。

如何理解这个不可分割？举个例子，我们以向某个索引对应的 B+ 树插入一条记录为例，在向 B+ 树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：

* 情况一：该**数据页的剩余的空闲空间充足**，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，**记录一条类型为 MLOG_COMP_REC_INSERT 的 redo log 就好了，我们把这种情况称之为乐观插入**。

* 情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行**页分裂**，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在非叶子节点中添加一条目录项记录指向这个新创建的页面。

  很显然，这个过程要对多个页面进行修改，也就意味着会**产生多条 redo log**，我们把这种情况称之为**悲观插入**。

InnoDB 认为向某个索引的 B+ 树中插入一条记录的过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向非叶子节点中插入一条目录项记录 ，这个插入过程就是不完整的，这样会形成一棵不正确的 B+ 树。

而 redo log 就是为了保证能够在系统崩溃后恢复到崩溃前的状态而诞生的，**那么如果在悲观插入的过程中只记录了一部分 redo log，那么在系统奔溃重启时会将索引对应的 B+ 树恢复成一种不正确的状态**。

所以，InnoDB 规定在执行这些原子性操作时必须以**组**的形式来记录 redo log，在进行系统奔溃重启恢复时，**针对某个组中的 redo log，要么把全部的日志都恢复掉，要么一条也不恢复**。

那么 MySQL 是如何做到的呢？其实只需要一些小手段，但是需要分类讨论：

1. 有的需要保证原子性的操作会生成**多条 redo log**，比如向某个索引对应的 B+ 树中进行一次悲观插入就需要生成许多条 redo 日志。这时，我们**在该组的最后一条 redo log 之后再添加一条特殊类型的 redo log**，该类型名称为 MLOG_MULTI_REC_END，type 的值为 31，结构很简单，仅有 type 一个字段。

   所以这一个组看起来像这样：

   ![image-20220718221746758](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718221746758.png)

   这样在系统奔溃重启进行恢复时，**只有当解析到类型为 MLOG_MULTI_REC_END 的 redo 日志，才认为解析到了一组完整的 redo 日志，才会进行恢复；否则的话直接放弃前边解析到的 redo 日志**。

2. 有的需要保证原子性的操作**只生成一条 redo log**，这时如果使用上面的方法加一个特殊的 redo log 也可以，但是有点浪费，而我们知道，InnoDB 是出了名的抠门，这时怎么办呢？

   redo log 的类型虽然多，但是也就几十种，是小于 127 这个数字的，也就是说我们用 7 个比特位就足以包括所有的 redo log 类型，而 type 字段其实是占用 1 个字节，也就是 8 个比特的，也就是说我们可以省出来 1 个比特位用来表示该需要保证原子性的操作只产生单一的一条 redo log。

   ![image-20220718222033406](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718222033406.png)

#### 1.3.2 Mini-Transaction 的概念

我们刚刚介绍的按组写入 redo log 是不是很像一个事务？也是要么全部成功，要么全部失败，因此 **MySQL 把对底层页面中的一次原子访问的过程称之为一个 Mini-Transaction（迷你事务），简称 mtr**。

一个事务可以包含若干条语句，每一条语句其实是由若干个 mtr 组成，每一个 mtr 又可以包含若干条 redo log，画个图表示它们的关系就是这样：

![image-20220718222232533](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718222232533.png)

### 1.5  redo log 的写入过程

#### 1.5.1 redo log block

**InnoDB 为了更好的进行系统崩溃恢复，它把 mtr 生成的 redo log 都放在了大小为 512 字节的页中，称之为 redo log block**。

示意图如下：

![image-20220718222444215](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718222444215.png)

真正的 redo 日志都是存储到占用 496 字节大小的 log block body 中的，图中的 log block header 和 log block trailer 存储的是一些管理信息。

管理信息结构如下：

![image-20220718222513508](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718222513508.png)

* LOG_BLOCK_HDR_NO：每一个 block 都有一个大于 0 的唯一标号，这个字段就表示该标号值。

* LOG_BLOCK_HDR_DATA_LEN：表示 block 中已经使用了多少字节，初始值为 12 （因为 log block body 从第 12 个字节处开始），随着往 block 中写入的 redo log 越来也多，本属性值也跟着增长。

  如果 log block body 已经被全部写满，那么本属性的值被设置为 512。

* LOG_BLOCK_FIRST_REC_GROUP：一条 redo log 也可以称之为一条 redo log record，一个 mtr 会生产多条redo log record，这些 redo log record 被称之为一个 redo log record group。

  LOG_BLOCK_FIRST_REC_GROUP 就代表该 block 中第一个 mtr 生成的 redo log record group 的偏移量。

* LOG_BLOCK_CHECKPOINT_NO ：表示所谓的 checkpoint 的序号， checkpoint 是我们后续内容的重点，现在先不用清楚它的意思。

* LOG_BLOCK_CHECKSUM：表示 block 的校验值，用于正确性校验。

#### 1.5.2 log buffer

就像读写数据页一样，写 redo log 也需要缓冲区，称之为 redo log buffer，简称为 log buffer。

和 Buffer Pool 结构类似，这片内存空间被划分成若干个连续的 redo log block ，就像这样：

![image-20220718224222624](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718224222624.png)

我们可以通过启动参数 `innodb_log_buffer_size` 来指定 log buffer 的大小，默认为 16MB。

#### 1.5.3 redo log 写入 log buffer

**向 log buffer 中写入 redo log 的过程是顺序的，也就是先往前边的 block 中写，当该 block 的空闲空间用完之后再往下一个 block 中写**。

当我们想往 log buffer 中写入 redo log 时，第一个遇到的问题就是应该写在哪个 block 的哪个偏移量处，所以 InnoDB 特意提供了一个称之为 buf_free 的全局变量，该变量指明后续写入的 redo log 应该写入到 log buffer 中的哪个位置，如图所示：

![image-20220718224512974](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718224512974.png)

我们前边说过一个 mtr 执行过程中可能产生若干条 redo log，这些 redo log 是一个不可分割的组，所以其实**并不是每生成一条 redo log，就将其插入到 log buffer 中，而是每个 mtr 运行过程中产生的日志先暂时存到一个地方，当该 mtr 结束的时候，将过程中产生的一组 redo log 再全部复制到 log buffer 中**。

### 1.6 redo log 文件

#### 1.6.1 redo log 刷盘时机

redo log 有一些固定的刷盘时机：

* **log buffer 空间不足时**：log buffer 的大小是有限的，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。

  InnoDB 规定如果达到了 log buffer 的一半左右，那么就需要把日志写到磁盘上。

* **事务提交时**：我们之前说过之所以使用 redo log 主要是因为它占用的空间少，而且还是顺序写，因此在事务提交时可以不把修改过的 Buffer Pool 页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的 redo log 刷新到磁盘。

* **后台线程**：和 Buffer Pool 类似，InnoDB 设置了一个后台线程，大约每秒会刷新一次 redo log 到磁盘。

* **正常关闭服务器时**。

* **做 checkpoint 时**（checkpoint 还没讲到，稍后会讲）

* ...

#### 1.6.2 redo log 文件组

**MySQL 的数据目录下默认有两个名为 ib_logfile0 和 ib_logfile1 的文件， log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中**。

如果我们对默认的 redo log 文件不满意，可以通过下边几个启动参数来调节：

* `innodb_log_group_home_dir`：该参数指定了 **redo log 文件所在的目录**，默认值就是当前的数据目录。
* `innodb_log_file_size`：该参数指定了**每个 redo log 文件的大小**，默认值为 48MB。
* `innodb_log_files_in_group`：该参数指定 **redo log 文件的个数**，默认值为 2，最大值为 100。

从上边的描述中可以看到，**磁盘上的 redo log 文件不只一个，而是以一个日志文件组的形式出现的**。这些文件以 ib_logfile[数字] （0 、 1 、 2 ...）的形式进行命名。

在将 redo log 写入日志文件组时，先从 ib_logfile0 开始写；如果 ib_logfile0 写满了，就接着 ib_logfile1 写；同理， ib_logfile1 写满了就去写 ib_logfile2 ，依此类推。

如果最后一个 redo log 也写满了怎么办呢？那就重新转到 ib_logfile0 继续写，所以整个过程如下图所示：

![image-20220718230442736](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718230442736.png)

> 既然是这样循环写入的话，那么岂不是要覆盖掉之前的日志？是的，所以 InnoDB 提出了 checkpoint 的概念，稍后我们详细讲解。

#### 1.6.3 redo log 文件格式

log buffer 本质上是一片连续的内存空间，被划分成了若干个 512 字节大小的 block。那么，将 log buffer中的 redo log 刷新到磁盘的本质就是把 block 的镜像写入日志文件中，所以 redo log 文件其实也是由若干个 512 字节大小的 block 组成。

redo 日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：

* 前 2048 个字节，也就是前 4 个 block 是用来存储一些管理信息的。
* 从第 2048 字节往后是用来存储 log buffer 中的 block 镜像的。

所以，我们前面所说的循环写入，实际上是从每个日志文件的第 2048 个字节开始算起：

![image-20220718230843699](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718230843699.png)

block 的格式大家应该很熟悉了，现在我们来介绍一下日志文件的前 4 个 block：

![image-20220718231036164](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718231036164.png)

* **log file header**：描述该 redo log 文件的一些整体属性。

  它的组成如下：

  ![image-20220718231156637](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718231156637.png)

  | 属性名               | 长度（单位：字节） | 描述                                                         |
  | -------------------- | ------------------ | ------------------------------------------------------------ |
  | LOG_HEADER_FORMAT    | 4                  | redo log 的版本                                              |
  | LOG_HEADER_PAD1      | 4                  | 字节填充用的，没什么实际意义                                 |
  | LOG_HEADER_START_LSN | 8                  | 标记该 redo log 文件开始的 LSN 值                            |
  | LOG_HEADER_CREATOR   | 32                 | 一个字符串，标记该 redo log文件的创建者是谁<BR>正常运行时该值为 MySQL 的版本号，比如： "MySQL 5.7.21" <BR>使用 mysqlbackup 命令创建的 redo log 文件的该值为 "ibbackup" 和创建时间 |
  | LOG_BLOCK_CHECKSUM   | 4                  | 该 block 的校验值                                            |

* **checkpoint1**：记录关于 checkpoint 的一些属性，看一下它的结构：

  ![image-20220718231548331](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718231548331.png)

  | 属性名                      | 长度（单位：字节） | 描述                                                         |
  | --------------------------- | ------------------ | ------------------------------------------------------------ |
  | LOG_CHECKPOINT_NO           | 8                  | 服务器做 checkpoint 的编号，每做一次 checkpoint，该值就加 1  |
  | LOG_CHECKPOINT_LSN          | 8                  | 服务器做 checkpoint 结束时对应的 LSN 值，系统奔溃恢复时将从该值开始 |
  | LOG_CHECKPOINT_OFFSET       | 8                  | 上个属性中的 LSN 值在 redo 日志文件组中的偏移量              |
  | LOG_CHECKPOINT_LOG_BUF_SIZE | 8                  | 服务器在做 checkpoint 操作时对应的 log buffer 的大小         |
  | LOG_BLOCK_CHECKSUM          | 4                  | 该 block 的校验值                                            |

  现在看不懂不要紧，我们之后会详细介绍。

* 没用到的 block，忽略掉。

* **checkpoint2**：和 checkpoint1 一样。

### 1.7 Log Sequence Number（LSN）

自 MySQL 开始运行，就不断的在修改页面，也就意味着会不断的生成 redo log。

redo log 的量在不断的递增，就像人的年龄一样，自打出生起就不断递增，永远不可能缩减了。设计 InnoDB 的大叔为记录已经写入的 redo log，设计了一个称之为 Log Sequence Number（日志序列号，LSN）的全局变量。

不过不像人一出生的年龄是 0 岁，InnoDB 规定初始的 LSN 值为 8704。

我们知道在向 log buffer 中写入 redo log 时不是一条一条写入的，而是以一个 mtr 生成的一组 redo log 为单位进行写入的。而且实际上是把日志内容写在了 log block body 处。但是**在统计 LSN 的增长量时，是按照实际写入的日志量加上占用的 log block header 和 log block trailer 来计算的**。

**每一组由 mtr 生成的 redo log 都有一个唯一的 LSN 值与其对应，LSN 值越小，说明 redo log 产生的越早**。

#### 1.7.1 `flushed_to_disk_lsn`

redo log 是首先写到 log buffer 中，之后才会被刷新到磁盘上的 redo log 文件。所以 **InnoDB 提出了一个称之为 `buf_next_to_write` 的全局变量，标记当前 log buffer 中已经有哪些日志被刷新到磁盘中了**。

画个图表示就是这样：

![image-20220719081744881](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719081744881.png)

我们前边说 LSN 是表示当前系统中写入的 redo 日志量，这包括了写到 log buffer 而没有刷新到磁盘的日志，相应的，InnoDB 提出了一个表示刷新到磁盘中的 redo log 量的全局变量，称之为 `flushed_to_disk_lsn`。系统第一次启动时，该变量的值和初始的 LSN 值是相同的，都是 8704 。随着系统的运行， redo 日志被不断写入 log buffer，但是并不会立即刷新到磁盘，此时 LSN 的值就和 flushed_to_disk_lsn 的值拉开了差距。

#### 1.7.2 LSN 和 redo log 文件偏移量的对应关系

因为 LSN 的值是代表系统写入的 redo log 量的一个总和，一个 mtr 中产生多少日志，LSN 的值就增加多少（当然要加上 log block header 和 log block trailer 的大小），这样 mtr 产生的日志写到磁盘中时，很容易计算某一个 LSN 值在 redo 日志文件组中的偏移量，如图：

![image-20220719082216309](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719082216309.png)

#### 1.7.3 flush 链表中的 LSN

**在 mtr 结束时，除了要把一组 redo log 写入到 log buffer 之外，还需要把修改过的页面加入到 Buffer Pool 的 flush 链表中**。

回顾一下 flush 链表：当第一次修改某个缓存在 Buffer Pool 中的页面时，就会把这个页面对应的控制块插入到 flush 链表的头部，之后再修改该页面时由于它已经在 flush 链表中了，就不再次插入了。

也就是说 flush 链表中的脏页是按照页面的第一次修改时间从大到小进行排序的。在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：

* oldest_modification：如果某个页面被加载到 Buffer Pool 后进行第一次修改，那么就将修改该页面的 mtr 开始时对应的 LSN 值写入这个属性。
* newest_modification：每修改一次页面，都会将修改该页面的 mtr 结束时对应的 LSN 值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统 LSN 值。

### 1.8 checkpoint

刚刚我们也提到了，redo 日志文件组的容量是有限的，我们不得不循环使用 redo log 文件，但是这会造成成最后写的 redo log 把最开始写的 redo log 覆盖的情况。

这时候就要看情况再决定是否覆盖了：

* 如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统奔溃，那么在重启后也不需要使用 redo log 恢复该页面了，所以该 redo log 也就没有存在的必要了。
* 反过来，如果还没有刷新到磁盘，此时一旦你覆盖掉了，那么就意味着这些被覆盖的 redo log 对应的脏页很可能就丢失了，数据的一致性就得不到保证了。

以下面这个例子为例：

![image-20220719085053840](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719085053840.png)

如图，这里有三个 mtr，并且 mtr_1 和 mtr_2 的 redo log 已经被写回到文件中了，但是从 flush 链表的情况可以看出，修改后的脏页还在 flush 链表中，因此此时如果 redo log 满了，作为开头的 mtr_1 和 mtr_2 的 redo log 是不能被覆盖的。

现在，我们假设页面 a 被刷新到了磁盘中，如下图所示：

![image-20220719085308933](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719085308933.png)

这样 mtr_1 生成的 redo 日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。

InnoDB 为了方便知道哪些日志可以覆盖，提出了 `checkpoint_lsn` 这样一个全局变量，来代表当前系统中可以被覆盖的 redo log 总量是多少。

上面的例子中，mtr_1 的页 a 被刷到磁盘中之后，`checkpoint_lsn` 的值就可以增加到 mtr_1 结束时的 LSN 了，我们把这个过程称之为**做一次 checkpoint**。

做一次 checkpoint 其实分两个步骤：

1. **计算一下当前系统中可以被覆盖的 redo log 对应的 LSN 值最大是多少**。

   只要我们计算出当前系统中被最早修改的脏页对应的 oldest_modification 值，那凡是在系统 LSN 值小于该节点的 oldest_modification 值时产生的 redo log 都是可以被覆盖掉的，我们就把该脏页的 oldest_modification 赋值给 `checkpoint_lsn`。

   在上面的例子中，当前系统中页 a 已经被刷新到磁盘，那么 flush 链表的尾节点就是页 c ，该节点就是当前系统中最早修改的脏页了，它的 oldest_modification 值为 8916，我们就把 8916 赋值给 `checkpoint_lsn`，也就是说在 redo log 对应的 LSN 值小于 8916 时就可以被覆盖掉。

2. 将` checkpoint_lsn` 和对应的 redo 日志文件组偏移量以及此次 checkpint 的编号**写到日志文件的管理信息（就是 checkpoint1 或者 checkpoint2 ）中**。

   InnoDB 维护了一个目前系统做了多少次 checkpoint 的变量 checkpoint_no，每做一次 checkpoint ，该变量的值就加 1。

   我们前边说过计算一个 lsn 值对应的 redo 日志文件组偏移量是很容易的，所以可以计算得到该 checkpoint_lsn 在 redo 日志文件组中对应的偏移 checkpoint_offset ，然后把这三个值都写到 redo 日志文件组的管理信息中。

   我们说过，每一个 redo log 文件都有 2048 个字节的管理信息，但是**上述关于 checkpoint 的信息只会被写到日志文件组的第一个日志文件的管理信息中**。

   不过，我们有两个 checkpoint block，我们到底是存储到 checkpoint1 中还是 checkpoint2 中呢？InnoDB 规定，**当 checkpoint_no 的值是偶数时，就写到 checkpoint1 中，是奇数时，就写到 checkpoint2 中**。

#### 1.8.1 批量从 flush 链表写回脏页

我们在介绍 Buffer Pool 的时候说过，一般情况下都是后台的线程在对 LRU 链表和 flush 链表进行刷新脏页的操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。

但是如果当前系统修改页面的操作十分频繁，这样就导致写日志操作十分频繁，系统 LSN 值增长过快。如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做 checkpoint ，可能就需要用户线程同步的从 flush 链表中把那些最早修改的脏页（oldest_modification 最小的脏页）刷新到磁盘，这样这些脏页对应的 redo log 就没用了，然后就可以去做 checkpoint 了。

### 1.9 `innodb_flush_log_at_trx_commit`

我们前边说为了保证事务的持久性 ，**用户线程在事务提交时需要将该事务执行过程中产生的所有 redo log 都刷新到磁盘上**。

这一条要求其实比较影响性能，因为一个事务所做的修改涉及到的页面可能很多，redo log 也会很多，这样会很明显的降低数据库性能。

如果有的同学对事务的持久性要求不是那么强烈的话，可以选择**修改一个称为 `innodb_flush_log_at_trx_commit` 的系统变量的值，它决定了事务提交时时 redo log 的刷新策略**，该变量有 3 个可选的值：

* 0：当该系统变量值为 0 时，表示**在事务提交时不立即向磁盘中同步 redo log，这个任务完全交给后台线程**。

  这样虽然会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将 redo log 刷新到磁盘，那么该事务对页面的修改会丢失。

* 1：当该系统变量值为 1 时，表示**在事务提交时需要将 redo log 立即同步到磁盘，可以保证事务的持久性**。（默认值）

* 2：当该系统变量值为 2 时，表示**在事务提交时需要将 redo log 写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘**。

  这种情况下如果数据库挂了，操作系统没挂的话，事务的持久性还是可以保证的，但是**操作系统也挂了的话，那就不能保证持久性了**。

### 1.10 崩溃恢复

说了这么多遍 redo log 可以用来崩溃恢复，那么它到底是怎么恢复的呢？

崩溃恢复主要有三个步骤：

1. **确定恢复的起点**：我们之前说过，checkpoint_lsn 之前的 redo log 都可以被覆盖，我们就没必要恢复它们了；而对于 checkpoint_lsn 之后的 redo log，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要**从 checkpoint_lsn 开始读取 redo log 来恢复页面**。

   由于存在 checkpoint1 和 checkpoint2，我们当然是要从中选取最近发生的那次 checkpoint 的信息。

2. **确定恢复的终点**：redo log 恢复的起点确定了，那终点是哪个呢？这个还得从 block 的结构说起。我们说在写 redo log 的时候都是顺序写的，写满了一个 block 之后会再往下一个 block 中写。

   而 block 的 log block header 部分有一个称之为 LOG_BLOCK_HDR_DATA_LEN 的属性，该属性值记录了当前 block 里使用了多少字节的空间：

   * 对于被填满的block来说，该值永远为 512 。
   * 如果该属性的值不为 512 ，那么意味着该 block 没有填满，因此它就是此次奔溃恢复中需要扫描的最后一个 block。

3. **执行恢复**：我们看一个例子：

   ![image-20220719091937120](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719091937120.png)

   由于 redo 0 在 checkpoint_lsn 后边，恢复时可以不管它。我们现在可以按照 redo log 的顺序依次扫描 checkpoint_lsn 之后的各条 redo log，按照日志中记载的内容将对应的页面恢复出来。

   InnoDB 觉得这样比较慢，因此还是想了一些办法加快这个恢复的过程：

   * **使用哈希表**：根据 redo log 的 space ID 和 page number 属性计算出散列值，把 space ID 和 page number 相同的 redo log 放到哈希表的同一个槽里，如果有多个 space ID 和 page number 都相同的 redo log，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，如图所示：

     ![image-20220719092100266](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719092100266.png)

     之后就可以遍历哈希表，因为**对同一个页面进行修改的 redo log 都放在了一个槽里，所以可以一次性将一个页面修复好**，避免了很多读取页面的随机 I/O。

     但是需要注意的是：同一个页面的 redo log 是按照生成时间顺序进行排序的，所以恢复的时候也是按照这个顺序进行恢复。

   * **跳过已经刷新到磁盘的页面**：对于 checkpoint_lsn 之后的 redo log，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，因此实际上之后有一些页被刷盘了的话我们是可以跳过这些页的。

     那么怎么判断呢？这就要回到页面的结构了，页面的 File Header 部分有一个 FIL_PAGE_LSN 的属性，它记录了最近一次修改页面时对应的  LSN 值，**如果在做了某次 checkpoint 之后有脏页被刷新到磁盘中，那么该页对应的 FIL_PAGE_LSN 代表的 LSN 值肯定大于 checkpoint_lsn 的值**。

## 2. undo log

### 2.1 事务回滚的需求

我们说过事务需要保证原子性 ，也就是事务中的操作要么全部完成，要么什么也不做。

但是偏偏有时候事务执行到一半会出现一些情况，比如：

* 情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。

* 情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前的事务的执行。

这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为回滚（rollback），这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。

和保证持久性类似，**为了保证能够回滚，我们也需要把回滚时所需的东西记录下来**，比如：

* 你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。
* 你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。
* 你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
* ...

**InnoDB 把这些为了回滚而记录的这些东西称之为撤销日志（undo log）**。特别需要注意的是，由于查询操作（ SELECT ）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的 undo log。

### 2.2 事务 ID

#### 2.2.1 给事务分配 ID 的时机

如果某个事务执行过程中对某个表执行了增、删、改操作，那么 InnoDB 存储引擎就会给它分配一个独一无二的事务 ID，分配方式如下：

* 对于只读事务来说，只有在它第一次对某个**用户创建的临时表**执行增、删、改操作时才会为这个事务分配一个事务 ID，否则的话是不分配事务 ID 的。
* 对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务 ID，否则的话也是不分配事务 ID 的。

有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个事务 ID。

#### 2.2.2 事务 ID 的生成机制

事务 ID 本质上就是一个数字，它的分配策略和我们前边提到的对隐藏列 row_id （当用户没有为表创建主键和 UNIQUE 键时 InnoDB 自动创建的列）的分配策略大抵相同，具体策略如下：服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务 ID 时，就会把该变量的值当作事务 ID 分配给该事务，并且把该变量自增 1。

每当这个变量的值为 256 的倍数时，就会将该变量的值刷新到系统表空间的页号为 5 的页面中一个称之为 Max Trx ID 的属性处，这个属性占用 8 个字节的存储空间。

当系统下一次重新启动时，会将上边提到的 Max Trx ID 属性加载到内存中，将该值加上 256 之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于 Max Trx ID 属性值）。这样就可以保证整个系统中分配的事务 ID 值是一个递增的数字。先被分配 ID 的事务得到的是较小的事务 ID，后被分配 ID 的事务得到的是较大的事务 ID。

#### 2.2.3 trx_id 隐藏列

我们前边说 InnoDB 记录行格式的时候重点强调过：聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为 trx_id、roll_pointer 的隐藏列，如果用户没有在表中定义主键以及 UNIQUE 键，还会自动添加一个名为 row_id 的隐藏列。

所以一条记录在页面中的真实结构看起来就是这样的：

![image-20220719224949348](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719224949348.png)

其中的 **trx_id 列其实就是某个对这个聚簇索引记录做改动的语句所在的事务对应的事务 ID**（此处的改动可以是 INSERT、DELETE、UPDATE 操作）。

### 2.3 undo log 的格式

为了实现事务的原子性，InnoDB 存储引擎在实际进行增、删、改一条记录时，都需要先把对应的 undo log 记下来。**一般来说，每对一条记录做一次改动，就对应着一条 undo log，但在某些更新记录的操作中，也可能会对应着 2 条 undo log**，这个我们之后再说。

一个事务在执行过程中可能新增、删除、更新若干条记录，也就是说需要记录很多条对应的 undo log，这些 **undo log 会被从 0 开始编号**，也就是说根据生成的顺序分别被称为第 0 号 undo log、第 1 号 undo log、...、第 n 号 undo log 等，这个编号也被**称之为 undo no**。

这些 **undo log 是被记录到页面类型为 FIL_PAGE_UNDO_LOG (对应的十六进制数为 0x0002）的页面中的，这些页面可以从系统表空间中分配，也可以从一种专门存放 undo log 的表空间，也就是所谓的 undo tablespace 中分配**。不过关于如何分配存储 undo log 的页面这个事情我们稍后再说，现在先来看看不同操作都会产生什么样子的 undo log。

为了方便说明，我们先来创建一个名为 undo_demo 的表：

```mysql
CREATE TABLE undo_demo (
  	id INT NOT NULL,
  	key1 VARCHAR(100),
  	col VARCHAR(100),
  	PRIMARY KEY (id),
  	KEY idx_key1 (key1)
)Engine=InnoDB CHARSET=utf8;
```

还记得我们之前说过的吗，每个表都会有一个唯一的 table id，可以在系统数据库 `information_schema` 中的 innodb_sys_table 表（8.0 版本后已改名为 `innodb_tables`）中查询到，我们这就来查一下：

![image-20220723151552883](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723151552883.png)

可以看到，我们这个表的 table id 为 1186，请记住这个数，后面还会用到它。

#### 2.3.1 `INSERT` 的 undo log

插入一条记录分为乐观插入和悲观插入，这点我们在讲 redo log 的时候就讲过了。但是**无论是何种插入，想要回滚这个操作，那么把这个记录删除就好了**。

InnoDB 为此设计了类型为 TRX_UNDO_INSERT_REC 的 undo log，格式如下：

![image-20220723152212100](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723152212100.png)

有以下几点需要注意：

1. undo no 从 0 开始，也就是说只要事务没提交，每生成一条 undo log，那么该条 日志的 undo no 就增 1。

2. 如果记录中的主键只包含一个列，那么在类型为 TRX_UNDO_INSERT_REC 的 undo log 中只需要把该列占用的存储空间大小和真实值记录下来；

   如果记录中的主键包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下来（图中的 len 就代表列占用的存储空间大小， value 就代表列的真实值）。

> 如果表中有其他索引，那么更新聚簇索引的时候需要连带引起更新其他索引，这个大家都知道。但是这里的 undo log 好像只记录了主键信息，是不是漏了二级索引？
>
> 其实没有，因为我们说过二级索引也是存放该列值 + 主键值的，因此只要知道主键值就可以了。
>
> 之后要讲的 UPDATE 和 DELETE 也是这个逻辑，我们就不再强调了。

让我们往 undo_demo 里插入两条数据：

![image-20220723153445331](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723153445331.png)

因为记录的主键只包含一个 id 列，所以我们在对应的 undo log 中只需要将待插入记录的 id 列占用的存储空间长度（id 列的类型为 INT，INT 类型占用的存储空间长度为 4 个字节）和真实值记录下来。本例中插入了两条记录，所以会产生两条类型为 TRX_UNDO_INSERT_REC 的 undo log:

![image-20220723153601525](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723153601525.png)

![image-20220723153612816](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723153612816.png)

##### 2.3.1.1 `roll_pointer` 隐藏列的含义

这个隐藏列其实没什么大不了的，它就是一个指向 undo log 的指针。

比方说我们上边向 undo_demo 表里插入了2条记录，每条记录都有与其对应的一条 undo log，记录被存储到了类型为 FIL_PAGE_INDEX 的页面中（数据页），而 undo log 被存放到了类型为 FIL_PAGE_UNDO_LOG 的页面中：

![image-20220723153920736](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723153920736.png)

从这里我们还看到，这两条记录都是由事务 ID 为 100 的事务添加的。

#### 2.3.2 `DELETE` 的 undo log

##### 2.3.2.1 删除一条记录的过程

还记得 MySQL 行格式中的记录的额外信息的记录头信息吗，有一个字段叫做 `delete_mask`，表示逻辑删除，实际上这些逻辑删除的记录会组成一个垃圾链表，之后可以重用这些空间。

那么这个**链表头**在哪呢？**在每个页面的 Page Header 中的 PAGE_FREE 部分，它指向由被删除记录组成的垃圾链表中的头节点**，示意图如下：

![image-20220723154534997](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723154534997.png)

事实上，MySQL 删除一条记录其实分为两个步骤：

1. 仅仅将记录的 delete_mask 标识位设置为 1，其他的不做修改（除了 trx_id 、 roll_pointer 这些隐藏列）。InnoDB 把这个阶段称之为 delete mark。

   ![image-20220723155240255](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723155240255.png)

   可以看到，正常记录链表中的最后一条记录的 delete_mask 值被设置为 1 ，但是并没有被加入到垃圾链表，也就是此时记录处于一个中间状态。

   > 为什么不立即加入到垃圾链表呢？这其实是为了 MVCC 铺路，稍后我们就会介绍。

2. **当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉**。所谓真正的删除就是把该记录从正常记录链表中移除，并且加入到垃圾链表中，然后还要调整一些页面的其他信息，比如页面中的用户记录数量 PAGE_N_RECS、上次插入记录的位置 PAGE_LAST_INSERT、垃圾链表头节点的指针

   PAGE_FREE、页面中可重用的字节数量 PAGE_GARBAGE、还有页目录的一些信息等等。InnoDB 把这个阶段称之为 purge。

   ![image-20220723155450413](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723155450413.png)

从上面的介绍中我们也看到了，删除语句的事务在提交前，只会经历第一个阶段，也就是 delete mark 阶段（提交之后我们就不用回滚了，所以只需考虑对删除操作的阶段一做的影响进行回滚）。InnoDB 为此设计了一种称之为 TRX_UNDO_DEL_MARK_REC 类型的 undo log。

##### 2.3.2.2 TRX_UNDO_DEL_MARK_REC

它的格式如下：

![image-20220723155710451](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723155710451.png)

有以下几点需要注意：

1. 在对一条记录进行 delete mark 操作前，需要把该记录的旧的 trx_id 和 roll_pointer 隐藏列的值都保存到对应的 undo log 中，就是我们图中显示的 old trx_id 和 old roll_pointer 属性。

   这样做有一个好处：可以通过 undo log 的 old roll_pointer 找到记录在修改之前对应的 undo log。比方说在一个事务中，我们先插入了一条记录，然后又执行对该记录的删除操作，示意图如下：

   ![image-20220723155959634](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723155959634.png)

   从图中可以看出来，执行完 delete mark 操作后，它对应的 undo log 和 INSERT 操作对应的 **undo log 就串成了一个链表，这个链表称之为版本链**，现在貌似看不出这个版本链有啥用，等讲完 UPDATE 操作对应的 undo log 后，你就知道这个版本链的厉害之处了。

2. 与类型为 TRX_UNDO_INSERT_REC 的 undo log 不同，类型为 TRX_UNDO_DEL_MARK_REC 的 undo log 还多了一个索引列各列信息的内容，也就是说**如果某个列被包含在某个索引中，那么它的相关信息就应该被记录到索引列各列信息部分**，所谓的相关信息包括该列在记录中的位置（用 pos 表示），该列占用的存储空间大小（用 len 表示），该列实际值（用 value 表示）。所以索引列各列信息存储的内容实质上就是 <pos, len, value> 的一个列表。**这部分信息主要是用在事务提交后，对该中间状态记录做真正删除的阶段二，也就是 purge 阶段中使用的**，具体如何使用现在我们可以忽略。

让我们把刚刚加入的第一条记录删掉：

![image-20220723161349516](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723161349516.png)

产生了一条这样的日志：

![image-20220723161415118](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723161415118.png)

#### 2.3.3 `UPDATE` 的 undo log

`UPDATE` 操作需要分为更新主键与否两种情况。

##### 2.3.3.1 不更新主键的情况

在不更新主键的情况下，又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。

* **就地更新**：更新记录时，**对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行就地更新**，也就是直接在原记录的基础上修改对应列的值。

  注意，必须是一样大，如果是小了或者大了都不行。

  比方说现在 undo_demo 表里还有一条 id 值为 2 的记录，它的各个列占用的大小如图所示（采用 utf8 字符集，所以`'步枪'`这两个字符占用 6 个字节)：

  ![image-20220723161732941](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723161732941.png)

  假如我们有这样的 UPDATE 语句：

  ```mysql
  UPDATE undo_demo
  SET key1 = 'P92', col = '手枪' 
  WHERE id = 2;
  ```

  在这个 UPDATE 语句中，col 列从步枪被更新为手枪，前后都占用 6 个字节，也就是占用的存储空间大小未改变; key1 列从 M416 被更新为 P92 ，也就是从 4 个字节被更新为 3 个字节，这就不满足 就地更新需要的条件了，所以不能进行就地更新。

  但是如果 UPDATE 语句长这样:

  ```mysql
  UPDATE undo_demo
  SET key1 = 'M249', col = '机枪' 
  WHERE id = 2;
  ```

  由于各个被更新的列在更新前后占用的存储空间是一样大的，所以这样的语句可以执行就地更新。

* **先删除掉旧记录，再插入新记录**：在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。

  请注意，这里的删除不是 delete mark，而是真正删除，也就是把这条记录从正常记录链表中移除并加入到垃圾链表中，并且修改页面中相应的统计信息。

  不过这里做真正删除操作的线程并不是 purge 操作中使用的另外专门的线程，而是**由用户线程同步执行真正的删除操作**，真正删除之后紧接着就要根据各个列更新后的值创建的新记录插入。

  这里如果新创建的记录占用的存储空间大小不超过旧记录占用的空间，那么可以直接重用被加入到垃圾链表中的旧记录所占用的存储空间，否则的话需要在页面中新申请一段空间以供新记录使用，如果本页面内已经没有可用的空间的话，那就需要进行页分裂操作，然后再插入新记录。

针对不更新主键的情况，InnoDB 提出了 TRX_UNDO_UPD_EXIST_REC 的 undo log：

![image-20220723163556061](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723163556061.png)

其实大部分属性和我们介绍过的 TRX_UNDO_DEL_MARK_REC 类型的 undo log 是类似的，不过还是要注意这么几点：

* n_updated 属性表示本条 UPDATE 语句执行后将有几个列被更新，后边跟着的 <pos, old_len, old_value> 分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。
* 如果在 UPDATE 语句中更新的列包含索引列，那么也会添加索引列各列信息这个部分，否则的话是不会添加这个部分的。

现在我们把 id 为 2 的那条记录更新一下：

![image-20220723163729239](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723163729239.png)

这个 UPDATE 语句更新的列大小都没有改动，所以可以采用就地更新的方式来执行，在真正改动页面记录时，会先记录一条类型为 TRX_UNDO_UPD_EXIST_REC 的 undo log，长这样：

![image-20220723163806169](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723163806169.png)

##### 2.3.3.2 更新主键的情况

在聚簇索引中，记录是按照主键值的大小连成了一个单向链表的，**如果我们更新了某条记录的主键值，意味着这条记录在聚簇索引中的位置将会发生改变**。

针对这种情况，InnoDB 在聚簇索引中分了两步处理：

1. **将旧记录进行 delete mark 操作**。请注意，这里是 delete mark 操作。

   也就是说在 UPDATE 语句所在的事务提交前，对旧记录只做一个 delete mark 操作，在事务提交后才由专门的线程做 purge 操作，把它加入到垃圾链表中。

   这里一定要和我们上边所说的在不更新记录主键值时，先真正删除旧记录，再插入新记录的方式区分开。

2. **根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中**（需重新定位插入的位置）。

   由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位这条记录所在的位置，然后把它插进去。

针对 UPDATE 语句更新记录主键值的这种情况，在对该记录进行 delete mark 操作前，会记录一条类型为 TRX_UNDO_DEL_MARK_REC 的 undo log；之后插入新记录时，会记录一条类型为 TRX_UNDO_INSERT_REC 的 undo log，也就是说每对一条记录的主键值做改动时，会记录 2 条 undo log。

这些日志的格式我们上边都讲过了，这里就不再赘述了。

### 2.4 FIL_PAGE_UNDO_LOG 页面

我们说过，undo log 既可以放在数据页里，还可以放在专门的 undo 页里，这种页的类型就是 FIL_PAGE_UNDO_LOG。

它的结构如下所示：

![image-20220723172028902](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723172028902.png)

我们看到，undo 页包含每种类型页都有的 File Header 和 File Trailer，除此之外，有一个独有的 Undo Page Header 和真正存放 undo log 的区域。

接下来我们就来看看这个 Undo Page Header 的结构：

![image-20220723172407952](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723172407952.png)

* **TRX_UNDO_PAGE_TYPE**：本页面准备存储什么种类的 undo log。

  * TRX_UNDO_INSERT（对应的值为 1）：类型为 TRX_UNDO_INSERT_REC 的 undo log 属于此大类。

    一般来自于 INSERT 语句或者 UPDATE 语句中更新主键的情况。

  * TRX_UNDO_UPDATE（对应的值为 2）：除了类型为 TRX_UNDO_INSERT_REC 的 undo log，其他类型的 undo log 都属于这个大类。

    一般由 DELETE 、 UPDATE 语句产生的 undo log 属于这个大类。

  TRX_UNDO_PAGE_TYPE 属性可选的值就只有上边介绍的这两个，用来标记本页面用于存储哪个大类的 undo log，不同大类的 undo log 不能混着存储。

  > **提示**
  >
  > 之所以要分为两个大类别，是因为 TRX_UNDO_INSERT 的日志在事务提交后就可以删除，而其他类型的日志都要为 MVCC 服务。
  >
  > 我们在之后会介绍 MVCC。

* **TRX_UNDO_PAGE_START**：表示在当前页面中是从什么位置开始存储 undo log 的，或者说表示第一条 undo log 在本页面中的起始偏移量。

* **TRX_UNDO_PAGE_NODE**：代表一个链表节点的结构，我们很快就会用到这个属性了。 

### 2.5 undo 页面链表

#### 2.5.1 单个事务中的 undo 页面链表

因为一个事务可能包含多个语句，而且一个语句可能对若干条记录进行改动，而对每条记录进行改动前，都需要记录 1 条或 2 条的 undo log，所以**在一个事务执行过程中可能产生很多 undo log，这些日志可能一个页面放不下，需要放到多个页面中，这些页面就通过我们上边介绍的 TRX_UNDO_PAGE_NODE 属性连成了链表**。

如下图所示：

![image-20220723184443451](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723184443451.png)

上面的图中，我们特意把链表中的第一个 undo 页面给标了出来，称它为 first undo page，其余的 undo 页面称之为 normal undo page，这是因为**在 first undo page 中除了记录 Undo Page Header 之外，还会记录其他的一些管理信息**。

在一个事务执行过程中，可能混着执行 INSERT、DELETE、UPDATE 语句，也就意味着会产生不同类型的 undo log。但是我们前边又强调过，同一个 undo 页面要么只存储 TRX_UNDO_INSERT 大类的 undo日志 ，要么只存储 TRX_UNDO_UPDATE 大类的 undo log，反正不能混着存，所以在一个事务执行过程中就可能需要 2 个 undo 页面的链表，一个称之为 insert undo 链表，另一个称之为 update undo 链表。画个示意图就是这样：

![image-20220723185358877](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723185358877.png)

另外，InnoDB 规定对普通表和临时表的记录改动时产生的 undo log 要分别记录（我们稍后阐释为啥这么做），所以在一个事务中最多有 4 个以 undo 页面为节点组成的链表：

![image-20220723230508841](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723230508841.png)

当然，并不是在事务一开始就会为这个事务分配这 4 个链表，具体分配策略如下：

* 刚刚开启事务时，一个 undo 页面链表也不分配。
* 当事务执行过程中向普通表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个普通表的 insert undo 链表。
* 当事务执行过程中删除或者更新了普通表中的记录之后，就会为其分配一个普通表的 update undo 链表。
* 当事务执行过程中向临时表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个临时表的 insert undo 链表 。
* 当事务执行过程中删除或者更新了临时表中的记录之后，就会为其分配一个临时表的 update undo 链表 。

总结一句就是：**按需分配**。

#### 2.5.2 多个事务中的 undo 页面链表

**为了尽可能提高 undo log 多个事务并发写入的效率，InnoDB 规定不同事务执行过程中产生的 undo log 需要被写入到不同的 undo 页面链表中**。比方说现在有事务 id 分别为 1、2 的两个事务，我们分别称之为 trx 1 和 trx 2，假设在这两个事务执行过程中：

* trx 1 对普通表做了 DELETE 操作，对临时表做了 UPDATE 和 INSERT 操作。
* trx 2 对普通表做了 INSERT、UPDATE 和 DELETE 操作，没有对临时表做改动。

那么，InnoDB 会为 trx 1 分配三个链表，为 trx 2 分配两个链表：

![image-20220723231212398](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723231212398.png)

### 2.6 undo log 的写入过程

#### 2.6.1 Undo Log Segment Header

InnoDB 规定，每一个 Undo 页面都来自于一个段，称作 Undo Log Segment。也就是说，链表中的页面都是从这个段里申请的。

> **段**
>
> 我们之前介绍过段的概念，现在来稍微回顾一下：数据页的段是由一些零散的页面 + 若干个完整的区组成的，每个聚簇索引都有两个段，一个段存储叶子结点，一个段存储非叶子结点。
>
> 这里的 undo log 只有一个段，这点是和数据页不一样的。

所以 InnoDB 在 Undo 页面链表的第一个页面，也就是 first undo page 中设计了一个称之为 Undo Log Segment Header 的部分，这个部分中包含了该链表对应的段的 segment header 信息以及其他的一些关于这个段的信息，所以 Undo 页面链表的第一个页面其实长这样：

![image-20220724161748112](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724161748112.png)

可以看到这个 Undo 链表的第一个页面比普通页面多了个 Undo Log Segment Header，我们来看一下它的结构：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724161810936.png" alt="image-20220724161810936" style="zoom:67%;" />

* **TRX_UNDO_STATE**：本 Undo 页面链表处在什么状态。

  一个 Undo Log Segment 可能处在的状态包括：

  * TRX_UNDO_ACTIVE：活跃状态，也就是一个活跃的事务正在往这个段里边写入 undo log。
  * TRX_UNDO_CACHED：被缓存的状态。处在该状态的 Undo 页面链表等待着之后被其他事务重用。
  * TRX_UNDO_TO_FREE：对于 insert undo 链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。
  * TRX_UNDO_TO_PURGE：对于 update undo 链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。
  * TRX_UNDO_PREPARED：包含处于 PREPARE 阶段的事务产生的 undo 日志。

  > 有关 Undo 页面链表什么时候会被重用，怎么重用我们之后会详细说的。
  >
  > 而事务的 PREPARE 阶段是在**分布式事务**中的两阶段提交事务才出现的，本书中不会介绍更多关于分布式事务的事情，所以大家目前忽略这个状态就好了。

* **TRX_UNDO_LAST_LOG**：本 Undo 页面链表中最后一个 Undo Log Header 的位置。

  > 注意和 Undo Page Header 区分，这个 Undo Log Header 我们还没讲。

* **TRX_UNDO_FSEG_HEADER**：本 Undo 页面链表对应的段的 Segment Header 信息。

* **TRX_UNDO_PAGE_LIST**：Undo 页面链表的基节点。

  我们上面说过的 Undo Page Header 有一个 TRX_UNDO_PAGE_NODE，也就是说每一个 Undo 页面都有一个链表节点，而这个是基节点，这样整个 Undo 页面就被串成链表了。

#### 2.6.2 Undo Log Header

一个事务在向 Undo 页面中写入 undo log 时的方式是十分简单暴力的，就是直接往里写，写完一条紧接着写另一条，各条 undo log 之间是亲密无间的（因此 undo log 包含一个分隔符的部分，我们之前也说过了）。写完一个 Undo 页面后，再从段里申请一个新页面，然后把这个页面插入到 Undo 页面链表中，继续往这个新申请的页面中写。

InnoDB 认为**同一个事务向一个 Undo 页面链表中写入的 undo log 算是一个组**。比方说我们上边介绍的 trx 1 由于会分配 3 个 Undo 页面链表，也就会写入 3 个组的 undo log; trx 2 由于会分配 2 个 Undo 页面链表，也就会写入 2 个组的 undo log。

在每写入一组 undo log 时，都会在这组 undo log 前先记录一下关于这个组的一些属性，InnoDB 把存储这些属性的地方称之为 Undo Log Header。所以 Undo页面链表的第一个页面在真正写入 undo log 前，其实都会被填充 Undo Page Header、Undo Log Segment Header、Undo Log Header 这 3 个部分。

如下图所示：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724164538786.png" alt="image-20220724164538786" style="zoom: 50%;" />

Undo Log Header 的具体结构如下：

![image-20220724164637974](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724164637974.png)

* **TRX_UNDO_TRX_ID**：生成本组 undo log 的事务 id。

* **TRX_UNDO_TRX_NO**：事务提交后生成的一个需要序号，使用此序号来标记事务的提交顺序（先提交的此序号小，后提交的此序号大）。

* **TRX_UNDO_DEL_MARKS**：标记本组 undo log 中是否包含由于 delete mark 操作产生的 undo log。 

* **TRX_UNDO_LOG_START**：表示本组 undo log 中第一条 undo log 的在页面中的偏移量。 

* **TRX_UNDO_XID_EXISTS**：本组 undo log 是否包含 XID 信息。

  > **XID**
  >
  > XID 也和分布式事务有关，XID 作为事务分支标识符是在 XA 规范中定义的。

* **TRX_UNDO_DICT_TRANS**：标记本组 undo log 是不是由 DDL 语句产生的。

* **TRX_UNDO_TABLE_ID**：如果 TRX_UNDO_DICT_TRANS 为真，那么本属性表示 DDL 语句操作的表的 table id。 

* **TRX_UNDO_NEXT_LOG**：下一组的 undo log 在页面中开始的偏移量。

* **TRX_UNDO_PREV_LOG**：上一组的 undo log 在页面中开始的偏移量。

  > 一般来说一个 Undo 页面链表只存储一个事务执行过程中产生的一组 undo log，但是在某些情况下，可能会在一个事务提交之后，之后开启的事务重复利用这个 Undo 页面链表，这样就会导致一个 Undo 页面中可能存放多组 undo log。
  >
  > TRX_UNDO_NEXT_LOG 和 TRX_UNDO_PREV_LOG 就是用来标记下一组和上一组 undo log 在页面中的偏移量的。
  >
  > 关于什么时候重用Undo页面链表，怎么重用这个链表我们稍后会详细说明的，现在先理解 TRX_UNDO_NEXT_LOG 和 TRX_UNDO_PREV_LOG 这两个属性的意思就好了。 

* **TRX_UNDO_HISTORY_NODE**：一个 12 字节的 List Node 结构，代表一个称之为 History 链表的节点。

  > 有关 History 链表的内容我们稍后详细介绍。

最后，我们来看一下完整的链表示意图：

![image-20220724165528379](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724165528379.png)

### 2.7 重用 undo 页面

我们前边说为了提高并发执行的多个事务写入 undo log 的性能，InnoDB 决定为每个事务单独分配相应的 Undo 页面链表（最多可能单独分配 4 个链表）。

但是这样也造成了一些问题，比如其实大部分事务执行过程中可能只修改了一条或几条记录，针对某个 Undo 页面链表只产生了非常少的 undo log，这些 undo log 可能只占用很少的存储空间，这样会导致每开启一个事务就新创建一个 undo 页面链表（虽然这个链表中只有一个页面）来存储，有点浪费空间。

于是，InnoDB 本着勤俭节约的优良传统，决定**在事务提交后在某些情况下重用该事务的 Undo 页面链表**。

一个 Undo 页面链表是否可以被重用的条件很简单：

* 该链表中只包含一个 Undo 页面。
* 该 Undo 页面已经使用的空间小于整个页面空间的 $\frac{3}{4}$。

根据 undo log 所属的大类不同，重用的策略也不同（虽然只有两个大类）：

* insert undo 链表：insert undo 链表中只存储类型为 TRX_UNDO_INSERT_REC 的 undo log，**这种类型的 undo log 在事务提交之后就没用了，可以随时被清除掉**。

  所以在某个事务提交后，**重用这个事务的 insert undo 链表时，可以直接把之前事务写入的一组 undo log 覆盖掉**，从头开始写入新事务的一组 undo log。

  如下图所示：

  ![image-20220724170046658](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724170046658.png)

* update undo 链表：在一个事务提交后，它的 update undo 链表中的 undo log 也不能立即删除掉（要用于 MVCC，我们说过挺多次了，之后会详细介绍 MVCC 的）。

  所以如果之后的事务**想重用 update undo 链表时，就不能覆盖之前事务写入的 undo log，只能接着往后写。这样就相当于在同一个 Undo 页面中写入了多组的 undo log**，效果看起来就是这样：

  ![image-20220724170225545](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724170225545.png)

### 2.8 回滚段

#### 2.8.1 回滚段的概念

我们现在知道一个事务在执行过程中最多可以分配 4 个 Undo 页面链表，在同一时刻不同事务拥有的 Undo 页面链表是不一样的，所以在同一时刻系统里其实可以有许许多多个 Undo 页面链表存在。

为了更好的管理这些链表，InnoDB 设计了一个称之为 Rollback Segment Header 的页面，在这个页面中存放了各个 Undo 页面链表的 frist undo page 的 页号，他们把这些页号称之为 undo slot。

我们看一下这个称之为 Rollback Segment Header 的页面长啥样（以默认的 16KB 为例）:

![image-20220724170346280](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724170346280.png)

**InnoDB 规定，每一个 Rollback Segment Header 页面都对应着一个段，这个段就称为 Rollback Segment（回滚段）**。

与我们之前介绍的各种段不同的是，这个 Rollback Segment 里其实只有一个页面。

>这可能是 InnoDB 设计上的一种洁癖，InnoDB 可能觉得为了某个目的去分配页面的话都得先申请一个段。
>
>或者 InnoDB 觉得虽然目前版本的 MySQL 里 Rollback Segment 里其实只有一个页面，但可能之后的版本里会增加页面也说不定。

各个部分的含义如下：

* **TRX_RSEG_MAX_SIZE**：本 Rollback Segment 中管理的所有 Undo 页面链表中的 Undo 页面数量之和的最大值。

  换句话说，本 Rollback Segment 中所有 Undo 页面链表中的 Undo 页面数量之和不能超过 TRX_RSEG_MAX_SIZE 代表的值。

  该属性的值默认为无限大，也就是我们想写多少 Undo 页面都可以。

* **TRX_RSEG_HISTORY_SIZE**：History 链表占用的页面数量。

* **TRX_RSEG_HISTORY**：History 链表的基节点。

* **TRX_RSEG_FSEG_HEADER**：本 Rollback Segment 对应的 10 字节大小的 Segment Header 结构，通过它可以找到本段对应的 INODE Entry。

* **TRX_RSEG_UNDO_SLOTS**：各个 Undo页面链表的 first undo page 的页号集合，也就是 undo slot 集合。

  一个页号占用 4 个字节，对于 16KB 大小的页面来说，这个 TRX_RSEG_UNDO_SLOTS 部分共存储了 1024 个 undo slot ，所以共需 1024 × 4 = 4096 个字节。

#### 2.8.2 从回滚段申请 Undo 页面链表

初始情况下，由于未向任何事务分配任何 Undo 页面链表，所以对于一个 Rollback Segment Header 页面来说，它的各个 undo slot 都被设置成了一个特殊值：`FIL_NULL`（0xFFFFFFFF），表示该 undo slot 不指向任何页面。

随着时间的流逝，开始有事务需要分配 Undo 页面链表了，于是就**从回滚段的第一个 undo slot 开始，看看该 undo slot 的值是不是 FIL_NULL**：

* 如果是 FIL_NULL，那么在表空间中新创建一个段（也就是 Undo Log Segment），然后从段里申请一个页面作为 Undo 页面链表的 first undo page，然后把该 undo slot 的值设置为刚刚申请的这个页面的页号，这样也就意味着这个 undo slot 被分配给了这个事务。
* 如果不是 FIL_NULL，说明该 undo slot 已经指向了一个 undo 链表，也就是说这个 undo slot 已经被别的事务占用了，那就跳到下一个 undo slot。

一个 Rollback Segment Header 页面中包含 1024 个 undo slot，如果这 1024 个 undo slot 的值都不为 FIL_NULL，这就意味着这 1024 个 undo slot 都被分配给了某个事务，此时由于新事务无法再获得新的 Undo 页面链表，就会回滚这个事务并且给用户报错：`Too many active concurrent transactions`。

用户看到这个错误，可以选择重新执行这个事务，这个时候，可能有别的事务已经提交了，该事务就可以被分配 Undo 页面链表了。

当一个事务提交时，它所占用的 undo slot 有两种命运：

* 如果该 undo slot 指向的 Undo 页面链表符合被重用的条件，那么就让该 undo slot 处于被缓存的状态，这时 Undo 页面链表的 TRX_UNDO_STATE 属性（在 first undo page 的 Undo Log Segment Header 部分）会被设置为 TRX_UNDO_CACHED。

  **被缓存的 undo slot 都会被加入到一个链表**，根据对应的 Undo 页面链表的类型不同，也会被加入到不同的链表：

  * 如果对应的 Undo 页面链表是 insert undo 链表，则该 undo slot 会被加入 insert undo cached 链表。
  * 如果对应的 Undo 页面链表是 update undo 链表，则该 undo slot 会被加入 update undo cached 链表。

  **一个回滚段就对应着上述两个 cached 链表，如果有新事务要分配 undo slot 时，先从对应的 cached 链表中找。如果没有被缓存的 undo slot，才会到回滚段的 Rollback Segment Header 页面中再去找**。

* 如果该 undo slot 指向的 Undo 页面链表不符合被重用的条件，那么针对该 undo slot 对应的 Undo 页面链表类型不同，也会有不同的处理：

  * 如果是 insert undo 链表，则该 Undo 页面链表的 TRX_UNDO_STATE 属性会被设置为 TRX_UNDO_TO_FREE，之后该 Undo 页面链表对应的段会被释放掉，然后把该 undo slot 的值设置为 FIL_NULL。

  * 如果是 update undo 链表，则该 Undo 页面链表的 TRX_UNDO_STATE 属性会被设置为 TRX_UNDO_TO_PRUGE，则会将该 undo slot 的值设置为 FIL_NULL ，然后将本次事务写入的一组 undo 日志放到 History链表中。

    需要注意的是，这里并不会将 Undo 页面链表对应的段给释放掉，因为这些 undo log 还有其他作用。

#### 2.8.3 多个回滚段

我们说一个事务执行过程中最多分配 4 个 Undo 页面链表，而一个回滚段里只有 1024 个 undo slot，很显然 undo slot 的数量有点少。我们即使假设一个读写事务执行过程中只分配 1 个 Undo 页面链表，那 1024 个 undo slot 也只能支持 1024 个读写事务同时执行，再多了就崩溃了。

InnoDB 意识到了这个问题，所以 InnoDB 定义了最多 128 个回滚段，也就相当于有了 128 × 1024 = 131072 个 undo slot。假设一个读写事务执行过程中只分配 1 个 Undo页面 链表，那么就可以同时支持 131072 个读写事务并发执行。

> **提示**
>
> 只读事务并不需要分配 Undo 页面链表，MySQL 5.7 中所有刚开启的事务默认都是只读事务，只有在事务执行过程中对记录做了某些改动时才会被升级为读写事务。

每个回滚段都对应着一个 Rollback Segment Header 页面，有 128 个回滚段，自然就要有 128 个 Rollback Segment Header 页面，这些页面的地址在系统表空间的第 5 号页面的某个区域包含了 128 个 8 字节大小的格子：

![image-20220724180621070](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724180621070.png)

每个 8 字节的格子的构造就像这样：

![image-20220724180631326](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724180631326.png)

如果所示，每个 8 字节的格子其实由两部分组成：

* 4 字节大小的 Space ID，代表一个表空间的 ID。

* 4 字节大小的 Page number，代表一个页号。

也就是说每个 8 字节大小的格子相当于一个指针，指向某个表空间中的某个页面，这些页面就是 Rollback Segment Header。

这里需要注意的一点是，要定位一个 Rollback Segment Header 还需要知道对应的表空间 ID，这也就意味着**不同的回滚段可能分布在不同的表空间中**。

总结一下：在系统表空间的第 5 号页面中存储了 128 个 Rollback Segment Header 页面地址，每个 Rollback Segment Header 就相当于一个回滚段。在 Rollback Segment Header 页面中，又包含 1024 个 undo slot ，每个 undo slot 都对应一个 Undo 页面链表。

我们画个示意图：

![image-20220724180918659](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724180918659.png)

#### 2.8.4 回滚段的分类

我们把这 128 个回滚段给编一下号，最开始的回滚段称之为第 0 号回滚段，之后依次递增，最后一个回滚段就称之为第 127 号回滚段。

这 128 个回滚段可以被分成两大类：

* 第 0 号、第 33 ~ 127 号回滚段属于一类。

  其中第 0 号回滚段必须在系统表空间中（就是说第 0 号回滚段对应的 Rollback Segment Header 页面必须在系统表空间中），第 33 ~ 127 号回滚段既可以在系统表空间中，也可以在自己配置的 undo 表空间中，关于怎么配置我们稍后再说。

  如果一个事务在执行过程中由于**对普通表的记录做了改动**需要分配 Undo 页面链表时，必须从这一类的段中分配相应的 undo slot。

* 第 1 ~ 32 号回滚段属于一类。

  这些回滚段必须在临时表空间（对应着数据目录中的 ibtmp1 文件）中。

  如果一个事务在执行过程中由于**对临时表的记录做了改动**需要分配 Undo 页面链表时，必须从这一类的段中分配相应的 undo slot。

> **为什么要根据临时表和普通表来划分？**
>
> 这是**因为 undo log 是写在页面上的，这也意味着在修改这些页面之前还要写 redo log**。
>
> 但是对于临时表来说，**因为修改临时表而产生的 undo log 只需要在系统运行过程中有效**，如果系统奔溃了，那么在重启时也不需要恢复这些 undo log 所在的页面，所以在写针对临时表的 Undo 页面时，并不需要记录相应的 redo log。

#### 2.8.5 为事务分配 Undo 页面链表的详细过程

这一小节我们总结一下分配链表的详细过程。

* 事务在执行过程中对普通表的记录首次做改动之前，首先会到系统表空间的第 5 号页面中分配一个回滚段（其实就是获取一个 Rollback Segment Header 页面的地址）。

  一旦某个回滚段被分配给了这个事务，那么之后该事务中再对普通表的记录做改动时，就不会重复分配了。

* 在分配到回滚段后，首先看一下这个回滚段的两个 cached 链表有没有已经缓存了的 undo slot，比如如果事务做的是 INSERT 操作，就去回滚段对应的 insert undo cached 链表中看看有没有缓存的 undo slot; 如果事务做的是 DELETE 操作，就去回滚段对应的 update undo cached 链表中看看有没有缓存的 undoslot。

* 如果有缓存的 undo slot，那么就把这个缓存的 undo slot 分配给该事务。

* 如果没有缓存的 undo slot 可供分配，那么就要到 Rollback Segment Header 页面中找一个可用的 undo slot 分配给当前事务。

  从 Rollback Segment Header 页面中分配可用的 undo slot 的方式我们上边也说过了，就是从第 0 个 undo slot 开始，如果该 undo slot 的值为 FIL_NULL，意味着这个 undo slot 是空闲的，就把这个 undo slot 分配给当前事务，否则查看第 1 个 undo slot 是否满足条件，依次类推，直到最后一个 undo slot。

  如果这 1024 个 undo slot 都没有值为 FIL_NULL 的情况，就直接报错。

* 找到可用的 undo slot 后，如果该 undo slot 是从 cached 链表中获取的，那么它对应的 Undo Log Segment 已经分配了，否则的话需要重新分配一个 Undo Log Segment，然后从该 Undo Log Segment 中申请一个页面作为 Undo 页面链表的 first undo page。
* 然后事务就可以把 undo log 写入到上边申请的 Undo 页面链表了。

需要再次强调的是，如果一个事务在执行过程中**既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配 2 个回滚段**。

> 并发执行的不同事务其实也可以被分配相同的回滚段，只要分配不同的 undo slot 就可以了。

### 2.9 回滚段相关配置

#### 2.9.1 配置回滚段数量

我们之前说系统中一共有 128 个回滚段，其实这只是默认值，我们可以通过启动参数 `innodb_rollback_segments` 来配置回滚段的数量，可配置的范围是 1 ~ 128。但是这个参数并不会影响针对临时表的回滚段数量，针对临时表的回滚段数量一直是 32，也就是说：

* 如果我们把 `innodb_rollback_segments` 的值设置为 1，那么只会有 1 个针对普通表的可用回滚段，但是仍然有 32 个针对临时表的可用回滚段。
* 如果我们把 `innodb_rollback_segments` 的值设置为 2 ~ 33 之间的数，效果和将其设置为 1 是一样的。
* 如果我们把 `innodb_rollback_segments` 设置为大于 33 的数，那么针对普通表的可用回滚段数量就是该值减去 32。

#### 2.9.2 配置 Undo 表空间

默认情况下，针对普通表设立的回滚段（第 0 号以及第 33 ~ 127 号回滚段）都是被分配到系统表空间的。

其中的第 0 号回滚段是一直在系统表空间的，但是**第 33 ~ 127 号回滚段可以通过配置放到自定义的 undo 表空间中**。但是这种配置只能在系统初始化（创建数据目录时）的时候使用，一旦初始化完成，之后就不能再次更改了。我们看一下相关启动参数：

* 通过 `innodb_undo_directory` 指定 undo 表空间所在的目录，如果没有指定该参数，则默认 undo 表空间所在的目录就是数据目录。

* 通过 `innodb_undo_tablespaces` 定义 undo 表空间的数量。该参数的默认值为 0，表明不创建任何 undo 表空间。

  第 33 ~ 127 号回滚段可以平均分布到不同的 undo 表空间中。

> **提示**
>
> 如果我们在系统初始化的时候指定了创建了 undo 表空间，那么系统表空间中的第 0 号回滚段将处于不可用状态。

设立 undo 表空间的一个好处就是在 undo 表空间中的文件大到一定程度时，可以自动的将该 undo 表空间截断（truncate）成一个小文件。而系统表空间的大小只能不断的增大，却不能截断。

## 3. binlog

### 3.1 binlog 介绍

前面介绍的 undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。

而 **binlog 是 Mysql Sever 层维护的一种二进制日志**，与 InnoDB 引擎中的 redo/undo log 是完全不同的日志；其**主要是用来记录对 MySQL 数据更新或潜在发生更新的 SQL 语句**，并以"事务"的形式保存在磁盘中。

它的作用比前面两种日志都要大，因为它是通用的。binlog 主要用途有：

* 主从复制：MySQL Replication 在 Master 端开启 binlog，Master 把它的二进制日志传递给 slaves 并回放来达到 master-slave 数据一致的目的。
* 数据恢复：通过 mysqlbinlog 工具恢复数据。

### 3.2 binlog 的使用方式

#### 3.2.1 binlog 配置

binlog 日志功能默认是开启的，线上情况下 binlog 日志的增长速度是很快的，在 MySQL 的配置文件中提供一些参数来对 binlog 进行设置。

如下所示：

```ini
[mysqld]
# 设置此参数表示启用b inlog 功能，并制定二进制日志的存储目录，开启 binlog 日志大概会有 1% 的性能损耗
log-bin=/home/mysql/binlog/

# 高版本 MySQL 需要 server-id 这个参数，提供一个集群中不重复的 id 值即可
server-id=1

# mysql-bin.* 日志文件最大字节（单位：字节）
max_binlog_size=104857600

# 设置了只保留 7 天 binlog
expire_logs_days = 7

# binlog 日志只记录指定库的更新
#binlog-do-db=db_name

# binlog 日志不记录指定库的更新
#binlog-ignore-db=db_name

# 写缓冲多少次，刷一次磁盘，默认 0
sync_binlog=0
```

需要注意的有：

* `max_binlog_size` ：b默认值是 1G，该设置并不能严格控制 binlog 的大小，尤其是 binlog 比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性不可能做切换日志的动作，只能将该事务的所有 SQL 都记录进当前日志直到事务结束。所以**真实文件有时候会大于 max_binlog_size 设定值**。 

* `expire_logs_days`：**binlog 过期删除不是服务定时执行，是需要借助事件触发才执行**，事件包括：

  - 服务器重启

  - 服务器被更新

  - 日志达到了最大日志长度 max_binlog_size

  - 日志被刷新

#### 3.2.2 常用的 binlog 操作

* 查看是否启用 binlog：`show variables like 'log_bin'`
* 查看 binlog 的目录：`show global variables like "%log_bin%"`
* 查看当前服务器使用的 binlog 文件个数及大小：`show binary logs`
* 查看最新一个 binlog 日志文件名称和 position：`show master status`
* 事件查询命令：`show binlog events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]`
  * `IN ['log_name']`：指定要查询的 binlog 文件名（不指定就是第一个 binlog 文件）
  * `FROM pos`：指定从哪个pos起始点开始查起（不指定就是从整个文件首个 pos 点开始算）
  * `LIMIT [offset,]`：偏移量（不指定就是 0）
  * `row_count`：查询总条数（不指定就是所有行）
* 查看具体一个 binlog 文件的内容（in 后面为 binlog 的文件名）：`show binlog events in 'master.000003'` 
* 分页显示、过滤日志：`pager less`，`pager grep "drop"`
* 设置 binlog 文件保存事件，过期删除，单位天：`set global expire_log_days = 3`
* 删除当前的 binlog 文件：`reset master`
* 删除 slave 的中继日志：`reset slave`
* 删除指定日期前的日志索引中 binlog 日志文件：`purge master logs before '2019-03-09 14:00:00'`
* 删除指定日志文件：`purge master logs to 'master.000003'`

### 3.3 binlog 文件以及拓展

binlog日志包括两类文件:

- 二进制日志索引文件（文件名后缀为.index）：用于记录所有有效的的二进制文件。
- 二进制日志文件（文件名后缀为.00000*）：用于记录数据库所有的 DDL 和 DML 语句事件。

当遇到以下 3 种情况时，MySQL 会重新生成一个新的日志文件，文件序号递增：

- MySQL 服务器停止或重启时；
- 使用 `flush logs` 命令；
- 当 binlog 文件大小超过 `max_binlog_size` 变量的值时；

max_binlog_size 的最小值是 4096 字节，最大值和默认值是 1 GB（1073741824字节）。

事务被写入到 binlog 的一个块中，所以它不会在几个二进制日志之间被拆分。因此，如果你有很大的事务，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的日志都记录到当前日志文件中，直到事务结束，你可能会看到 binlog 文件大于 max_binlog_size 的情况。

### 3.4 binlog 记录格式

binlog 有三种格式，可以通过 `binlog_format` 参数指定：

* **statement**：该格式下，记录的是 SQL 原文。

  比如执行一条`update T set update_time=now() where id=1`，记录的内容如下：

  ![image-20220724224638056](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724224638056.png)

  同步数据时，会执行记录的 SQL 语句，但是有个问题，`update_time=now()` 这里会获取恢复时的当前系统时间，直接执行会导致与原库的数据不一致。

* **row**：在 statement 格式的基础上，记录的内容不再是简单的 SQL 语句了，还包含操作的具体数据，记录内容如下：

  ![image-20220724225157739](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724225157739.png)

  row 格式记录的内容看不到详细信息，要通过 `mysqlbinlog` 工具解析出来。

  `update_time=now()` 变成了具体的时间 `update_time=1627112756247`，条件后面的 @1、@2、@3 都是该行数据第 1 个到第 3 个字段的原始值（假设这张表只有 3 个字段）。

  这样就能保证同步数据的一致性，通常情况下都是指定为 row，这样可以为数据库的恢复与同步带来更好的可靠性。

  但是这种格式需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗 I/O 资源，影响执行速度。

* **mixed**：mixed 是一种折中的方案，MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。

### 3.5 写入机制

binlog 的写入时机也非常简单，事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。

因为一个事务的 binlog 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为 binlog cache。

我们可以通过 `binlog_cache_size` 参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。

binlog 日志刷盘流程如下：

![image-20220724225609720](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724225609720.png)

这里要注意两点：

- 上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。
- 上图的 fsync，才是将数据持久化到磁盘的操作。

write 和 fsync 的时机，可以由参数 `sync_binlog` 控制，默认是 0。

为 0 的时候，表示每次提交事务都只 write，由系统自行判断什么时候执行 fsync。虽然性能得到提升，但是如果机器宕机，page cache 里面的 binlog 会丢失。

为了安全起见，可以设置为 1，表示每次提交事务都会执行 fsync。

最后还有一种折中方式，可以设置为 N（N > 1），表示每次提交事务都 write，但累积 N 个事务后才 fsync。

在出现 I/O 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。

同样的，如果机器宕机，会丢失最近 N 个事务的 binlog 日志。
