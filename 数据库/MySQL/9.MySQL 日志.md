[TOC]

# MySQL 日志

## 1. redo log（重做日志）

### 1.1 redo log 介绍

InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。

我们讲 Buffer Pool 的时候说过，在真正访问页面之前，需要把**在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问**；但是在介绍**事务**的时候又强调过一个称之为**持久性的特性**，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。

但是如果我们只在内存的 Buffer Pool 中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的。

那么如何保证这个持久性呢？一个很简单的做法就是**在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题**：

* **刷新一个完整的数据页太浪费了**：有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在 InnoDB 中是以页为单位来进行磁盘 I/O 的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是 16KB 大小，只修改一个字节就要刷新 16KB 的数据到磁盘上显然是太浪费了。
* **随机 I/O 刷起来比较慢**：一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，更倒霉的是**该事务修改的这些页面可能并不相邻**，这就意味着在将某个事务修改的 Buffer Pool 中的页面刷新到磁盘时，需要进行很多的随机 I/O，随机 I/O 比顺序 I/O 要慢，尤其对于传统的机械硬盘来说。

那么我们到底怎么办呢？再次回到我们的初心：**我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来**。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，**只需要把修改了哪些东西记录一下就好**。

比方说某个事务将系统表空间中的第 100 号页面中偏移量为 1000 处的那个字节的值 1 改成 2 我们只需要记录一下：

```text
将第 0 号表空间的 100 号页面的偏移量为 1000 处的值更新为 2
```

这样我们**在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足了持久性的要求**。

因为这是在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为**重做日志（redo log）**。

![image-20220513104333243](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220513104333243.png)

redo log 有什么好处呢？

* **redo log 占用的空间非常小**：存储表空间 ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于 redo 日志的格式我们稍后会详细介绍，现在只要知道一条 redo 日志占用的空间不是很大就好了。
* **redo log 是顺序写入磁盘的**：在执行事务的过程中，每执行一条语句，就可能产生若干条 redo 日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序 I/O。 

### 1.2 redo log 格式

redo log 本质上只是记录了一下事务对数据库做了哪些修改，InnoDB 针对事务对数据库的不同修改场景定义了多种类型的 redo log，但是绝大部分类型的 redo log 都有下面这种通用的结构：

![image-20220718201406184](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718201406184.png)

* **type**：该条 redo log 的类型。
* **space ID**：表空间 ID。
* **page number**：页号。
* **data**：redo log 的具体内容。

#### 1.2.1 简单的 redo log 类型

我们举个 MySQL 中实际的例子吧：

我们前边介绍 InnoDB 的记录行格式的时候说过，如果我们没有为某个表显式的定义主键，并且表中也没有定义 Unique 键，那么 InnoDB 会自动的为表添加一个称之为 row_id 的隐藏列作为主键。为这个 row_id 隐藏列赋值的方式如下：

* 服务器会在内存中维护一个全局变量，每当向某个包含隐藏的 row_id 列的表中插入一条记录时，就会把该变量的值当作新记录的 row_id 列的值，并且把该变量自增 1。
* 每当这个变量的值为 256 的倍数时，就会将该变量的值刷新到系统表空间的页号为 7 的页面中一个称之为 Max Row ID 的属性处（我们前边介绍表空间结构时详细说过）。
* 当系统启动时，会将上边提到的 Max Row ID 属性加载到内存中，将该值加上 256 之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于 Max Row ID 属性值）。

这个 Max Row ID 属性占用的存储空间是 8 个字节，当某个事务向某个包含 row_id 隐藏列的表插入一条记录，并且为该记录分配的 row_id 值为 256 的倍数时，就会向系统表空间页号为 7 的页面的相应偏移量处写入 8 个字节的值。

但是我们要知道，这个写入实际上是在 Buffer Pool 中完成的，我们需要为这个页面的修改记录一条 redo log，以便在系统奔溃后能将已经提交的该事务对该页面所做的修改恢复出来。这种情况下对页面的修改是极其简单的， **redo log 中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是什么就好了，InnoDB 把这种极其简单的 redo log 称之为 物理日志** ，并且**根据在页面中写入数据的多少划分了几种不同的 redo 日志类型**：

* MLOG_1BYTE（type 字段的值为 1）：表示在页面的某个偏移量处写入 1 个字节的 redo log 类型。
* MLOG_2BYTE（type 字段的值为 2）：表示在页面的某个偏移量处写入 2 个字节的 redo log 类型。
* MLOG_4BYTE（type 字段的值为 4）：表示在页面的某个偏移量处写入 4 个字节的 redo log 类型。
* MLOG_8BYTE（type 字段的值为 8）：表示在页面的某个偏移量处写入 8 个字节的 redo log 类型。
* MLOG_WRITE_STRING（type 字段的值为 30）：表示在页面的某个偏移量处写入一串数据。

我们刚刚提到的 Max Row ID 为 8 个字节，说明它会使用一个 MLOG_8BYTE 的 redo log 类型。其实，MLOG_1/2/4/8BYTE 的结构都差不多，示意图如下：

![image-20220718213802750](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718213802750.png)

唯一不同的只有 MLOG_WRITE_STRING，它多了一个字符串的长度：

![image-20220718213746801](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718213746801.png)

> **为什么要 redo log 要分这么细，而不是直接用一个 MLOG_WRITE_STRING 把这些情况全部包含进去？**
>
> 答案当然是为了**省空间**，能不写 len 字段就不写，把空间压缩到极致。

#### 1.2.2 复杂的 redo log 类型

有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的 B+ 树）。

以一条 INSERT 语句为例，我们通常需要知道的是：

* 表中包含多少个索引，一条 INSERT 语句就可能更新多少棵 B+ 树。
* 针对某一棵 B+ 树来说，既可能更新叶子节点页面，也可能更新非叶子节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在非叶子节点页面中添加目录项记录 ）。

在语句执行过程中， INSERT 语句对所有页面的修改都得保存到 redo log 中去。这句话说起来轻巧，做起来可就比较麻烦了，比方说将记录插入到聚簇索引中时，如果定位到的叶子节点的剩余空间足够存储该记录时，那么只更新该叶子节点页面就好，那么只记录一条 MLOG_WRITE_STRING 类型的 redo log，表明在页面的某个偏移量处增加了哪些数据就完成了吗？那就太付钱了，别忘了，一个数据页中除了存储实际的记录之后，还有 File Header、Page Header、Page Directory 等等存储元数据的部分需要连锁更新，所以**每往叶子节点代表的数据页里插入一条记录时，还有其他很多地方会跟着更新**。

如果你非要使用物理日志，这时候有两种解决方案：

* 方案一：对每一个修改的地方都记录一个 redo log。这其实不可行，因为被修改的地方实在太多了，可能最后你记录出来的 redo log 的大小都超过了你修改的整个页面的大小。

* 方案二：既然方案一产生的 log 可能太大，我们不如直接**把第一个被修改的字节到最后一个修改的字节 之间所有的数据当成是一条物理 redo log 中的具体数据**。

  但是这也很浪费，因为这个区间内实际上还是有很多没有修改过的地方的。

所以，两种方案都不能解决的情况下，只能创造新的 redo log 类型：

* MLOG_REC_INSERT（type 字段的值为 9）：表示插入一条使用**非紧凑行格式**的记录时的 redo log 类型。
* MLOG_COMP_REC_INSERT（type 字段的值为 38）：表示插入一条使用**紧凑行格式**的记录时的 redo log 类型。
* MLOG_COMP_PAGE_CREATE（type 字段的值为 58）：表示创建一个存储**紧凑行格式**记录的页面的 redo log 类型。
* MLOG_COMP_REC_DELETE（type 字段的值为 42）：表示删除一条使用**紧凑行格式**记录的 redo log 类型。
* MLOG_COMP_LIST_START_DELETE（type 字段对应的十进制数字为 44）：表示从某条给定记录开始删除页面中的一系列使用**紧凑行格式**记录的 redo log 类型。
* MLOG_COMP_LIST_END_DELETE（type 字段对应的十进制数字为 43）：与 MLOG_COMP_LIST_START_DELETE 类型的 redo log 呼应，表示删除一系列记录直到 MLOG_COMP_LIST_END_DELETE 类型的 redo log 对应的记录为止。

> 我们之前介绍过四种行格式，其中，Redundant 是一种比较原始的行格式，它就是非紧凑的。而 Compact、Dynamic 以及 Compressed 行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。

除此之外，还有很多，这里就不说了。

这些类型的 redo 日志既包含物理层面的意思，也包含逻辑层面的意思，具体指：

* 物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。
* 逻辑层面看，在系统奔溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子。

因为 compact 行格式是最常用的行格式，所以我们有必要介绍一下它的具体结构，我们以插入为例，看看它的具体格式：

![image-20220718215547621](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718215547621.png)

### 1.3 Mini-Transaction

#### 1.3.1 以组的形式写入 redo log

语句在执行过程中可能修改若干个页面。比如我们前边说的一条 INSERT 语句可能修改系统表空间页号为 7 的页面的 Max Row ID 属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会更新聚簇索引和二级索引对应 B+ 树中的页面。由于对这些页面的更改都发生在 Buffer Pool 中，所以在修改完页面之后，需要记录一下相应的 redo log。

**在执行语句的过程中产生的 redo log 被 InnoDB 划分成了若干个不可分割的组**，比如：

* 更新 Max Row ID 属性时产生的 redo 日志是不可分割的。
* 向聚簇索引对应 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。
* 向某个二级索引对应 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。
* 还有其他的一些对页面的访问操作时产生的 redo 日志是不可分割的。

如何理解这个不可分割？举个例子，我们以向某个索引对应的 B+ 树插入一条记录为例，在向 B+ 树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：

* 情况一：该**数据页的剩余的空闲空间充足**，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，**记录一条类型为 MLOG_COMP_REC_INSERT 的 redo log 就好了，我们把这种情况称之为乐观插入**。

* 情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行**页分裂**，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在非叶子节点中添加一条目录项记录指向这个新创建的页面。

  很显然，这个过程要对多个页面进行修改，也就意味着会**产生多条 redo log**，我们把这种情况称之为**悲观插入**。

InnoDB 认为向某个索引的 B+ 树中插入一条记录的过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向非叶子节点中插入一条目录项记录 ，这个插入过程就是不完整的，这样会形成一棵不正确的 B+ 树。

而 redo log 就是为了保证能够在系统崩溃后恢复到崩溃前的状态而诞生的，**那么如果在悲观插入的过程中只记录了一部分 redo log，那么在系统奔溃重启时会将索引对应的 B+ 树恢复成一种不正确的状态**。

所以，InnoDB 规定在执行这些原子性操作时必须以**组**的形式来记录 redo log，在进行系统奔溃重启恢复时，**针对某个组中的 redo log，要么把全部的日志都恢复掉，要么一条也不恢复**。

那么 MySQL 是如何做到的呢？其实只需要一些小手段，但是需要分类讨论：

1. 有的需要保证原子性的操作会生成**多条 redo log**，比如向某个索引对应的 B+ 树中进行一次悲观插入就需要生成许多条 redo 日志。这时，我们**在该组的最后一条 redo log 之后再添加一条特殊类型的 redo log**，该类型名称为 MLOG_MULTI_REC_END ， type 的值为 31，结构很简单，仅有 type 一个字段。

   所以这一个组看起来像这样：

   ![image-20220718221746758](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718221746758.png)

   这样在系统奔溃重启进行恢复时，**只有当解析到类型为 MLOG_MULTI_REC_END 的 redo 日志，才认为解析到了一组完整的 redo 日志，才会进行恢复；否则的话直接放弃前边解析到的 redo 日志**。

2. 有的需要保证原子性的操作**只生成一条 redo log**，这时如果使用上面的方法加一个特殊的 redo log 也可以，但是有点浪费，而我们知道，InnoDB 是出了名的抠门，这时怎么办呢？

   redo log 的类型虽然多，但是也就几十种，是小于 127 这个数字的，也就是说我们用 7 个比特位就足以包括所有的 redo log 类型，而 type 字段其实是占用 1 个字节，也就是 8 个比特的，也就是说我们可以省出来 1 个比特位用来表示该需要保证原子性的操作只产生单一的一条 redo log。

   ![image-20220718222033406](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718222033406.png)

#### 1.3.2 Mini-Transaction 的概念

我们刚刚介绍的按组写入 redo log 是不是很像一个事务？也是要么全部成功，要么全部失败，因此 **MySQL 把对底层页面中的一次原子访问的过程称之为一个 Mini-Transaction（迷你事务），简称 mtr**。

一个事务可以包含若干条语句，每一条语句其实是由若干个 mtr 组成，每一个 mtr 又可以包含若干条 redo log，画个图表示它们的关系就是这样：

![image-20220718222232533](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718222232533.png)

### 1.5  redo log 的写入过程

#### 1.5.1 redo log block

**InnoDB 为了更好的进行系统崩溃恢复，它把 mtr 生成的 redo log 都放在了大小为 512 字节的页中，称之为 redo log block**。

示意图如下：

![image-20220718222444215](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718222444215.png)

真正的 redo 日志都是存储到占用 496 字节大小的 log block body 中的，图中的 log block header 和 log block trailer 存储的是一些管理信息。

管理信息结构如下：

![image-20220718222513508](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718222513508.png)

* LOG_BLOCK_HDR_NO：每一个 block 都有一个大于 0 的唯一标号，这个字段就表示该标号值。

* LOG_BLOCK_HDR_DATA_LEN：表示 block 中已经使用了多少字节，初始值为 12 （因为 log block body 从第 12 个字节处开始），随着往 block 中写入的 redo log 越来也多，本属性值也跟着增长。

  如果 log block body 已经被全部写满，那么本属性的值被设置为 512。

* LOG_BLOCK_FIRST_REC_GROUP：一条 redo log 也可以称之为一条 redo log record，一个 mtr 会生产多条redo log record，这些 redo log record 被称之为一个 redo log record group。

  LOG_BLOCK_FIRST_REC_GROUP 就代表该 block 中第一个 mtr 生成的 redo log record group 的偏移量。

* LOG_BLOCK_CHECKPOINT_NO ：表示所谓的 checkpoint 的序号， checkpoint 是我们后续内容的重点，现在先不用清楚它的意思。

* LOG_BLOCK_CHECKSUM：表示 block 的校验值，用于正确性校验。

#### 1.5.2 log buffer

就像读写数据页一样，写 redo log 也需要缓冲区，称之为 redo log buffer，简称为 log buffer。

和 Buffer Pool 结构类似，这片内存空间被划分成若干个连续的 redo log block ，就像这样：

![image-20220718224222624](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718224222624.png)

我们可以通过启动参数 `innodb_log_buffer_size` 来指定 log buffer 的大小，默认为 16MB。

#### 1.5.3 redo log 写入 log buffer

**向 log buffer 中写入 redo log 的过程是顺序的，也就是先往前边的 block 中写，当该 block 的空闲空间用完之后再往下一个 block 中写**。

当我们想往 log buffer 中写入 redo log 时，第一个遇到的问题就是应该写在哪个 block 的哪个偏移量处，所以 InnoDB 特意提供了一个称之为 buf_free 的全局变量，该变量指明后续写入的 redo log 应该写入到 log buffer 中的哪个位置，如图所示：

![image-20220718224512974](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718224512974.png)

我们前边说过一个 mtr 执行过程中可能产生若干条 redo log，这些 redo log 是一个不可分割的组，所以其实**并不是每生成一条 redo log，就将其插入到 log buffer 中，而是每个 mtr 运行过程中产生的日志先暂时存到一个地方，当该 mtr 结束的时候，将过程中产生的一组 redo log 再全部复制到 log buffer 中**。

### 1.6 redo log 文件

#### 1.6.1 redo log 刷盘时机

redo log 有一些固定的刷盘时机：

* **log buffer 空间不足时**：log buffer 的大小是有限的，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。

  InnoDB 规定如果达到了 log buffer 的一半左右，那么就需要把日志写到磁盘上。

* **事务提交时**：我们之前说过之所以使用 redo log 主要是因为它占用的空间少，而且还是顺序写，因此在事务提交时可以不把修改过的 Buffer Pool 页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的 redo log 刷新到磁盘。

* **后台线程**：和 Buffer Pool 类似，InnoDB 设置了一个后台线程，大约每秒会刷新一次 redo log 到磁盘。

* **正常关闭服务器时**。

* **做 checkpoint 时**（checkpoint 还没讲到，稍后会讲）

* ...

#### 1.6.2 redo log 文件组

**MySQL 的数据目录下默认有两个名为 ib_logfile0 和 ib_logfile1 的文件， log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中**。

如果我们对默认的 redo log 文件不满意，可以通过下边几个启动参数来调节：

* `innodb_log_group_home_dir`：该参数指定了 **redo log 文件所在的目录**，默认值就是当前的数据目录。
* `innodb_log_file_size`：该参数指定了**每个 redo log 文件的大小**，默认值为 48MB。
* `innodb_log_files_in_group`：该参数指定 **redo log 文件的个数**，默认值为 2，最大值为 100。

从上边的描述中可以看到，**磁盘上的 redo log 文件不只一个，而是以一个日志文件组的形式出现的**。这些文件以 ib_logfile[数字] （0 、 1 、 2 ...）的形式进行命名。

在将 redo log 写入日志文件组时，先从 ib_logfile0 开始写；如果 ib_logfile0 写满了，就接着 ib_logfile1 写；同理， ib_logfile1 写满了就去写 ib_logfile2 ，依此类推。

如果最后一个 redo log 也写满了怎么办呢？那就重新转到 ib_logfile0 继续写，所以整个过程如下图所示：

![image-20220718230442736](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718230442736.png)

> 既然是这样循环写入的话，那么岂不是要覆盖掉之前的日志？是的，所以 InnoDB 提出了 checkpoint 的概念，稍后我们详细讲解。

#### 1.6.3 redo log 文件格式

log buffer 本质上是一片连续的内存空间，被划分成了若干个 512 字节大小的 block。那么，将 log buffer中的 redo log 刷新到磁盘的本质就是把 block 的镜像写入日志文件中，所以 redo log 文件其实也是由若干个 512 字节大小的 block 组成。

redo 日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：

* 前 2048 个字节，也就是前 4 个 block 是用来存储一些管理信息的。
* 从第 2048 字节往后是用来存储 log buffer 中的 block 镜像的。

所以，我们前面所说的循环写入，实际上是从每个日志文件的第 2048 个字节开始算起：

![image-20220718230843699](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718230843699.png)

block 的格式大家应该很熟悉了，现在我们来介绍一下日志文件的前 4 个 block：

![image-20220718231036164](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718231036164.png)

* **log file header**：描述该 redo log 文件的一些整体属性。

  它的组成如下：

  ![image-20220718231156637](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718231156637.png)

  | 属性名               | 长度（单位：字节） | 描述                                                         |
  | -------------------- | ------------------ | ------------------------------------------------------------ |
  | LOG_HEADER_FORMAT    | 4                  | redo log 的版本                                              |
  | LOG_HEADER_PAD1      | 4                  | 字节填充用的，没什么实际意义                                 |
  | LOG_HEADER_START_LSN | 8                  | 标记该 redo log 文件开始的 LSN 值                            |
  | LOG_HEADER_CREATOR   | 32                 | 一个字符串，标记该 redo log文件的创建者是谁<BR>正常运行时该值为 MySQL 的版本号，比如： "MySQL 5.7.21" <BR>使用 mysqlbackup 命令创建的 redo log 文件的该值为 "ibbackup" 和创建时间 |
  | LOG_BLOCK_CHECKSUM   | 4                  | 该 block 的校验值                                            |

* **checkpoint1**：记录关于 checkpoint 的一些属性，看一下它的结构：

  ![image-20220718231548331](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718231548331.png)

  | 属性名                      | 长度（单位：字节） | 描述                                                         |
  | --------------------------- | ------------------ | ------------------------------------------------------------ |
  | LOG_CHECKPOINT_NO           | 8                  | 服务器做 checkpoint 的编号，每做一次 checkpoint，该值就加 1  |
  | LOG_CHECKPOINT_LSN          | 8                  | 服务器做 checkpoint 结束时对应的 LSN 值，系统奔溃恢复时将从该值开始 |
  | LOG_CHECKPOINT_OFFSET       | 8                  | 上个属性中的 LSN 值在 redo 日志文件组中的偏移量              |
  | LOG_CHECKPOINT_LOG_BUF_SIZE | 8                  | 服务器在做 checkpoint 操作时对应的 log buffer 的大小         |
  | LOG_BLOCK_CHECKSUM          | 4                  | 该 block 的校验值                                            |

  现在看不懂不要紧，我们之后会详细介绍。

* 没用到的 block，忽略掉。

* **checkpoint2**：和 checkpoint1 一样。

### 1.7 Log Sequence Number（LSN）

自 MySQL 开始运行，就不断的在修改页面，也就意味着会不断的生成 redo log。

redo log 的量在不断的递增，就像人的年龄一样，自打出生起就不断递增，永远不可能缩减了。设计 InnoDB 的大叔为记录已经写入的 redo log，设计了一个称之为 Log Sequence Number（日志序列号，LSN）的全局变量。

不过不像人一出生的年龄是 0 岁，InnoDB 规定初始的 LSN 值为 8704。

我们知道在向 log buffer 中写入 redo log 时不是一条一条写入的，而是以一个 mtr 生成的一组 redo log 为单位进行写入的。而且实际上是把日志内容写在了 log block body 处。但是**在统计 LSN 的增长量时，是按照实际写入的日志量加上占用的 log block header 和 log block trailer 来计算的**。

**每一组由 mtr 生成的 redo log 都有一个唯一的 LSN 值与其对应，LSN 值越小，说明 redo log 产生的越早**。

#### 1.7.1 `flushed_to_disk_lsn`

redo log 是首先写到 log buffer 中，之后才会被刷新到磁盘上的 redo log 文件。所以 **InnoDB 提出了一个称之为 `buf_next_to_write` 的全局变量，标记当前 log buffer 中已经有哪些日志被刷新到磁盘中了**。

画个图表示就是这样：

![image-20220719081744881](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719081744881.png)

我们前边说 LSN 是表示当前系统中写入的 redo 日志量，这包括了写到 log buffer 而没有刷新到磁盘的日志，相应的，InnoDB 提出了一个表示刷新到磁盘中的 redo log 量的全局变量，称之为 `flushed_to_disk_lsn`。系统第一次启动时，该变量的值和初始的 LSN 值是相同的，都是 8704 。随着系统的运行， redo 日志被不断写入 log buffer，但是并不会立即刷新到磁盘，此时 LSN 的值就和 flushed_to_disk_lsn 的值拉开了差距。

#### 1.7.2 LSN 和 redo log 文件偏移量的对应关系

因为 LSN 的值是代表系统写入的 redo log 量的一个总和，一个 mtr 中产生多少日志，LSN 的值就增加多少（当然要加上 log block header 和 log block trailer 的大小），这样 mtr 产生的日志写到磁盘中时，很容易计算某一个 LSN 值在 redo 日志文件组中的偏移量，如图：

![image-20220719082216309](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719082216309.png)

#### 1.7.3 flush 链表中的 LSN

**在 mtr 结束时，除了要把一组 redo log 写入到 log buffer 之外，还需要把修改过的页面加入到 Buffer Pool 的 flush 链表中**。

回顾一下 flush 链表：当第一次修改某个缓存在 Buffer Pool 中的页面时，就会把这个页面对应的控制块插入到 flush 链表的头部，之后再修改该页面时由于它已经在 flush 链表中了，就不再次插入了。

也就是说 flush 链表中的脏页是按照页面的第一次修改时间从大到小进行排序的。在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：

* oldest_modification：如果某个页面被加载到 Buffer Pool 后进行第一次修改，那么就将修改该页面的 mtr 开始时对应的 LSN 值写入这个属性。
* newest_modification：每修改一次页面，都会将修改该页面的 mtr 结束时对应的 LSN 值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统 LSN 值。

### 1.8 checkpoint

刚刚我们也提到了，redo 日志文件组的容量是有限的，我们不得不循环使用 redo log 文件，但是这会造成成最后写的 redo log 把最开始写的 redo log 覆盖的情况。

这时候就要看情况再决定是否覆盖了：

* 如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统奔溃，那么在重启后也不需要使用 redo log 恢复该页面了，所以该 redo log 也就没有存在的必要了。
* 反过来，如果还没有刷新到磁盘，此时一旦你覆盖掉了，那么就意味着这些被覆盖的 redo log 对应的脏页很可能就丢失了，数据的一致性就得不到保证了。

以下面这个例子为例：

![image-20220719085053840](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719085053840.png)

如图，这里有三个 mtr，并且 mtr_1 和 mtr_2 的 redo log 已经被写回到文件中了，但是从 flush 链表的情况可以看出，修改后的脏页还在 flush 链表中，因此此时如果 redo log 满了，作为开头的 mtr_1 和 mtr_2 的 redo log 是不能被覆盖的。

现在，我们假设页面 a 被刷新到了磁盘中，如下图所示：

![image-20220719085308933](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719085308933.png)

这样 mtr_1 生成的 redo 日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。

InnoDB 为了方便知道哪些日志可以覆盖，提出了 `checkpoint_lsn` 这样一个全局变量，来代表当前系统中可以被覆盖的 redo log 总量是多少。

上面的例子中，mtr_1 的页 a 被刷到磁盘中之后，`checkpoint_lsn` 的值就可以增加到 mtr_1 结束时的 LSN 了，我们把这个过程称之为**做一次 checkpoint**。

做一次 checkpoint 其实分两个步骤：

1. **计算一下当前系统中可以被覆盖的 redo log 对应的 LSN 值最大是多少**。

   只要我们计算出当前系统中被最早修改的脏页对应的 oldest_modification 值，那凡是在系统 LSN 值小于该节点的 oldest_modification 值时产生的 redo log 都是可以被覆盖掉的，我们就把该脏页的 oldest_modification 赋值给 `checkpoint_lsn`。

   在上面的例子中，当前系统中页 a 已经被刷新到磁盘，那么 flush 链表的尾节点就是页 c ，该节点就是当前系统中最早修改的脏页了，它的 oldest_modification 值为 8916，我们就把 8916 赋值给 `checkpoint_lsn`，也就是说在 redo log 对应的 LSN 值小于 8916 时就可以被覆盖掉。

2. 将` checkpoint_lsn` 和对应的 redo 日志文件组偏移量以及此次 checkpint 的编号**写到日志文件的管理信息（就是 checkpoint1 或者 checkpoint2 ）中**。

   InnoDB 维护了一个目前系统做了多少次 checkpoint 的变量 checkpoint_no，每做一次 checkpoint ，该变量的值就加 1。

   我们前边说过计算一个 lsn 值对应的 redo 日志文件组偏移量是很容易的，所以可以计算得到该 checkpoint_lsn 在 redo 日志文件组中对应的偏移 checkpoint_offset ，然后把这三个值都写到 redo 日志文件组的管理信息中。

   我们说过，每一个 redo log 文件都有 2048 个字节的管理信息，但是**上述关于 checkpoint 的信息只会被写到日志文件组的第一个日志文件的管理信息中**。

   不过，我们有两个 checkpoint block，我们到底是存储到 checkpoint1 中还是 checkpoint2 中呢？InnoDB 规定，**当 checkpoint_no 的值是偶数时，就写到 checkpoint1 中，是奇数时，就写到 checkpoint2 中**。

#### 1.8.1 批量从 flush 链表写回脏页

我们在介绍 Buffer Pool 的时候说过，一般情况下都是后台的线程在对 LRU 链表和 flush 链表进行刷新脏页的操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。

但是如果当前系统修改页面的操作十分频繁，这样就导致写日志操作十分频繁，系统 LSN 值增长过快。如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做 checkpoint ，可能就需要用户线程同步的从 flush 链表中把那些最早修改的脏页（oldest_modification 最小的脏页）刷新到磁盘，这样这些脏页对应的 redo log 就没用了，然后就可以去做 checkpoint 了。

### 1.9 `innodb_flush_log_at_trx_commit`

我们前边说为了保证事务的持久性 ，**用户线程在事务提交时需要将该事务执行过程中产生的所有 redo log 都刷新到磁盘上**。

这一条要求其实比较影响性能，因为一个事务所做的修改涉及到的页面可能很多，redo log 也会很多，这样会很明显的降低数据库性能。

如果有的同学对事务的持久性要求不是那么强烈的话，可以选择**修改一个称为 `innodb_flush_log_at_trx_commit` 的系统变量的值，它决定了事务提交时时 redo log 的刷新策略**，该变量有 3 个可选的值：

* 0：当该系统变量值为 0 时，表示**在事务提交时不立即向磁盘中同步 redo log，这个任务完全交给后台线程**。

  这样虽然会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将 redo log 刷新到磁盘，那么该事务对页面的修改会丢失。

* 1：当该系统变量值为 1 时，表示**在事务提交时需要将 redo log 立即同步到磁盘，可以保证事务的持久性**。（默认值）

* 2：当该系统变量值为 2 时，表示**在事务提交时需要将 redo log 写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘**。

  这种情况下如果数据库挂了，操作系统没挂的话，事务的持久性还是可以保证的，但是**操作系统也挂了的话，那就不能保证持久性了**。

### 1.10 崩溃恢复

说了这么多遍 redo log 可以用来崩溃恢复，那么它到底是怎么恢复的呢？

崩溃恢复主要有三个步骤：

1. **确定恢复的起点**：我们之前说过，checkpoint_lsn 之前的 redo log 都可以被覆盖，我们就没必要恢复它们了；而对于 checkpoint_lsn 之后的 redo log，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要**从 checkpoint_lsn 开始读取 redo log 来恢复页面**。

   由于存在 checkpoint1 和 checkpoint2，我们当然是要从中选取最近发生的那次 checkpoint 的信息。

2. **确定恢复的终点**：redo log 恢复的起点确定了，那终点是哪个呢？这个还得从 block 的结构说起。我们说在写 redo log 的时候都是顺序写的，写满了一个 block 之后会再往下一个 block 中写。

   而 block 的 log block header 部分有一个称之为 LOG_BLOCK_HDR_DATA_LEN 的属性，该属性值记录了当前 block 里使用了多少字节的空间：

   * 对于被填满的block来说，该值永远为 512 。
   * 如果该属性的值不为 512 ，那么意味着该 block 没有填满，因此它就是此次奔溃恢复中需要扫描的最后一个 block。

3. **执行恢复**：我们看一个例子：

   ![image-20220719091937120](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719091937120.png)

   由于 redo 0 在 checkpoint_lsn 后边，恢复时可以不管它。我们现在可以按照 redo log 的顺序依次扫描 checkpoint_lsn 之后的各条 redo log，按照日志中记载的内容将对应的页面恢复出来。

   InnoDB 觉得这样比较慢，因此还是想了一些办法加快这个恢复的过程：

   * **使用哈希表**：根据 redo log 的 space ID 和 page number 属性计算出散列值，把 space ID 和 page number 相同的 redo log 放到哈希表的同一个槽里，如果有多个 space ID 和 page number 都相同的 redo log，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，如图所示：

     ![image-20220719092100266](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719092100266.png)

     之后就可以遍历哈希表，因为**对同一个页面进行修改的 redo log 都放在了一个槽里，所以可以一次性将一个页面修复好**，避免了很多读取页面的随机 I/O。

     但是需要注意的是：同一个页面的 redo log 是按照生成时间顺序进行排序的，所以恢复的时候也是按照这个顺序进行恢复。

   * **跳过已经刷新到磁盘的页面**：对于 checkpoint_lsn 之后的 redo log，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，因此实际上之后有一些页被刷盘了的话我们是可以跳过这些页的。

     那么怎么判断呢？这就要回到页面的结构了，页面的 File Header 部分有一个 FIL_PAGE_LSN 的属性，它记录了最近一次修改页面时对应的  LSN 值，**如果在做了某次 checkpoint 之后有脏页被刷新到磁盘中，那么该页对应的 FIL_PAGE_LSN 代表的 LSN 值肯定大于 checkpoint_lsn 的值**。

## 2. undo log

### 2.1 事务回滚的需求

我们说过事务需要保证原子性 ，也就是事务中的操作要么全部完成，要么什么也不做。

但是偏偏有时候事务执行到一半会出现一些情况，比如：

* 情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。

* 情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前的事务的执行。

这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为回滚（rollback），这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。

和保证持久性类似，**为了保证能够回滚，我们也需要把回滚时所需的东西记录下来**，比如：

* 你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。
* 你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。
* 你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
* ...

**InnoDB 把这些为了回滚而记录的这些东西称之为撤销日志（undo log）**。特别需要注意的是，由于查询操作（ SELECT ）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的 undo log。

### 2.2 事务 ID

#### 2.2.1 给事务分配 ID 的时机

如果某个事务执行过程中对某个表执行了增、删、改操作，那么 InnoDB 存储引擎就会给它分配一个独一无二的事务 ID，分配方式如下：

* 对于只读事务来说，只有在它第一次对某个**用户创建的临时表**执行增、删、改操作时才会为这个事务分配一个事务 ID，否则的话是不分配事务 ID 的。
* 对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务 ID，否则的话也是不分配事务 ID 的。

有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个事务 ID。

#### 2.2.2 事务 ID 的生成机制

事务 ID 本质上就是一个数字，它的分配策略和我们前边提到的对隐藏列 row_id （当用户没有为表创建主键和 UNIQUE 键时 InnoDB 自动创建的列）的分配策略大抵相同，具体策略如下：服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务 ID 时，就会把该变量的值当作事务 ID 分配给该事务，并且把该变量自增 1。

每当这个变量的值为 256 的倍数时，就会将该变量的值刷新到系统表空间的页号为 5 的页面中一个称之为 Max Trx ID 的属性处，这个属性占用 8 个字节的存储空间。

当系统下一次重新启动时，会将上边提到的 Max Trx ID 属性加载到内存中，将该值加上 256 之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于 Max Trx ID 属性值）。这样就可以保证整个系统中分配的事务 ID 值是一个递增的数字。先被分配 ID 的事务得到的是较小的事务 ID，后被分配 ID 的事务得到的是较大的事务 ID。

#### 2.2.3 trx_id 隐藏列

我们前边说 InnoDB 记录行格式的时候重点强调过：聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为 trx_id、roll_pointer 的隐藏列，如果用户没有在表中定义主键以及 UNIQUE 键，还会自动添加一个名为 row_id 的隐藏列。

所以一条记录在页面中的真实结构看起来就是这样的：

![image-20220719224949348](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719224949348.png)

其中的 trx_id 列其实还蛮好理解的，就是某个对这个聚簇索引记录做改动的语句所在的事务对应的事务 ID（此处的改动可以是 INSERT、DELETE、UPDATE 操作）。

### 2.3 undo log 的格式



## 3. bin log
