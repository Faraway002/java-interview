# Redis 持久化

Redis 是内存型数据库，为了保证数据在宕机后不会丢失，需要将内存中的数据持久化到硬盘上。

Redis 支持两种持久化方式：RDB 和 AOF。

- RDB：RDB 即**快照**方式，它将某个时间点的所有 Redis 数据保存到一个经过压缩的二进制文件（RDB 文件）中。
- AOF：AOF（Append Only File）是以文本日志形式**将所有写命令追加到 AOF 文件的末尾**，以此来记录数据的变化。当服务器重启的时候会重新载入和执行这些命令来恢复原始的数据。

## AOF

试想一下，如果 Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，这不就相当于恢复了缓存数据了吗？

![image-20220510144832753](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220510144832753.png)

这种保存写操作命令到日志的持久化方式，就是 Redis 里的 **AOF（Append Only File）**的做法。

注意，AOF 只会记录写操作命令，读操作命令是不会被记录的，因为对于数据保存没有任何意义。

在 Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 `redis.conf` 配置文件中的以下参数：

```conf
appendonly yes   				 // 是否开启，默认 no
appendfilename "appendonly.aof"  // 文件名称
```

AOF 日志文件其实就是普通的文本，我们可以通过 `cat` 命令查看里面的内容，不过里面的内容如果不知道一定的规则的话，可能会看不懂，以 `SET name abc` 为例，它的 AOF 记录如下：

```
*3
$3
set
$4
name
$7
abc
```

它的含义是：*3 表示这个 AOF 有三个部分，每部分都是以`$ + 数字` 开头，后紧跟具体的命令、键或者值。这里的数字表示这部分中的命令、键或值一共有多少字节。

**Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里**，这么做其实有两个好处：

* **避免额外的检查开销**。

  如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，假设当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。

  而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。

* **不会阻塞当前写操作命令的执行**。

当然，AOF 也是有风险的：

* 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有**丢失的风险**。
* 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是**可能会给下一个命令带来阻塞风险**。

**缺点**也是有的，那就是**恢复数据比较慢**，因为要从文本文件中解析命令。

### AOF 的写回策略

AOF 使用一些写回策略来解决上面提到的两个风险。

首先，AOF 的整体流程如下：

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220510151952367.png" alt="image-20220510151952367" style="zoom: 67%;" />

1. Redis 执行完写操作命令后，会将命令追加到 `server.aof_buf` **缓冲区**；
2. 然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；
3. 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。

Redis 提供了 3 种写回硬盘的策略就是用于控制写回硬盘（第三步）的时机：

- **always**：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；
- **everysec**：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；
- **no**：不由 Redis 控制写回硬盘的时机，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。

这可以在 `redis.conf` 配置文件中的 `appendfsync` 配置中配置。

这 3 种写回策略都无法能完美解决主进程阻塞和减少数据丢失的问题，因为这两个问题是对立的，偏向于一边的话，就会要牺牲另外一边，原因如下：

- always 策略的话，可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能；
- no 策略的话，是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。
- everysec 策略的话，是折中的一种方式，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。

总结如下表：

| 写回策略 | 写回时机               | 优点                             | 缺点                               |
| -------- | ---------------------- | -------------------------------- | ---------------------------------- |
| always   | 同步写回               | 高可靠性，最大程度保证数据不丢失 | 每个写命令都要写回硬盘，性能开销大 |
| everysec | 每秒写回               | 性能和可靠性都适中               | 宕机时会丢失 1s 内的数据           |
| no       | 由操作系统控制写回时机 | 高性能                           | 宕机时丢失的数据可能会比较多       |

实际上，AOF 写回策略仅仅是控制 `fsync()` 系统调用的调用时机，这个函数会确保一直到写磁盘操作结束才会返回，所以当你的程序使用这个函数并且它成功返回时，就说明数据肯定已经安全的落盘了。

- always 策略就是每次写入 AOF 文件数据后，就执行 `fsync()`
- everysec 策略就会创建一个异步任务来执行 `fsync()` 
- no 策略就是永不执行 `fsync()`

### AOF 重写机制

AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大，这会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。

Redis 为了避免 AOF 文件越写越大，提供了 **AOF 重写机制**：当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。

#### AOF 后台重写

写入 AOF 日志的操作虽然是在主进程完成的，因为它写入的内容不多，所以一般不太影响命令的操作。

但是**在触发 AOF 重写时**，这时是需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，重写完后，就把现在的 AOF 文件替换掉，**这个过程其实是很耗时的，所以重写的操作不能放在主进程里**。

Redis 的**重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的**，这么做可以达到两个好处：

- 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；

- 子进程带有主进程的数据副本。

  这里使用子进程而不是线程，因为如果是使用线程，**多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全**，而这样就会降低性能。

  而使用子进程，创建子进程时，**父子进程是共享内存数据的**，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生**写时复制**，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。

触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。

但是子进程重写过程中，主进程依然可以正常处理命令。

如果此时**主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的**。

所以如果这个阶段修改的是一个 bigkey，也就是数据量比较大的 key-value 的时候，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。

还有个问题，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在**子进程的内存数据就跟主进程的内存数据不一致**了，这时要怎么办呢？

为了解决这种数据不一致问题，Redis 设置了一个 **AOF 重写缓冲区**，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。

在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会**同时将这个写命令写入到 AOF 缓冲区和 AOF 重写缓冲区**：

![image-20220510200455770](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220510200455770.png)

也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:

- 执行客户端发来的命令；
- 将执行后的写命令追加到 AOF 缓冲区；
- 将执行后的写命令追加到 AOF 重写缓冲区；

当子进程完成 AOF 重写工作（扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。

主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：

- **将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中**，使得新旧两个 AOF 文件所保存的数据库状态一致；
- 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。

信号函数执行完后，主进程就可以继续像往常一样处理命令了。

在整个 AOF 后台重写过程中，除了**发生写时复制会对主进程造成阻塞**，还有**信号处理函数执行时也会对主进程造成阻塞**，在其他时候，AOF 后台重写都不会阻塞主进程。

## RDB

**RDB 即快照方式，它将某个时间点的所有 Redis 数据保存到一个经过压缩的二进制文件（RDB 文件）中**。

所谓快照，就是记录某一个瞬间当前数据库中所有的内容，比如当我们给风景拍照时，那一个瞬间的画面和信息就记录到了一张照片。所以，**RDB 快照就是记录某一个瞬间的内存实际数据**，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。

也正因如此，在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。

### 使用方式

有两个 Redis 命令可以用于生成 RDB 文件：`SAVE` 和 `BGSAVE`。

- `SAVE`命令会**阻塞** Redis 服务器进程，直到 RDB 创建完成为止，在阻塞期间，服务器不能响应任何命令请求。

- `BGSAVE` 命令会派生出（fork）一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理命令请求。

  `BGSAVE` 命令执行期间，`SAVE`、`BGSAVE`、`BGREWRITEAOF` 三个命令会被拒绝，以免与当前的 `BGSAVE` 操作产生竞态条件，降低性能。

RDB 文件的**加载工作是在服务器启动时自动执行的**，Redis 并没有提供专门用于加载 RDB 文件的命令。

Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 `BGSAVE` 命令，默认会提供以下配置：

```bash
save 900 1     # 900 秒之内，对数据库进行了至少 1 次修改
save 300 10    # 300 秒之内，对数据库进行了至少 10 次修改
save 60 10000  # 60 秒之内，对数据库进行了至少 10000 次修改
```

别看选项名叫 sava，实际上执行的是 `BGSAVE` 命令，也就是会创建子进程来生成 RDB 快照文件。

快照是一个比较重量级的操作，**如果频率太频繁，可能会对 Redis 性能产生影响；如果频率太低，服务器故障时，丢失的数据会更多**。

### RDB的快照原理

执行 `BGSAVE` 命令的时候，会通过 `fork()` 创建子进程，这一点和 AOF 的后台重写机制是类似的，关键都在于 `fork()` 的写时复制，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，只有在发生修改内存数据的情况时，物理内存才会被复制一份。

写时复制的目的是为了减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。

所以，创建 `BGSAVE` 子进程后，由于共享父进程的所有内存数据，于是就可以直接读取主线程（父进程）里的内存数据，并将数据写入到 RDB 文件。

如果父进程要**修改共享数据里的某一块数据**时，就会发生写时复制，于是这块数据的**物理内存就会被复制一份**，然后**主线程在这个数据副本进行修改操作**。与此同时，**`BGSAVE` 子进程可以继续把原来的数据写入到 RDB 文件**。

细心的读者肯定发现了，`BGSAVE` 快照过程中，如果父进程修改了共享数据，**发生了写时复制后**，RDB 快照保存的是原本的内存数据，而**父进程刚修改的数据，是被办法在这一时间写入 RDB 文件的**，只能交由下一次的 `BGSAVE` 快照。

所以 **Redis 在使用 `BGSAVE` 快照过程中，如果父进程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入父进程刚修改的数据**，因为此时父进程的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。

如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失父进程在快照期间修改的数据。

## AOF 和 RDB 混合使用

我们刚刚分析了 AOF 和 RDB 的原理及其各自的优缺点，有没有什么方法不仅有 RDB 恢复速度快的优点又有 AOF 丢失数据少的优点呢？

当然有，那就是将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫**混合使用 AOF 日志和内存快照**，也叫混合持久化。

如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：

```bash
aof-use-rdb-preamble yes
```

当开启了混合持久化时，在 AOF 重写日志时，`fork` 出来的重写子进程会先将与主线程共享的内存数据**以 RDB 方式写入到 AOF 文件**，然后**主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件**。

也就是说，使用了混合持久化，AOF 文件的**前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据**：

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220510213827477.png" alt="image-20220510213827477" style="zoom:67%;" />

这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样**加载的时候速度会很快**。

加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得**数据更少的丢失**。