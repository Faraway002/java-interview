# MySQL 事务

## 什么是事务？

**事务就是一组原子性的 SQL 语句**。具体来说，事务指的是满足 ACID 特性的一组操作。**事务内的 SQL 语句，要么全执行成功，要么全执行失败**。

![image-20220402180641688](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220402180641688.png)

### 使用事务

MySQL 中，使用 `START TRANSACTION` 语句开始一个事务；使用 `COMMIT` 语句提交所有的修改；使用 `ROLLBACK` 语句撤销所有的修改。

不能回退 `SELECT` 语句，回退 `SELECT` 语句也没意义，也不能回退 `CREATE` 和 `DROP` 语句。

- `START TRANSACTION`：指令用于标记事务的起始点。
- `SAVEPOINT`：指令用于创建保留点。
- `ROLLBACK TO`：指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 `START TRANSACTION` 语句处。
- `COMMIT`：提交事务。

### AUTOCOMMIT

MySQL 默认采用**隐式提交策略（`autocommit`）**：每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。

通过 `set autocommit = 0` 可以取消自动提交，直到 `set autocommit = 1` 才会提交；`autocommit` 标记是针对每个连接而不是针对服务器的。

## 事务的 ACID 特性

ACID 是四个单词的缩写：

* **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；

* **一致性（Consistency）**：数据库的完整性不会因为事务的执行而受到破坏。

  比如表中有一个字段为姓名，它有唯一约束，也就是表中姓名不能重复，如果一个事务对姓名字段进行了修改，但是在事务提交后，表中的姓名变得非唯一性了，这就破坏了事务的一致性要求，这时数据库就要撤销该事务，返回初始化的状态。

* **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

  并发事务是十分常见的，数据库专门为该特性设置了**隔离级别**。

* **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？

- 持久性是通过 redo log（重做日志）来保证的。
- 原子性是通过 undo log（回滚日志）来保证的。
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的。
- 一致性则是通过持久性 + 原子性 + 隔离性来保证。

我们将在 MySQL 日志和 MySQL 锁中详细讲解实现。

## 并发事务带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）:** 如果一个事务**读到了另一个未提交事务修改过的数据**，就意味着发生了脏读现象。

  如下图所示：

  ![image-20220402182142665](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220402182142665.png)

- **不可重复读（Unrepeatableread）:** 在一个事务内多次读取同一个数据，如果出现**前后两次读到的数据不一样的情况**，就意味着发生了不可重复读现象。

  如下图所示：

  ![image-20220402182225635](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220402182225635.png)

- **幻读（Phantom read）:** 在一个事务内多次查询某个符合查询条件的记录数量，如果出现**前后两次查询到的记录数量不一样的情况**，就意味着发生了幻读现象。

  ![image-20220402182715453](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220402182715453.png)

这三个现象的严重性排序如下：

![图片](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/d37bfa1678eb71ae7e33dc8f211d1ec1.png)

## 事务的隔离级别

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（read uncommitted）**：指一个事务还没提交时，它做的变更就能被其他事务看到。
- **读提交（read committed）**：指一个事务提交之后，它做的变更才能被其他事务看到。
- **可重复读（repeatable read）**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，这是**MySQL InnoDB 引擎的默认隔离级别**。
- **串行化（serializable）**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

按隔离水平高低排序如下：

![图片](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/cce766a69dea725cd8f19b90db2d0430.png)

针对不同的隔离级别，并发事务时可能发生的现象也会不同。

![图片](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/4e98ea2e60923b969790898565b4d643.png)

InnoDB 引擎的默认隔离级别虽然是可重复读，但是它通过 next-key lock（行锁和间隙锁的组合）来锁住记录之间的间隙和记录本身，**防止其他事务在这个记录之间插入新的记录**，这样就避免了幻读现象。

### 隔离级别的实现

- 对于**读未提交**隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以**直接读取**最新的数据就好了；

- 对于**串行化**隔离级别的事务来说，通过**加读写锁**的方式来避免并行访问；

- 对于读提交和可重复读隔离级别的事务来说，它们是通过 MVCC 的 **Read View** 来实现的，它们的区别在于创建 Read View 的时机不同。

  Read View 可以被理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。

  * 读已提交隔离级别是在每个语句执行前都会重新生成一个 Read View。
  * 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。

