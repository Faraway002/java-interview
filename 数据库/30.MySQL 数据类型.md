# MySQL 数据类型

## 整型

`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT` 分别使用 `8`, `16`, `24`, `32`, `64` 位存储空间，一般情况下越小的列越好。

**`UNSIGNED` 表示不允许负值，大致可以使正数的上限提高一倍**。

`INT(11)` 中 **`()` 里的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的**。

`BOOLEAN` 和 `BOOL` 类型等价于 `TINYINT(1)`。

## 浮点型

`FLOAT` 和 `DOUBLE` 为浮点类型。**`DECIMAL` 类型主要用于精确计算，代价较高，应该尽量只在对小数进行精确计算时才使用 `DECIMAL` ——例如存储财务数据**。数据量比较大的时候，可以使用 `BIGINT` 代替 `DECIMAL`。

`FLOAT`、`DOUBLE` 和 `DECIMAL` 都可以指定列宽，例如 `DECIMAL(18, 9)` 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

## 字符串

主要有 `CHAR` 和 `VARCHAR` 两种类型，一种是定长的，一种是变长的。

**`VARCHAR` 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长**。当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

**`VARCHAR` 会保留字符串末尾的空格，而 `CHAR` 会删除。**

### 二进制数据

二进制数据也是属于字符串的，一般有 `BINARY` 和 `VARBINARY`，这和 `CHAR`、`VARCHAR` 是类似的。

### BLOB 和 TEXT

`BLOB` 和 `TEXT` 都是为了存储大的数据而设计，**前者存储二进制数据**，**后者存储字符串数据**。

**不能对 `BLOB` 和 `TEXT` 类型的全部内容进行排序、索引**。

### JSON

MySQL 5.7.8 版本之后原生支持 JSON 类型，可以更有效地存储和管理JSON文档。 本机JSON数据类型提供JSON文档的自动验证和最佳存储格式。

## 时间和日期

MySQL 提供日期和时间的类型以及日期和时间的组合，此外，MySQL 还支持**时间戳**数据类型，用于跟踪表的一行中的更改。

* `DATE` 表示 `YYYY-MM-DD` 形式的日期。

* `TIME` 表示 `hh:mm:ss` 形式的时间。
* `DATETIME` 则等价于 `DATE + TIME`，即表示 `YYYY-MM-DD hh:mm:ss` 形式的日期与时间。
* `TIMESTAMP` 则是 `YYYY-MM-DD hh:mm:ss`格式的时间戳。

`TIMESTAMP` 和 `DATETIME` 的区别在于：

* `DATETIME` 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 **8 字节**的存储空间。

* `TIMESTAMP` 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 **4 个字节**，只能表示从 1970 年 到 2038 年。

  它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。

## 类型选择技巧

- **整数类型通常是标识列最好的选择**，因为它们很快并且可以使用 `AUTO_INCREMENT`。
- `ENUM` 和 `SET` 类型通常是一个糟糕的选择，应尽量避免。
- 应该尽量避免用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。对于 `MD5`、`SHA`、`UUID` 这类随机字符串，由于比较随机，所以可能分布在很大的空间内，导致 `INSERT` 以及一些 `SELECT` 语句变得很慢。
  - 如果存储 UUID ，应该移除 `-` 符号；更好的做法是，用 `UNHEX()` 函数转换 UUID 值为 16 字节的数字，并存储在一个 `BINARY(16)` 的列中，检索时，可以通过 `HEX()` 函数来格式化为 16 进制格式。