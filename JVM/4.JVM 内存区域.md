[TOC]

# JVM 内存区域

使用 Java 的开发者不需要手动管理内存，**JVM 会自动管理内存，但是这并不意味着 Java 不会出现内存泄漏等错误**，而且一旦出现了错误，对于不了解 JVM 是如何使用内存的程序员来说，排查和修正错误会是一项极为艰难的工作。

本章将会详细介绍 JVM 内存的各个区域，讲解这些区域的作用、服务对象以及可能产生的问题。

## 1. 运行时数据区

**JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域**。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。

根据《Java 虚拟机规范》中的说法，运行时数据区可以分为公有和私有两部分：

* 公有部分指的是所有线程都共享的部分，包括：Java 堆、方法区、运行时常量池。
* 私有部分指的是每个线程的私有数据，包括：程序计数器（PC）、Java 虚拟机栈、本地方法栈。

如下图所示：

![image-20220407160033119](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220407160033119.png)

为什么要特意标明这是 JDK 1.6 的内存布局呢？这是因为 1.8 有一个比较大的变化：

![image-20220407160153194](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220407160153194.png)

### 1.1 线程私有部分

#### 1.1.1 程序计数器

程序计数器（Program Counter）是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，很接近于 CPU 中 PC 的概念。

字节码解释器工作时通过**改变这个计数器的值**来选取下一条需要执行的字节码指令；分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储**。

注意：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，同时也不存在 GC，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

> **本地方法会使用 JVM 里的程序计数器吗？**
>
> 如果线程正在执行的是一个 Java 方法，那么我们知道这个计数器记录的是正在执行的虚拟机字节码指令的地址。
>
> 事实上，**如果正在执行的是本地方法，这个计数器值则为空**。

#### 1.1.2 虚拟机栈

虚拟机栈也是线程私有，类似于进程内存空间的栈，它的生命周期和线程相同，**描述的是 Java 方法执行的内存模型**，每次方法调用的数据都是通过栈传递的。

**每个 Java 方法在执行的同时都会创建一个栈帧**（Stack Frame）用于存储**局部变量表**、**操作数栈**、**动态链接**、**返回地址**等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220406162823751.png" alt="image-20220406162823751" style="zoom: 80%;" />

栈帧的结构介绍如下：

- **局部变量表**：局部变量表是变量值的存储空间，调用方法时传递的参数以及在方法内部创建的局部变量都保存在局部变量表中。

  在 Java 编译成 class 文件的时候，就会在方法的 Code 属性表中的 `max_locals` 数据项中，确定该方法需要分配的最大局部变量表的容量。

- **操作数栈**：虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。

  同局部变量表一样，操作数栈的最大深度也在编译的时候写入方法的 Code 属性表中的 `max_stacks` 数据项中。

  > **栈顶缓存**
  >
  > 由于虚拟机会频繁的和操作数栈打交道，因此 JVM 会将栈顶元素（或栈顶周边）元素缓存到物理 CPU 的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。

- **动态链接**：每个栈帧都包含一个指向运行时常量池（方法区中的一部分）中该栈帧所属**方法的引用**。持有这个引用是为了支持方法调用过程中的动态链接。

  类文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析；另一部分将在每一次的运行期间转化为直接引用，这部分称为动态链接。

- **返回地址（方法出口）**：一个方法开始之后，只有两种方式可以退出这个方法：

  - 正常退出：指方法中的代码正常完成，或者遇到任意一个方法返回的字节码指令（如 return）并退出，没有抛出任何异常
  - 异常退出：指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法提出。

  不管是什么方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行。虚拟机栈中的返回地址就是用来帮助当前方法恢复它的上层方法执行状态。

Java 虚拟机栈会出现两种错误：

- **`StackOverFlowError`：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- **`OutOfMemoryError`：** Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

> **虚拟机栈中的局部变量一定线程安全吗？**
>
> 答案是**不一定**。看下面的例子：
>
> ```java
> public void method1() {
>        StringBuilder sb = new StringBuilder();
> 
>        sb.append(1);
>        sb.appebd(2);
> 
>        return;
> }
> ```
>
> 上面这个方法中，sb 只在该方法内部使用，因此是线程安全的。
>
> 再看下面的例子：
>
> ```java
> public void method1(StringBuilder sb) {
> 
>        sb.append(1);
>        sb.appebd(2);
> 
>        return;
> }
> 
> public StringBuilder method2() {
>        StringBuilder sb = new StringBuilder();
> 
>        sb.append(1);
>        sb.appebd(2);
> 
>        return sb;
> }
> ```
>
> 这两个方法中 sb 都不一定是线程安全的，因为局部变量从方法中**逃逸**出去了，在方法的外部也有可能被其他线程使用，因此不一定是线程安全的。
>
> 虚拟机中的后端编译器会对这种情况进行分析，叫做**逃逸分析**。
>
> 总结：**如果变量是在方法内部产生并且在内部消亡的，那么它就是线程安全的**。

#### 1.1.3 本地方法栈

本地方法栈（Native Method Stack） 与虚拟机栈的作用相似。

二者的区别在于：**虚拟机栈为 Java 方法服务；本地方法栈为本地方法服务**。

本地方法并不是用 Java 实现的，而是由 C/C++ 实现的，而且，本地方法栈也会抛出 `StackOverflowError` 异常和 `OutOfMemoryError` 异常。

在 Hotspot 虚拟机中，本地方法栈和 Java 虚拟机栈合二为一。

### 1.2 线程公有部分

这块空间的详细分配如下图所示：

![image-20220407160735319](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220407160735319.png)

#### 1.2.1 堆

**Java 堆（Java Heap） 的作用就是存放对象实例，几乎所有的对象实例都是在这里分配内存**。

也有部分小型对象会直接在栈里进行分配，这种现象称之为**栈上分配**。

> **栈上分配**
>
> Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。
>
> 从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

> **为什么对象几乎都分配在堆上，而基本数据类型都分配在栈中？**
>
> * 堆通常比栈要大，但是栈的运算速度更快。将复杂数据类型放在堆上是为了不影响栈的效率。
>
> * 对象的大小通常不能确定，而基本类型能够确定下来（对象的引用也能够确定下来）。

Java 堆是垃圾收集的主要区域，因此也被叫做 **GC 堆**。

为了加快分配，**虚拟机会把堆划分出多个线程私有的分配缓冲区**（Thread Local Allocate Buffer，TLAB），以提升对象分配时的效率。

从分代的角度，虚拟机把 Java 堆分成以下两块内存分别代表两个代：

- **新生代**（Young Generation），新生代又包括三个区域：

  - Eden
  - From Survivor，也叫 S0 区
  - To Survivor，也叫 S1 区

  当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。

  大部分情况，**对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1**，这个年龄阈值可以通过 `-XX:MaxTenuringThreshold` 选项来指定。

  Eden : From Survivor : To Survivor 的大小占比为 8 : 1 : 1，这是根据大量统计得出的结果：**80% 的对象存活时间都很短**。

- **老年代**（Old Generation）：当对象的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。

  老年代和新生代的比例通常是 2 : 1，再根据之前介绍的新生代内部的比例，假设我们有 600 MB 的堆内存，那么，老年代将是 400 M，新生代将为 200 M，在新生代中，Eden 区是 160 M，两个 Survivor 各占 20 M。

堆并不需要连续的内存，但是应该被视为一块连续的内存，并且可以动态扩展其内存，如果扩展失败，则会抛出 `OutOfMemoryError` 异常。

#### 1.2.2 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于**存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的是与堆区分开来。

在 Java 1.7 以前，Hotspot 将方法区实现为永久代。很多人都会分不清方法区和永久代的关系，事实上，《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。**方法区和永久代的关系很像 Java 中接口和类的关系，永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式**。这也就是说，永久代是 HotSpot 的概念，其他的虚拟机实现并没有永久代这一说法。

之所以 HotSpot 将方法区实现为永久代，是因为 HotSpot 希望能够像管理堆一样管理永久代，省去专门为方法编写内存管理的代码。但是使用永久代实现方法区并不是一个好主意，这是因为整个永久代有一个 JVM 本身设置的固定大小上限，这导致了 Java 程序更容易出现内存溢出。

JDK 7 时，HotSpot 已经把原本放在永久代的**字符串常量池**、**静态变量**等移出放到堆中，而到了 JDK 8，则完全废弃了永久代的概念，改用**元空间**（MetaSpace），并且把 JDK 7 中永久代剩余的内容（主要是**类型信息**）全部移到元空间中。

**元空间使用的是本地内存**，这意味着只要本地内存足够，就不会出现 OOM。

如果方法区无法满足新的内存分配请求时，将抛出 `OutOfMemoryError`。

##### 1.2.2.1 运行时常量池

**运行时常量池是方法区的一部分。**Class 文件中的**常量池表会在类加载后被放入这个区域**。

运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备**动态性**，也就是说，**运行期间也可以将新的常量放入池中**，例如 `String` 类的 `intern()`。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OOM。

JDK 1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。

### 1.3 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。

JDK 1.4 中新加入的 NIO 包可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 `DirectByteBuffer` 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

**本机直接内存的分配不会受到 Java 堆的限制**，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 2. 对象在 Java 堆中的分配、布局和访问过程

### 2.1 对象的创建

之前我们谈过类加载的过程，当类的初始化结束后，一旦碰到一个 `new` 之类的创建对象的指令，就会开始对象的创建。

* JVM 会为新生对象分配内存，实际上等同于在堆内存中划分一块出来给对象。

  * 假设内存是绝对规整的，即所有被使用的内存放在一边，未使用的内存放在另一边，中间则是放了一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间方向挪动一段，这种分配方式称作**指针碰撞**。
  * 如果不是规整的，则虚拟机必须维护一个**空闲列表**，记录哪些空间可用。

  具体采用哪种分配方式由**所采用的垃圾收集器是否带有空间压缩整理**的能力决定。

* 除了分配内存的策略，还必须考虑分配时并发的问题。**创建对象是非常频繁的动作，并发情况下并不一定是线程安全的**。

  * 一种方法是堆分配内存空间的动作进行同步（一般采用 CAS）。
  * 另一种方法是使用 **TLAB**，因为**是线程独有的**，所以不用同步。只有在 TLAB 用完之后才需要同步。

* 内存分配完成后，虚拟机必须将分配到的内存空间初始化为类型的初始值。注意这里是类实例变量，而类加载过程中的准备阶段是类变量。
* 接下来，JVM 还必须为对象进行必要的设置。比如这个对象是哪个类的实例、如何才能找到类的元信息、对象的哈希码、对象的 GC 分代年龄等。
* 执行类的 `<init>` 方法，这和 `<clinit>` 是类似的，不同的是 `<clinit>` 是针对类的，`<init>` 是针对实例的。`<init>` 实际上就是构造方法。

* 最后，把实例的引用放入栈中即可完成对象的创建。

### 2.2 对象的内存布局

在 HotSpot 中，对象在堆内存中的布局可以分为三个部分：

* 对象头。对象头包括两类信息：

  1. 对象自身**运行时数据**，比如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。

     这部分在 32 位和 64 位虚拟机中分配占用 32 位和 64 位，官方称之为 `Mark Word`。考虑到虚拟机的空间效率，`Mark Word` 被设计为动态的数据结构，以便在小空间下存储尽量多的数据，根据对象的状态复用自己的存储空间。

     根据锁状态的不同，存储的数据也不一样：

     ![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220302132048922.png)

  2. **类型指针**，指向它的类型元数据的指针。

* 实例数据。实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在本类中定义的都必须存储起来。

* 对齐填充。这部分不是必须存在的，它仅用于进行 8 字节的对齐。

### 2.3 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：

1. 使用**句柄**。如果使用此方法，那么 Java 堆中将会划分出一块内存来作为句柄池，**reference 中存储的就是对象的句柄地址**，而**句柄中包含了对象实例数据与类型数据各自的具体地址信息**：

   ![image-20220406201325883](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220406201325883.png)

2. 使用**直接指针**。如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 **reference 中存储的直接就是对象的地址**。

   ![image-20220406201437073](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220406201437073.png)

使用句柄的好处就是 **reference 中存储的是稳定的句柄地址，对象被移动后只需改变句柄中的实例数据指针**。

使用直接指针的好处就是**速度快，它节省了一次指针定位的时间开销。**
