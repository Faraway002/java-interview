# JVM 垃圾回收

## 概述

由于 Java 程序员不需要手动管理内存，因此不需要的对象（垃圾）回收的动作就得由 JVM 来完成，如果不进行垃圾回收，内存迟早都会被消耗空。

垃圾回收需要考虑三个问题：

1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？

对于程序计数器、虚拟机栈、本地方法栈 3 个区域来说，它们随线程而生，随线程而死，栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈，每一个栈帧分配多少内存基本上是在字节码确定下来后就已知的，因此这几个区域的内存回收都具备确定性，在这几个内存区域回收就不需要过多考虑如何回收的问题，当方法结束或者线程死亡时，内存自然而然就回收掉了。

而 Java **堆和方法区则有着不确定性**，只有运行期间我们才知道堆中需要分配多少对象，需要分配多大的对象，因此这部分内存具有动态性。**垃圾回收器关注的就是这部分区域的内存该如何管理**，本章后续讨论的也就是这部分的内存。

## 哪些内存需要回收？

如果一个对象还在被使用，那么垃圾回收器就不能回收它；反之，如果一个对象不再被使用了，那么就需要回收掉它。

垃圾回收的第一步就是要确定这些对象中哪些已经不再被使用，哪些还在被使用。

通常来说，检测对象是否被使用的算法有两种，分别是**引用-计数**和**可达性分析**。

### 引用-计数

算法的思想是：**给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。**

客观来说，该算法的思想简单，判定效率高，大多数情况下它都是一个不错的算法，也有很多领域（比如 Python）采用的就是引用-计数算法。

但是很可惜，在 Java 中几乎都不使用引用-计数，这是因为这个算法需要考虑很多例外情况，必须要配合大量的额外处理才能保证正确的工作。

举个简单的例子：**两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收**：

```java
public class ReferenceCountingGC {
    public Object instance = null;

    private static final int _1MB = 1024 * 1024;

    // 这个对象占 2MB 内存，只是为了在 GC 中能看的更清楚
    private byte[] bigSize = new byte[16 * _1MB];

    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();

        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        // 假设在此处发生 GC，objA 和 objB 是否被回收？
        System.gc();
    }
}
```

这个例子中，objA 引用 objB，计数器都是 1，但是 objA 和 objB 都不再使用了，因此无法被回收。

这个例子同时也证明了，JVM 不是采用引用计数的方式判断对象是否可被回收。

### 可达性分析

这个算法的思路是：通过称为 **GC Roots** 的一系列根对象作为起始节点集，根据引用关系向下进行搜索，搜索过程中走过的路径称为**引用链**，如果某个对象到 GC Roots 之间没有任何一根引用链相连（即不可达），则证明此对象没有被引用了，可以被回收。

示意图如下：

![image-20220407174027174](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220407174027174.png)

在 Java 技术体系中，固定可以作为 GC Roots 的对象包括下面几种：

可达性分析算法

**可作为 GC Roots 的对象**包括下面几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中，类静态属性引用的对象
- 方法区中，常量引用的对象
- 本地方法栈中引用的对象（Native 方法）
- Java 虚拟机内部的引用，比如基本数据类型的 Class 对象，类加载器等等
- 所有被 `synchronized` 持有的对象

除了上述这些对象之外，根据用户所使用的垃圾收集器以及当前回收的内存区域不同，还有对象可以临时加入，共同构成完整的 GC Roots 集合。

### Java 中的引用

无论是引用计数还是可达性分析都离不开引用，Java 对引用分为了四种：

1. **强引用（Strongly Reference）**：是指在程序代码中普遍存在的引用赋值。任何情况下，只要强引用存在，垃圾回收器就不会回收掉被引用的对象。

2. **软引用（Soft Reference）**：软引用用于描述一些还有用，但是非必须的对象。只被软引用关联的对象，在系统将要发生内存溢出异常时，垃圾收集器会把这些引用列为回收范围内进行回收，如果本次回收还没有获得足够的内存，就抛出异常。

   可以使用 `SoftReference` 类来获得软引用。

3. **弱引用（Weak Reference）**：用来描述非必须对象，它的强度比软引用更弱，被弱引用关联的对象只能活到下一次 GC 之前，即无论内存是否足够，都会回收掉。

   可以使用 `WeakReference` 类来获得弱引用。

4. **虚引用（Phantom Reference）**：它是最弱的引用，一个对象是否有虚引用关联完全不会影响其生存时间，也无法通过虚引用来取得对象实例。虚引用的唯一作用就是在这个对象回收时收到一个系统通知。

   可以使用 `PhantomReference` 类来获得虚引用。

### `finalize` 方法

**被一次可达性分析判定为不可达的对象也并不是“非死不可”的**，要真正宣告一个对象死亡，**至少要经历两次标记过程**。

也就是说，在第二次标记之前，对象有一次自救的机会，这个机会来自于 `Object` 的 `finalize` 方法，这是 `protected` 方法，子类可以覆盖该方法以实现资源清理工作，GC 在回收对象之前调用该方法。

* 当对象第一次被标记为不可达时，GC 会判断该对象是否覆盖了 `finalize` 方法，若未覆盖，则直接将其回收。
* 否则，若对象未执行过 `finalize` 方法，将其放入 F-Queue 队列，之后由一个低优先级的线程执行该队列中对象的 `finalize` 方法。
* 执行 `finalize` 方法完毕后，GC 会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。

对象只有一次自救的机会，如果对象自救成功后再尝试第二次自救，则会失败，因为**任意一个对象的 `finalize` 方法都只会被执行一次**。

`finalize` 并不是一个好的做法，它并不能等同于 C++ 中的析构函数，而是由于一些历史原因而产生的方法，它的运行代价高昂、不确定性大，无法保证各个对象的调用顺序，现已被官方标记为不推荐使用的语法。

**建议大家忘记这个方法的存在**。

### 回收方法区

方法区垃圾收集的性价比是比较低的，在方法区回收有苛刻的判定条件，其区域垃圾回收的成果往往低于此。

方法区能回收的部分大致有两个：

* 废弃的常量：如果一个常量不再被任何一个引用所连接，那么它就有可能被回收。
* 不再使用的类型：这个条件就比较苛刻了，我们前文在讲类加载时也已经提到过了：
  1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
  2. 加载该类的 `ClassLoader` 已经被回收。
  3. 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib 等字节码框架、动态生成 JSP 以及 OSGi 这类频繁自定义 `ClassLoader` 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。

## 垃圾回收算法

### 分代收集理论

分代收集理论，是基于程序运行对象存活数量和对象年龄之间关系的一套经验法则。

它建立在两个分代假说之上：

- **弱分代假说（Weak Generational Hypothesis）**：绝大多数对象都是朝生夕灭的。
- **强分代假说（Strong Generational Hypothesis）**：熬过越多次垃圾收集过程的对象就越难以消亡。

基于这个理论，收集器将 Java 堆划分出不同的区域，然后将回收对象按照年龄分配到不同的区域存储，这也是我们把 Java 内存区域分为多块区域的原因。

具体来讲，就是把 Java 堆划分为**新生代 （Young Generation）和老年代（Old Generation）两个区域**，新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。

根据回收区域的不同，垃圾回收一般分为部分收集和整堆收集：

* 部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：

  * 新生代收集（Minor GC）：指目标只是新生代的垃圾收集。

  * 老年代收集（Major GC）：指目标只是老年代的垃圾收集。

    目前只有 CMS 收集器会有单独收集老年代的行为。

  * 混合收集（Mixed GC）：指目标是收集整个新生代与部分老年代的垃圾收集。

    目前只有 G1 收集器会有这样的行为。

* 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。

### 标记 - 清除算法

这是最基础的垃圾回收算法，它分为标记和清除阶段：

* 标记：这个阶段中，会通过之前提过的可达性分析算法标记出所有应该回收的对象。
* 清除：对上一阶段标记的所有对象进行回收。（当然，也可以反过来，标记存活的对象，清除未标记的对象）

示意图如下：

![image-20220408160830563](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220408160830563.png)

之所以说它是最基础的算法，这是因为后面要介绍的算法都是基于它改良的。它有几个不足之处：

- **执行效率不稳定**。如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。
- **内存空间的碎片化问题**。标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 标记 - 复制

该算法简称为复制算法，为了解决标记 - 清除算法中面对大量可回收对象时的执行效率低的问题，有人就提出了这种算法。

它的核心思想是：**将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。**

这种算法在面对少量可回收对象时会有大量的对象复制开销，但是如果是有大量对象要回收，这个算法的效率就非常高了。

算法示意图如下所示：

![image-20220408161329265](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220408161329265.png)

除此之外的主要不足是：**该算法只使用了内存的一半**。为此，现在的商业虚拟机都采用这种收集算法**来回收新生代**，但是并不是将内存划分为大小相等的两块，而是分为**一块较大的 Eden 空间和两块较小的 Survior 空间**，**每次使用 Eden 空间和其中一块 Survivor**。

**在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor**。

HotSpot 虚拟机的 Eden 和两块 Survivor 的大小比例默认为 8: 1: 1，保证了内存的利用率达到 90 %。

如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行**分配担保**，也就是借用老年代的空间存储放不下的对象。

分配担保就好比我们去银行贷款，只要有一个担保人能够保证在我们还不上钱时从担保人那里拿取，这样银行就会认为没有什么风险了。内存的分配担保也一样，只要老年代还有能够容纳从新生代存活的对象的空间，那么就可以安全的把对象直接移入老年代中。

我们在后面还会详细讲解分配担保。

### 标记 - 整理

刚刚的复制算法解决了效率低的问题，但是也仅限于新生代，而且它还有一部分空间未使用，所以老年代并不适合这种算法。

针对老年代的特点，有人提出了标记 - 整理算法：其中的标记过程仍然和标记 - 清除一样，在整理阶段时，会让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

![image-20220408162321826](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220408162321826.png)



#### 标记 - 清除和标记 - 整理比较

在标记 - 整理中，移动存活对象是一种优缺点并存的决策：

* 如果移动对象，尤其是在老年代这种地方，这种操作将会是非常负重的，而且风险很大，**必须让用户线程全部暂停之后才能进行，这种暂停被称之为 `Stop The World`**。
* 如果不移动对象，则就回到了标记 - 清除，需要用更复杂的数据结构和分配算法来分配内存，这毫无疑问会给内存分配增加额外的负担，尤其是内存分配还是一个非常频繁的操作。

因此，不同的垃圾收集器的侧重点会不一样：如果侧重**低停顿时间**，则通常会使用标记 - 清除算法；如果侧重**高吞吐量**，则通常会使用标记 - 整理算法。

也有一种杂合方案，就是先使用标记 - 清除，直到内存碎片多到难以忍受的时候，再使用标记 - 整理一次性整理好内存，我们即将介绍的 CMS 垃圾收集器就是用的这种方案。

### 分代收集

根据 Java 内存区域的特点以及垃圾回收算法的特点，对于不同的区域应该采用不一样的垃圾回收算法，大致可以总结为：

- 新生代使用**标记 - 复制**算法
- 老年代使用**标记 - 清除**或者**标记 - 整理**算法

## 垃圾收集器

垃圾收集器是对各种垃圾收集算法的实践者，通常一个虚拟机内会提供多种垃圾收集器，用户可以根据应用类型的特点选择其中一种或多种组合。

下图展示了 JVM 中经典的垃圾收集器，它们都被认为是稳定的且足够成熟的：

![image-20220408192826931](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220408192826931.png)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以组合使用。

其中，G1 垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。

### Serial 收集器

串行收集器（Serial）是最基本、历史最悠久的收集器，从名字也可以看出，这个收集器是一个单线程工作的收集器。

这个单线程的意义不仅仅是说明**它只有一条收集线程去完成垃圾收集工作**，更重要的是强调**它在垃圾收集时，必须暂停其他所有的线程，直到它收集结束**。

**Serial 收集器采用单线程 stop-the-world 的方式进行收集**，当内存不足时，串行 GC 设置停顿标识，**待所有线程都进入安全点**（Safepoint）时，应用线程暂停，GC 开始工作，**采用单线程方式回收空间并整理内存**。

示意图如下：

![Serial/Serial Old收集器运行示意图](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/e9077f10fdaf4b66965faf3cbd1f1c31~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

单线程意味着**复杂度更低**、**占用内存更少**、**垃圾回收效率高**；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核 CPU 的场合。

虽然它给用户带来的体验很不好（每过一段时间应用程序就会暂停一会），但是它仍是 **`client` 模式下默认的新生代收集器**，使用**标记 - 复制算法**。因为在客户端模式下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的年轻代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。

### Serial Old 收集器

**Serial Old 是 Serial 收集器的老年代版本**，它同样是一个单线程的收集器，使用**标记 - 整理**算法，也是给 client 模式下的虚拟机使用。

如果用在 Server 模式下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### ParNew 收集器

ParNew 实际是上 Serial 收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，**其余的行为都与 Serial 收集器完全一致**（包括回收使用的算法）。

ParNew 和 Serial Old 配合使用的垃圾收集如图所示：

![ParNew/Serial Old收集器运行示意图](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/979f8e4f017c4c6e9cad49c492a60299~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

需要注意的是，这个**并行仅仅是描述同一时间多条 GC 线程协同工作，而不是 GC 线程和用户线程同时运行**。ParNew 垃圾收集也是需要 Stop The World 的。

它除了支持并行收集之外，其他与 Serial 并没有太多差别，但是它却是 JDK 7 之前系统的首选新生代收集器，原因是它是除 Serial 之外唯一能和 CMS 配合使用的收集器。

### Parallel Scavenge 收集器

Parallel Scavenge 和 ParNew 一样，是一款新生代的收集器，它也使用**标记 - 复制**算法，也能并行。

它和 ParNew 的主要区别在于：其他收集器都是以关注停顿时间为目标，而 **Parallel Scavenge 收集器是以关注吞吐量为目标的垃圾收集器**。

- 停顿时间越短就**越适合需要与用户交互的程序**，良好的响应速度能提升用户体验；
- 而高吞吐量则可以**高效率地利用 CPU 时间**，尽快完成垃圾收集，让用户线程得到充分的调度。

### Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于**标记 - 整理**算法实现。

它可以和 Parallel Scavenge 配合使用，示意图如下：

![Parallel Scavenge/Parallel Old收集器运行示意图](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/46edbff5b9b047ebbcfde2556ce2cd43~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

### CMS 收集器

CMS 的全称是 Concurrent Mark Sweep，从字面意思上看该收集器就是使用的**标记 - 清除**算法，它是**老年代**的收集器，以获得最短 STW 时间为目标。

CMS 收集器运行步骤如下：

1. **初始标记**：单线程运行，需要 STW，但是很快，标记 GC Roots 能直达的对象。
2. **并发标记**：无停顿，和用户线程同时运行，从 GC Roots 直达对象开始遍历整个对象图。
3. **重新标记**：多线程运行，需要 STW，比第一步稍慢，主要是标记**并发标记阶段因用户程序继续运作而导致标记产生变动的那部分对象**。
4. **并发清除**：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。

**在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿**，所以它的 STW 时间很短。

它的运行过程如下图所示：

![Concurrent Mark Sweep收集器运行示意图](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/1d5a92196ffa4233805fc03624b7c320~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

- 优点：CMS最主要的优点在名字上已经体现出来——**并发收集**、**低停顿**。
- 缺点：
  - Mark Sweep 算法会导致内存碎片比较多
  - CMS 的并发能力比较依赖于 CPU 资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。
  - 并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。

### G1 收集器

Garbage First，简称 G1，是垃圾收集器技术发展史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式。前面提到的垃圾收集器一般策略是关注吞吐量或停顿时间。而 **G1 是一种兼顾吞吐量和停顿时间的 GC 收集器**。

G1 是 Oracle JDK 9 以后的默认 GC 收集器。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。

虽然 G1 也仍是遵循分代收集理论设计的，但**其堆内存的布局与其他收集器有非常明显的差异**。以前的收集器分代是划分新生代、老年代、持久代等，**G1 把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间**。收集器能够对扮演不同角色的 Region 采用不同的策略去处理。

Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象，G1 认为只要超过了一个 Region 的一半就算大对象。G1 大多数行为都会把 Humongous 当成老年代。

![G1 Heap Regions](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/f7c4e7d53d5548e1a7f59ba328e13e03~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

这样就避免了收集整个堆，而是按照若干个 Region 集进行收集，同时**维护一个优先级列表，跟踪各个 Region 回收的价值，优先收集价值高的 Region**，这也是 G1 名称的由来。

G1收集器的运行过程大致可划分为以下四个步骤：

- 初始标记（initial mark）：标记了从 GC Roots 开始**直接关联可达**的对象，需要 STW。
- 并发标记（concurrent marking）：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，可与用户线程并发执行。
- 最终标记（final marking）：标记在并发标记过程中产生的垃圾，需要 STW。
- 筛选回收（live data counting and evacuation）：根据用户所期望的停顿时间来制定回收计划，选择多个 Region 构成回收集，把回收集中 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间（类似标记 - 复制），需要 STW。

![G1收集器运行示意图](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/abf34804ca3845da8f1aa81ec5e22810~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

**G1 从整体来看是基于标记 - 整理算法实现的收集器，但从局部（两个 Region 之间）上看又是基于标记 - 复制算法实现**，无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。

### 垃圾收集器总结

|        收集器         | 串行/并行/并发 |  年轻代/老年代  |       收集算法       |     目标     |                   适用场景                    |
| :-------------------: | :------------: | :-------------: | :------------------: | :----------: | :-------------------------------------------: |
|      **Serial**       |      串行      |     年轻代      |         复制         | 响应速度优先 |          单 CPU 环境下的 Client 模式          |
|    **Serial Old**     |      串行      |     老年代      |      标记-整理       | 响应速度优先 |  单 CPU 环境下的 Client 模式、CMS 的后备预案  |
|      **ParNew**       |  串行 + 并行   |     年轻代      |       复制算法       | 响应速度优先 |   多 CPU 环境时在 Server 模式下与 CMS 配合    |
| **Parallel Scavenge** |  串行 + 并行   |     年轻代      |       复制算法       |  吞吐量优先  |       在后台运算而不需要太多交互的任务        |
|   **Parallel Old**    |  串行 + 并行   |     老年代      |      标记-整理       |  吞吐量优先  |       在后台运算而不需要太多交互的任务        |
|        **CMS**        |  并行 + 并发   |     老年代      |      标记-清除       | 响应速度优先 | 集中在互联网站或 B/S 系统服务端上的 Java 应用 |
|        **G1**         |  并行 + 并发   | 年轻代 + 老年代 | 标记-整理 + 复制算法 | 响应速度优先 |         面向服务端应用，将来替换 CMS          |

## 内存分配与回收策略

### 内存分配策略

1. **对象优先在 Eden 分配**。

   大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。

2. **大对象直接进入老年代**。

   大对象是指需要连续内存空间的对象，最典型的大对象是那种**很长的字符串**以及**数组**。

   比遇到大对象更坏的是遇到短命的大对象，经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

   JVM 提供了 `-XX:PretenureSizeThreshold` 设置，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。

3. **长期存活的对象进入老年代**。

   JVM 为每个对象都定义了一个年龄计数器，存储在对象头中，对象在 Eden 出生并经过 Minor GC 依然存活，则将移动到 Survivor 中，然后设置为 1 岁。之后，每经过一次 Minor GC，年龄就增加 1 岁，增加到一定年龄（默认 15）则移动到老年代中。

   `-XX:MaxTenuringThreshold` 用来定义年龄的阈值。

4. **动态对象年龄判定**。

   虚拟机并不是永远地要求对象的年龄必须达到 `MaxTenuringThreshold` 才能晋升老年代，**如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代**，无需等到 `MaxTenuringThreshold` 中要求的年龄。

5. **空间分配担保**。

   在发生 Minor GC 之前，虚拟机先检查**老年代最大可用的连续空间是否大于年轻代所有对象总空间**

   * 如果条件成立的话，那么 Minor GC 可以确认是安全的；
   * 如果不成立的话，那么虚拟机会查看 `HandlePromotionFailure` 设置值是否允许担保失败
     * 如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
       * 如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；
       * 如果小于，那这时要改为进行一次 Full GC。
     * 如果不允许，那这时也要改为进行一次 Full GC。
   
   如果还是分配不出空间，就要抛出 OOM 了。

### Minor GC 的触发时机

**当 `Eden` 区空间不足时，触发 Minor GC**。

**Minor GC 发生在新生代上**，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。

### Full GC 的触发时机

**Full GC 发生在老年代和新生代上**，老年代对象和新生代对象得特点相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。

触发条件：

1. **调用 `System.gc()`**

   此方法的调用是建议虚拟机进行 Full GC，**虽然只是建议而非一定，但很多情况下它会触发 Full GC**，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此**强烈建议能不使用此方法就不要使用**，让虚拟机自己去管理它的内存。

   可通过 `-XX:DisableExplicitGC` 来禁止调用 `System.gc()`。

2. **老年代空间不足**

   老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 `java.lang.OutOfMemoryError: Java heap space`。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在年轻代多存活一段时间以及不要创建过大的对象及数组。

3. **方法区空间不足**（JDK 1.7 之前）

   JVM 规范中运行时数据区域中的**方法区**，在 HotSpot 虚拟机中又被习惯称为**永久代**，永久代中存放的是类的描述信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，**在未配置为采用 CMS GC 的情况下也会执行 Full GC**。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出 `java.lang.OutOfMemoryError: PermGen space` 错误。

   为避免永久代占满造成 Full GC 现象，可采用的方法为增大 PermGen 空间或转为使用 CMS GC。

4. **Minor GC 的平均晋升空间大小大于老年代可用空间**。

   如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。

5. **对象大小大于 To 区和老年代的可用内存**。

   由 `Eden` 区、`From` 区向 `To` 区复制时，如果大小大于 To 区可用内存，则把该对象转存到老年代，此时老年代的可用内存小于该对象大小，就会触发 Full GC。
