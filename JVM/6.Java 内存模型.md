[TOC]

# Java 内存模型与线程

从操作系统课程中我们了解到，现代应用程序的性能瓶颈大多在 I/O、网络通信以及数据库访问上。为了尽可能多的利用 CPU 而不是让 CPU 在大部分时间内都在等待其他事务，CPU 必须在等待的时间内进行其他的运算，这就不得不涉及到并发编程。

并发编程的一大难点就在于同步，同步就不得不涉及到内存访问和缓存一致性，**Java 内存模型为我们屏蔽了在不同硬件和操作系统中的内存访问差异，使得 Java 程序在各种平台下都能达到一致的内存访问效果**。

## 1. 硬件效率与一致性

要理解 Java 内存模型，我们先从硬件说起。

现代计算机硬件架构的简单图示：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/v2-67833188e191c5e7a11d34e613ca352c_720w.jpg)

- **CPU**：CPU 存在多个核心。现代计算机上同时运行多个线程是可能的。每个 CPU 在某一时刻运行一个线程是没有问题的。这意味着，如果你的 Java 程序是多线程的，在你的 Java 程序中每个 CPU 上一个线程可能同时（并发）执行。

- **寄存器**：每个 CPU 都包含一系列的寄存器，它们是 CPU 存储数据的基础。CPU 在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为 CPU 访问寄存器的速度远大于主存。

- **高速缓存 Cache**：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

  CPU 访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度要慢。每个 CPU 都有一级或者多级 CPU 缓存。

- **内存**：一个计算机还包含一个主存。所有的 CPU 都可以访问主存，主存通常比 CPU 中的缓存大得多，但是也要慢上不少。

高速缓存和多核 CPU 解决了速度的问题，但是也为系统带来了更高的复杂度，引入了新的问题：

* **缓存一致性问题**：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况。如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？

  为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI、MOSI、Synapse、Firefly 及 DragonProtocol 等，我的操作系统系列文章中介绍了著名的 MESI 协议，这里就不再赘述了。

* **指令重排序问题**：为了使得 CPU 内部的运算单元能够被充分利用，现代 CPU 采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。换句话说，CPU 会对输入代码进行**乱序执行**优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但**并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致**。

  除此之外，编译器在不改变单线程程序语义的前提下，也可以重新安排语句的执行顺序。

  * 单线程环境下，CPU/编译器对指令的重排序都会遵守 as-if-serial 语义，遵守 as-if-serial 意味着**它们不会对数据依赖关系的操作做重排序**，换句话说，**不管怎么重排序，单线程下的执行结果不能被改变**。

  * 多线程环境下，为了解决重排序问题，又提出了**内存屏障**的概念。

    内存屏障可以简单理解为：在操作数据的时候，往数据插入一条内存屏障指令，**重排序时不能把后面的指令重排序到屏障之前的位置**。

## 2. Java 内存模型

由于不同 CPU 架构的缓存体系不一样、缓存一致性协议不一样、重排序的策略不一样、所提供的内存屏障指令也有差异，为了简化 Java 开发人员的工作。Java 封装了一套规范，这套规范就是 Java 内存模型，**用来屏蔽各种硬件和操作系统之间的内存访问差异**。

Java 内存模型定义是非常困难的，定义必须足够严谨，才不会让内存访问操作发生歧义；但也必须足够宽松，让 JVM 能有足够的空间去利用硬件的特性。

Java 内存模型是一个比较大的主题，我们从每个小主题开始一一介绍。

### 2.1 主内存与工作内存

Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）。

每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比）。

- 线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。
- 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

![image-20220701092037575](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220701092037575.png)

这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一层次的内存划分，这两者基本上是没有关系的。如果两者一定要勉强对应起来，从变量、主内存、工作内存的定义看，**主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应了虚拟机栈中部分区域**。

更底层上的对应则是：主内存对应物理内存，而工作内存则对应于寄存器和高速缓存。

### 2.2 内存间的交互操作

Java 内存模型定义了以下 8 种操作来完成主内存与工作内存之间的具体交互协议：

* lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。
* load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
* use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
* assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。
* write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

![image-20220703224822729](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703224822729.png)

如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。注意，**Java 内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行**。也就是说，read 与 load 之间、store 与 write 之间是可插入其他指令的，如对主内存中的变量 a、b 进行访问时，一种可能出现顺序是 read a、read b、load b、load a。

此外，Java 内存模型还规定上述 8 种基本操作时必须满足如下规则：

- 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。
- 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
- 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。
- 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。
- 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。

这 8 种内存访问操作以及上述规则限定，再加上稍后介绍的对 volatile 的一些特殊规定，就已经完全确定了 Java 程序中哪些内存访问操作在并发下是安全的。

虽然这种定义相当严谨，但是也极为繁琐，实践起来更是无比麻烦，考虑到这一点，Java 开发团队将原来的八种操作简化为四种：read、write、lock 以及 unlock。

### 2.3 对于 `volatile` 型变量的特殊规则

Java 专门为 `volatile` 型的变量定义了一些特殊的访问规则。

首先，我们回顾一下 `volatile` 的作用：当一个变量被定义成 `volatile` 之后，它将具备两项特性：

1. 保证此变量堆所有线程的**可见性**。

   可见性是指**当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的**。

   普通变量是无法做到可见性的，普通变量的值在线程间传递必须通过主内存。

   而 `volatile` 变量能够使得对改变量的写操作立即反映到其他线程中，但是由于 Java 运算符并非是原子性的，因此并不保证运算的原子性。

2. **禁止指令重排序**优化。

   普通的变量仅能保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证赋值操作的顺序与程序代码中的执行顺序一致。这也就是所谓的 as-if-serial 语义。

   有 `volatile` 的变量赋值之后会多执行一个内存屏障的操作，此时重排序时不能把后面的指令重排序到内存屏障之前的位置。

事实上，Java 内存模型对 `volatile` 有一些特殊的规则，假定 T 表示一个线程，V 和 W 分别表示两个 `volatile` 型变量。在 Java 内存模型中规定在进行 read、load、use、assign、store 和 write 操作时需要满足如下规则：

- 只有当线程 T 对变量 V 执行的前一个动作是 load 的时候，线程 T 才能对变量 V 执行 use 动作。并且，只有当线程 T 对变量 V 执行的后一个动作是 use 的时候，线程 T 才能对变量 V 执行 load 动作。

  也可以理解为：线程对变量 V 的 use 动作，必须与 read、load 动作连在一起，即 read -> load -> use 必须一起出现。

  也即：**要使用变量 V 之前，必须去主内存读取变量 V**。

- 只有当线程 T 对变量 V 执行的前一个动作是 assign 的时候，线程 T 才能对变量 V 执行 store 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 store 的时候，线程 T 才能对变量 V 执行 assign 动作。

  也可以理解为：线程对变量 V 的 assign 动作，必须与 store、write 连在一起，即：assign -> store -> write 必须一起出现。

  也即：**每次修改 V 后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量 V 所做的修改**。

- 假定动作 A 是线程 T 对变量 V 实施的 use 或 assign 动作，假定动作 F 是和动作 A 相关联的 load 或 store 动作，假定动作 P 是和动作 F 相应的对变量 V 的 read 或 write 动作。类似的，假定动作 B 是线程 T 对变量 W 实施的 use 或 assign 动作，假定动作 G 是和动作 B 相关联的 load 或 store 动作，假定动作 Q 是和动作 G 相应的对变量 W 的 read 或 write 动作。如果 A 先于 B，那么 P 先于 Q。

  这条规则要求 volatile 修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。

所以说 `volatile` 变量的可见性以及禁止重排序的语义，其实都来源于 Java 内存模型里对于 `volatile` 变量的定义。

### 2.4 针对 long 和 double 型变量的特殊规则

Java 内存模型要求八种内存交互操作（lock，assign，read 等）都必须有原子性，但是对于 64 位数据类型（long 和 double）来说，Java 内存模型特别定义了一条宽松的规定：**允许虚拟机将没有被 `volatile` 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行**。

目前各种平台下的 64 位商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile，但是 32 位虚拟机上确实会出现读取“半个变量”的情况。

### 2.5 针对 `final` 型变量的特殊规则

我们知道，`final` 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。

`final` 关键字的可见性是指：**被 `final` 修饰的字段在声明时或者构造器中，一旦初始化完成，那么在其他线程无须同步就能正确看见 `final` 字段的值**。这是因为一旦初始化完成，`final` 变量的值立刻回写到主内存。

### 2.6 先行发生原则（Happens-Before）

如果 Java 内存模型中所有的有序性都禁考 volatile 和 synchronized 来实现，那么所有操作都会变得非常麻烦，但是我们写代码时并没有察觉到这一点，这是因为 JMM 中还有一个 Happens-Before 原则。

happens-before 原则用于描述下 2 个操作的内存可见性，**如果操作 A happens-before 操作 B，那么 A 的结果对 B 可见**。

JMM 天然具有以下 Happens-Before 关系：

- **程序次序规则**：一个线程内，按照代码顺序，书写在前面的操作 happens-before 书写在后面的操作。
- **锁定规则**：一个 unlock 操作 happens-before 后面对同一个锁的 lock 操作。
- **volatile 变量规则**：对一个 volatile 变量的写操作 happens-before 后面对这个变量的读操作。
- **线程启动规则**：Thread 对象的 start() 方法 happens-before 此线程的每个一个动作。
- **线程中断规则**：对线程 interrupt() 方法的调用 happens-before 被中断线程的代码检测到中断事件的发生。
- **线程终结规则**：线程中所有的操作都 happens-before 线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行。
- **对象终结规则**：一个对象的初始化完成 happens-before 它的 finalize() 方法的开始。
- **传递规则**：如果操作 A happens-before 操作 B，而操作 B 又 happens-before 操作 C，则可以得出操作 A happens-before 操作 C。

### 2.7 内存屏障

内存屏障是被插入两个 CPU 指令之间的一种指令，**用来禁止处理器指令发生重排序**（像屏障一样），从而保障有序性的；另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障可见性。

举个例子说明：

```text
Store1; 
Store2;   
Load1;   
StoreLoad;  // 内存屏障
Store3;   
Load2;   
Load3;
```

对于上面的一组 CPU 指令（Store 表示写入指令，Load 表示读取指令，StoreLoad 代表写读内存屏障），StoreLoad 屏障之前的 Store 指令无法与 StoreLoad 屏障之后的 Load 指令进行交换位置，即重排序。

但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。

常见的有 4 种屏障：

- **LoadLoad 屏障：**对于这样的语句 Load1；LoadLoad；Load2，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。

- **StoreStore 屏障：**对于这样的语句 Store1；StoreStore；Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其他处理器可见。

- **LoadStore 屏障：**对于这样的语句 Load1；LoadStore；Store2，在 Store2 及后续写入操作被执行前，保证 Load1 要读取的数据被读取完毕。

- **StoreLoad 屏障：**对于这样的语句 Store1；StoreLoad；Load2，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。

  在大多数处理器的实现中，这个屏障是个万能屏障，兼具其他三种内存屏障的功能。

Java 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 volatile 和 synchronized 关键字修饰的代码块，还可以通过 Unsafe 这个类来使用内存屏障。

#### 2.7.1 利用内存屏障实现 `volatile`

`volatile` 的具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证：

- **在每个 volatile 写操作的前面插入一个 StoreStore 屏障**。该屏障除了保证了屏障之前的写操作和该屏障之后的写操作不能重排序，还会保证了 volatile 写操作之前，任何的读写操作都会先于 volatile 被提交。
- **在每个 volatile 写操作的后面插入一个 StoreLoad 屏障**。该屏障除了使 volatile 写操作不会与之后的读操作重排序外，还会刷新处理器缓存，使 volatile 变量的写更新对其他线程可见。
- **在每个 volatile 读操作的后面插入一个 LoadLoad 屏障**。该屏障除了使 volatile 读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使 volatile 变量读取的为最新值。
- **在每个 volatile 读操作的后面插入一个 LoadStore 屏障**。该屏障除了禁止了 volatile 读操作与其之后的任何写操作进行重排序，还会刷新处理器缓存，使其他线程 volatile 变量的写更新对 volatile 读操作的线程可见。