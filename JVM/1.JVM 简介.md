[TOC]

# JVM 简介

## 1. 概述

官方规定的 Java 技术体系包括以下几个组成部分：

* Java 程序设计语言
* **各种硬件平台上 Java 虚拟机的实现**
* Class 文件格式
* Java 类库 API
* 来自商业机构和其他开源社区的第三方 Java 类库

JVM是 Java Virtual Machine（Java虚拟机）的缩写，JVM 是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

JVM 作为 Java "Write Once, Run Anywhere" 的后盾，是 Java 技术体系中相当重要的一环，学习 JVM 能够帮助我们写出更好的 Java 代码，帮助我们更加深刻的理解 Java 语言。

JVM 并不像字面意思一样是专属于 Java 语言的虚拟机，相反，它并不关注某一种特定的编程语言，它关注的是 JVM 上能够运行的代码规范，也叫做**字节码**。这是一种介于二进制机器码和编程语言之间的中间代码，**它在任何平台上都一致**，JVM 在不同的平台上会把字节码翻译为不同的底层机器码，再由 CPU 来执行。

**任何一种编程语言，只要有一种编译器能够将该编程语言翻译为字节码，就能被 JVM 所执行**。

![image-20220404151425580](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220404151425580.png)

## 2. JVM 发展历程

* 早在 1996 年 Java 1.0 版本的时候，Sun 公司发布了一款名为 Sun **Classic VM** 的 Java 虚拟机，它同时也是世界上第一款上用虚拟机，JDK 1.4 时完全被淘汰。

  这款虚拟机内部只提供了解释器，如果使用 JIT（Just In Time，即时编译器），就需要进行外挂，但是一旦使用 JIT 编译器，JIT 就会接管虚拟机的执行系统，解释器就不再工作，即**解释器和编译器不能配合工作**。

* 为了解决 Classic VM 虚拟机存在的问题，JDK 1.2 时，Sun 提供了 **Exact VM**，Exact 是精确的意思，意味着它能够提供准确式内存管理，即虚拟机可以知道内存中某个位置的数据具体是什么类型。

  它具备高性能虚拟机的雏形，能够探测热点代码，并将其提前编译，保证了高性能，并且它支持编译器与解释器混合工作模式。

  但是它只在 Solaris 平台短暂使用，其他平台上还是 Classic VM。

* **HotSpot VM** 最初由一家名为 Longview Technologies 的小公司设计，1997年，此公司被 Sun 收购；2009年，Sun 公司又被甲骨文收购，JDK1.3 时，HotSpot VM 成为默认虚拟机。

  目前 HotSpot 占有绝对的市场地位，称霸武林，是当前 Oracle JDK 和 OpenJDK 的默认虚拟机。

  HotSpot 指的就是它的热点代码探测技术，通过计数器找到最具编译价值代码，触发即时编译或栈上替换。

  它也支持编译器和解释器共同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。

* **Graal VM**，2018 年 4 月，Oracle Labs 公开了 Graal VM，号称 `Run Programs Faster Anywhere`。

  Graal VM 在 HotSpot VM 基础上增强而成的**跨语言全栈虚拟机，可以作为任何语言的运行平台。

现在使用最广泛的 JVM 仍然是 HotSpot VM，今后的讲解中若无特别说明，都是以 HotSpot 为例。

## 3. HotSpot 架构

我们最常用的 Java 虚拟机是 HotSpot，名字来源于其**热点代码探测技术**，它可以通过执行计数器找出最具有编译价值的代码，然后通知编译器进行编译。这使得 Java 代码的执行效率变得较高，甚至可以追平 C/C++。

HotSpot 的架构简图如下：

![image-20220404155151809](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220404155151809.png)

这个架构可以分成三层看：

* 最上层：javac 编译器将编译好的字节码 class 文件，通过 Java 类装载器执行机制，把对象或 class 文件存放在 JVM 划分内存区域。
* 中间层：称为 Runtime Data Area，主要是在 Java 代码**运行时用于存放数据**的，从左至右为方法区（永久代\元数据区）、堆（共享，GC 回收对象区域）、栈、程序计数器、寄存器、本地方法栈（私有）。
* 最下层：执行引擎（包括解释器、JIT 编译器和垃圾回收器）、本地方法接口以及本地方法库。

下面是一张更详细的架构图，学完再回来看会有更深的感触：

![image-20220404155447185](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220404155447185.png)

## 4. 从 Java 源代码到字节码

### 4.1 前端编译器

javac 是 JDK 提供的编译器，用于将 Java 源文件翻译为类文件的字节码，因为其处于编译的前期，也叫做**前端编译器**。

> **其他前端编译器简介**
>
> javac 仅仅是常见的一种前端**全量**编译器，除此之外，常见的 Java 前端编译器还有 Eclipse 的 ECJ，它是 Eclipse 和 Tomcat 默认的编译器，是一种增量编译器，当开发人员保存代码以后，ECJ 就在后台编译，因此速度也要相对快一些。

javac 的编译过程主要分为三步：

- 解析与填充符号表
- 注解处理
- 语义分析与字节码生成

![image-20220701082918023](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220701082918023.png)

下面是一个经典的 HelloWorld 程序：

```java
public class Demo {
    public static void main(String args[]) {
        System.out.println("Hello World!");
    }
}
```

使用 javac 命令编译上面这个类，它会经历上述的所有过程，最后会生成一个 Demo.class 文件，如果使用文本方式打开，结果将会是这样的：

![](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220317212225517.png)

#### 4.1.1 解释与填充符号表

这一阶段包括：

* **词法、语法分析**：将源代码中的字符流解析成语法树（AST），编译器后续的操作都是基于语法树，不再处理源码字符流。
* **填充符号**：完成语法分析后，开始会对符号表（由符号地址和符号信息构成的类似哈希表的结构）就行填充。符号表记录的内容将用于语义检查（如一个变量名的使用是否和之前声明的一致）、以及在目标代码生成阶段对符号名进行地址分配。

#### 4.1.2 注解处理

注解处理通常是由**注解处理器**来完成的。

可以把插入式注解处理器看作是一组**编译器的插件**，当这些插件工作时，**允许读取、修改、添加抽象语法树中的任意元素**。

如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止。

#### 4.1.3 语义分析与字节码生成

**语义分析**主要分为：

- 标注检查：主要检查变量使用前是否声明、变量类型与赋值之间是否匹配、同时还会进行常量折叠（如 `int a = 1 + 2` 会被折叠成`int a = 3`）。
- 数据及控制流分析：主要验证程序的上下文逻辑是否正确，如：检查局部变量使用前是否已赋值、方法的每条路径是否有返回值等。

**字节码生成**主要分为：

- 解语法糖：将语法糖还原成原始语法，如变长参数、自动装箱/拆箱、泛型等。
- 字节码生成：将改革阶段所生成的信息（符号表、语法树）转换成字节码指令并写到磁盘中，同时还需要做少量代码添加和转换工作（如填加默认的实例构造器`<init>`，添加类构造器`<cinit>`等）。

### 4.2 后端编译器

后端编译指的是把 **class 文件转换成本地基础设施（硬件指令集、操作系统）相关的二进制机器码**的过程。主要分为**即时编译（Just in Time, JIT）** 和**提前编译（Ahead of Time, AOT）**两种形式。

#### 4.2.1 即时编译器

**在运行时才将代码编译成本地机器码的过程称为即时编译**。

在 Hotspot 虚拟机中，Java 程序一般最初都是通过解释器来执行的（一边解释一边执行），当发现**某个方法或者代码块运行特别频繁（热点代码）**，运行时则将该方法编译成本地机器码（直接执行）并尽可能优化代码以提高执行效率。因此在 JVM 执行架构中，**解释器和编译器通常是配合来完成工作的**。

![image-20220701083547645](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220701083547645.png)

在 HotSpot 虚拟机内置了两个**即时编译器**，分别称为 Client Compiler 和 Server Compiler。这两种不同的编译器衍生出两种不同的编译模式，我们分别称之为：C1 编译模式，C2 编译模式。

> **注意**
>
> 现在许多人习惯上将 Client Compiler 称为 C1 编译器，将 Server Compiler 称为 C2 编译器，但在 Oracle 官方文档中将其描述为 compiler mode（编译模式）。所以说 C1 编译器、C2 编译器只是我们自己的习惯性称呼，并不是官方的说法。这点需要特别注意。

二者的区别在于：

* C1 编译模式会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。
* C2 编译模式，也是将字节码编译为本地代码，但是会**启用一些编译耗时较长的优化**，甚至会根据性能监控信息进行一些不可靠的**激进优化**。

简单地说，C1 编译模式做的优化相对比较保守，其编译速度相比 C2 较快；而 C2 编译模式会做一些激进的优化，并且会根据性能监控做针对性优化，所以其编译质量相对较好，但是耗时更长。

那么该如何选择呢？实际上，对于我们最常用的 HotSpot 虚拟机来说，其一共有三种运行模式可选，分别是：

- 混合模式（Mixed Mode） 。即 C1 和 C2 两种模式混合起来使用，这是默认的运行模式。如果你想单独使用 C1 模式或 C2 模式，使用 `-client` 或 `-server` 打开即可。
- 解释模式（Interpreted Mode）。即所有代码都解释执行，使用 `-Xint` 参数可以打开这个模式。
- 编译模式（Compiled Mode）。 此模式优先采用编译，但是无法编译时也会解释执行，使用 `-Xcomp` 打开这种模式。

在命令行中输入 `java -version` 可以看到，虚拟机默认使用 Mixed Mode 运行模式：

![image-20220317213142675](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220317213142675.png)

#### 4.2.2 提前编译器

提前编译器主要分为两个分支：

- 一是在程序运行之前把程序翻译成机器码的静态翻译工作，静态优化相对较为保守，如果采用即时编译那样的激进优化（如去掉不常用的分支代码）可能导致程序报错而无法挽回（即时编译则可回退到低级编译器甚至解释器上执行）。
- 另一种是把原本在即时编译器运行时要做的编译工作（如代码优化）提前做好并保存下来，下次运行到这些代码时则直接加载使用即可。

根据上面所述，JVM 一般把 AOT 编译器用做 JIT 的缓存加速。

### 4.3 代码执行

当源代码转化为字节码之后，要运行程序，有两种选择：

* 使用 Java **解释器**解释执行字节码。
* 使用编译器将字节码转化为本地机器代码。

这两种方式的区别在于：**前者启动速度快但运行速度慢**，而**后者启动速度慢但运行速度快**。

其原因很简单：解释器不需要像编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。而当编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。

在实际情况中，为了运行速度以及效率，**JVM 通常采用两者相结合的方式进行 Java 代码的执行**。如下图所示：

![image-20220408145253627](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220408145253627.png)
