# JVM 简介

官方规定的 Java 技术体系包括以下几个组成部分：

* Java 程序设计语言
* **各种硬件平台上 Java 虚拟机的实现**
* Class 文件格式
* Java 类库 API
* 来自商业机构和其他开源社区的第三方 Java 类库

Java 虚拟机（Java Virtual Machine，JVM） 作为 Java `Write Once Run Anywhere` 的后盾，是 Java 技术体系中相当重要的一环，学习 JVM 能够帮助我们写出更好的 Java 代码，帮助我们更加深刻的理解 Java 语言。

JVM 并不像字面意思一样是专属于 Java 语言的虚拟机，相反，它并不关注某一种特定的编程语言，它关注的是 JVM 上能够运行的代码规范，也叫做**字节码**。这是一种介于二进制机器码和编程语言之间的中间代码，**它在任何平台上都一致**，JVM 在不同的平台上会把字节码翻译为不同的底层机器码，再由 CPU 来执行。

**任何一种编程语言，只要有一种编译器能够将该编程语言翻译为字节码，就能被 JVM 所执行**。

![image-20220404151425580](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220404151425580.png)

## JVM 发展历程

* 早在 1996 年 Java 1.0 版本的时候，Sun 公司发布了一款名为 Sun **Classic VM** 的 Java 虚拟机，它同时也是世界上第一款上用虚拟机，JDK 1.4 时完全被淘汰。

  这款虚拟机内部只提供了解释器，如果使用 JIT（Just In Time，即时编译器），就需要进行外挂，但是一旦使用 JIT 编译器，JIT 就会接管虚拟机的执行系统，解释器就不再工作，即**解释器和编译器不能配合工作**。为

* 为了解决 Classic VM 虚拟机存在的问题，JDK 1.2 时，Sun 提供了 **Exact VM**，Exact 是精确的意思，意味着它能够提供准确式内存管理，即虚拟机可以知道内存中某个位置的数据具体是什么类型。

  它具备高性能虚拟机的雏形，能够探测热点代码，并将其提前编译，保证了高性能，并且它支持编译器与解释器混合工作模式。

  但是它只在 Solaris 平台短暂使用，其他平台上还是 Classic VM。

* **HotSpot VM** 最初由一家名为 Longview Technologies 的小公司设计，1997年，此公司被 Sun 收购；2009年，Sun 公司又被甲骨文收购，JDK1.3 时，HotSpot VM 成为默认虚拟机。

  目前 HotSpot 占有绝对的市场地位，称霸武林，是当前 Oracle JDK 和 OpenJDK 的默认虚拟机。

  HotSpot 指的就是它的热点代码探测技术，通过计数器找到最具编译价值代码，触发即时编译或栈上替换。

  它也支持编译器和解释器共同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。

* **Graal VM**，2018 年 4 月，Oracle Labs 公开了 Graal VM，号称 `Run Programs Faster Anywhere`。

  Graal VM 在 HotSpot VM 基础上增强而成的**跨语言全栈虚拟机，可以作为任何语言的运行平台。

现在使用最广泛的 JVM 仍然是 HotSpot VM，今后的讲解中若无特别说明，都是以 HotSpot 为例。

## HotSpot 架构

我们最常用的 Java 虚拟机是 HotSpot，名字来源于其**热点代码探测技术**，它可以通过执行计数器找出最具有编译价值的代码，然后通知编译器进行编译。这使得 Java 代码的执行效率变得较高，甚至可以追平 C/C++。

HotSpot 的架构简图如下：

![image-20220404155151809](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220404155151809.png)

这个架构可以分成三层看：

* 最上层：javac 编译器将编译好的字节码 class 文件，通过 java 类装载器执行机制，把对象或 class 文件存放在 JVM 划分内存区域。
* 中间层：称为 Runtime Data Area，主要是在 Java 代码**运行时用于存放数据**的，从左至右为方法区（永久代\元数据区）、堆（共享，GC 回收对象区域）、栈、程序计数器、寄存器、本地方法栈（私有）。
* 最下层：解释器、JIT（just in time）编译器和 GC（Garbage Collection，垃圾回收器）。

下面是一张更详细的架构图，学完再回来看会有更深的感触：

![image-20220404155447185](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220404155447185.png)

## 从 Java 源代码到字节码

### 前端编译器

javac 是 JDK 提供的编译器，用于将 Java 源文件翻译为类文件的字节码，因为其处于编译的前期，也叫做前端编译器。

下面是一个经典的 HelloWorld 程序：

```java
public class Demo {
    public static void main(String args[]) {
        System.out.println("Hello World!");
    }
}
```

使用 javac 命令编译上面这个类，便会生成一个 Demo.class 文件，如果使用纯文本方式打开，结果将会是这样的：

![](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220317212225517.png)

javac 把 Java 语言规范转换为字节码规范，经过如下四个阶段：

1. 词法、语法分析。在这个阶段，javac 编译器会对源代码的字符进行一次扫描，最终生成一个抽象的语法树。
2. 填充符号表。**在编译阶段，使用一个符号引用代替类的引用地址，等到类加载阶段，JVM 会将符号替换成具体的内存地址。**
3. 注解处理。注解可以在三个阶段处理，这里是第一个阶段。在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。
4. 分析与字节码生成。javac 编译器会根据上面几个阶段分析出来的结果，进行字节码的生成，最终输出为 class 文件。

javac 仅仅是常见的一种前端**全量**编译器，除此之外，常见的 Java 前端编译器还有 Eclipse 的 ECJ，它是 Eclipse 和 Tomcat 默认的编译器，是一种增量编译器，当开发人员保存代码以后，ECJ 就在后台编译，因此速度也要相对快一些。

### 后端编译器与代码执行

当源代码转化为字节码之后，要运行程序，有两种选择：

* 使用 Java **解释器**解释执行字节码。
* 使用 JIT（Just In Time）即时**编译器**将字节码转化为本地机器代码。

这两种方式的区别在于：**前者启动速度快但运行速度慢**，而**后者启动速度慢但运行速度快**。

其原因很简单：解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。而当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。

在实际情况中，为了运行速度以及效率，**JVM 通常采用两者相结合的方式进行 Java 代码的执行**。如下图所示：

![image-20220408145253627](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220408145253627.png)

在 HotSpot 虚拟机内置了两个**即时编译器**，分别称为 Client Compiler 和 Server Compiler。这两种不同的编译器衍生出两种不同的编译模式，我们分别称之为：C1 编译模式，C2 编译模式。

> **注意**
>
> 现在许多人习惯上将 Client Compiler 称为 C1 编译器，将 Server Compiler 称为 C2 编译器，但在 Oracle 官方文档中将其描述为 compiler mode（编译模式）。所以说 C1 编译器、C2 编译器只是我们自己的习惯性称呼，并不是官方的说法。这点需要特别注意。

二者的区别在于：

* C1 编译模式会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。
* C2 编译模式，也是将字节码编译为本地代码，但是会**启用一些编译耗时较长的优化**，甚至会根据性能监控信息进行一些不可靠的**激进优化**。

简单地说，C1 编译模式做的优化相对比较保守，其编译速度相比 C2 较快。而 C2 编译模式会做一些激进的优化，并且会根据性能监控做针对性优化，所以其编译质量相对较好，但是耗时更长。

那么该如何选择呢？实际上，对于我们最常用的 HotSpot 虚拟机来说，其一共有三种运行模式可选，分别是：

- 混合模式（Mixed Mode） 。即 C1 和 C2 两种模式混合起来使用，这是默认的运行模式。如果你想单独使用 C1 模式或 C2 模式，使用 `-client` 或 `-server` 打开即可。
- 解释模式（Interpreted Mode）。即所有代码都解释执行，使用 `-Xint` 参数可以打开这个模式。
- 编译模式（Compiled Mode）。 此模式优先采用编译，但是无法编译时也会解释执行，使用 `-Xcomp` 打开这种模式。

在命令行中输入 `java -version` 可以看到，虚拟机默认使用 Mixed Mode 运行模式：

![image-20220317213142675](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220317213142675.png)

