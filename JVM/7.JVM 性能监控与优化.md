[TOC]

# JVM 性能监控与优化

## 1. Java 程序性能监控

### 1.1 命令行工具

#### 1.1.1 操作系统工具

##### 1.1.1.1 `top`：显示系统整体资源使用情况

top 命令是 Linux 下最常用的性能分析工具，能够实时显示系统中各个进程的资源占用情况。

在 Linux 使用 top 命令的部分输出如下：

![image-20220409155303744](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409155303744.png)

###### 1.1.1.1.1 输出含义

top 命令的输出可以分为两个部分：前半部分是系统统计信息，后半部分是进程信息。

在统计信息中：

- 第 1 行是任务队列信息：
  * 系统当前时间
  * up dd days hh:mm 表示系统已经运行了 dd 天 hh 小时 mm 分钟
  * xx user 表示当前有 xx 个登录用户
  * load average 表示系统的平均负载，三个数值分别为 1 分钟、5 分钟、15 分钟前到现在的平均值
- 第 2 行是进程统计信息：
  * total 表示进程总数
  * running 表示正在运行的进程数
  * sleeping 表示正在休眠的进程数
  * stopped 表示已停止的进程数
  * zombie 表示僵尸进程数
- 第 3 行是 CPU 统计信息：
  * us 表示用户空间 CPU 占用率
  * sy 表示内核空间 CPU 占用率
  * ni 表示用户进程空间改变过优先级的进程 CPU 的占用率
  * id 表示空闲 CPU 占用率
  * wa 表示等待输入输出的 CPU 时间百分比
  * hi 表示硬件中断请求
  * si 表示软件中断请求

在进程信息区中，显示了系统各个进程的资源使用情况，主要字段的含义：

- PID：进程 id
- USER：进程所有者的用户名
- PR：优先级
- NI：nice 值，负值表示高优先级，正值表示低优先级
- VIRT：进程使用的虚拟内存的总量，单位 kb
- RES：进程使用的、未被换出的物理内存大小，单位 kb
- SHR：共享内存大小，单位 kb
- S：进程状态，D 表示不可中断的睡眠状态、R 表示运行、S 表示睡眠、T 表示跟踪/停止、Z 表示僵尸进程
- %CPU：上次更新到现在的 CPU 时间占用百分比
- %MEM：进程使用的物理内存百分比
- TIME+：进程使用的 CPU 时间总计，单位 1/100 秒
- COMMAND：命令名/命令行

###### 1.1.1.1.2 使用方式

```bash
top [-] [d] [p] [q] [c] [C] [S] [s]  [n]
```

参数说明：

* d：指定每两次屏幕信息刷新之间的时间间隔。当然，用户可以使用 s 交互命令来改变之。 
* p：通过指定监控进程 ID 来仅仅监控某个进程的状态。 
* q：该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么 top 将以尽可能高的优先级运行。 
* S：指定累计模式 。
* s：使 top 命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 
* i：使 top 不显示任何闲置或者僵死进程。 
* c：显示整个命令行而不只是显示命令名。

在 top 的使用过程中，还可以使用一些交互命令：

* Ctrl+L：擦除并且重写屏幕。 

* h 或者 ?：显示帮助画面，给出一些简短的命令总结说明。 

* k：终止一个进程。

  系统将提示用户输入需要终止的进程 PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用 15 信号；如果不能正常结束那就使用信号 9 强制结束该进程。默认值是信号 15。

  在安全模式中此命令被屏蔽。 

* i：忽略闲置和僵死进程。这是一个开关式命令。 

* q：退出程序。 

* r：重新安排一个进程的优先级别。

  系统提示用户输入需要改变的进程 PID 以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。 

* S：切换到累计模式。 

* s：改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为 s；如果有小数，就换算成 ms。输入 0 值则系统将不断刷新，默认值是 5 s。

  需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。 

* f 或者 F：从当前显示中添加或者删除项目。 

* o 或者 O：改变显示项目的顺序。 

* l：切换显示平均负载和启动时间信息。 

* m：切换显示内存信息。 

* t：切换显示进程和 CPU 状态信息。 

* c：切换显示命令名称和完整命令行。 

* M：根据驻留内存大小进行排序。 

* P：根据 CPU 使用百分比大小进行排序。 

* T：根据时间/累计时间进行排序。 

* W：将当前设置写入 ~/.toprc 文件中，这是写 top 配置文件的推荐方法。

##### 1.1.1.2 `vmstat`：监控内存和CPU

vmstat 也是一款功能比较齐全的性能监测工具。它可以统计 CPU、内存使用情况、swap 使用情况能信息。

一般 vmstat 工具的使用是通过两个数字参数来完成的，第一个参数是**采样的时间间隔数**，单位是秒，第二个参数是**采样的次数**，如:

![image-20220409155710870](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409155710870.png)

输出的各个列的含义：

| 分类   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| Procs  | r: 运行队列中进程数量<BR>b: 等待IO的进程数量                 |
| Memory | swpd: 使用虚拟内存大小<BR>free: 可用内存大小<BR>buff: 用作缓冲的内存大小<BR>cache: 用作缓存的内存大小 |
| Swap： | si: 每秒从交换区写到内存的大小<BR>so: 每秒写入交换区的内存大小<BR> |
| io     | bi: 每秒读取的块数<br />bo: 每秒写入的块数                   |
| system | in: 每秒中断数，包括时钟中断<br />cs: 每秒上下文切换数       |
| CPU    | us: 用户进程执行时间<br />sy: 系统进程执行时间<br />id: 空闲时间（包括 I/O 等待时间），中央处理器的空闲时间。以百分比表示<br />wa: 等待 I/O 时间 |

##### 1.1.1.3 `iostat`：监控 I/O 使用

iostat 可以提供磁盘 I/O 的监控数据：

![image-20220409160151526](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409160151526.png)

以上命令显示了 CPU 的使用概况和磁盘 I/O 的信息。

##### 1.1.1.4 `netstat`：监控网络使用

可以使用 netstat 命令监控网络流量：

![image-20220409160325206](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409160325206.png)

#### 1.1.2 JVM 工具

##### 1.1.2.1 jps：虚拟机进程查看

类似于 Linux 下的 ps，它会列出属于 Java 程序的进程。

![image-20220409162502369](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409162502369.png)

jps 的常用选项见下表：

| 选项列表 | 描述                                            |
| -------- | ----------------------------------------------- |
| -q       | 只输出进程 ID，忽略主类信息                     |
| -l       | 输出主类全名，或者执行 JAR 包则输出路径         |
| -m       | 输出虚拟机进程启动时传递给主类 main()函数的参数 |
| -v       | 输出虚拟机进程启动时的 JVM 参数                 |

请记下你想要查找的 Java 进程 PID 号，之后的工具几乎都要使用它。

##### 1.1.2.2 jstat：虚拟机运行时信息查看

jstat 是一个强大的工具，它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。

jstat工具主要选项：

| 选项列表          | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| -class            | 监视类加载、卸载数量、总空间以及类装载所耗费时长             |
| -gc               | 监视 Java 堆情况，包括 Eden 区、2 个 Survivor 区、老年代、永久代或者 jdk1.8 元空间等，容量、已用空间、垃圾收集时间合计等信息 |
| -gccapacity       | 监视内容与-gc 基本一致，但输出主要关注 Java 堆各个区域使用到的最大、最小空间 |
| -gcutil           | 监视内容与-gc 基本相同，但输出主要关注已使用空间占总空间的百分比 |
| -gccause          | 与 -gcutil 功能一样，但是会额外输出导致上一次垃圾收集产生的原因 |
| -gcnew            | 监视新生代垃圾收集情况                                       |
| -gcnewcapacity    | 监视内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间 |
| -gcold            | 监视老年代垃圾收集情况                                       |
| -gcoldcapacity    | 监视内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间 |
| -compiler         | 输出即时编译器编译过的方法、耗时等信息                       |
| -printcompilation | 输出已经被即时编译的方法                                     |

##### 1.1.2.3 jinfo：虚拟机配置查看

jinfo 的作用是实时查看和调整虚拟机各项参数。

比如：

![image-20220409162832533](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409162832533.png)

##### 1.1.2.4 jmap：内存映像（导出）

jmap 命令用于生成堆转储快照（一般称为 heapdump 或 dump 文件）。

jmap 的作用并不仅仅是为了获取堆转储快照，它还可以查询 finalize 执行队列、Java 堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。

##### 1.1.2.5 jhat：堆转储快照分析

JDK 提供 jhat 命令与 jmap 搭配使用，来分析 jmap 生成的堆转储快照。 jhat 内置了一个微型的 HTTP/Web 服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。

##### 1.1.2.6 jstack：Java 堆栈跟踪

jstack 命令用于生成虚拟机当前时刻的线程快照（一般称为 threaddump 或者 javacore 文件）。

##### 1.1.2.7 jcmd：多功能命令

在 JDK 7 以后，新增了一个强大的命令行工具 jcmd，它可以实现上面除了 jstat 外所有命令的功能。

### 1.2 第三方工具

- **MAT**：Java 堆内存分析工具。

- **GChisto**：GC 日志分析工具。

- **GCViewer**：GC 日志分析工具。

- **JProfiler**：商用的性能分析利器。

- **arthas**：阿里开源诊断工具。

- **async-profiler**：Java 应用性能分析工具，开源、火焰图、跨平台。

其中最出名的莫过于 JProfiler 和 arthas 了，JProfiler 是 GUI 工具，而 arthas 则是命令行工具，适用于各大服务器。

arthas 是阿里开源的 Java 应用诊断利器，官网：[Arthas 应用诊断利器 (aliyun.com)](https://arthas.aliyun.com/zh-cn/)，这里并不会叙述它到底是怎么用的，它的官网文档非常详细，请自行查阅。

## 2. JVM 调优总结

JVM 调优不是常规手段，性能问题一般第一选择是优化代码，最后的选择才是进行 JVM 调优。

JVM 的自动内存管理本来就是为了将开发人员从内存管理的泥潭里拉出来。**即使不得不进行 JVM 调优，也绝对不能拍脑门就去调整参数，一定要全面监控，详细分析性能数据。**

### 调优时机

不得不考虑进行 JVM 调优的是那些情况呢？

- Heap 内存（老年代）持续上涨达到设置的最大内存值
- Full GC 次数频繁
- GC 停顿时间过长（超过1秒）
- 应用出现 OOM 等内存异常
- 应用中有使用本地缓存且占用大量内存空间
- 系统吞吐量与响应性能不高或下降

### 调优目标

**吞吐量、延迟、内存占用**三者类似 CAP，构成了一个不可能三角，**只能选择其中两个进行调优**，不可三者兼得。

- 延迟：GC 低停顿和 GC 低频率；
- 低内存占用
- 高吞吐量

选择了其中两个，必然会以牺牲另一个为代价。

下面展示了一些 JVM 调优的量化目标参考实例：

- Heap 内存使用率 <= 70%
- 老年代内存使用率 <= 70%
- 平均延迟时间 <= 1秒
- Full GC 次数为 0 或平均触发时间 >= 24小时 

注意：不同应用的 JVM 调优量化目标是不一样的。

### 调优步骤

一般情况下，JVM 调优可通过以下步骤进行：

- 分析系统系统运行情况：分析 GC 日志及 dump 文件，判断是否需要优化，确定瓶颈问题点
- 确定 JVM 调优量化目标
- 确定 JVM 调优参数（根据历史 JVM 参数来调整）
- 依次确定调优内存、延迟、吞吐量等指标
- 对比观察调优前后的差异
- 不断的分析和调整，直到找到合适的 JVM 参数配置
- 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪

以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行。

![JVM调优步骤](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/ac22afe6c0ef45cc9f16b042f9751665~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

### 调优策略

#### 选择合适的垃圾回收器

* CPU 单核，那么毫无疑问 Serial 垃圾收集器是你唯一的选择。
* CPU 多核，关注吞吐量 ，那么选择 Parallel Scavenge + Parllel Old 组合。
* CPU 多核，关注用户停顿时间，JDK 版本 1.6 或者 1.7，那么选择 CMS，新生代可以选择 Serial 或 ParNew。
* CPU 多核，关注用户停顿时间，JDK 1.8 及以上，JVM 可用内存 6G 以上，那么选择 G1。

#### 调整内存大小

现象：垃圾收集频率非常频繁。

原因：如果内存太小，就会导致频繁的需要进行垃圾收集才能释放出足够的空间来创建新的对象，所以增加堆内存大小的效果是非常显而易见的。

注意：如果垃圾收集次数非常频繁，但是每次能回收的对象非常少，那么这个时候并非内存太小，而可能是内存泄露导致对象无法回收，从而造成频繁GC。

#### 设置符合预期的停顿时间

现象：程序间接性的卡顿。

原因：如果没有确切的停顿时间设定，垃圾收集器以吞吐量为主，那么垃圾收集时间就会不稳定。

注意：不要设置不切实际的停顿时间，单次时间越短也意味着需要更多的 GC 次数才能回收完原有数量的垃圾。

#### 调整内存区域大小比率

现象：某一个区域的GC频繁，其他都正常。

原因：如果对应区域空间不足，导致需要频繁GC来释放空间，在JVM堆内存无法增加的情况下，可以调整对应区域的大小比率。

注意：也许并非空间不足，而是因为内存泄造成内存无法回收。从而导致GC频繁。

#### 调整对象升老年代的年龄

现象：老年代频繁GC，每次回收的对象很多。

原因：如果升代年龄小，新生代的对象很快就进入老年代了，导致老年代对象变多，而这些对象其实在随后的很短时间内就可以回收，这时候可以调整对象的升级代年龄，让对象不那么容易进入老年代解决老年代空间不足频繁GC问题。

注意：增加了年龄之后，这些对象在新生代的时间会变长可能导致新生代的GC频率增加，并且频繁复制这些对象新生的GC时间也可能变长。

#### 调整大对象的标准

现象：老年代频繁GC，每次回收的对象很多,而且单个对象的体积都比较大。

原因：如果大量的大对象直接分配到老年代，导致老年代容易被填满而造成频繁GC，可设置对象直接进入老年代的标准。

注意：这些大对象进入新生代后可能会使新生代的GC频率和时间增加。

#### 调整 GC 的触发时机

现象：CMS，G1 经常 Full GC，程序卡顿严重。

原因：G1 和 CMS  部分 GC 阶段是并发进行的，业务线程和垃圾收集线程一起工作，也就说明垃圾收集的过程中业务线程会生成新的对象，所以在 GC 的时候需要预留一部分内存空间来容纳新产生的对象，如果这个时候内存空间不足以容纳新产生的对象，那么 JVM 就会停止并发收集暂停所有业务线程（STW）来保证垃圾收集的正常运行。这个时候可以调整 GC 触发的时机（比如在老年代占用 60% 就触发 GC），这样就可以预留足够的空间来让业务线程创建的对象有足够的空间分配。

注意：提早触发 GC 会增加老年代 GC 的频率。

#### 调整 JVM 本地内存大小

现象：GC 的次数、时间和回收的对象都正常，堆内存空间充足，但是报 OOM。

原因：JVM 除了堆内存之外还有一块堆外内存，这片内存也叫本地内存，可是这块内存区域不足了并不会主动触发 GC，只有在堆内存区域触发的时候顺带会把本地内存回收了，而一旦本地内存分配不足就会直接报 OOM 异常。

注意： 本地内存异常的时候除了上面的现象之外，异常信息可能是 `OutOfMemoryError：Direct buffer memory`。 解决方式除了调整本地内存大小之外，也可以在出现此异常时进行捕获，手动触发 GC。

## 3. Java 程序故障排查思路

