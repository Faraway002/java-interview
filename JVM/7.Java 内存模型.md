# Java 内存模型与线程

从操作系统课程中我们了解到，现代应用程序的性能瓶颈大多在 I/O、网络通信以及数据库访问上。为了尽可能多的利用 CPU 而不是让 CPU 在大部分时间内都在等待其他事务，CPU 必须在等待的时间内进行其他的运算，这就不得不涉及到并发编程。

并发编程的一大难点就在于同步，同步就不得不涉及到内存访问和缓存一致性，**Java 内存模型为我们屏蔽了在不同硬件和操作系统中的内存访问差异，使得 Java 程序在各种平台下都能达到一致的内存访问效果**。

## 硬件的效率与一致性

要理解 Java 内存模型，我们先从硬件说起。

现代计算机硬件架构的简单图示：

![img](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/v2-67833188e191c5e7a11d34e613ca352c_720w.jpg)

- **CPU**：CPU 存在多个核心。现代计算机上同时运行多个线程是可能的。每个 CPU 在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的 Java 程序中每个 CPU 上一个线程可能同时（并发）执行。

- **寄存器**：每个 CPU 都包含一系列的寄存器，它们是 CPU 存储数据的基础。CPU 在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为 CPU 访问寄存器的速度远大于主存。

- **高速缓存 Cache**：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

  CPU 访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度要慢。每个 CPU 都有一级或者多级 CPU 缓存。

- **内存**：一个计算机还包含一个主存。所有的 CPU 都可以访问主存，主存通常比 CPU 中的缓存大得多，但是也要慢上不少。

高速缓存和多核 CPU 解决了速度的问题，但是也为系统带来了更高的复杂度，引入了新的问题：

* **缓存一致性问题**：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况。如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？

  为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI、MOSI、Synapse、Firefly 及 DragonProtocol 等，我的操作系统系列文章中介绍了著名的 MESI 协议，这里就不再赘述了。

* **指令重排序问题**：为了使得 CPU 内部的运算单元能够被充分利用，现代 CPU 采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。换句话说，CPU 会对输入代码进行**乱序执行**优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但**并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致**。

  除此之外，编译器在不改变单线程程序语义的前提下，也可以重新安排语句的执行顺序。

  * 单线程环境下，CPU/编译器对指令的重排序都会遵守 as-if-serial 语义，遵守 as-if-serial 意味着**它们不会对数据依赖关系的操作做重排序**，换句话说，**不管怎么重排序，单线程下的执行结果不能被改变**。

  * 多线程环境下，为了解决重排序问题，又提出了**内存屏障**的概念。

    内存屏障可以简单理解为：在操作数据的时候，往数据插入一条内存屏障指令，**重排序时不能把后面的指令重排序到屏障之前的位置**。



## Java 内存模型

**由于不同 CPU 架构的缓存体系不一样、缓存一致性协议不一样、重排序的策略不一样、所提供的内存屏障指令也有差异，为了简化 Java 开发人员的工作。Java 封装了一套规范，这套规范就是 Java 内存模型**。

线程之间的共享变量存储在主内存中，每个线程都有自己私有的本地内存（也叫工作内存），本地内存存储了该线程以读/写共享变量的副本。**不同的线程之间无法直接访问对方的工作内存，线程之间的变量传递均需要通过主内存完成。**

如果硬要把主内存、本地内存和 JVM 中的内存区域对应起来，那么主内存主要是 Java 堆中对象实例数据部分