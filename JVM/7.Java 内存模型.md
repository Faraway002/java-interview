[TOC]

# Java 内存模型与线程

从操作系统课程中我们了解到，现代应用程序的性能瓶颈大多在 I/O、网络通信以及数据库访问上。为了尽可能多的利用 CPU 而不是让 CPU 在大部分时间内都在等待其他事务，CPU 必须在等待的时间内进行其他的运算，这就不得不涉及到并发编程。

并发编程的一大难点就在于同步，同步就不得不涉及到内存访问和缓存一致性，**Java 内存模型为我们屏蔽了在不同硬件和操作系统中的内存访问差异，使得 Java 程序在各种平台下都能达到一致的内存访问效果**。

## 1. 硬件效率与一致性

要理解 Java 内存模型，我们先从硬件说起。

现代计算机硬件架构的简单图示：

![img](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/v2-67833188e191c5e7a11d34e613ca352c_720w.jpg)

- **CPU**：CPU 存在多个核心。现代计算机上同时运行多个线程是可能的。每个 CPU 在某一时刻运行一个线程是没有问题的。这意味着，如果你的 Java 程序是多线程的，在你的 Java 程序中每个 CPU 上一个线程可能同时（并发）执行。

- **寄存器**：每个 CPU 都包含一系列的寄存器，它们是 CPU 存储数据的基础。CPU 在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为 CPU 访问寄存器的速度远大于主存。

- **高速缓存 Cache**：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

  CPU 访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度要慢。每个 CPU 都有一级或者多级 CPU 缓存。

- **内存**：一个计算机还包含一个主存。所有的 CPU 都可以访问主存，主存通常比 CPU 中的缓存大得多，但是也要慢上不少。

高速缓存和多核 CPU 解决了速度的问题，但是也为系统带来了更高的复杂度，引入了新的问题：

* **缓存一致性问题**：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况。如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？

  为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI、MOSI、Synapse、Firefly 及 DragonProtocol 等，我的操作系统系列文章中介绍了著名的 MESI 协议，这里就不再赘述了。

* **指令重排序问题**：为了使得 CPU 内部的运算单元能够被充分利用，现代 CPU 采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。换句话说，CPU 会对输入代码进行**乱序执行**优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但**并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致**。

  除此之外，编译器在不改变单线程程序语义的前提下，也可以重新安排语句的执行顺序。

  * 单线程环境下，CPU/编译器对指令的重排序都会遵守 as-if-serial 语义，遵守 as-if-serial 意味着**它们不会对数据依赖关系的操作做重排序**，换句话说，**不管怎么重排序，单线程下的执行结果不能被改变**。

  * 多线程环境下，为了解决重排序问题，又提出了**内存屏障**的概念。

    内存屏障可以简单理解为：在操作数据的时候，往数据插入一条内存屏障指令，**重排序时不能把后面的指令重排序到屏障之前的位置**。

## 2. Java 内存模型

由于不同 CPU 架构的缓存体系不一样、缓存一致性协议不一样、重排序的策略不一样、所提供的内存屏障指令也有差异，为了简化 Java 开发人员的工作。Java 封装了一套规范，这套规范就是 Java 内存模型，**用来屏蔽各种硬件和操作系统之间的内存访问差异**。

Java 内存模型定义是非常困难的，定义必须足够严谨，才不会让内存访问操作发生歧义；但也必须足够宽松，让 JVM 能有足够的空间去利用硬件的特性。

Java 内存模型是一个比较大的主题，我们从每个小主题开始一一介绍。

### 2.1 主内存与工作内存

Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）。

每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比）。

- 线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。
- 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

![image-20220701092037575](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220701092037575.png)

这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一层次的内存划分，这两者基本上是没有关系的。如果两者一定要勉强对应起来，从变量、主内存、工作内存的定义看，**主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应了虚拟机栈中部分区域**。

更底层上的对应则是：主内存对应物理内存，而工作内存则对应于寄存器和高速缓存。

### 2.2 内存间的交互操作

Java 内存模型定义了以下 8 种操作来完成主内存与工作内存之间的具体交互协议：

* lock（锁定）：作用于主内存，它把一个变量标识为一条线程独占的状态。
* unlock（解锁）：