# 消息队列基础

## 1. 什么是消息队列

消息队列本质上是一个转发器，它使用一个队列作为容器（意味着消息队列是先进先出的），包含**发消息、存消息、消费消息**的过程。

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628165054284.png" alt="image-20220628165054284" style="zoom:50%;" />

最简单的消息队列模型如下，我们完全可以使用队列实现一个简单的消息队列：

![image-20220628164851280](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628164851280.png)

我们通常说的消息队列，简称 **MQ（Message Queue）**，它其实就指**消息中间件**，当前业界比较流行的开源消息中间件包括：ActiveMQ、RabbitMQ、RocketMQ 以及 Kafka。

## 2. 为什么需要消息队列

消息队列主要有以下几大用途：

1. 异步处理
2. 流量削峰
3. 应用解耦

### 2.1 异步处理

首先我们看一个场景：用户注册成功后，给它发个短信和发个邮件。

如果注册信息入库是 30ms，发短信、邮件也是 30ms，三个动作**串行执行**的话，会比较耗时，响应需要 90ms：

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628165426971.png" alt="image-20220628165426971" style="zoom:67%;" />

如果采用并行执行的方式，可以减少响应时间，具体来说：注册信息入库后，同时异步发短信和邮件。

这个时候，我们就可以将用户的请求数据存储到消息队列之后就立即返回结果（这个一般比较快），比如返回一个“您的请求正在处理”的提示信息；随后，系统再对消息进行消费，这时再发送邮件和短信：

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628165736209.png" alt="image-20220628165736209" style="zoom:67%;" />

使用消息队列后，由于业务是异步的，因此响应时间就得到了比较大的提升。

> **注意事项**
>
> 因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，**使用消息队列进行异步处理之后，需要适当修改业务流程进行配合**，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票的场景。

### 2.2 流量削峰

**先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉**。

举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：

![image-20220628170139558](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628170139558.png)

> **为什么使用消息队列可以进行削峰？消息队列不会垮掉吗？**
>
> 首先，消息队列这种中间件的设计就是高并发，它必然拥有极高的性能，就像 Redis 一样，天生的性能好。
>
> 其次，消息队列通常是集群部署的，保证了其高可用性。
>
> 最后，消息队列如果也处理不了这么多消息的话（比如队列满了），我们可以设置消息队列直接抛弃掉消息，返回一个错误页面给用户（虽然这样做用户体验不太好，但是至少后台服务不会垮掉）。

### 2.3 应用解耦

举个常见业务场景：下单扣库存，用户下单后，订单系统去通知库存系统扣减。传统的做法就是订单系统直接调用库存系统：

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628171325207.png" alt="image-20220628171325207" style="zoom:67%;" />

这样做有两个显著的问题：

- 如果库存系统无法访问，下单就会失败，订单和库存系统存在耦合关系
- 如果业务又接入一个营销积分服务，那订单下游系统要扩充，如果未来接入越来越多的下游系统，那订单系统代码需要经常**修改**

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628171517539.png" alt="image-20220628171517539" style="zoom:67%;" />

我们在引入消息队列后，就可以对订单系统和其他系统进行解耦，订单系统只需要发送消息到消息队列中，其他系统只需要消费消息即可：

<img src="https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628171840430.png" alt="image-20220628171840430" style="zoom:67%;" />

1. 订单系统：用户下单后，消息写入到消息队列，返回下单成功
2. 库存系统：订阅下单消息，获取下单信息，进行库存操作。
3. 积分系统：订阅下单消息，增减积分。
4. ...

## 3. 引入消息队列可能带来的问题

- **系统可用性降低：** 系统可用性在某种程度上降低：在加入 MQ 之前，不用考虑消息丢失或者说 MQ 挂掉等等的情况；但是，引入 MQ 之后就需要去考虑了。
- **系统复杂性提高：** 加入 MQ 之后，需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题。
- **一致性问题：** 消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了，这些情况都是要考虑的。

## 4. 消息队列的工作模型

### 4.1 P2P 模型

P2P 也就是点对点模型，该模型下，消息生产者生产消息发送到队列中，然后消息消费者从队列中取出并且消费消息。

消息被消费以后，队列中不再存储，所以**消费者不可能消费到已经被消费的消息**。队列支持存在多个消费者，但是**对一个消息而言，只会有一个消费者可以消费**。

![image-20220628175453746](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628175453746.png)

### 4.2 Pub/Sub 模型

发布订阅模型（Pub/Sub） 使用**主题（Topic）作为消息通信载体，类似于广播模式**；发布者发布一条消息，该消息通过主题传递给所有的订阅者，**在一条消息广播之后才订阅的用户则是收不到该条消息的**。

![image-20220628175616007](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628175616007.png)

和 P2P 模式不同的是，**发布到 Topic 的消息可以被所有订阅者消费**。

### 4.3 支持订阅组的 Pub/Sub

在普通发布/订阅模式下，当发布者消息量很大时，显然单个订阅者的处理能力是不足的。

实际上，现实场景中是多个订阅者节点组成一个订阅组负载均衡消费 topic 消息即分组订阅，这样订阅者很容易实现消费能力线性扩展。

可以看成是一个 topic 下有多个 Queue，每个 Queue 是点对点的方式，Queue 之间是发布订阅方式，示意图如下：

![image-20220628175830565](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628175830565.png)

## 5. 消息队列协议

### 5.1 JMS

JMS 是 Java Message Service 的简写，它是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息，它使分布式通信耦合度更低，消息服务更加可靠以及异步性。

我们常用的 ActiveMQ 就是基于 JMS 规范实现的。

JMS 支持 P2P 和 Pub/Sub 模型。

### 5.2 AMQP

AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准**高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。

RabbitMQ 就是基于 AMQP 协议实现的。

### 5.3 JMV 和 AMQP 的对比

| 对比方向     | JMS                                         | AMQP                                                         |
| :----------- | :------------------------------------------ | :----------------------------------------------------------- |
| 定义         | Java API                                    | 协议                                                         |
| 跨语言       | 否                                          | 是                                                           |
| 跨平台       | 否                                          | 是                                                           |
| 支持消息类型 | 提供两种消息模型：<BR>1. P2P<BR/>2. Pub/sub | 提供了五种消息模型：<BR>1. direct exchange<BR>2. fanout exchange<BR>3. topic change<BR>4. headers exchange<BR>5. system exchange<BR>本质来讲，后四种和 JMS 的 Pub/Sub 模型没有太大差别，仅是在路由机制上做了更详细的划分； |
| 支持消息类型 | 支持多种消息类型                            | 二进制消息                                                   |

- AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。
- JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持二进制消息类型（复杂的类型可序列化后发送）。
- 由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 P2P 和 Pub/Sub 两种方式。

## 6. 常见消息队列对比

|            | RocketMQ                                                     | Kafka                                                    | RabbitMQ                                       |
| ---------- | ------------------------------------------------------------ | -------------------------------------------------------- | ---------------------------------------------- |
| 单机吞吐量 | 11.6w/s                                                      | 17.3w/s                                                  | 2.6w/s（消息做持久化）                         |
| 开发语言   | Java                                                         | Java/Scala                                               | Erlang                                         |
| 主要维护者 | Alibaba                                                      | Apache                                                   | Mozilla/Spring                                 |
| 订阅形式   | 基于 Topic/messageTag，按照消息类型、属性进行正则匹配的发布订阅模式 | 基于 Topic，按照 Topic 进行正则匹配的发布订阅模式        | 提供了 4 种：direct, topic ,Headers 和fanout   |
| 持久化     | 支持大量堆积                                                 | 支持大量堆积                                             | 支持少量堆积                                   |
| 顺序消息   | 支持                                                         | 支持                                                     | 不支持                                         |
| 集群方式   | 常用 多对 Master-Slave 模式，开源版本需手动切换 Slave 变成 Master | 天然的主从，无状态集群，每台服务器既是 Master 也是 Slave | 支持简单集群，复制模式，对高级集群模式支持不好 |
| 性能稳定性 | 一般                                                         | 较差                                                     | 好                                             |

