# 消息队列基础

## 1. 什么是消息队列

消息队列本质上是一个转发器，它使用一个队列作为容器（意味着消息队列是先进先出的），包含**发消息、存消息、消费消息**的过程。

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628165054284.png" alt="image-20220628165054284" style="zoom:50%;" />

最简单的消息队列模型如下，我们完全可以使用队列实现一个简单的消息队列：

![image-20220628164851280](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628164851280.png)

我们通常说的消息队列，简称 **MQ（Message Queue）**，它其实就指**消息中间件**，当前业界比较流行的开源消息中间件包括：ActiveMQ、RabbitMQ、RocketMQ 以及 Kafka。

## 2. 为什么需要消息队列

消息队列主要有以下几大用途：

1. 异步处理
2. 流量削峰
3. 应用解耦

### 2.1 异步处理

看一个场景：

A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。

![image-20220703131836601](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703131836601.png)

一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。

如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了。

![image-20220703131908262](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703131908262.png)

> **注意事项**
>
> 因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，**使用消息队列进行异步处理之后，需要适当修改业务流程进行配合**，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票的场景。

### 2.2 流量削峰

**先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉**。

看如下场景：

每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。

一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。

但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。

![image-20220703132001752](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703132001752.png)

如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就可以了，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。

这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。

![image-20220703132048874](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703132048874.png)

> **为什么使用消息队列可以进行削峰？消息队列不会垮掉吗？**
>
> 首先，消息队列这种中间件的设计就是高并发，它必然拥有极高的性能，就像 Redis 一样，天生的性能好。
>
> 其次，消息队列通常是集群部署的，保证了其高可用性。
>
> 最后，消息队列如果也处理不了这么多消息的话（比如队列满了），我们可以设置消息队列直接抛弃掉消息，返回一个错误页面给用户（虽然这样做用户体验不太好，但是至少后台服务不会垮掉）。

### 2.3 应用解耦

看如下场景：

A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃......

![image-20220703131714930](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703131714930.png)

在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？

如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。

![image-20220703131749876](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703131749876.png)

通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。

## 3. 引入消息队列可能带来的问题

- **系统可用性降低：** 系统可用性在某种程度上降低：在加入 MQ 之前，不用考虑消息丢失或者说 MQ 挂掉等等的情况；但是，引入 MQ 之后就需要去考虑了。
- **系统复杂性提高：** 加入 MQ 之后，需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题。
- **一致性问题：** 消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？比如 A 系统处理完直接返回了，用户就以为这个请求成功了。但是 BCD 系统内，BD 两个系统写数据库成功了，结果 C 挂掉了，这样就会导致数据不一致。

所以消息队列实际是一种非常复杂的架构，并不是万金油，**引入 MQ 有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉**，做好之后，你会发现系统复杂度提升了一个数量级，也许是复杂了 10 倍。

## 4. 常见消息队列对比

| 特性                     | ActiveMQ                              | RabbitMQ                                           | RocketMQ                                                     | Kafka                                                        |
| ------------------------ | ------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量               | 万级，比 RocketMQ、Kafka 低一个数量级 | 同 ActiveMQ                                        | 10 万级，支撑高吞吐                                          | 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |
| topic 数量对吞吐量的影响 |                                       |                                                    | topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic | topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 |
| 时效性                   | ms 级                                 | 微秒级，这是 RabbitMQ 的一大特点，延迟最低         | ms 级                                                        | 延迟在 ms 级以内                                             |
| 可用性                   | 高，基于主从架构实现高可用            | 同 ActiveMQ                                        | 非常高，分布式架构                                           | 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 消息可靠性               | 有较低的概率丢失数据                  | 基本不丢                                           | 经过参数优化配置，可以做到 0 丢失                            | 同 RocketMQ                                                  |
| 功能支持                 | MQ 领域的功能极其完备                 | 基于 erlang 开发，并发能力很强，性能极好，延时很低 | MQ 功能较为完善，还是分布式的，扩展性好                      | 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 |

选型建议：

* **中小型公司**，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；**大型公司**，基础架构研发实力较强，用 RocketMQ 是很好的选择。
* 如果是**大数据领域**的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，更何况 Kafka 几乎是全世界这个领域的事实性规范。

## 5. 消息队列的工作模型

### 5.1 P2P 模型

P2P 也就是点对点模型，该模型下，消息生产者生产消息发送到队列中，然后消息消费者从队列中取出并且消费消息。

消息被消费以后，队列中不再存储，所以**消费者不可能消费到已经被消费的消息**。队列支持存在多个消费者，但是**对一个消息而言，只会有一个消费者可以消费**。

![image-20220628175453746](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628175453746.png)

### 5.2 Pub/Sub 模型

发布订阅模型（Pub/Sub） 使用**主题（Topic）作为消息通信载体，类似于广播模式**；发布者发布一条消息，该消息通过主题传递给所有的订阅者，**在一条消息广播之后才订阅的用户则是收不到该条消息的**。

![image-20220628175616007](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628175616007.png)

和 P2P 模式不同的是，**发布到 Topic 的消息可以被所有订阅者消费**。

### 5.3 支持订阅组的 Pub/Sub

在普通发布/订阅模式下，当发布者消息量很大时，显然单个订阅者的处理能力是不足的。

实际上，现实场景中是多个订阅者节点组成一个订阅组负载均衡消费 topic 消息即分组订阅，这样订阅者很容易实现消费能力线性扩展。

可以看成是一个 topic 下有多个 Queue，每个 Queue 是点对点的方式，Queue 之间是发布订阅方式，示意图如下：

![image-20220628175830565](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628175830565.png)

## 6. 消息队列协议

### 6.1 JMS

JMS 是 Java Message Service 的简写，它是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息，它使分布式通信耦合度更低，消息服务更加可靠以及异步性。

我们常用的 ActiveMQ 就是基于 JMS 规范实现的。

JMS 支持 P2P 和 Pub/Sub 模型。

### 6.2 AMQP

AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准**高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。

RabbitMQ 就是基于 AMQP 协议实现的。

### 6.3 JMV 和 AMQP 的对比

| 对比方向     | JMS                                         | AMQP                                                         |
| :----------- | :------------------------------------------ | :----------------------------------------------------------- |
| 定义         | Java API                                    | 协议                                                         |
| 跨语言       | 否                                          | 是                                                           |
| 跨平台       | 否                                          | 是                                                           |
| 支持消息类型 | 提供两种消息模型：<BR>1. P2P<BR/>2. Pub/sub | 提供了五种消息模型：<BR>1. direct exchange<BR>2. fanout exchange<BR>3. topic change<BR>4. headers exchange<BR>5. system exchange<BR>本质来讲，后四种和 JMS 的 Pub/Sub 模型没有太大差别，仅是在路由机制上做了更详细的划分； |
| 支持消息类型 | 支持多种消息类型                            | 二进制消息                                                   |

- AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。
- JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持二进制消息类型（复杂的类型可序列化后发送）。
- 由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 P2P 和 Pub/Sub 两种方式。

