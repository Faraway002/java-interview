# 面向对象

面向对象的程序是由一系列对象组成的，每个对象各司其职，共同组成了一个完整的程序。

对象体现在编程语言中就是类，对象的职责就是对象能够调用的方法，对象中的数据就是它的字段（也叫成员变量），对象的状态就是某个时间点该对象的字段的取值。

## 面向对象概述

**类是构造对象的模板或蓝图，由类构造对象的过程称为创建类的实例。**

在 Java 中，所有的代码都写在一个或多个类中。Java 自身也提供了很多类供用户使用。

面向对象有三大特征：

1. 封装，指的是将数据和行为组合在一个包内，并对使用者隐藏具体的实现方式。

   Java 提供许多好用的类，比如日期类 `java.util.Date`，我们直接可以拿来用，而无需关心它底层是如何表示、计算日期的。这也是封装的好处。

2. 继承，指的是通过拓展一个类来创建一个新类的过程。在 Java 中，所有的类都有一个共同的祖先类 `Object`。

3. 多态，指的是父类变量可以指向任意子类对象。在讲解继承时将会详细讲解这个概念。

### 类之间的关系

类与类之间一般有五种关系，从上到下耦合度依次升高：

1. 依赖，通俗的讲就是一个类使用了另一个类。体现为一个类是另一个类的方法中的参数，局部变量。
2. 关联，关联分为单向关联和双向关联（甚至还有自关联），体现为一个类的对象被作为另一个类的字段。（如果另一个类也有该类的字段，则是双向关联）
3. 聚合，是关联的一种，表现形式上和关联一致。唯一区别体现在语义上：聚合的两个类有一种整体和局部的感觉，而关联的两个类一般是平等的。
4. 组合，是聚合的一种，区别体现在语义上，聚合的两个类虽然是整体和局部的关系，但是整体消亡了局部仍然存在；而组合则是一荣俱荣，一损俱损。
5. 继承，指的是某个类是另一个类的父类。

## 使用 Java 提供的类

Java 提供了很多类，封装了很多好用的功能，以 `java.util.Date` 类为例，它用于表示日期，看下面的例子：

```java
import java.util.Date;

public class Application {
    public static void main(String[] args) {
        Date date = new Date();
        System.out.println(date);
    }
}
```

运行这段代码，你会发现打印了当前的日期（虽然格式可能不是你熟悉的格式）。

要使用类，首先需要有一个该类的对象实例，因此需要使用对象的构造器（构造函数、构造方法）构造一个实例。我们在之后还会详细说明构造器，现在需要知道的是，构造器与类同名，需要以 `new` 调用，可以接受 0 个或多个参数，没有返回值，每个类可以有一个或多个构造器（涉及到重载，之后会详细解释）。

**`new` 操作符用于给对象在内存中分配空间，分配完成以后，构造器开始工作，完成类的初始化，之后返回一个地址给类变量。**

如果一个类的实例在一个方法中没有经过 `new` 初始化就被直接拿来使用，那么代码将无法通过编译。

**一个类的实例还可以指向名为 `null` 的特殊值，表示该类变量还未经过任何初始化或不引用任何对象。**

## 使用自定义类

首先看一个例子：

```java
class Car {
    public void move() {
    }
}

class Driver {
    public void drive(Car car) {
        car.move();         
    }
}
```

这里有两个类，一个是司机类，一个是车类。车类中有一个移动方法，表示车正在移动；司机类中有一个开车方法，需要有一辆车才能够开车，司机开车，车才会动。

像这样对真实世界进行抽象，把真实世界的对象抽象成一个个自定义的类，通过类的方法调用来描述真实世界中对象的操作。这就是面向对象的程序设计的体现。

其中，我们看到一个 `.` 运算符，它用于通过对象变量访问对象存储空间。换句话说，该运算符可以访问对象中的成员变量以及方法。

**如果对一个 `null` 的对象变量使用 `.` 操作符，会产生一个 `NullPointerException`（空指针）异常，程序会立即停止工作**。这是一个非常严重的错误，因此在调用前一定要详细的检查该对象变量是否已经有一个实际的对象引用。

> **多个源文件的使用**
>
> 迄今为止，我们编写的程序都写在一个源文件中。这样会导致一个文件变得很大，难以管理和查看。
>
> 事实上，我们可以把类写在单独的源文件中，Java 在编译时会自动寻找这些类对应的源文件进行编译。更重要的是，如果某个源文件发生了变化，Java 还会自动重新编译该源文件。
>

### 成员变量

类的成员变量指的是对象运行所必须的数据，这些数据使用变量来表示。比如：

```java
class Car {
    int speed;
}
```

`Car` 类具有一个名为 `speed` 的成员变量，这个变量可以表示车在运行中的速度。

注意，和函数中的临时变量不同，成员变量定义后如果未赋初值，则会取该类型的默认值。

### 成员函数

成员函数就是其他编程语言中的函数，是可复用的代码块。函数由返回值类型，函数名，函数参数列表，函数体组成。

返回值类型指的是这一段代码块运算完成之后产生了何种类型的结果，函数最后会把这个结果返回给函数的调用者。调用者需要使用该种类型的变量来接收。特别地，函数可以不返回任何东西，此时返回值类型要声明为 `void`。

要返回一个值，需要使用 `return xxx` 语句，特别的，如果不返回任何东西，也可以使用 `return;` 来提前结束函数的执行。

Java 中，由于所有代码都属于类，因此函数也就属于类，叫做类的成员函数（方法）。指的是该对象能够做的操作，通常这些成员函数会访问成员变量，对成员变量进行一些操作。比如：

```java
class Car {
    int speed;
    
    int speedUp(int additionalSpeed) {
        speed += additionalSpeed;
        return speed;
    }
}
```

这里有一个加速的操作，指定一个增加量，车就会把速度提升，并且把当前的速度返回。

#### 可变参数

函数可以有可变参数，即可以接受任意数量的参数。语法为 `returnType method(type ...args)`。

本质上，args 为 type 类型的数组，那么它和直接写 `type[] args` 有什么不同呢？

答案是在调用时，可变参数可以直接传递参数，而后者还需要构造数组传入。

比如：

```java
public int add(int ...nums) {
    int result = 0;
    for (int num : nums) {
        result += num;
    }
    return result;
}

// 等价于
public int add(int[] nums) {
    int result = 0;
    for (int num : nums) {
        result += num;
    }
    return result;
}

// 调用时不同
add(1, 2, 3); // 可变参数
add(new int[] {1, 2, 3}); // 需要构造数组
```

#### 隐式参数

看下面的例子：

```java
class Car {
    int speed;
    
    int speedUp(int speed) {
        speed += speed;
        return speed;
    }
}
```

在这个例子中，我们的参数名称也叫 speed，这会和成员变量 speed 冲突吗？答案是肯定的。

事实上，当方法中参数与成员变量重名时，方法参数优先级更高。为此，需要使用隐式参数 `this`。

```java
class Car {
    int speed;
    
    int speedUp(int speed) {
        this.speed += speed;
        return this.speed;
    }
}
```

`this` 代表当前对象的实例，可以通过 `.` 操作符访问成员变量以及方法。

> 可以通过在每个方法的第一个参数中声明一个本类变量，变量名为 `this` 的方式显式接收 `this` 参数，比如：
>
> ```java
> class Car {
>     int speed;
>     
>     int speedUp(Car this, int speed) {
>         this.speed += speed;
>         return this.speed;
>     }
> }
> ```

### 访问权限

我们一直在强调封装，但是实际操作过就发现，我们类中的成员变量可以被随意更改，方法可以被随意调用。

为此，编程语言需要提供一种访问权限，来阻止这样的事情发生。

Java 有四种访问权限，如下表所示：

| 访问权限  | 本类 | 本包的类 | 子类 | 非子类且非本包类 |
| :-------: | :--: | :------: | :--: | :--------------: |
|  public   |  是  |    是    |  是  |        是        |
| protected |  是  |    是    |  是  |        否        |
|  default  |  是  |    是    |  否  |        否        |
|  private  |  是  |    否    |  否  |        否        |

其中，default 是默认的访问权限，什么也不写就是属于这种访问权限。

关于子类和包，我们将在之后详细介绍。

### setter 和 getter

习惯上，我们把类的成员变量都设置为 `private`，而通过 setter 和 getter 方法对它进行修改、访问。

比如：

```java
class Person {
    private int age;
    
    public void setAge(int age) {
        this.age = age;
    }
    
    public int getAge() {
        return age;
    }
}
```

getter 和 setter 一目了然，这里就不再赘述了。

getter 和 setter 的好处是：可以增加更多实现细节，做更多的优化，同时，很好的实现了代码封装。

### 静态方法与静态字段

一个方法或字段如果以 `static` 修饰，那么就称它是静态的。

静态的东西属于类，而不属于具体的某个对象。体现在代码中，静态的东西可以直接通过类名 + `.` 进行访问，而非静态的东西只能通过对象实例访问。

`static` 还可以和 `final` 结合使用作用在字段上，表示是一个静态的常量。

静态的原理简单来说，就是静态的东西优先于非静态的东西被加载到内存中，所以不需要 `new` 就可以直接访问。

因此，静态的内容不能访问非静态的内容，反之则可以。

> 不是完全不能访问非静态的内容，可以在静态方法里 `new` 一个对象出来，然后访问其非静态内容。

### main 方法

main 方法是一个静态方法，它的标准格式为：

```java
public static void main(String[] args) {
    
}
```

main 方法是静态的表明，程序的入口不需要任何其他对象辅助，直接可以使用。因此，所有其他对象都是在 main 方法中被 `new` 出来或静态调用的。

## 构造函数

### 函数重载

首先要介绍函数签名，一个函数签名由它的名称 + 参数决定，而参数由参数个数，每个参数的类型决定。

函数重载指的是一个函数可以具有多个**相同的名称，但是函数签名不同的函数**。既然函数名称相同，但是函数签名又要求不同，则重载函数的区别就在参数上。

函数重载的例子：

```java
class Car {
    private int speed;
    
    public void speedUp() {
        speed += 1;
    }
    
    public void speedUp(int speed) {
        this.speed += speed;
    }
}
```

> **返回值**
>
> 返回值不在函数签名内，因此返回值不同，其他地方相同的函数不能算作函数重载。
>
> 同理，修饰符 `static`、`final` 等也不算在函数签名中，因此也不能算作重载。

### 构造函数

构造函数（constructor），也叫构造器，构造方法，之前已经了解到了，它在类初始化时被调用。

构造函数有如下特点：

1. 函数名和类名相同。
2. 通过 `new` 调用。
3. 无返回值。
4. 可以有参数。
5. 可以重载。

在没有显式声明一个构造函数时，Java 编译器会自动为该类生成一个无参数的构造函数，对其成员变量进行默认初始化。

但是如果有显式的带参数的构造器了，且构造时不提供参数，那么就会报错，提示找不到该函数。因为只要具有一个显式的构造器，Java 编译器就不会生成默认的构造器。

如果一个 `final` 的常量（非 `static`）未在声明时被初始化，那么它必须在构造函数中被初始化，且之后不能再被赋值。

### 默认初始化

不同的数据类型，初始化的值不同：

1. 整数型，初始化为 0。
2. 浮点数型，初始化为 0.0。
3. 字符型，初始化为 0，表示空字符。
4. 布尔型，初始化为 `false`。
5. 对象，初始化为 `null`。

### 在构造函数中调用其他构造函数

假设某个类已有一个构造器，初始化了部分成员变量，现在要编写一个新的构造器初始化全部成员变量，这时就不用重新写这些代码，而是直接调用这个构造器。

在构造器中调用构造器使用 `this(params)` 的形式调用，其中 params 为参数。

### 初始化块

初始化块是代码块，使用 `{ }` 包裹。一个类可以包含多个这样的初始化块，用于初始化类。

初始化块的执行是优先于构造函数执行的。

如：

```java
class Car {
    private int speed;
    
    {
        speed = 2;
    }
    
    public Car() {
        speed += 3;
    }
}
```

当该类初始化完毕后，这个对象的 speed 成员的取值为 5。

#### 静态初始化块

初始化块还可以添加 `static` 关键字，这样的块叫做静态初始化块。

静态初始化块比初始化块要常见，它只会在类初次被加载到内存时执行一次。一般用于复杂的静态初始化。

## 包

Java 使用包将类组织在一个集合中，便于管理和组织代码。

使用包的主要目的是确保类名的唯一性，在 Java 中就有这样的例子，比如 `java.sql.Date` 和 `java.util.Date`。

包名一般是公司的域名的逆序，一般是全小写字母，而类名遵循驼峰命名法，这就可以将类名和包名区分开来，比如 `com.baidu.util.Date`。

包中还可以有其他包，比如：`com.baidu.util` 包还可以包括一个 `com.baidu.util.provider` 包。事实上这两个包是没有任何关系的，每一个包都是独立的类的集合。

包体现在文件系统上，就是文件夹的区别，比如：

```java
package com.baidu.util;

public class Date {
    
}
```

```java
package com.baidu;

import com.baidu.util.Date;

public class Application {
    public static void main(String[] args) {
        Date date = new Date();
    }
}
```

这里的 `package` 关键字就是用于声明该类属于哪个包。

体现在文件夹上，就是：

![image-20220117181933952](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220117181933952.png)

编译时需要注意，要回到项目根目录（这里是和 com 同级别的目录），使用类的路径名进行编译，而使用完全限定名（包名 + 类名）运行：

```shell
$> javac com/baidu/Application.java
$> java com.baidu.Application
```

### 导入

要使用其他包中的类，除了使用类的完全限定名外，还可以使用导入的方式。

导入使用 `import` 关键字，用于导入一个类或多个类。

比如 `import java.util.List` 表示只导入了该包下的 `List` 这个类；而 `import java.util.*` 则表示引入了 `java.util` 包下的所有类。

注意，导入包的所有类不会导入其子包的类。

假设你导入了 `java.sql.*` 和 `java.util.*`，此时你想使用 `java.util` 的 `Date` 类，有两种方法可以解决：

1. 增加一个单独的导入语句：

   ```java
   import java.sql.*;
   import java.util.*;
   import java.util.Date;
   ```

2. 使用完全限定的类名）。

### 静态导入

在 `import` 后增加一个 `static` 关键字可以导入某个类的单个或全部静态成员。比如：

```java
import static java.lang.System.out;

public class Application {
    public static void main(String[] args) {
        out.println("123");
    }
}
```

## 类路径

**类路径是所有包含类文件的路径的集合。**

类路径可以通过设置操作系统环境变量 `CLASSPATH` 来配置，也可以通过命令加上 `-classpath（或 -cp）` 参数来指定。

下面是一个例子：

```shell
$> java -classpath c:\classdir;.;c:\archives\xxx.jar MyApplication
```

`c:\classdir;.;c:\archives\xxx.jar` 这样的就是一个类路径，其中，`.` 代表当前目录，`;` 代表目录之间的分隔符。分隔符由操作系统决定，Linux 上是 `:`。

> **CLASSPATH**
>
> 通过设置 CLASSPATH 的方式配置类路径的方式已经过时。在早期版本的 JDK 中需要配置 CLASSPATH 以找到 JDK 类库，8 以后的版本已经不需要此配置。

### 类路径与 java、javac 命令

javac 命令用于编译指定的 Java 源文件，可以是当前目录下的源文件，也可以是子目录下的源文件，如果是子目录下的源文件，就需要使用操作系统中的路径分隔符来编译，这种情况一般发生在包中。

编译完成之后生成的是 `.class` 文件，这是介于源码和机器码之间的一种 JVM 字节码文件，是有规律的。它可以被 java 命令装载到 JVM 中，如果有 main 函数，就可以执行。 

javac 和 java 命令总是会在你的类路径下搜索 Java 源文件以及类文件。唯一不同的是，javac 命令总是会搜索当前目录，而 java 命令只有在类路径中设置有当前目录（用一个 `.` 表示）时才会查看当前目录。

### jar

在包的学习中我们已经了解到，通过包可以很好的组织我们的类。事实上，如果类不在它对应包所对应的文件夹中，那么类将无法工作。平常我们自己使用 IDE 开发，IDE 会管理我们自己编写的类，出现这种错误的情况很少。

当我们使用第三方库时，如果这个库的规模很小，我们大可以把类文件复制到我们的工程路径中，但是库的规模很大的话（比如著名的 Spring），该如何组织呢？

事实上，Java 允许使用格式为 `.jar` 的压缩文件（本质上是 zip 文件）把类装载进去，在需要时使用即可。这里的使用方式就是把 jar 文件（也叫 jar 包）放置到你的类路径下。

#### 打包

JDK 提供了 `jar` 命令进行打包，它很类似 Linux 上的 `tar` 命令，下面是一些选项说明：

| 选项 | 说明                                                         |
| :--- | :----------------------------------------------------------- |
| c    | 创建一个新的 jar 文件并把指定的文件放入其中，如果是目录，会递归的处理。 |
| v    | 生成详细的输出结果                                           |
| f    | 档案文件名。省略时, 基于操作使用 stdin 或 stdout             |
| i    | 建立索引文件加快查找（适用于大型 jar 包）                    |
| m    | 将一个清单文件加入到 jar 包中                                |
| e    | 在清单文件中创建一个入口点                                   |
| x    | 解压 jar 文件                                                |
| u    | 更新 jar 文件                                                |

#### 清单文件

jar 包含有一个清单文件 `MANIFEST.MF`，它被放在 jar 包中的 META-INF 目录下（该目录在打包时自动生成）。

清单文件用于描述 jar 包的一些信息，最小的清单文件可以只有一行：‘

```
Manifest-Version: 1.0
```

含义是当前版本是 1.0 版本。清单文件可以包含更多的条目，这些条目可以被组织为多个节，节与节之间用空行隔开。由于一些工具会自动为我们编辑清单文件，因此我们并不关注它的具体内容。

> **可执行 jar 包**
>
> 在清单文件中添加一行：
>
> ```
> Main-Class: 含有 main 方法的类
> ```
>
> 那么这个 jar 包就可以被运行，需要使用 java 命令的 `-jar` 选项。

## 文档注释

JDK 提供了一个很好用的工具 javadoc，用于抽取代码中的文档注释，生成 HTML 文件。

文档注释的格式是：

```java
/**
  * 这是Java的文档注释
  *
  * @author wzy
  */
```

javadoc 会从以下几个地方抽取文档：

1. 模块
2. 包
3. public 的类与接口
4. public 和 protected 的字段
5. public 和 protected 的构造器以及方法

由于文档注释最后会转换成 HTML，因此可以使用 HTML 的标签，也存在一些特殊语法。

文档注释可以包含标记，标记以 `@` 开头（或以 `{@` 开头，`}` 结尾），比如 `@author` 可以放在类注释上，说明该类的作者，`@since` 则是说明从何时开始有该类等等。

javadoc 可以识别的标记如下：

| 标签          | 描述                                                      |
| :------------ | :-------------------------------------------------------- |
| @author       | 标识一个类的作者，一般用于类注释                          |
| {@code ...}   | 在省略号处可以键入代码                                    |
| @deprecated   | 指名一个过期的类或成员，表明该类或方法不建议使用          |
| {@docRoot}    | 指明当前文档根目录的路径                                  |
| @exception    | 可能抛出异常的说明，一般用于方法注释                      |
| {@inheritDoc} | 从直接父类继承的注释                                      |
| {@link}       | 插入一个到另一个主题的链接                                |
| {@linkplain}  | 插入一个到另一个主题的链接，但是该链接显示纯文本字体      |
| @param        | 说明一个方法的参数，一般用于方法注释                      |
| @return       | 说明返回值类型，一般用于方法注释，不能出现再构造方法中    |
| @see          | 指定一个到另一个主题的链接，需要使用 `#` 分割类名和方法名 |
| @serial       | 说明一个序列化属性                                        |
| @serialData   | 说明通过 writeObject() 和 writeExternal() 方法写的数据    |
| @serialField  | 说明一个 ObjectStreamField 组件                           |
| @since        | 说明从哪个版本起开始有了这个函数                          |
| @throws       | 和 @exception 标签一样.                                   |
| {@value}      | 显示常量的值，该常量必须是 static 属性。                  |
| @version      | 指定类的版本，一般用于类注释                              |

对两种标签格式的说明：

- @tag 格式的标签（不被`{ }`包围的标签）为块标签，只能在主要描述（类注释中对该类的详细说明为主要描述）后面的标签部分（如果块标签放在主要描述的前面，则生成 API 帮助文档时会检测不到主要描述）。
- {@tag} 格式的标签（由`{ }`包围的标签）为内联标签，可以放在主要描述中的任何位置或块标签的注释中。

比如：

```java
/**
  * 测试类
  *
  * @author wzy
  * @version 1.0.0
  */
public class Test{
} 
```

文档注释可以包含大部分的 HTML 标签，甚至是 img 图像标签。使用图像时，需要把图像等外部文件放在 `doc-files` 文件夹里，javadoc 工具会自动提取这些文件。

下面介绍一些常用的文档注释：

1. 类注释。必须放在 `import` 语句后，类定义之前。
2. 方法注释。必须放在方法之前。
3. 字段注释。必须放在字段之前，一般来说，只需要对 public 和 protected 的字段说明注释即可，但是不排除需要查看源代码的情况，此时加上注释也是很好的。
4. 包注释。包注释需要在每个包中添加一个单独的文件，名为 `package-info.java`，它除了能包含 javadoc 之外，不能包含任何其他东西。

使用 javadoc 命令行工具就可以抽取并生成文档了，一般会添加 `-d` 选项。如：`javadoc -d doc com.example.test`，这样就为 `com.example.test` 生成 javadoc 的 HTML 文件，放在 doc 目录中。

## 继承

Java 中使用 `extends` 关键字继承一个已存在且允许继承的类，比如比亚迪汽车继承了汽车：

```JAVA
class Car {
    private int speed;
    
    public Car(int speed) {
        this.speed = speed;
    }
} 

class BYDCar extends Car {
    public BYDCar() {
        super(100);
    }
}
```

**子类会继承父类的一切，包括私有属性，只不过子类不能直接访问父类的私有属性**，除非父类有 `public` 或 `protected` 的方法用于访问。子类还可以添加自己的属性，方法。

在初始化子类时，首先会初始化一个父类对象，因此子类的构造器中的第一行代码必须调用父类的构造器，这通过 `super` 关键字调用。

**如果子类构造器没有显式调用父类构造器，那么默认调用父类无参的构造器。如果父类没有无参构造器，就必须显式调用一个构造器。**

**`super` 不仅仅可以调用父类构造器，在其他成员方法中，还可以通过 `super` 调用父类的方法**。

### 方法重写

子类可以重写父类的方法，叫做方法重写。

方法重写的要求比重载苛刻许多，**子类重写的方法的签名需要和父类的方法完全一致**，才能称之为重写。一般来说，重写的方法上会添加 `@Override` 注解。

由于返回值不是方法的签名，因此**返回值可以不同，但是仅限于原返回值类型及其子类类型。**这叫做有**协变的返回类型**。

**方法的重写还不允许子类抛出父类没有抛出的异常**，我们在之后还会提到这一点。

**`static` 方法是属于类的，因此不会被重写**（`static` 成员根本不参与继承），即使子类定义和父类相同的静态方法，那也只是属于子类的静态方法。

**子类重写的方法的可见性不能低于父类。**

## 多态

多态指的是子类对象可以赋给父类变量，父类变量的值可以是任何一个它的子类对象。反过来则不行。

比如：

```java
Car car = new BYDCar();
```

多态表明了一种替换原则，但是这样做有什么好处呢？要明白这一点，需要明白方法的调用机制。

### 理解方法调用

综合多态、继承、重写、重载等内容，总结方法调用的过程：

假设有 `x.f(args)` 的调用，其中 `x` 是 C 类的对象

1. 编译器查看对象的**声明类型**及**方法名**，列出候选方法（重载）。编译器会一一列举该类及其父类的所有可访问到的该名字的方法。

2. 编译器确定参数的类型。

3. 如果是 `private`、`static`、`final` 的方法，或者是构造函数，那么编译器可以准确的知道调用的是哪个方法，这称为静态绑定。

4. 如果调用的方法依赖对象的实际类型，则称为动态绑定。动态绑定过程最后应该且只能产生一个方法候选者，如果发现多个，编译器将不能决定调用哪一个。

   **动态绑定时，JVM 会调用实际对象的类型的方法。**假设上面 x 的类型实际上是 C 类的子类 D 类的对象，那么会调用 D 类里的 f 方法（除非没有才会去父类 C 中寻找）。

   > **字段“重写”**
   >
   > 事实上，**字段是不会进行重写的**。即使子类有一个和父类一样的字段，在子类的空间中实际上有两个该字段，一个属于父类，一个属于子类。子类的通过 `this` 引用，而父类的通过 `super` 引用（如果可见的话）。
   >
   > 多态中，字段由于不会重写，因此即使子类有一个和父类一样的字段，父类对象总是会访问自己的同名字段（如果可见的话）。

由于每次调用都要经过上述过程，开销比较大，因此 JVM 会提前为每个类生成一张方法表，真正调用方法时，查表即可。

## 阻止继承

使用 `final` 关键字不仅可以定义常量，还可以作用在方法上或类上，表示不可变方法或类，即禁止该方法被重写或禁止该类被继承。

> 如果一个方法是 `final` 方法，且它并不长，则编译器会对它进行内联优化。

### 强制类型转换

类之间的强制类型转换只有一种情况允许：某个类先赋给父类变量，再从父类变量转换回去。

注意，父类不能强制类型转换为子类，虽然可以通过编译，但是运行时会抛出异常。

为了判断能否进行转换，可以使用 `instanceof` 运算符，主要用于判断一个父类变量是否实际上是一个子类对象。

## 抽象类与抽象方法

抽象的类或者方法需要使用 `abstract` 修饰，表示必须被继承或必须被实现。

抽象对应面向对象设计中的抽象，它为子类提供一个相当上层的抽象，表示子类都有这样的特性，但是细节不同，所有的子类必须继承或实现这种抽象。

**抽象类不允许被实例化，它只能被继承，一般含有 0 个或多个抽象方法**。如果含有多个抽象方法，那么子类必须实现每一个抽象方法，除非子类也被声明为抽象的。

**抽象方法充当占位的角色，由子类具体实现，因此抽象类中的其他非抽象成员方法可以调用抽象方法。**由于动态绑定，而抽象父类又不会被初始化，因此在实际调用方法时一定会调用抽象方法的某一个实现。

抽象类可以有变量，但是它只能指向子类对象（多态）。

> 抽象类仅仅是不能被实例化，它与其它正常的类没有任何区别。因此它也可以拥有构造方法，只是该构造方法必须由子类调用。

## 所有类的父类：`Object`

每个类的最终父类都是 `Object`，如果一个类没有显式声明它继承自一个类，那么它默认继承自 `Object`。

由于多态，`Object` 类的变量可以指向任意对象。在 Java 中，只有基本类型（`int` 等）不是对象，但是它们有对应的属于对象的类型，我们在之后会详细讲述。

`Object` 类有 9 大方法，这意味着任意一个对象都具有这 9 个基本方法：

| 方法                                                         | 说明                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `protected Object clone()`                                   | 创建与该对象的类相同的新对象                                 |
| `public boolean equals(Object)`                              | 比较两对象是否相等                                           |
| `protected void finalize()`                                  | 当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法 |
| `public Class<?> getClass()`                                 | 返回一个对象运行时的实例类                                   |
| `public int hashCode()`                                      | 返回该对象的散列码值                                         |
| `public void notify()`                                       | 激活等待在该对象的监视器上的一个线程                         |
| `public void notifyAll()`                                    | 激活等待在该对象的监视器上的全部线程                         |
| `public String toString()`                                   | 返回该对象的字符串表示                                       |
| `public void wait()`<br />`public void wait(long timeout)`<br />`public void wait(long timeout, int nanos)` | 在其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法前，导致当前线程等待 |

这些方法我们在之后会分别遇到，本节我们讲解其中的 `equals`、`hashCode` 以及 `toString`，它们也是最常用的几个方法。

### `equals` 方法

该方法用于检测一个对象是否等于另一个对象。在 `Object` 类中，它被实现为检测两个对象引用是否相等。如下面的代码所示：

```java
public boolean equals(Object obj) {
     return (this == obj);
}
```

同类之间可以使用 `==` 进行比较。使用 `==` 比较就等价于默认的 `equals` 方法。

> **建议**
>
> 无论何时都不要对类类型使用 `==` 进行比较。不过有一些特殊情况下是可以的。

对于绝大多数类来说，这个方法的默认实现不能满足它们的需求，因此大部分类会选择重写这个方法。比如员工类，只有员工的名字，性别，年龄，身份证一致时，才能认为它们是同一个员工。

一般来说，`equals` 方法需要满足以下几条性质：

1. 自反性，对于任何非空引用 x，x.equals(x) 应该为 true。
2. 对称性，如果 x.equals(y) 为 true，则 y.equals(x) 也应该为 true。
3. 传递性，如果 x.equals(y) 为 true，y.equals(z) 为 true，则 x.equals(z) 也应该为 true。
4. 一致性，如果 x 和 y 没有发生变化，那么多次调用 x.equals(y) 结果应该相同。
5. 对于任意非空引用 x，x.equals(null) 应该为 false。

下面是一个 equals 方法的模板，完全遵守了上面的原则：

```java
public boolean equals(Object otherObject) {
    if (this == otherObject) {
        return true;
    }
    
    if (otherObject == null) {
        return false;
    }
    
    if (getClass() != otherObject.getClass()) {
        return false;
    }
    
    当前类 obj = (当前类) otherObject; // 类型转换
    
    return 当前类的字段比较;
}
```

> **讨论**
>
> 到底是使用 `getClass` 还是使用 `instanceof` 进行类型的比较？
>
> `getClass` 方法是定义在 `Object` 中的方法，返回该类型的元数据类，每一个类都有一个，且是唯一一个对应的元数据类。
>
> 到底使用哪一个完全由类的语义决定，`getClass` 是十分严格的比较，它严格要求对象的类型必须一致才能通过；而 `instanceof` 则是可以让一个父类和一个子类进行比较。

Java 提供了工具类 `Objects` 和 `Arrays` 以及 `Collections`，它们都有对应的 `equals` 方法进行快速比较。同时，还有一些类拥有 `compareTo` 等比较方法，使用时需要仔细阅读文档后再调用。

### `hashCode` 方法

散列码（hash code）是由对象导出的一个整型值，它是没有规律的。

由于它定义在 `Object` 对象中，因此**每个对象都有一个默认的散列码，这个值由对象实际的存储地址导出**。

有些类重写了该方法，比如 `String`，它的散列码是由字符串实际内容导出，因此引用了相同字符串的变量的散列码相同。

如果重写了 `equals` 方法，则必须为可能放入散列表（`HashMap` 等容器）的对象重写 `hashCode` 方法，因为这是散列表判断冲突的首要依据。反过来说，**如果一个类不需要放入散列表中存储，则 `hashCode` 毫无作用**。

> **`hashCode` 和 `equals` 的关系**
>
> 如果一个类的对象不会被放进散列容器中存储，则它们毫无关系。
>
> 如果会被放进散列容器中存储，则**散列容器首先根据 `hashCode` 进行比较**，如果散列码相等，再调用 `equals` 判断是否真的相等。
>
> **在散列容器中，如果两个对象相等，则它们的散列码一定相等，反之则不一定。这是因为计算散列码的算法是有可能出现两个对象不相等但是散列码相同的情况的。**
>
> 为什么这些容器不直接调用 `equals` 判断相等呢？首先，散列容器的索引需要通过散列码计算得到，计算得到索引以后就可以把元素直接插入到对应的位置，而无需与其他元素进行多次比较；其次，以 `hashCode` 判断是否重复的效率比调用 `equals` 快得多。
>
> 那么为什么一些 Java 开发规范要求重写 `equals` 的同时也要重写 `hashCode` 方法？首先，你的对象放在散列容器中存储的概率是相当高的；其次，重写的 `equals` 中根本不会用到 `hashCode`，这就会出现散列码不同但是两个对象实际上是相同的场景。

重写该方法十分简单，可以对类中的每个字段都调用其 `hashCode` 方法然后加起来，也可以通过 `Objects` 提供的 `hash` 方法，它会为传来的参数（可变参数）一起计算散列码。

### `toString` 方法

`toString` 方法为每个对象返回一个字符串表示。

任何类进行字符串的拼接时，都会默认调用其 `toString` 方法。所以调用 `x.toString()` 和 `x + ""` 有相同的效果。详情参见字符串。

`Object` 类中的实现为：

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

这个默认的实现是没有特别意义的，为此，人们一般会选择重写该方法，默认的实现模板为：

```java
@Override
public String toString() {
    return "类名{" +
            "字段1=" + 字段1 +
            ", 字段2='" + 字段2 +
            ", 字段3=" + 字段3 +
            '}';
}
```

打印的效果就是：`类名{字段1=xxx, 字段2=yyy, 字段3=zzz}`。也可以使用 `[ ]` 甚至是 `( )` 包裹。

> **数组的 `toString`**
>
> 数组虽然本质上是对象，但是数组并未重写 `toString` 方法，你可能会看到下面的令人匪夷所思的输出：`[I@1a45e30`。`[I` 表示是 `int` 型的数组，`@` 后的内容是 hash code。
>
> 补救的办法是使用 `Arrays.toString`，它接受一个数组，可以在一行中打印出每个数组的元素。

## 基本类型的包装类

之前提到过，在 Java 中只有八大基本数据类型不是对象。事实上，它们有它们的对象包装版本：

* `int` -> `Integer`
* `byte` -> `Byte`
* `short` -> `Short`
* `long` -> `Long`
* `float` -> `Float`
* `double` -> `Double`
* `char` -> `Character`
* `boolean` -> `Boolean`

除了 `int` 和 `char`，其他的几类都是首字母大写，比较好记。

包装类是不可变的，一旦生成了一个包装类的对象，它其中的值就不会发送改变了。并且包装类本身也是 `final` 的。

所谓的**自动装箱，就是指对每一个需要包装类的地方，会自动为原始类型 `Y` 的变量 `x` 调用 `Y包装类.valueOf(x)`，以自动把 `x` 转换为包装类对象。**

而**自动拆箱则与之相反，当需要原始类型 `xxx` 时，如果变量是对应的包装类型，则会自动调用其 `xxxValue` 方法。**

比如：

```java
Integer i = 3; // 自动装箱
Integer i = Integer.valueOf(3); // 和上面的代码等价

int j = i; // 自动拆箱
int j = i.intValue(); // 和上面的代码等价
```

由于自动拆箱的特性，包装类也是可以直接参与数值运算的。



包装类除了自动拆装箱，最便利的是它们提供了很多关于类型转换的方法，比如从字符串转换到 `Integer` 的 `parseInt` 方法。

### 包装类的比较

由于自动拆箱，可能有人认为下面的代码的答案是 `true`：

```java
Integer i = 1000;
Integer j = 1000;

i == j; // 实际上是 false
i.equals(j); // true
```

这是由于 `i == j` 是比较对象的地址，而且这里是比较的包装类对象，因此不会进行自动拆箱。由于这两个对象地址不同，答案自然是 `false`。正确的比较要通过其 `equals` 方法。

不过，当 i 和 j 的值为 -128 ~ 127 之间的数时，`i == j` 会返回 `true`。比如：

```java
Integer i = 127;
Integer j = 127;
System.out.println(i == j);

Integer ii = 128;
Integer jj = 128;
System.out.println(ii == jj);
```

答案是先打印 `true` 再打印 `false`。

这是由于 -128 ~ 127（`Byte` 的取值范围）之间的数在 JVM 中被放到了**常量池**中，因此只存在一个 127 的对象。无论是 `Byte`，还是 `Integer`、`Short`、`Long`，只要你的值处于 `Byte` 的取值范围中，那么它们总是同一个对象。

以 `Integer` 为例，其内部持有一个名为 `IntegerCache` 的整数缓存，如果 `Integer.valueOf` 中的值在  -128 ~ 127 之间，则直接从缓存中（常量池）拿对象。如下面的代码所示：

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static {
        // high value may be configured by property
        int h = 127;
    }
}

```

这个缓存的大小可以根据 JVM 的参数（`java` 命令后携带 `-XX:AutoBoxCacheMax=?`）调整。

## `String` 类

Java 中的字符串不是原始类型，而是用一个名为 `String` 的类来表示的。

Java 的字符串使用 `""` 括起来，如果 `""` 里没有任何东西就叫做空串，但是并非为 `null`。

`String` 类是不可变的，它内部使用 `private final` 关键字修饰保存字符串的数据结构，同时它本身也是 `final` 的，这意味着不能通过继承破坏这个不可变性。同时，`String` 没有提供任何可以修改字符串中某个字符的方法，除非对字符串取子串然后进行拼接。这意味着 `"Hello"` 字符串的内容永远是这五个字符，无论发生什么都不会改变。

> 给字符串变量赋新值实际上只是改变了引用，字符串本身没有改变。

Java 语言为字符串重载了运算符 `+`，可以使用 `+` 拼接字符串。当字符串与非字符串拼接时，会将其转换为字符串：基本类型会调用 `String.valueOf()` 静态方法，而类类型则会调用其 `toString` 方法。

> **字符串常量池**
>
> 字符串被存放在 JVM 的常量池中，字符串变量指向其中的一个位置。初始时常量池为空，每当程序员使用一个字符串，如果常量池中没有，JVM 就把这个字符串装入常量池，下次要用时直接取出。
>
> 那么，这样一行代码中，有几个对象被创建了？
>
> ```java
> String a = new String("A" + "B");
> ```
>
> 答案是 5，首先 `"A"`和 `"B"` 字符串是两个，它们拼接以后形成 `"AB"`，所以字面量就有三个对象。
>
> 其次是 `new String("AB")`，这里使用了 `new` 操作符创建对象，被分配在了堆中，这个对象的持有的字面量字符串指向常量池中的 `"AB"`。
>
> 最后是 a，a 是一个引用，分配在栈上，指向 `new String("AB")` 这块区域。
>
> Java 的设计者认为共享字符串带来的收益远远高于可变字符串带来的不能共享，因此把 `String` 设置为不可变的。

`String` 底层一般是 `char[]`，但是在 Java 9 中，还有使用 `byte[]` 实现的。

检测两个字符串是否相等，可以使用 `equals` 方法，但是千万不要使用 `==`。

下表列出了 `String` 类的常用 API，这些 API 大多都是很常用的：

| 方法                                                         | 作用                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `new String(String str)`                                     | 根据 str 构造一个字符串，即构造一个 str 的副本。             |
| `new String(char[] value)`                                   | 根据字符数组构造字符串。                                     |
| `new String(byte[] bytes)`                                   | 根据字节数组构造字符串。                                     |
| `new String(StringBuffer buffer)`                            | 根据 `StringBuffer` 构造字符串。                             |
| `new String(StringBuilder builder)`                          | 根据 `StringBuilder` 构造字符串。                            |
| `int length()`                                               | 得到一个字符串的长度。                                       |
| `boolean isEmpty()`                                          | 判断是否为空串。                                             |
| `char charAt(int index)`                                     | 返回 index 上的字符。                                        |
| `void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)` | 把字符串中指定范围内的字符复制到字符数组中。                 |
| `byte[] getBytes()`                                          | 获得字符串的 `byte[]` 数组表示。                             |
| `boolean equals(Object anObject)`                            | 将此字符串与指定对象进行比较。 当且仅当参数不为 null 并且是表示与此对象相同的字符序列的 String 对象时，结果才为 true。 |
| `boolean equalsIgnoreCase(String anotherString)`             | 将此 String 与另一个 String 进行比较，忽略大小写。           |
| `int compareTo(String anotherString)`                        | 按字典顺序比较两个字符串。如果此 String 更大，返回小于 0 的数。 |
| `int compareToIgnoreCase(String str) `                       | 上面方法的忽略大小写版本。                                   |
| `boolean startsWith(String prefix)`                          | 判断字符串是否以 `prefix` 开头。                             |
| `boolean endsWith(String suffix)`                            | 判断字符串是否以 `suffix` 结尾。                             |
| `int indexOf(String str)`                                    | 返回字串在字符串中的索引，如有多个匹配，返回第一个。         |
| `int lastIndexOf(String str)`                                | 返回字串在字符串中的索引，如有多个匹配，返回最后一个。       |
| `String substring(int beginIndex, int endIndex)`             | 截取字串。包括开头，不包括结尾。                             |
| `boolean matches(String regex)`                              | 判断该字符串是否与正则表达式匹配。                           |
| `boolean contains(CharSequence s)`                           | 判断该字符串是否包含另一个字符串。                           |
| `String replaceFirst(String regex, String replacement)`      | 用给定的字符串替换掉此字符串中与给定正则表达式匹配的第一个子字符串。 |
| `String replaceAll(String regex, String replacement)`        | 用给定的字符串替换掉此字符串中与给定正则表达式匹配的全部子字符串。 |
| `String replace(CharSequence target, CharSequence replacement)` | 用给定的字符串 `replacement` 替换掉此字符串中和 `target` 相同的全部子字符串。 |
| `String[] split(String regex)`                               | 根据给定正则表达式的匹配拆分此字符串。                       |
| `String join(CharSequence delimiter, CharSequence... elements)` | 使用 `delimiter` 连接 `elements`，返回拼接后的字符串         |
| `String toLowerCase()`                                       | 字符串转小写                                                 |
| `String toUpperCase()`                                       | 字符串转大写                                                 |
| `String trim()`                                              | 去除字符串的前后空格                                         |
| `String strip()`                                             | 去除字符串的前后空格（支持删除 Unicode 空格）                |
| `boolean isBlank()`                                          | 判断字符串是否为空串或仅包含空格类的字符。                   |
| `char[] toCharArray()`                                       | 获得字符串的 `char[]` 数组表示。                             |
| `String format(String format, Object... args)`               | 格式化字符串                                                 |
| `String valueOf(Object obj)`                                 | 将任意对象转换为字符串                                       |
| `String valueOf(基本类型 obj)`                               | 将任意基本类型转换为字符串                                   |
| `String repeat(int count)`                                   | 将字符串重复 count 次后返回                                  |

其中，值得一提的是格式化方法 `format`，这涉及到字符串的表现形式，和每一个程序员\用户都息息相关。

### 字符串格式化

字符串格式化指的是，在字符串中使用占位符规定某个数据的格式，然后利用格式化方法把数据插入到字符串中，这个数据被插入到字符串时会根据占位符规定好的格式来进行格式的转换。

看一个例子：

```java
String.format("你好，%s，明年你 %d 岁了", name, age);
```

占位符就是以 `%` 开头的字符串，也叫格式制符。

下表列出了常用的格式制符：

| 格式制符 | 说明                                       |
| :------- | :----------------------------------------- |
| %d       | 十进制整数                                 |
| %x       | 十六进制整数                               |
| %o       | 八进制整数                                 |
| %f       | 定点浮点数                                 |
| %s       | 字符串                                     |
| %c       | 字符                                       |
| %b       | 布尔                                       |
| %h       | 散列码                                     |
| %e       | 指数形式的浮点数                           |
| %g       | 通用浮点数，会在 %e 和 %f 中选择最短的那个 |
| %a       | 十六进制浮点数                             |
| %n       | 平台相关的分隔符                           |

基本的格式制符告诉格式化器要把该数据展示成何种形式，还有具体对格式的规定符号，如下表所示：

| 符号               | 作用                                                        |
| :----------------- | :---------------------------------------------------------- |
| +                  | 打印正数和负数的符号                                        |
| ` `                | 这是一个单独的空格，表示要在正数之前添加空格                |
| 0                  | 表示在数字前补 0                                            |
| -                  | 左对齐                                                      |
| (                  | 表示将负数括在括号里，会去掉负号                            |
| #（和 %f 结合）    | 包含小数点                                                  |
| #（和 %x %o 结合） | 添加前缀 0x 或 0                                            |
| n$                 | 参数索引，表示使用后面参数中的第 n 个数据作为这个地方的数据 |
| <                  | 使用前一个格式制符的原始数据                                |

看几个例子：

```java
System.out.println(String.format("%d \t %<#x", 1233));
System.out.println(String.format("%2$(,f \t %1$+d", 123, -1334f));
```

结果：

![image-20220129112816608](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220129112816608.png)



