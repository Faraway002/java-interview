#  并发

## 基本概念

### **并发和并行**

1. **并发**：指具备处理多个任务的能力，但**不一定要同时**。
2. **并行**：指具备**同时**处理多个任务的能力。

具体的例子是：

- 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
- 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
- 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。

### 同步和异步

- **同步**：是指在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。
- **异步**：则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

举例来说明：

- 同步就像是打电话：不挂电话，通话不会结束。
- 异步就像是发短信：发完短信后，就可以做其他事；当收到回复短信时，手机会通过铃声或振动来提醒。

### 阻塞和非阻塞

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：

- **阻塞**：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
- **非阻塞**：是指在不能立刻得到结果之前，该调用不会阻塞当前线程。

举例来说明：

- 阻塞调用就像是打电话，通话不结束，不能放下。
- 非阻塞调用就像是发短信，发完短信后，就可以做其他事，短信来了，手机会提醒。

### 进程与线程

- **进程**：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，**进程是操作系统进行资源分配的基本单位**。
- **线程**：**线程是操作系统进行调度的基本单位**。

进程和线程的差异：

- **一个程序至少有一个进程，一个进程至少有一个线程**。
- 线程比进程划分更细，所以**执行开销更小**，并发性更高。
- 进程是一个实体，拥有独立的资源；而**同一个进程中的多个线程共享进程的资源**。

在 Java 中，JVM 在单个进程中运行，**JVM 中的线程共享属于该进程的堆**，这就是为什么几个线程可以访问同一个对象。

但是**线程拥有自己的栈空间**，因此线程中的局部变量是线程安全的。

### 竞态条件和临界区

- **竞态条件（Race Condition）**：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。
- **临界区（Critical Sections）**：导致竞态条件发生的代码区称作临界区。

### 管程

管程（Monitor），也称监视器，是指管理共享变量以及对共享变量的操作过程，让他们支持并发。一个管程是一个由过程、 变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。

Java 中 `synchronized` 采用的就是管程技术，`synchronized` 关键字及 `wait()`、`notify()`、`notifyAll()` 这三个方法都是管程的组成部分。

而**管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程**。

## 并发编程概述

技术在进步，CPU、内存、I/O 设备的性能也在不断提高。但是，始终存在一个核心矛盾：**CPU、内存、I/O 设备存在速度差异**。CPU 远快于内存，内存远快于 I/O 设备。

木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即 I/O 操作），所以单方面提高 CPU、内存的性能是无效的。

为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：

- **CPU 增加了缓存**，以均衡与内存的速度差异；
- **操作系统增加了进程、线程**，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；
- **编译程序优化指令执行次序**，使得缓存能够得到更加合理地利用。

其中，**进程、线程使得计算机、程序有了并发处理任务的能力**。

**并发的优点**在于：

- **提升资源利用率**。看下面的例子：

  从磁盘读取一个文件需要 5 秒，处理一个文件需要 2 秒。

  ```text
  5秒读取文件A
  2秒处理文件A
  5秒读取文件B
  2秒处理文件B
  ---------------------
  总共需要14秒
  ```
  
  从磁盘中读取文件的时候，大部分的 CPU 时间用于等待磁盘去读取数据。在这段时间里，CPU 非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用 CPU 资源。看下面的顺序：

  ```text
  5秒读取文件A
  5秒读取文件B + 2秒处理文件A
  2秒处理文件B
  ---------------------
  总共需要12秒
  ```
  
- **程序响应更快**。将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。

  设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。

  服务器的流程如下所述：

  ```java
  while(server is active) {
      listen for request
      process request
  }
  ```
  
  **如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端**。只有服务器在监听的时候，请求才能被接收。

  另一种设计是，监听线程把请求传递给工作者线程（worker thread），然后立刻返回去监听，而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：

  ```java
  while(server is active) {
      listen for request
      hand request to worker thread
  }
  ```
  
  这种方式，服务端线程迅速地返回去监听，因此，更多的客户端能够发送请求给服务端，这个服务也变得响应更快，并发量也就提高了。

  GUI 桌面应用也是如此，如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程，当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。

并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。

### 并发带来的问题

解决并发问题是并发编程的核心。

#### 安全性问题

**并发安全是指保证程序的正确性，使得并发处理结果符合预期**。由于线程的调度是由操作系统控制的，因此线程执行的顺序并不是一定的，需要使用某些手段保证线程的执行结果和预期的相同。

并发安全需要保证几个基本特性：

- **可见性**：是指一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为**将线程本地状态反映到内存上**。

  多核 CPU 中，每个 CPU 核心都有自己的缓存，当多个线程在不同的 CPU 核心上运行时，使用的缓存是当前核心的，而并不会立即把某个值写到内存中，造成其他线程读取时读到的值不一样。这就是缓存导致的可见性问题。

  **`volatile` 能够保证可见性，其原理是被 `volatile` 修饰的变量不会被缓存在寄存器或对其他核心不可见的地方（所以一般保存在内存中，`volatile` 总是会把修改后的值写回内存中），因此读取 `volatile` 变量总是能读取到最新的值**。

  同时，**`volatile` 能够防止编译器对指令进行重排序**。

- **原子性**：简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制（加锁：`sychronized`、`Lock`）实现。

  由于线程执行顺序的切换，因此本来看上去正确的代码得出的结果很可能是错误的，比如 `i++` 这个表达式，它可以被分解为：

  1. 取 i 的值，加载到 CPU 的寄存器中
  2. 把 i 的值 + 1
  3. 把结果写入到内存中

  一个表达式相当于三条指令。现在假设 i 的初始值是 100，假设执行完第二步时，CPU 切换到另一个线程执行，把 i 的值又设置为 100，这时，刚才的线程又重新运行，把值写到内存中。其他人看来就是该线程根本没有对 i 进行加 1 的操作。

- **有序性**：是指**保证线程内串行语义**，避免指令重排等。

  编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：`a=6;b=7;`，编译器优化后可能变成 `b=7;a=6;`，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。

  看一个经典的单例模式实现：

  ```java
  public class Singleton {
      private static Singleton instance;
      
      private Singleton() {
          
      }
      
      public static Singleton getInstance() {
          if (instance == null) {
              synchronized (Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
  ```

  看上去好像无懈可击，但是还是有可能会出现问题。

  问题出在哪里呢？出在 `new` 操作上，我们以为的 `new` 操作应该是：

  1. 分配一块内存 M；
  2. 在内存 M 上初始化 Singleton 对象；
  3. 然后 M 的地址赋值给 instance 变量。

  但是实际上优化后的执行路径却是这样的：

  1. 分配一块内存 M；
  2. 将 M 的地址赋值给 instance 变量；
  3. 最后在内存 M 上初始化 Singleton 对象。

  优化后会导致什么问题呢？我们假设线程 A 先执行 `getInstance()` 方法，当执行完优化后的指令的第 2 步时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 `getInstance()` 方法，那么线程 B 在执行第一个判断时会发现 instance 并不空 ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。

##### 安全性问题的解决思路

1. 互斥同步（阻塞同步）：

   互斥是实现同步的一种手段：当其他线程想要访问共享数据时，已经在访问的线程会排斥它，随后该线程会进入阻塞，因此也叫做阻塞同步。

   **临界区（Critical Sections）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式**。

   **互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题**，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

2. 非阻塞同步：

   随着硬件指令集的发展，我们可以使用基于冲突检测的**乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）**。

   这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。

   为什么说乐观锁需要**硬件指令集的发展**才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。

   这类乐观锁指令常见的有：

   - 测试并设置（TestAndSet）
   - 获取并增加（FetchAndIncrement）
   - 比较并交换（CompareAndSwap）

3. 无同步：

   要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。

   Java 中的**无同步方案**有：

   - **可重入代码**：如果一个**方法的返回结果是可以预测的**，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。
   - **线程本地存储**：使用 **`ThreadLocal` 为共享变量在每个线程中都创建了一个本地副本**，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。

#### 活跃性问题

活跃性问题主要分为三类：

1. 死锁（Deadlock）：

   死锁指的是多个线程互相等待对方释放锁，导致都不工作的情况。

   死锁有四个条件，只要破坏其中任意一个条件就能够预防死锁，有关死锁的更多相关知识，参见操作系统。

2. 活锁（Livelock）：

   活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

   活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，即所谓的“活”， 而处于死锁的实体表现为等待；**活锁有可能自行解开，死锁则不能**。

3. 饥饿（Starvation）：

   饥饿指的是高优先级线程吞噬所有的低优先级线程的 CPU 时间，导致线程被永久堵塞在一个等待进入同步块的状态（因为其他线程总是能在它之前持续地对该同步块进行访问）。

   饥饿问题最经典的例子就是哲学家问题：有五个哲学家用餐，每个人要获得两把叉子才可以就餐。当 2、4 就餐时，1、3、5 永远无法就餐，只能看着盘中的美食饥饿的等待着。如下图所示：

   ![image-20220225175424259](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220225175424259.png)

#### 性能问题

并发一定比串行执行快吗？答案是不一定的。

多个线程（进程）并发看起来是同时执行，但是实际上是 CPU 在很快的切换，快到人们无法察觉，就好像是并行一样。

切换的过程称作上下文切换，这时 CPU 需要为上一个线程保存运行状态，并加载下一个线程的数据，这将会带来一定的开销。**当切换非常频繁时，整体的效率反而会变得更低**。

## Java 中的线程

### 创建线程

创建线程的基本方式有三种：

- **继承 `Thread` 类**：

  1. 定义 `Thread` 类的子类，并覆写该类的 `run` 方法。`run` 方法的方法体就代表了线程要完成的任务，因此把 `run` 方法称为执行体。
  2. 创建 `Thread` 子类的实例，即创建了线程对象。
  3. 调用线程对象的 `start` 方法来启动该线程。

  ```java
  public class ThreadDemo {
      public static void main(String[] args) {
          // 实例化对象
          MyThread tA = new MyThread("Thread 线程-A");
          MyThread tB = new MyThread("Thread 线程-B");
          // 调用线程主体
          tA.start();
          tB.start();
      }
  
      static class MyThread extends Thread {
          private int ticket = 5;
  
          MyThread(String name) {
              super(name);
          }
  
          @Override
          public void run() {
              while (ticket > 0) {
                  System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");
                  ticket--;
              }
          }
      }
  }
  ```

  注意，**直接调用 `run` 方法并不能启动一个线程**，仅仅是一个正常的方法调用。

- **实现 `Runnable` 接口**：

  `Runnable` 接口表示可执行的一个异步任务，是一个函数式接口。

  1. 定义 `Runnable` 接口的实现类，并覆写该接口的 `run` 方法。该 `run` 方法的方法体同样是该线程的线程执行体。
  2. 创建 `Runnable` 实现类的实例，并以此实例作为 `Thread` 构造函数的参数来创建 `Thread` 对象，该 `Thread` 对象才是真正的线程对象。
  3. 调用线程对象的 `start` 方法来启动该线程。

  ```java
  public class RunnableDemo {
      public static void main(String[] args) {
          // 实例化对象
          Thread tA = new Thread(new MyThread(), "Runnable 线程-A");
          Thread tB = new Thread(new MyThread(), "Runnable 线程-B");
          // 调用线程主体
          tA.start();
          tB.start();
      }
  
      static class MyThread implements Runnable {
          private int ticket = 5;
  
          @Override
          public void run() {
              while (ticket > 0) {
                  System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");
                  ticket--;
              }
          }
      }
  }
  ```

  **实现 `Runnable` 接口优于继承 `Thread` 类**，因为：

  - Java 不支持多重继承，所有的类都只允许继承一个父类，但可以实现多个接口。如果继承了 `Thread` 类就无法继承其它类，这不利于扩展。
  - 类可能只要求可执行就行，继承整个 `Thread` 类开销过大。

- **实现 `Callable` 接口**：

  **继承 `Thread` 类和实现 `Runnable` 接口这两种创建线程的方式都没有返回值**。所以线程执行完后，无法得到执行结果。但如果期望得到执行结果该怎么做？

  为了解决这个问题，Java 1.5 后，提供了 `Callable` 接口和 `Future` 接口，通过它们，可以在线程执行结束后，返回执行结果。

  `Callable` 是一个函数式泛型接口，表示可调用的，其泛型表示返回值的类型，其唯一的方法是 `call` 方法。它的使用方式一般是使用一个 `ExecutorService` 的示例，通过其 `Future<T> submit(Callable<T> task)` 调用一个 `Callable`，然后获取 `Future` 结果。
  
  `Future` 表示异步计算的结果，提供了检查计算是否完成、等待其完成以及检索计算结果的方法。可以通过 `get` 方法获取执行结果，**该方法会阻塞直到任务返回结果**。
  
  除此之外，还可以使用 `FutureTask`。它是 `Future` 的基本实现，同时实现了 `Runnable` 接口，它可以对一个 `Callable`  和 `Future` 进行包装，然后就可以交给 `Thread` 类来创建并执行，执行后的结果也是通过它来获取。
  
  通过实现 `Callable` 接口创建线程的步骤：
  
  1. 创建 `Callable` 接口的实现类，并实现 `call` 方法。该 `call` 方法将作为线程执行体，并且有返回值。
  2. 创建 `Callable` 实现类的实例，使用 `FutureTask` 类来包装 `Callable` 对象，该 `FutureTask` 对象封装了该 `Callable` 对象的 `call` 方法的返回值。
  3. 使用 `FutureTask` 对象作为 `Thread` 构造函数的参数创建线程，并启动新线程。
  4. 调用 `FutureTask` 对象的 `get` 方法来获得线程执行结束后的返回值。
  
  ```java
  public class CallableDemo {
      public static void main(String[] args) {
          Callable<Long> callable = new MyThread();
          FutureTask<Long> future = new FutureTask<>(callable);
          new Thread(future, "Callable 线程").start();
          try {
              System.out.println("任务耗时：" + (future.get() / 1000000) + "毫秒");
          } catch (InterruptedException | ExecutionException e) {
              e.printStackTrace();
          }
      }
  
      static class MyThread implements Callable<Long> {
          private int ticket = 10000;
  
          @Override
          public Long call() {
              long begin = System.nanoTime();
              while (ticket > 0) {
                  System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");
                  ticket--;
              }
              long end = System.nanoTime();
              return (end - begin);
          }
      }
  }
  ```
  
  **此方式经常在线程池中使用**，之后还会详细讲解。

### 线程状态

在 `Thread` 的内部枚举 `State` 中，定义了线程的六种状态，**在给定的一个时刻，线程只能处于其中的一个状态**：

1. `NEW`（新建）：指的是线程刚刚被创建，但是还未启动（`start`）的状态。

2. `RUNNABLE`（就绪）：已经调用了 `start` 方法的线程处于此状态。

   此状态意味着：**线程已经在 JVM 中运行，但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态**。

   所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。

3. `BLOCKED`（阻塞）：**线程处于被阻塞状态**，表示线程在等待资源。当等待的线程获得资源时，就又会从 `BLOCKED` 转换到 `RUNNABLE` 状态。

4. `WAITING`（等待）：**线程无限期等待，直到被其他线程显式地唤醒**。

    阻塞和等待的区别在于：**阻塞是被动的，而等待是主动的**。

5. `TIMED_WAITING`（定时等待）：它也是等待，和等待的区别是：**无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒**。

6. `TERMINATED`（终止）：**线程执行完毕，或因异常终止**，这意味着线程结束了它的生命周期。

在有些资料中，`RUNNABLE`被分为更细的两个状态：`RUNNING` 表示操作系统正在运行它，`READY` 则表示操作系统未运行它。

![image-20220226111729647](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220226111729647.png)

### 线程的基本使用方法

Java 并发中最核心的类就是 `Thread`，它实现了 `Runnable` 接口，意味着我们继承它然后重写 `run` 方法也可以创建线程，这点我们之前已经提过了，下面是它的方法：

| 方法                                   | 作用                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `static Thread currentThread()`        | 返回对当前正在执行的线程对象的引用。                         |
| `static void sleep(long millis)`       | 将当前正在执行的线程休眠。                                   |
| `static void yield()`                  | 将当前正在执行的线程暂停，让其他线程执行。                   |
| `Thread(Runnable target`               | 使用 `Runnable` 创建一个线程                                 |
| `Thread(Runnable target, String name)` | 使用 `Runnable` 创建一个线程，可以给线程起一个名字           |
| `void start()`                         | 线程的启动方法。                                             |
| `void run()`                           | 线程的执行实体，执行此方法并不会启动线程。                   |
| `void interrupt()`                     | 中断线程，调用该方法的线程的状态为将被置为中断状态。         |
| `static boolean interrupted()`         | 测试当前线程是否已被中断，此方法还会清除线程的中断状态。     |
| `boolean isInterrupted()`              | 测试此线程是否已被中断，线程的中断状态不受此方法的影响。     |
| `boolean isAlive()`                    | 判断线程是否启动。                                           |
| `void setPriority(int newPriority)`    | 设置线程优先级。<BR>Java 中的线程优先级的范围是 `[1, 10]`，默认优先级为 5。 |
| `int getPriority()`                    | 获取线程的优先级。                                           |
| `void setName(String name)`            | 设置线程名称。                                               |
| `String getName()`                     | 获取线程名称。                                               |
| `void join()`                          | 让当前线程等待该线程执行完毕，等价于 `join(0)`。             |
| `void join(long millis)`               | 让当前线程最多等待该线程 millis 毫秒，0 意味着永远等待，直到该线程结束。<br />如果 millis 毫秒内该线程没有执行完，那么当前线程就会进入就绪状态，重新等待 cpu 调度。<br />无论是执行完毕还是时间到了，都会调用 `notifyAll` 方法唤醒其他线程。 |
| `void setDaemon(boolean on)`           | 设置线程为守护线程，仅当 on 为 true 时。                     |
| `boolean isDaemon()`                   | 判断线程是否为守护线程。                                     |
| `State getState()`                     | 获取该线程的状态                                             |

#### 线程休眠

使用静态方法 `sleep` 可以让当前线程进入休眠，需要一个整数值表示休眠的毫秒数。该方法会抛出一个异常，由于**异常不能跨线程传播**，因此必须在本线程中处理。

示例：

```java
public class ThreadSleepDemo {
    public static void main(String[] args) {
        new Thread(new MyThread("线程A", 500)).start();
        new Thread(new MyThread("线程B", 1000)).start();
        new Thread(new MyThread("线程C", 1500)).start();
    }

    static class MyThread implements Runnable {
        private String name;

        private int time;

        private MyThread(String name, int time) {
            this.name = name;
            this.time = time;
        }

        @Override
        public void run() {
            try {
                // 休眠指定的时间
                Thread.sleep(this.time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(this.name + "休眠" + this.time + "毫秒。");
        }
    }
}
```

#### 线程礼让

静态方法 `yield` 的调用表明当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。

**由于实际的切换是由操作系统决定的，因此该方法只是对线程调度器的一个建议，实际上并不一定就能够让其他同优先级的线程运行。**

虽然可以为线程设置优先级，但是**无法保证高优先级的线程一定先执行**。原因在于线程优先级依赖于操作系统的支持，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 Java 中线程优先级一一对应。

#### 线程中断

当一个线程运行时，另一个线程可以直接通过 `interrupt` 方法中断其运行状态。

如：

```java
public class ThreadInterruptDemo {
    public static void main(String[] args) {
        MyThread mt = new MyThread(); 
        Thread t = new Thread(mt, "线程"); 
        t.start(); 
        try {
            Thread.sleep(2000); 
        } catch (InterruptedException e) {
            System.out.println("3、main线程休眠被终止");
        }
        t.interrupt(); 
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            System.out.println("1、进入run()方法");
            try {
                Thread.sleep(10000); 
                System.out.println("2、已经完成了休眠");
            } catch (InterruptedException e) {
                System.out.println("3、MyThread线程休眠被终止");
                return;
            }
            System.out.println("4、run()方法正常结束");
        }
    }
}
```

使用 `interrupt` 需要分两种情况：

1. 当线程在 `wait`、`sleep` 或者 `join` 时，如果调用了 `interrupt` 方法，则这些方法会被唤醒，抛出并处理 `InterruptException`，结果就是被中断了。

   当然并不只是上面列举的这些方法，当线程做 I/O 操作时也可能有类似的行为，此外还有其他的一些情况会出现这样的行为。

2. **当线程正常执行时，则需要程序手动检测中断状态，自行结束线程**。

安全地终止线程有两种方法：

- 定义 `volatile` 标志位，在 `run` 方法中使用标志位控制线程终止。

  如：

  ```java
  public class ThreadStopDemo2 {
      public static void main(String[] args) throws Exception {
          MyTask task = new MyTask();
          Thread thread = new Thread(task, "MyTask");
          thread.start();
          TimeUnit.MILLISECONDS.sleep(50);
          task.cancel();
      }
  
      private static class MyTask implements Runnable {
          private volatile boolean flag = true;
  
          private volatile long count = 0L;
  
          @Override
          public void run() {
              System.out.println(Thread.currentThread().getName() + " 线程启动");
              while (flag) {
                  System.out.println(count++);
              }
              System.out.println(Thread.currentThread().getName() + " 线程终止");
          }
  
          /**
           * 通过 volatile 标志位来控制线程终止
           */
          public void cancel() {
              flag = false;
          }
      }
  }
  ```

- 将 `interrupt` 方法和 `interrupted` 方法（或者是 `Thread.currentThread().isInterrupted()`）配合使用来控制线程终止。

  如：

  ```java
  public class ThreadStopDemo3 {
      public static void main(String[] args) throws Exception {
          MyTask task = new MyTask();
          Thread thread = new Thread(task, "MyTask");
          thread.start();
          TimeUnit.MILLISECONDS.sleep(50);
          thread.interrupt();
      }
  
      private static class MyTask implements Runnable {
          private volatile long count = 0L;
  
          @Override
          public void run() {
              System.out.println(Thread.currentThread().getName() + " 线程启动");
              // 通过 Thread.interrupted 和 interrupt 配合来控制线程终止
              while (!Thread.interrupted()) {
                  System.out.println(count++);
              }
              System.out.println(Thread.currentThread().getName() + " 线程终止");
          }
      }
  }
  ```

#### 守护线程

守护线程（Daemon Thread）是**在后台执行并且不会阻止 JVM 终止的线程，当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程**。与守护线程相反的叫用户线程（User Thread），也就是非守护线程。

为什么需要守护线程？因为**守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务**。典型的应用就是垃圾回收器。

可以使用 `isDeamon` 方法判断一个线程是否为守护线程，而可以使用 `setDeamon` 方法设置一个线程为守护线程。

注意，**正在运行的用户线程无法设置为守护线程，所以 `setDaemon` 必须在 `start` 方法之前调用**，否则会抛出 `llegalThreadStateException` 异常；一个守护线程创建的子线程依然是守护线程。

如：

```java
public class ThreadDaemonDemo {
    public static void main(String[] args) {
        Thread t = new Thread(new MyThread(), "线程");
        t.setDaemon(true); // 此线程在后台运行
        System.out.println("线程 t 是否是守护进程：" + t.isDaemon());
        t.start(); // 启动线程
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + "在运行。");
            }
        }
    }
}
```

#### 线程间通信

线程通信就是**当多个线程共同操作共享的资源时，互相告知自己的状态以避免资源争夺**，也叫做协调线程间的同步。

线程通信主要可以分为三种方式，分别为**共享内存**、**消息传递**和**管道流**。每种方式有不同的方法来实现：

* 共享内存：**线程之间共享程序的公共状态，线程之间通过读写内存中的公共状态来隐式通信**。

  常用方法是使用 `volatile` 变量来共享内存。

* 消息传递：线程之间没有公共的状态，**线程之间必须通过明确的发送信息来显示的进行通信**。

  常见的方式是使用 `wait/notify/notifyAll` 方式以及 `join` 方式。

* 管道流：管道流指的是使用管道输入/输出流，传输的媒介为内存，**线程通过读写一个管道类型的特殊文件来进行通信**。

  管道输入/输出流主要包括了如下 4 种具体实现：`PipedOutputStream`、`PipedInputStream`、`PipedReader` 和 `PipedWriter`，前两种面向字节，而后两种面向字符。

##### 共享内存

`volatile` 我们已经接触过，能够保证内存的可见性，让数据总是写回到内存中。

下面是一个示例：

```java
public class VolatileTest {
    public static volatile boolean flag = true;

    public static void main(String[] args) {
        Thread myThread = new Thread(new MyThread());
        
        // 主线程和 MyThread 交替执行
        myThread.start();
        while (true) {
            if (!flag) {
                System.out.println("主线程正在运行");
                flag = true;
            }
        }
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                if (flag) {
                    System.out.println("MyThread正在运行");
                    flag = false;
                }
            }
        }
    }
}
```

##### 消息传递

###### `wait\notify\notifyAll`

这三个方法是 `Object` 中的方法，而且均要配合 `synchronized` 使用，否则会抛出 `IllegalMonitorStateException`，作用如下：

- `wait`：`wait` 会**自动释放当前线程占有的对象锁**，并请求操作系统挂起当前线程，**让线程从 `RUNNING` 状态转入 `WAITING` 状态**，等待 `notify` / `notifyAll` 来唤醒。

  如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 `notify` 或者 `notifyAll` 来唤醒挂起的线程，造成死锁。

- `notify`：唤醒一个正在 `WAITING` 状态的线程，并让它拿到对象锁，具体唤醒哪一个线程由 JVM 控制 。

- `notifyAll`：唤醒所有正在 `WAITING` 状态的线程，接下来它们需要竞争对象锁。

> 迄今为止，除了应该避免使用的 `finalize` 方法，`Object` 中所有的方法都已经阐述完毕。那么问题来了，**为什么和多线程有关的方法要定义在 `Object` 中而非 `Thread` 中？**
>
> 首先，需要了解几个基本知识点：
>
> * 每一个 Java 对象都有一个与之对应的**监视器（monitor）**，也叫做管程
> * 每一个监视器里面都有一个**对象锁** 、一个**等待队列**、一个**同步队列**
>
> 由于每个对象都拥有对象锁，让当前线程等待某个对象锁，自然应该基于这个对象（`Object`）来操作，而非使用当前线程（`Thread`）来操作。因为当前线程可能会等待多个线程的锁，如果基于线程（`Thread`）来操作，就非常复杂了。
>
> **为什么 `wait`、`notify`、`notifyAll` 要配合 `synchronized` 使用？**
>
> 如果要调用某个对象的 `wait` 方法，则当前线程必须拥有这个对象的对象锁，因此调用 `wait` 方法必须在 `synchronized` 方法和 `synchronized` 代码块中。

生产者\消费者模式是 `wait`、`notify`、`notifyAll` 的一个经典使用案例：生产者负责产生数据，放入一个队列中；消费者负责拿出数据，至于拿出的数据要被用在何处则不必在意。当消费者取完了所有数据后，则它要 `wait`，直到生产者产生了数据并且 `notify` 消费者线程；反之，当消费者消费的太慢了，导致队列满时，生产者就要进入 `wait`，直到被 `notify`。

下面是代码实现：

```java
import java.util.ArrayDeque;
import java.util.Queue;

public class ProducerAndConsumer {
    private static final int QUEUE_SIZE = 10;
    private static final Queue<Integer> queue = new ArrayDeque<>(QUEUE_SIZE);

    public static void main(String[] args) {
        new Producer("生产者A").start();
        new Producer("生产者B").start();
        new Consumer("消费者A").start();
        new Consumer("消费者B").start();
    }

    static class Consumer extends Thread {
        Consumer(String name) {
            super(name);
        }

        @Override
        public void run() {
            while (true) {
                synchronized (queue) {
                    while (queue.size() == 0) {
                        try {
                            System.out.println("队列空，等待数据");
                            queue.notifyAll();
                            queue.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                            queue.notifyAll();
                        }
                    }
                    queue.poll(); // 每次移走队首元素
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + " 从队列取走一个元素，队列当前有：" + queue.size() + "个元素");
                }
            }
        }
    }

    static class Producer extends Thread {
        Producer(String name) {
            super(name);
        }

        @Override
        public void run() {
            while (true) {
                synchronized (queue) {
                    while (queue.size() == QUEUE_SIZE) {
                        try {
                            System.out.println("队列满，等待有空余空间");
                            queue.notifyAll();
                            queue.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                            queue.notifyAll();
                        }
                    }
                    queue.offer(1); // 每次插入一个元素
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + " 向队列中插入一个元素，队列当前有：" + queue.size() + "个元素");
                }
            }
        }
    }
}
```

###### `join`

`join` 会让当前线程最多等待调用者 millis 毫秒，0 意味着永远等待，直到调用者执行完毕。如果 millis 毫秒内该线程没有执行完，那么当前线程就会进入就绪状态，重新等待 cpu 调度。

`join` 的实现原理是使用 `wait` 和 `notifyAll`，当一个线程调用 `join` 时，当前的线程会 `wait`，之后无论是执行完毕还是时间到了，都会调用 `notifyAll` 方法唤醒其他线程。

`join` 可以让线程的并行执行变成串行执行：

```java
public class ThreadJoinDemo {
    public static void main(String[] args) {
        MyThread mt = new MyThread(); 
        Thread t = new Thread(mt, "mythread"); 
        t.start(); 
        for (int i = 0; i < 50; i++) {
            if (i > 10) {
                try {
                    t.join(); // 让 t 优先运行，当前线程等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("Main 线程运行 --> " + i);
        }
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 50; i++) {
                System.out.println(Thread.currentThread().getName() + " 运行，i = " + i);
            }
        }
    }
}
```

##### 管道

刚才也说过，管道是放在内存中的一个特殊的文件，事实上，进程间的管道通信是使用文件，而 Java 中线程间管道通信则使用一个数组，大小为 1024 字节。

下面是一个示例：

```java
import java.io.IOException;
import java.io.PipedReader;
import java.io.PipedWriter;

public class PipedTest {
    public static void main(String[] args) throws Exception {
        PipedWriter out = new PipedWriter();
        PipedReader in = new PipedReader();
        // 将输出流和输入流进行连接，否则在使用时会抛出 IOException
        out.connect(in);
        Thread printThread = new Thread(new PrintThread(in), "PrintThread");
        printThread.start();
        int receive;
        try {
            while ((receive = System.in.read()) != -1) {
                out.write(receive);
            }
        } finally {
            out.close();
        }
    }

    static class PrintThread implements Runnable {

        private PipedReader in;

        PrintThread(PipedReader in) {
            this.in = in;
        }

        public void run() {
            int receive = 0;
            try {
                while ((receive = in.read()) != -1) {
                    System.out.print((char) receive);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

## Java 并发编程核心机制

迄今为止，已经介绍了 `synchronized`、`volatile` 等基本机制，实际上，Java 还为我们提供了更高级的并发工具，这些工具绝大多数包括在 `java.util.concurrent` 包中，从功能上来说，大致有如下几类：

- 原子类，如：`AtomicInteger`、`AtomicIntegerArray`、`AtomicReference`、`AtomicStampedReference` 等。
- 锁，如：`ReentrantLock`、`ReentrantReadWriteLock` 等，还有一个很特殊的 `AbstractQueuedSynchronizer`，简称 AQS，许多并发工具都是根据它构建的。
- 并发容器，如：`ConcurrentHashMap`、`CopyOnWriteArrayList`、`CopyOnWriteArraySet` 等。
- 阻塞队列，如：`ArrayBlockingQueue`、`LinkedBlockingQueue` 等。
- 非阻塞队列，如： `ConcurrentLinkedQueue` 、`LinkedTransferQueue` 等。
- `Executor` 框架（线程池），如：`ThreadPoolExecutor`、`Executors` 等。

这些工具都基于 `synchronized`、`volatile`、硬件提供的原子指令以及 `ThreadLocal` 构建而来，在介绍这些工具之前，是很有深入必要了解这些基础机制的。

### `synchronized`

`synchronized` 是 Java 中的关键字，是**利用锁的机制来实现互斥同步的，`synchronized` 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块**。

如果不需要 `Lock` 、`ReadWriteLock` 所提供的高级同步特性，应该优先考虑使用 `synchronized` ，理由如下：

- Java 1.6 以后，`synchronized` 做了大量的优化，其性能已经与 `Lock` 、`ReadWriteLock` 基本上持平。从趋势来看，Java 未来仍将继续优化 `synchronized` ，而不是 `ReentrantLock` 。
- `ReentrantLock` 是 Oracle JDK 的 API，在其他版本的 JDK 中不一定支持；而 `synchronized` 是 JVM 的内置特性，所有 JDK 版本都提供支持。

#### 应用

`synchronized` 有两种基本的应用方式：

1. 同步代码块：可以使用 `synchronized (lock) {}` 来封锁一段代码。

   需要在 `()` 内为 `synchronized` 提供一把锁（也叫做监视器对象），线程进入该段代码时会持有该锁，由于任何对象都有一个锁，因此可以使用任何对象作为锁（如果要封锁代码在静态方法中，则要使用 `Class` 对象作为锁，静态方法中其他实例对象都访问不到），只有持有正确的锁的线程能够进入该代码段。

   示例：

   ```java
   class Account {
       private int balance;
       // 转账
       void transfer(Account target, int amt){
           synchronized (this) {
           	if (this.balance > amt) {
               	this.balance -= amt;
               	target.balance += amt;
           	}
           }
       } 
   }
   ```

   这里是模拟银行转账，使用了 `this` 作为锁，但是这样是有问题的。

   假设有 A、B、C 三个账户，余额都是 200 元，我们用两个线程分别执行两个转账操作：账户 A 转给账户 B 100 元，账户 B 转给账户 C 100 元，最后我们期望的结果应该是账户 A 的余额是 100 元，账户 B 的余额是 200 元， 账户 C 的余额是 300 元。

   线程 1 锁定的是账户 A 的实例（A.this），而线程 2 锁定的是账户 B 的实例（B.this），所以这两个线程可以同时进入临界区 `transfer()`，这时线程 1 和线程 2 都会读到账户 B 的余额为 200。

   这个时候，需要使用一个能够覆盖所有应该受保护的资源的锁：

   ```java
   class Account {
       private Object lock；
       private int balance;
       private Account();
       
       // 创建 Account 时传入同一个 lock 对象
       public Account(Object lock) {
           this.lock = lock;
       } 
       
       // 转账
       void transfer(Account target, int amt){
           // 此处检查所有对象共享的锁
           synchronized(lock) {
               if (this.balance > amt) {
                   this.balance -= amt;
                   target.balance += amt;
               }
           }
       }
   }
   ```

   更简单的方式是使用 `Account.class` 作为锁，这个对象在 JVM 中是绝对唯一的。

2. 同步方法：是指在方法（静态和普通方法均可）前添加 `synchronized` 修饰符，表明这个方法是同步方法。

   任何一个 `synchronized` 都必定有一个锁，普通方法中这个锁是 `this`，而静态方法中是当前类的 `Class` 对象。

#### 原理

**`synchronized` 代码块是由一对 `monitorenter` 和 `monitorexit` 指令实现的，`Monitor` 对象是同步的基本实现单元**。

当进入同步代码时，JVM 使用 `monitorenter` 指令进入同步代码，同时让线程持有 `Monitor` 对象；`monitorexit` 离开同步块后，线程释放 `Monitor` 对象。

如果是**方法，则会在方法的访问标识符上添加 `ACC_SYNCHRONIZED`**，这会体现在其字节码中的方法访问标识符中。

##### `Monitor`

`Monitor` 是监视器，每个对象实例都有一个 `Monitor`，和对象一起创建、销毁。`Monitor` 是由 `ObjectMonitor` 实现，而 `ObjectMonitor` 是由 C++ 的 `ObjectMonitor.hpp` 文件实现。

我们看一下 C++ 的源代码：

```c++
ObjectMonitor() {
    _header       = NULL;
    _count        = 0; // 记录个数
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL; // 处于 wait 状态的线程，会被加入到 _WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL;
    _succ         = NULL;
    _cxq          = NULL;
    FreeNext      = NULL;
    _EntryList    = NULL; // 处于等待锁 block 状态的线程，会被加入到该列表
    _SpinFreq     = 0;
    _SpinClock    = 0;
    OwnerIsThread = 0;
}
```

`ObjectMonitor` 中有两个队列：`_WaitSet` 和 `_EntryList`，用来保存 `ObjectWaiter` 对象列表（每个等待锁的线程都会被封装成 `ObjectWaiter`对象），`_owner` 指向持有 `ObjectMonitor` 对象的线程。

当多个线程同时访问一段同步代码时，首先会进入 `_EntryList` 集合，当线程获取到对象的 `Monitor` 后进入 `_owner` 区域并把 `Monitor` 中的 `_owner` 变量设置为当前线程，同时，`Monitor` 中的计数器 `_count` + 1。

若线程调用 `wait()` 方法，将释放当前持有的 `Monitor`，`_owner` 变量恢复为 `NULL`，`_count` 自减 1，同时该线程进入 `_WaitSet` 集合中等待被唤醒。

若当前线程执行完毕，也将释放 `Monitor` 并复位变量的值，以便其他线程进入获取 `Monitor`。

流程如下图所示：

![同步队列、阻塞队列](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/---------.svg)

所以，**`synchronized` 依靠的 `Monitor` 是一个可重入锁**，即线程可以重复获取同一把锁，此时 `_count` + 1，当 `_count` 清零后，也就意味着锁被释放了。

如果一个线程多次获取同一个锁，如果它不是可重入锁，则会引起死锁，比如：

```java
private UnReentrantLock lock; // 不可重入锁

public void m1() {
    lock.lock(); 
    m2();
    lock.unlock();
}

public void m2() {
    lock.lock();
    // 其他处理
    lock.unlock();
}
```

当调用 m1 时，首先加锁，然后调用 m2，可是 m2 也需要上锁，而无法完成 m2 的话 m1 的锁也解不开，因此死锁了。

如果是一个可重入锁，则 m1 上锁之后，由于 m1，m2 使用的是同一把锁，因此 m2 还能进入临界区，并且释放锁，m2 完成后，m1 正常完成，锁被释放，最后的 `_count` 一定是 0。

最后，由于 `Monitor` 在 JDK 1.6 之前的实现完全依赖于操作系统，因此**会频繁的从用户态切换到内核态**，是一个重量级操作。之后的版本 Java 一直在优化，并且取得了很好的效果。

#### 优化

Java 1.6 以后，`synchronized` 做了大量的优化，其性能已经与 `Lock` 、`ReadWriteLock` 基本上持平。

优化的思路是：**既然重量级锁依靠操作系统的互斥机制来实现，那么在真正需要重量级锁之前，尽量在 JVM 层面实现锁，避免使用操作系统中的互斥机制，减少切换的消耗**。

为此，JVM 在 `synchronized` 使用重量级锁之前，还提供了无锁、偏向锁和轻量级锁，这些都和 Java 对象头息息相关，想要详细了解这一部分的知识，可以参阅 JVM 教程。

##### Java 对象头和锁状态

在 JVM 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充，我们关注的部分是对象头。

对象头包括两类信息：

1. 对象自身**运行时数据**，比如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。

   这部分在 32 位和 64 位虚拟机中分配占用 32 位和 64 位，官方称之为 `Mark Word`。考虑到虚拟机的空间效率，`Mark Word` 被设计为动态的数据结构，以便在小空间下存储尽量多的数据，根据对象的状态复用自己的存储空间。

   根据锁状态的不同，存储的数据也不一样：

   ![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20210627210825952.png)

2. **类型指针**，指向它的类型元数据的指针（`Klass Pointer`）。

我们重点关注的就是这个锁状态了，**锁状态由标志位标识**，由于只占 2 位，因此应该有四种锁状态，不过**无锁和偏向锁的标志是一样的**，所以无锁和偏向锁的还需要额外的 1 位来决定。

JVM 引入了偏向锁和轻量级锁，从而让 `synchronized` 拥有了四个状态：

- **无锁状态（unlocked）**
- **偏向锁状态（biasble）**
- **轻量级锁状态（lightweight locked）**
- **重量级锁状态（inflated）**

当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，从而减小锁的开销：

* **当没有竞争出现时，默认会使用偏向锁**。JVM 会利用 CAS 操作（CompareAndSwap），在 Mark Word 偏向锁状态下的前 54 位设置为当前线程 ID，以表示这个对象偏向于当前线程。

  这样做的假设是基于**在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏向锁可以降低竞争开销**。

* **如果偏向锁中 CAS 设置线程 ID 失败了，则表明有另外的线程试图锁定某个已经被偏向过的对象，JVM 就需要撤销偏向锁，并切换到轻量级锁实现**。

  轻量级锁也依赖 CAS 操作 Mark Word，它会尝试利用 CAS 设置 Mark Word 中相应的部分为 Lock Record（轻量级锁实现）。

* **如果轻量级锁中 CAS 操作还是失败了，就进入一段时间的自旋；如果自旋这段时间内还是没有获取到锁，则升级到重量级锁**。

  重量级锁就是传统的 `Monitor`，处于这个状态的 Mark Word 会有一个指向 `Monitor` 的指针，`Monitor` 的原理就不再叙述了。

##### 偏向锁原理

偏向锁的思想是**偏向于第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要**。

偏向锁的获取流程如下：

1. 查看 Mark Word 中偏向锁的标识以及锁标志位，若是否偏向锁为 1 且锁标志位为 01，则该锁为可偏向状态。
2. 若为可偏向状态，则测试 Mark Word 中的线程 ID 是否与当前线程相同，**若相同，则直接执行同步代码（无需 CAS，最大程度的减少同步开销）**，否则进入下一步。
3. 当前线程通过 CAS 操作尝试获得偏向锁，即将 Mark Word 中线程 ID 设置为当前线程 ID，设置成功则执行同步代码，若失败，进入下一步。
4. 当前线程通过 CAS 获取锁失败的情况下，说明有竞争。当到达全局安全点时之前获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。

> **全局安全点**
>
> JVM 中没有字节码正在执行的时候称作全局安全点。

偏向锁的释放流程：

1. 其他线程尝试竞争偏向锁时，持有偏向锁状态的线程会释放锁（线程不会主动去释放偏向锁）
2. 偏向锁的撤销需要等待全局安全点，这时它会暂停拥有偏向锁的线程然后撤销锁，撤销后偏向锁恢复到未锁定状态或轻量级锁状态

##### 轻量级锁原理

轻量级锁不是用来替代传统的重量级锁的，而是**在没有多线程竞争的情况下，使用轻量级锁能够减少性能消耗**，但是当**多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁**。

轻量级锁流程如下：

1. 当线程执行代码进入同步块时，若 Mark Word 为无锁状态，虚拟机先在**当前线程的栈帧中建立一个名为 Lock Record（锁记录）的空间**，用于存储当前对象的 Mark Word 的拷贝。
2. **复制对象头中的 Mark Word 到 Lock Record 中**。
3. 复制成功后，虚拟机将**用 CAS 操作将对象的 Mark Word 更新为指向 Lock Record 的指针**，并**将 Lock Record 里的 owner 指针指向对象的 Mark Word**。如果更新成功，则执行 4，否则执行 5。
4. 更新成功，则这个线程拥有了这个锁，并将锁标志设为 00，表示处于轻量级锁状态
5. 更新失败，虚拟机会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是则说明当前线程已经拥有这个锁，可进入执行同步代码。否则说明多个线程竞争，在一段时间的**自旋**后，如果仍然未获取到锁，轻量级锁就会膨胀为重量级锁，Mark Word 中改为存储重量级锁（`Monitor`）的指针。

##### 锁消除/锁粗化

**锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除**。JIT 编译器在动态编译同步块的时候，借助了一种被称为**逃逸分析**的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。如果某个变量不存在逃逸，那么它的作用域就是当前块，可以消除冗余的加锁。

锁粗化同理，就是**在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块**，从而减少一个线程反复申请、释放同一个锁所带来的性能开销。

比如：

```java
public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

`StringBuffer` 是线程安全的，每一次 `append` 前都需要加锁，`append` 结束后又会释放锁，这里几个连续的 `append` 如果不涉及并发的话，那么将会优化为一个大的加锁、释放锁的同步块。

##### 适应性自旋

在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是**让一个线程在请求一个共享数据的锁时自旋一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态**。

自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行循环操作而占用 CPU 时间，因此它只适用于**共享数据的锁定状态很短的场景**。

JDK 1.6 时引入了**自适应性的自旋锁**，自旋的时间不再固定，而是**根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的**。

### `volatile`

`volatile` 可以看作是轻量级的 `synchronized`，它在多处理器开发中保证了共享变量的可见性。

被 `volatile` 修饰的变量，具备以下特性：

- **线程可见性**
- **禁止指令重排序**
- **不保证原子性**

我们知道，线程安全需要具备：可见性、原子性、有序性，而 `volatile` 不保证原子性，所以决定了它不能彻底地保证线程安全。

#### 应用

如果 `volatile` 变量修饰符使用恰当的话，它比 `synchronized` 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。但是需要再次强调的是，**`volatile` 无法替代 `synchronized` ，因为 `volatile` 无法保证操作的原子性**。如果需要原子性，请使用原子类型。

通常来说，**使用 `volatile` 必须具备以下 2 个条件**：

- **对变量的写操作不依赖于当前值**
- **该变量没有包含在具有其他变量的表达式中**

下面是一个双重判断实现的单例模式：

```java
class Singleton {
    private volatile static Singleton instance = null;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
```

注意，这里的 `volatile` 是一定要加的，我们稍后会讲到它不加

#### 原理

观察加入 `volatile` 关键字和没有加入 `volatile` 关键字时所生成的字节码发现，**加入 `volatile` 关键字时，会多出一个 `lock` 前缀指令**。

**`lock` 前缀指令实际上相当于一个内存屏障**，内存屏障会提供 3 个功能：

- **确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面**
- **强制将对缓存的修改操作立即写入主存**
- **如果是写操作，它会导致其他 CPU 中对应的缓存行无效**



### CAS

CAS（CompareAndSwap），字面意思为比较并交换，是硬件提供的原语。

CAS 有 3 个操作数，分别是：内存值 M，期望值 E，更新值 U。**当且仅当内存值 M 和期望值 E 相等时，将内存值 M 修改为 U，否则什么都不做**。

> **乐观并发策略**
>
> 最常用的互斥锁最主要的问题是**线程阻塞和唤醒所带来的性能问题**。
>
> 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。
>
> 随着硬件指令集的发展，我们可以使用基于冲突检测的**乐观并发策略**：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。
>
> 为什么说乐观锁需要**硬件指令集的发展**才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。

#### 应用

CAS 主要应用在原子类和自旋锁上。

下面是两个示例：

```java
public class AtomicIntegerDemo {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        // 原子类
        final AtomicInteger count = new AtomicInteger(0);
        for (int i = 0; i < 10; i++) {
            executorService.execute(new Runnable() {
                @Override
                public void run() {
                    count.incrementAndGet();
                }
            });
        }

        executorService.shutdown();
        executorService.awaitTermination(3, TimeUnit.SECONDS);
        System.out.println("Final Count is : " + count.get());
    }
}
```

```java
// 自己实现的自旋锁，利用 CAS
class SpinLock {
    // 原子引用，默认初始化时内部没有持有任何引用
    // 它提供了 CAS 方法，第一个参数为期望值，第二个参数为新值
    private AtomicReference<Thread> atomicReference = new AtomicReference<>();

    public void lock() {
        Thread current = Thread.currentThread();

        // 当一个线程进入该方法时，就会利用 CAS 将这个原子引用设置为自己，返回 true
        // 另一个线程进入时，由于原子引用内部已经持有引用了，因此不会设置，从而返回 false，进而自旋
        while (!atomicReference.compareAndSet(null, current)) {}
    }

    public void unlock() {
        Thread current = Thread.currentThread();
        // 解锁则是将原子引用重新设置为 null
        atomicReference.compareAndSet(current, null);
    }
}

class MyThread implements Runnable {
    private SpinLock lock;

    public MyThread(SpinLock lock) {
        this.lock = lock;
    }

    @Override
    public void run() {
        while (ticket > 0) {
            lock.lock();
            if (ticket > 0) {
                System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");
                ticket--;
            }
            lock.unlock();
        }
    }
}
```

#### 原理

Java 主要利用 `Unsafe` 这个类提供的 CAS 操作。

`Unsafe` 的 CAS 依赖的是 JVM 针对不同的操作系统实现的硬件指令 **`Atomic::cmpxchg`**。`Atomic::cmpxchg` 的实现使用了硬件的 CAS 操作。我们看一下这部分的 C++ 源码：

```c++
unsigned Atomic::cmpxchg(unsigned int exchange_value, volatile unsigned int* dest, unsigned int compare_value) {
    assert(sizeof(unsigned int) == sizeof(jint), "more work to do");
    /*
     * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载
     * 函数。相关的预编译逻辑如下：
     * 
     * atomic.inline.hpp：
     *    #include "runtime/atomic.hpp"
     *    
     *    // Linux
     *    #ifdef TARGET_OS_ARCH_linux_x86
     *    #include "atomic_linux_x86.inline.hpp"
     *    #endif
     *   
     *    // 省略部分代码
     *    
     *    // Windows
     *    #ifdef TARGET_OS_ARCH_windows_x86
     *    #include "atomic_windows_x86.inline.hpp"
     *    #endif
     *    
     *    // BSD
     *    #ifdef TARGET_OS_ARCH_bsd_x86
     *    #include "atomic_bsd_x86.inline.hpp"
     *    #endif
     * 
     * 接下来分析 atomic_windows_x86.inline.hpp 中的 cmpxchg 函数实现
     */
    return (unsigned int)Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest,
                                         (jint)compare_value);
}
```

```c++
// atomic_windows_x86.inline.hpp
#define LOCK_IF_MP(mp) __asm cmp mp, 0  \
					   __asm je L0      \
					   __asm _emit 0xF0 \
					   __asm L0:

inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {
    // alternative for InterlockedCompareExchange
    int mp = os::is_MP();
    __asm {
        mov edx, dest
            mov ecx, exchange_value
            mov eax, compare_value
            LOCK_IF_MP(mp)
            cmpxchg dword ptr [edx], ecx
    }
}
```

其实核心代码就是一条带 lock 前缀的 cmpxchg 指令，即 `lock cmpxchg dword ptr [edx], ecx`。

> **lock 前缀指令**
>
> Intel 规定在多处理器环境下，LOCK# 信号可以确保处理器独占使用某些共享内存。
>
> 通过在部分指令前添加 lock 前缀，即可让该指令具备原子性。
>
> 需要注意的是，这里的 lock 前缀指令是 CPU 层面的，是最底层的，之前在 `volatile` 中提到的 lock 前缀指令是字节码层面的，两者不可混为一谈。

#### CAS 存在的问题

一般情况下，**CAS 比锁性能更高**。因为 CAS 是一种非阻塞的方式，所以其避免了线程阻塞和唤醒的等待时间，同时也避免了上下文切换的开销。

但是，事物总会有利有弊，CAS 也存在三大问题：

- **ABA 问题**：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过，因此继续 CAS 操作。

  比如有三个线程 ABC 进行 CAS 操作，AB 期望值 1 修改为 0，C 期望值 0 修改为 1，它们的执行顺序是 ACB，当轮到 B 时，B 就会发现好像跟之前没有什么区别，事实上，值已经被改动过了。

  **大部分情况下 ABA 问题不会影响程序并发的正确性，但是部分场景下会有严重的问题**，比如金融交易场景下，AB 为扣钱，C 为存钱，那么 C 存入的钱将会不翼而飞，因此带来严重的问题。

  JUC 提供了一个带有标记的原子引用类 `AtomicStampedReference` 来解决这个问题，它可以通过控制变量值的**版本**来保证 CAS 的正确性，这也是解决 ABA 问题的一个通用方法。

- **循环时间长开销大**：自旋 CAS 如果长时间不成功，则性能开销非常大。

- **只能保证一个共享变量的原子性**：显而易见，CAS 操作仅能保护一个变量，如果有多个变量，还是使用锁更为高效。

### `ThreadLocal`

**`ThreadLocal` 是一个存储线程本地副本的工具类**。

要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。

`ThreadLocal` 可以实现让每一个线程拥有专属于本线程的变量。**如果你创建了一个`ThreadLocal` 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 `ThreadLocal` 变量名的由来。它们可以使用 `get（）` 和 `set（）` 方法来获取值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。**

#### 应用

`ThreadLocal` 提供的常用方法如下表：

| 方法                | 作用                                         |
| ------------------- | -------------------------------------------- |
| `T get()`           | 返回此线程局部变量的当前线程副本中的值。     |
| `void set(T value)` | 将此线程局部变量的当前线程副本设置为指定值。 |
| `void remove()`     | 删除此线程局部变量的当前线程值。             |

`ThreadLocal` 常用于防止对可变的单例（Singleton）变量或全局变量进行共享。典型应用场景有：JDBC 管理数据库连接以及 Web 开发的 Session 管理。

下面是 JDBC 数据库连接管理示例：

```java
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
    @Override
    public Connection initialValue() {
        return DriverManager.getConnection(DB_URL);
    }
};

public static Connection getConnection() {
    return connectionHolder.get();
}
```

#### 原理

**`Thread` 类中维护着一个 `ThreadLocal.ThreadLocalMap` 类型的成员** `threadLocals`，这个成员用来存储当前线程独占的变量副本：

```java
public class Thread implements Runnable {
    // ...
    ThreadLocal.ThreadLocalMap threadLocals = null;
    // ...
}
```

而 `ThreadLocalMap` 是 `ThreadLocal` 的内部类，它维护着一个 `Entry` 数组，**`Entry` 继承了 `WeakReference`**，所以是弱引用。

和其他许多 `Map` 类似，`Entry` 用于保存键值对，其中：

- `key` 是 `ThreadLocal` 对象
- `value` 是传递进来的对象（变量副本）

源码如下：

```java
static class ThreadLocalMap {
    // ...
    static class Entry extends WeakReference<ThreadLocal<?>> {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }
    // ...
}
```

我们先看一下 `ThreadLocal` 的 `get` 方法源码，从这里就可以了解到 `ThreadLocal` 的流程：

```java
public T get() {
    // 获取当前线程
    Thread t = Thread.currentThread();
    // 获取当前线程中的 threadLocals，也就是 ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        // 获取 entry，由于 key 是 ThreadLocal，因此传入它本身即可拿到 entry
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

`ThreadLocal` 的原理示意图如下：

![image-20220308104630626](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220308104630626.png)

所有线程共享一个或多个 `ThreadLocal`，当在 `ThreadLocal` 上设置值时，实际上是在线程内部的 `Map` 中以当前 `ThreadLocal` 为键设置一个键值对，每个线程自己的 `Map` 不同，键值对自然是本线程独享的。

##### 解决哈希冲突

`ThreadLocalMap` 虽然是类似 `Map` 结构的数据结构，但它并没有实现 `Map` 接口。它不支持 `Map` 接口中的 `next` 方法，这意味着 `ThreadLocalMap` 中**解决哈希冲突的方式并非链表法**。

实际上，**`ThreadLocalMap` 采用线性探测的方式来解决哈希冲突**，即根据初始 key 的 hashcode 值确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。

首先看一下它的 `hash` 算法：`int i = key.threadLocalHashCode & (len-1);`，计算出来的 i 就是下标。

这里最关键的就是`threadLocalHashCode`值的计算，`ThreadLocal` 中有一个属性为 `HASH_INCREMENT = 0x61c88647`：

```Java
public class ThreadLocal<T> {
    private final int threadLocalHashCode = nextHashCode();

    private static AtomicInteger nextHashCode =
        new AtomicInteger();

    private static final int HASH_INCREMENT = 0x61c88647;

    private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    }
    
    // ...
}
```

每当创建一个`ThreadLocal`对象，这个 `ThreadLocal.nextHashCode` 这个值就会增长 `0x61c88647` 。

这个值很特殊，它是**斐波那契数**也叫**黄金分割数**。`hash`增量为这个数字，带来的好处就是 `hash` **分布非常均匀**。

##### 内存泄漏问题

由于 `ThreadLocalMap` 的 `Entry` 继承了 `WeakReference`，所以键是弱引用，值是强引用。

如果 `ThreadLocal` 对象没有外部强引用来引用它，那么 `ThreadLocal` 对象会在下次 GC 时被回收。此时，**`Entry` 中的 key 已经被回收，但是 value 由于是强引用不会被垃圾收集器回收**。如果创建 `ThreadLocal` 的线程一直持续运行，那么 value 就会一直得不到回收，产生**内存泄露**。

那么如何避免内存泄漏呢？方法就是：**使用 `ThreadLocal` 的 `set` 方法后，显式的调用 `remove` 方法**。当然，`ThreadLocalMap` 也考虑到了这个问题，因此在添加和删除的时候会自动探测过期的 key，然后执行回收，这里涉及到两个策略，我们在接下来会详细讲解这个问题。

##### 过期 key 的清理

###### 探测式清理

这种清理策略在源码中是 `expungeStaleEntry` 方法，思想是：遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的 `Entry` 设置为 `null`，沿途中碰到未过期的数据则将此数据 `rehash` 后重新在 `table` 数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的 `Entry = null` 的桶中（线性探测），使 `rehash` 后的 `Entry` 数据距离正确的桶的位置更近一些。

源码如下：

```java
private int expungeStaleEntry(int staleSlot) {
    Entry[] tab = table;
    int len = tab.length;

    // 清空当前 staleSlot 位置的数据
    tab[staleSlot].value = null;
    tab[staleSlot] = null;
    size--;

    Entry e;
    int i;
    // 向后探测，找到下一个索引 i
    for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) {
        ThreadLocal<?> k = e.get();
        // 如果过期，清除它
        if (k == null) {
            e.value = null;
            tab[i] = null;
            size--;
        } else {
            // 如果 key 没有过期，重新计算当前 key 的下标位置（再哈希），如果计算结果不为 i，则将其移动，使 rehash 后的 Entry 数据距离正确的桶的位置更近一些
            int h = k.threadLocalHashCode & (len - 1);
            if (h != i) {
                // 将原位置清除
                tab[i] = null;
				
                // 找一个合适的位置，把 e 放进去
                while (tab[h] != null)
                    h = nextIndex(h, len);
                tab[h] = e;
            }
        }
    }
    return i;
}
```

###### 启发式清理

启发式清理则是在添加 `Entry` 或过期元素被清除时调用：

- 如果没有过期数据，n 会左移一位，即 / 2，也就是说只要扫描 `logn`次即可。
- 如果有过期数据，需要将 `n` 置为 `table` 的长度 `len`，做一次探测式清理，再从下一个空的 slot 开始继续扫描。

```java
private boolean cleanSomeSlots(int i, int n) {
    boolean removed = false;
    Entry[] tab = table;
    int len = tab.length;
    do {
        i = nextIndex(i, len);
        Entry e = tab[i];
        if (e != null && e.get() == null) {
            n = len;
            removed = true;
            i = expungeStaleEntry(i);
        }
    } while ( (n >>>= 1) != 0);
    return removed;
}
```

#### `InheritableThreadLocal`

`InheritableThreadLocal` 类是 `ThreadLocal` 类的子类。

`ThreadLocal` 中每个线程拥有它自己独占的数据。与 `ThreadLocal` 不同的是，`InheritableThreadLocal` 允许一个线程以及该线程创建的所有子线程都可以访问它保存的数据。

## 锁

确保线程安全最常用的办法就是使用锁，JUC 中提供了比 `synchronized` 更高级，功能更多的锁来简化多线程的开发。

### 基本概念

本节介绍一些锁的概念，包括各种各样的锁的类型，以及 Java 特有的锁的概念。

#### 可重入锁

可重入锁**指的是线程可以重复获取同一把锁**，而不会发生死锁。

#### 公平锁与非公平锁

- **公平锁**是指**多线程按照申请锁的顺序来获取锁**。
- **非公平锁**非公平锁是指**多线程不按照申请锁的顺序来获取锁** 。这就可能会出现优先级反转（后来者居上）或者饥饿现象（某线程总是抢不过别的线程，导致始终无法执行）。

公平锁为了保证线程申请顺序，势必要付出一定的性能代价，因此其吞吐量一般低于非公平锁。

#### 独享锁和共享锁

独享锁与共享锁是一种广义上的说法，从实际用途上来看，也常被称为读锁和写锁，独享锁有时也叫做独占锁、排它锁。

- **独享锁**：独享锁是指**锁一次只能被一个线程所持有**。
- **共享锁**：共享锁是指**锁可被多个线程所持有**。

#### 悲观锁与乐观锁

乐观锁与悲观锁不是指具体的什么类型的锁，而是**处理并发同步的策略**。

- **悲观锁**：悲观锁对于并发采取悲观的态度，认为：**不加锁的并发操作一定会出问题**。**悲观锁适合写操作频繁的场景**。
- **乐观锁**：乐观锁对于并发采取乐观的态度，认为：**不加锁的并发操作也没什么问题。对于同一个数据的并发操作，是不会发生修改的**。在更新数据的时候，会采用不断尝试更新的方式更新数据。**乐观锁适合读多写少的场景**。

常用的 `synchronized` 就是悲观锁，而 CAS 等原子操作就是乐观锁。

#### 偏向锁、轻量级锁、重量级锁

所谓轻量级锁与重量级锁，指的是锁控制粒度的粗细。显然，控制粒度越细，阻塞开销越小，并发性也就越高。

Java 1.6 以前，重量级锁一般指的是 `synchronized` ，而轻量级锁指的是 `volatile`。

Java 1.6 以后，针对 `synchronized` 做了大量优化，引入 4 种锁状态： 无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。

- **偏向锁**：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- **轻量级锁**：是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- **重量级锁**：是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

#### 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁。

所谓分段锁，就是**把锁的对象分成多段，每段独立控制，使得锁粒度更细，减少阻塞开销，从而提高并发性**。这其实很好理解，就像高速公路上的收费站，如果只有一个收费口，那所有的车只能排成一条队缴费；如果有多个收费口，就可以分流了。

`Hashtable` 使用 `synchronized` 修饰方法来保证线程安全性，那么面对线程的访问，`Hashtable` 就会锁住整个对象，所有的其它线程只能等待，这种阻塞方式的吞吐量显然很低。

Java 1.7 以前的 `ConcurrentHashMap` 就是分段锁的典型案例。`ConcurrentHashMap` 维护了一个 `Segment` 数组，一般称为分段桶。

```java
final Segment<K,V>[] segments;
```

当有线程访问 `ConcurrentHashMap` 的数据时，`ConcurrentHashMap` 会先根据 hashCode 计算出数据在哪个段，然后锁住这个段。

#### 显式锁和内置锁

`synchronized` 和 `volatile` 都是 Java 内置的机制，也叫做内置锁，即锁的申请和释放都是由 JVM 所控制。

JUC 提供了锁类，这类锁也叫做显式锁，即锁的申请和释放都可以由程序控制。

两者还是有一些差异：

* 内置锁不可以主动释放，而显式锁则可以
* 内置锁不能响应中断，而显式锁可以
* 内置锁没有超时机制，而显式锁有
* 内置锁只支持非公平锁，而显式锁既可以支持非公平锁，也可以支持公平锁
* 内置锁不能被共享，而显式锁可以根据 `Condition` 灵活的控制
* 内置锁不支持读写分离，而显式锁可以支持读写锁，使读写分离，有效提高并发性

### AQS

在正式介绍锁之前，我们还必须介绍一个类——`AbstractQueuedSynchronizer`（AQS），它是**队列同步器**，顾名思义，其主要作用是处理同步，它是并发锁和很多同步工具类的实现基石（如 `ReentrantLock`、`ReentrantReadWriteLock`、`CountDownLatch`、`Semaphore`、`FutureTask` 等）。

> 在 `java.util.concurrent.locks` 包中的相关锁（比如 `ReentrantLock`、 `ReadWriteLock`）都是基于 AQS 来实现。
>
> 这些锁没有直接继承 AQS，而是定义了一个内部的 `Sync` 类去继承 AQS。为什么要这样呢？因为锁面向的是用户，而同步器面向的则是线程控制，那么在锁的实现中使用**聚合**的方式而不是直接继承 AQS 就可以很好的隔离二者所关注的事情，这也是一种软件设计的技巧。

在 AQS 内部，通过维护一个 FIFO 的队列来管理多线程的排队工作，示意图如下：

![image-20220504155754089](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220504155754089.png)

当**头结点释放同步状态后**，且后继节点对应的线程被阻塞，此时头结点线程将会去**唤醒后继节点线程**；**后继节点线程恢复运行并获取同步状态后，会将旧的头结点从队列中移除，并将自己设为头结点**。示意图如下：

![image-20220504160015520](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220504160015520.png)

除此之外，**AQS 使用一个整型的 `volatile` 变量 `state` 来维护同步状态**，`state` 的含义由子类赋予，比如在即将要介绍的 `ReentrantLock` 中就是代表同一线程重入的次数。

从这里我们可以看出 AQS 的核心思想：**如果被请求的资源（AQS 中的 `state`）空闲，则将当前请求资源的线程设置为有效的工作线程（head 节点），并且将共享资源设置为锁定状态；如果被请求的共享资源被占用，那么就将线程封装为节点，排在队列的后面，等待获取资源**。

![image-20220306100204301](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220306100204301.png)

这就是 AQS 的大体工作流程，我们接下来还会详细深入的介绍 AQS 的内部原理，但是在那之前，需要介绍一下 AQS 的使用方式。

#### 使用方式

AQS 的 API 可以分为好几层：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/82077ccf14127a87b77cefd1ccf562d3253591.png)

我们介绍其中一些重要的方法，这些方法都是经常使用的，很多时候你只需要在你自己的类里继承 AQS，调用这几个方法就完成了一个简单同步组件的实现：

* 首先是关于 `state` 的几个方法：

  | 方法                                                 | 说明                  |
  | ---------------------------------------------------- | --------------------- |
  | `int getState()`                                     | 获取同步状态          |
  | `void setState()`                                    | 设置同步状态          |
  | `boolean compareAndSetState(int expect, int update)` | 通过 CAS 设置同步状态 |

* 然后是 AQS 的模板方法，这里也是运用到了模板方法的设计模式。

  模板方法就是父类规定好了该方法的规则，并且子类不应该（甚至不能）去重写模板方法，而是直接调用。但是模板方法中有钩子方法的存在，需要子类去实现。

  这些钩子方法仅在 AQS 中声明（也就是抽象方法），具体实现交给子类。但是，这些方法却在 AQS 的其他方法中被调用了，就相当于 AQS 给你一个模板，你填空就好了，因此也叫做模板方法设计模式。

  AQS 中的模板方法如下，子类需要重写它们：

  | 方法                                | 说明                       |
  | ----------------------------------- | -------------------------- |
  | `boolean tryAcquire(int arg)`       | 独占式获取同步状态         |
  | `boolean tryRelease(int arg)`       | 独占式释放同步状态         |
  | `int tryAcquireShared(int arg)`     | 共享式获取同步状态         |
  | `boolean tryReleaseShared(int arg)` | 共享式释放同步状态         |
  | `boolean isHeldExclusively()`       | 检测当前线程是否获取独占锁 |

* 最后就是调用了模板方法的成熟方法，这些方法可以直接调用：

  | 方法                                                | 说明                                                         |
  | --------------------------------------------------- | ------------------------------------------------------------ |
  | `void acquire(int arg)`                             | 独占式获取同步状态，该方法将会调用 `tryAcquire` 尝试获取同步状态。获取成功则返回，获取失败，线程进入同步队列等待。 |
  | `void acquireInterruptibly(int arg)`                | 响应中断版的 `acquire`                                       |
  | `boolean tryAcquireNanos(int arg,long nanos)`       | 超时 + 响应中断版的 `acquire`                                |
  | `void acquireShared(int arg)`                       | 共享式获取同步状态，同一时刻可能会有多个线程获得同步状态。比如读写锁的读锁就是就是调用这个方法获取同步状态的。 |
  | `void acquireSharedInterruptibly(int arg)`          | 响应中断版的 `acquireShared`                                 |
  | `boolean tryAcquireSharedNanos(int arg,long nanos)` | 超时+响应中断版的 `acquireShared`                            |
  | `boolean release(int arg)`                          | 独占式释放同步状态                                           |
  | `boolean releaseShared(int arg)`                    | 共享式释放同步状态                                           |

上面列举了一堆方法，看似繁杂。但稍微理一下，就会发现上面诸多方法无非就两大类：**一类是独占式获取和释放共享状态**，**另一类是共享式获取和释放同步状态**，所以我们也说，**AQS 主要是提供了对独占锁和共享锁的支持**。

接下来，我们使用 AQS 实现一个简单的锁：

```java
public class PlainLock {
    private static class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            // CAS 替换状态 0 -> 1，成功则直接获取到锁
            return compareAndSetState(0, 1);
        }

        @Override
        protected boolean tryRelease(int arg) {
            // 把 state 重新置为初始状态 0
            setState(0);
            return true;
        }

        @Override
        protected boolean isHeldExclusively() {
            // 如果 state = 1，那么它已经成功获取独占锁
            return getState() == 1;
        }
    }

    private Sync sync = new Sync();

    public void lock() {
        sync.acquire(1);
    }

    public void unlock() {
        sync.release(1);
    }
}
```

#### 原理

首先是 AQS 整体的定义：

```java
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    // 等待队列的队头，懒加载。只能通过 setHead 方法修改
    private transient volatile Node head;
    // 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点
    private transient volatile Node tail;
    // 同步状态 
    private volatile int state;
    
    // ...
}
```

* `state`：`state` 表示同步状态，其具体意义由子类来赋予，如`ReentrantLock` 中该状态值表示所有者线程已经重复获取该锁的次数，`Semaphore` 中该状态值表示剩余的许可数量。
* `head` 和 `tail`：AQS **维护了一个 `Node` 类型（AQS 的内部类）的双链表来完成同步状态的管理**，这个双链表是一个双向的 FIFO 队列，通过 `head` 和 `tail` 指针进行访问。**当有线程获取锁失败后，就被添加到队列末尾**。

##### AQS 队列节点的结构

在并发的情况下，AQS 会将未获取同步状态的线程将会封装成节点，并将其放入同步队列尾部。同步队列中的节点除了要保存线程，还要保存等待状态。不管是独占式还是共享式，在获取状态失败时都会用到节点类。所以这里我们要先看一下节点类的实现：

```java
static final class Node {
    // 共享类型节点，标记节点在共享模式下等待
    static final Node SHARED = new Node();

    // 独占类型节点，标记节点在独占模式下等待
    static final Node EXCLUSIVE = null;

    // 等待状态 - 取消
    static final int CANCELLED =  1;

    // 等待状态 - 通知
    // 如果某个节点是处于该状态，当该节点释放同步状态后，会通知后继节点线程，使之可以恢复运行 
    static final int SIGNAL    = -1;

    // 等待状态 - 条件等待
    // 如果某个节点处于该状态，表明节点等待在 Condition 上
    static final int CONDITION = -2;

    // 等待状态 - 传播
    // 表示无条件向后传播唤醒动作
    static final int PROPAGATE = -3;

    // 等待状态，取值可以是上面介绍的四个，也可以是 0
    volatile int waitStatus;

    // 前驱节点
    volatile Node prev;

    // 后继节点
    volatile Node next;

    // 对应的线程
    volatile Thread thread;

    // 下一个等待节点，用在 ConditionObject 中
    Node nextWaiter;

    // 判断节点是否是共享节点
    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    // 获取前驱节点
    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }

    Node() {

    }

    // addWaiter 方法会调用该构造方法
    Node(Thread thread, Node mode) {
        this.nextWaiter = mode;
        this.thread = thread;
    }

    // Condition 中会用到此构造方法 
    Node(Thread thread, int waitStatus) {
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
}
```

在 `Node` 中，`waitStatus` 有五个状态值：

- `CANCELLED`：此状态表示**等待线程超时或者被中断、需要从同步队列中取消等待**（也就是放弃资源的竞争），此状态不会再改变。
- `SIGNAL`：此状态表示后继节点会处于等待状态，**当前节点线程如果释放同步状态或者被取消则会通知后继节点线程，使后继节点线程的得以运行**。
- `CONDITION`：节点在等待队列中，线程在等待在 `Condition` 上，其他线程对 `Condition` 调用 `signal` 方法后，该节点加入到同步队列中。
- `PROPAGATE`：表示无条件向后传播唤醒动作。
- `0`：如果取值是 0，则表示该节点处于初始状态。

##### 独占模式分析

###### 获取同步状态

首先我们对独占锁流程做一个总结：

1. 调用 `tryAcquire` 方法尝试获取同步状态
2. 获取成功，直接返回
3. 获取失败，将线程封装到节点中，并将节点入队
4. 入队节点在 `acquireQueued` 方法中自旋获取同步状态
5. 若节点的前驱节点是头节点，则再次调用 `tryAcquire` 尝试获取同步状态
6. 获取成功，当前节点将自己设为头节点并返回
7. 获取失败，可能再次尝试，也可能会被阻塞

下面是源码分析，首先是入口 `acquire` 方法：

```java
/**
 * 该方法将会调用子类复写的 tryAcquire 方法获取同步状态
 * 
 * 如果获取成功：直接返回
 * 如果获取失败：则将线程封装在节点中，并将节点置于同步队列尾部，通过自旋尝试获取同步状态。、如果在有限次内仍无法获取同步状态，该线程将会被 LockSupport.park 方法阻塞住，直到被前驱节点唤醒
 */
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

1. `acquire` 首先会调用一次 `tryAcquire` 尝试获取，如果本次获取成功，直接就返回了；
2. 如果获取失败了，就会调用 `addWaiter` 向队列尾部添加一个节点，然后调用 `acquireQueued` 尝试自旋获取状态，如果自旋失败，就会阻塞。

接下来我们要阅读的就是 `addWaiter` 方法：

```java
// 向同步队列尾部添加一个节点
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // 尝试以快速方式（CAS）将节点添加到队列尾部
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }

    // 快速插入节点失败，调用 enq 方法，不停的尝试插入节点
    enq(node);
    return node;
}
```

这里我们又看到，有一个快速入队的尝试，如果失败了才调用 `enq` 方法，之前的 `acquire` 也是首先经过一次尝试，这些**首先尝试的步骤都是为了性能考虑**。

接下来是 `enq` 方法：

```java
// 通过 CAS + 自旋的方式插入节点到队尾
private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { 
            // 如果队列为空，创建结点，同时被 head 和 tail 引用
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // 将节点插入队列尾部
            // 这里是先将新节点的前驱指向原来的尾节点，之后在尝试将新节点设为尾节点，最后再将原尾节点的后继节点指向新的尾节点
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

入队列之后，就又一次尝试获取同步状态：

```java
// 同步队列中的线程在此方法中以循环尝试获取同步状态，在有限次的尝试后，若仍未获取锁，线程将会被阻塞，直至被前驱节点的线程唤醒
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        // 循环获取同步状态
        for (;;) {
            // 找到当前结点的前驱结点
            final Node p = node.predecessor();
            // 如果前驱结点是头结点，才 tryAcquire，其他结点是没有机会 tryAcquire 的
            // 前驱节点释放同步状态后，在不出异常的情况下，tryAcquire(arg) 应返回 true，此时节点就成功获取了同步状态，并将自己设为头节点，原头节点出队
            if (p == head && tryAcquire(arg)) {
                // 成功获取同步状态，设置自己为头节点
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }

            // 如果获取同步状态失败，则根据条件判断是否应该阻塞自己；如果不阻塞，CPU 就会处于忙等状态，这样会浪费 CPU 资源   
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt()) // parkAndCheckInterrupt 用来阻塞线程 
                interrupted = true;
        }
    } finally {
        // 如果在获取同步状态中出现异常，failed = true，cancelAcquire 方法会被执行。tryAcquire 需同步组件开发者覆写，难免不了会出现异常
        if (failed)
            cancelAcquire(node);
    }
}
```

这里需要注意的就是 AQS 是如何判断一个线程是否需要阻塞的，这是通过调用 `shouldParkAfterFailedAcquire` 实现的：

```java
/**
 * 该方法主要用途是，当线程在获取同步状态失败时，根据前驱节点的等待状态，决定后续的动作。
 * 比如前驱节点等待状态为 SIGNAL，表明当前节点线程应该被阻塞。不能老是尝试，避免 CPU 忙等。
 *    —————————————————————————————————————————————————————————————————
 *    | 前驱节点等待状态  |                   相应动作                    |
 *    —————————————————————————————————————————————————————————————————
 *    | SIGNAL         | 阻塞                                          |
 *    | CANCELLED      | 向前遍历, 移除前面所有为该状态的节点               |
 *    | waitStatus < 0 | 将前驱节点状态设为 SIGNAL, 并再次尝试获取同步状态   |
 *    —————————————————————————————————————————————————————————————————
 */
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    // 前驱节点等待状态为 SIGNAL，当前线程应该被阻塞
    if (ws == Node.SIGNAL)
        return true;

    // 前驱节点等待状态为 CANCELLED，则以前驱节点为起点向前遍历，找到一个非 CANCEL 状态的结点，将自己设置为它的后继结，顺便移除其他等待状态为 CANCELLED 的节点  
    if (ws > 0) {
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        // 若前驱结点为其他状态，将其设置为 SIGNAL 状态
        // 这是因为把前驱状态设置为 SIGNAL，以便当前线程阻塞后，前驱能根据 SIGNAL 状态来唤醒自己
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
```

如果在获取同步状态中出现异常，那么就要取消获取，这个方法的流程如下：

```java
// 取消获取同步状态
private void cancelAcquire(Node node) {
    if (node == null)
        return;

    node.thread = null;

    // 前驱节点等待状态为 CANCELLED，则向前遍历并移除其他为该状态的节点
    Node pred = node.prev;
    while (pred.waitStatus > 0)
        node.prev = pred = pred.prev;

    // 记录 pred 的后继节点，后面会用到
    Node predNext = pred.next;

    // 将当前节点等待状态设为 CANCELLED
    node.waitStatus = Node.CANCELLED;

    // 如果当前节点是尾节点，则通过 CAS 设置前驱节点 prev 为尾节点。设置成功后，再利用 CAS 将 prev 的 next 引用置空，断开与后继节点的联系，完成清理工作
    if (node == tail && compareAndSetTail(node, pred)) {
        // 执行到这里，表明 pred 节点被成功设为了尾节点，这里通过 CAS 将 pred 节点的后继节点设为 null。注意这里的 CAS 即使失败了也没关系
        // 失败了表明 pred 的后继节点更新了，pred 此时已经是尾节点了，若后继节点被更新，则是有新节点入队了，这种情况下，CAS 会失败，但失败不会影响同步队列的结构
        compareAndSetNext(pred, predNext, null);
    } else {
        int ws;
        // 根据条件判断是唤醒后继节点，还是将前驱节点和后继节点连接到一起
        if (pred != head &&
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&
            pred.thread != null) {

            Node next = node.next;
            if (next != null && next.waitStatus <= 0)
                /**
                 * 这里使用 CAS 设置 pred 的 next，表明多个线程同时在取消，这里存在竞争。
                 * 不过此处没针对 compareAndSetNext 方法失败后做一些处理，表明即使失败了也
                 * 没关系。实际上，多个线程同时设置 pred 的 next 引用时，只要有一个能设置成
                 * 功即可。
                 */
                compareAndSetNext(pred, predNext, next);
        } else {
            /**
             * 唤醒后继节点对应的线程。这里简单讲一下为什么要唤醒后继线程，考虑下面一种情况：
             *        head          node1         node2         tail
             *        ws=0          ws=1          ws=-1         ws=0
             *      +------+  prev +-----+  prev +-----+  prev +-----+
             *      |      | <---- |     | <---- |     | <---- |     |  
             *      |      | ----> |     | ----> |     | ----> |     |
             *      +------+  next +-----+  next +-----+  next +-----+
             *      
             * 头结点初始状态为 0，node1、node2 和 tail 节点依次入队。node1 自旋过程中调用 
             * tryAcquire 出现异常，进入 cancelAcquire。head 节点此时等待状态仍然是 0，它
             * 会认为后继节点还在运行中，所它在释放同步状态后，不会去唤醒后继等待状态为非取消的
             * 节点 node2。如果 node1 再不唤醒 node2 的线程，该线程面临无法被唤醒的情况。此
             * 时，整个同步队列就回全部阻塞住。
             */
            unparkSuccessor(node);
        }

        node.next = node; // help GC
    }
}
```

###### 释放同步状态

相对于获取同步状态，释放同步状态的过程则要简单的多，这里简单讲一下步骤：

1. 调用 `tryRelease` 尝试释放同步状态
2. 根据条件判断是否应该唤醒后继线程

```java
public final boolean release(int arg) {
    // tryRelease，若成功，唤醒其后继结点，失败则返回 false
    if (tryRelease(arg)) {
        Node h = head;
        /**
          * 这里简单列举条件分支的可能性，如下：
          * 1. head = null
          *     head 还未初始化。初始情况下，head = null，当第一个节点入队后，head 会被初始
          *     为一个虚拟（dummy）节点。这里，如果还没节点入队就调用 release 释放同步状态，
          *     就会出现 h = null 的情况。
          *     
          * 2. head != null && waitStatus = 0
          *     表明后继节点对应的线程仍在运行中，不需要唤醒
          * 
          * 3. head != null && waitStatus < 0
          *     后继节点对应的线程可能被阻塞了，需要唤醒 
          */
        if (h != null && h.waitStatus != 0)
            // 唤醒后继节点
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

##### 共享模式分析

与独占模式不同，共享模式下，同一时刻会有多个线程获取共享同步状态（比如读锁）。

###### 获取共享状态

共享模式下获取同步状态的大致流程如下：

1. 获取共享同步状态
2. 若获取失败，则生成节点，并入队
3. 如果前驱为头结点，再次尝试获取共享同步状态
4. 获取成功则将自己设为头结点，如果后继节点是共享类型的，则唤醒
5. 若失败，将节点状态设为 SIGNAL，再次尝试；若再次失败，线程进入等待状态

下面是源码入口，首先是 `acquireShared`：

```java
public final void acquireShared(int arg) {
    // 尝试获取共享同步状态，tryAcquireShared 返回的是整型
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
```

`tryAcquireShared` 失败后，返回一个负数，此时直接 `doAcquireShared` 进行再次获取：

```java
private void doAcquireShared(int arg) {
    // 入队，但是此时以共享模式入队
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        // 这里和前面一样，也是通过有限次自旋的方式获取同步状态
        for (;;) {
            final Node p = node.predecessor();
           /**
             * 前驱是头结点，其类型可能是 EXCLUSIVE，也可能是 SHARED.
             * - 如果是 EXCLUSIVE，线程无法获取共享同步状态。
             * - 如果是 SHARED，线程则可获取共享同步状态。
             * 能不能获取共享同步状态要看 tryAcquireShared 具体的实现：
             * 比如多个线程竞争读写锁的中的读锁时，均能成功获取读锁；但多个线程同时竞争信号量时，可能就会有一部分线程因无法竞争到信号量资源而阻塞
             */ 
            if (p == head) {
                // 尝试获取共享同步状态
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    // 这里已经获取成功了，设置头结点
                    // 若还有可用资源，传播下去，也就是继续唤醒后继结点，当然，只有后继节点也是 SHARED 时才能被唤醒
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            // 判断自己是否该阻塞
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

`setHeadAndPropagate` 是其中的一个重要方法，这个方法做了两件事情：

1. 设置自身为头结点

2. 根据条件判断是否要唤醒后继节点

源码如下：

```java
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head;
    // 设置头结点
    setHead(node);

    /**
     * 这个条件分支由 propagate > 0 和 h.waitStatus < 0 两部分组成。
     * h.waitStatus < 0 时，waitStatus = SIGNAL 或 PROPAGATE。这里仅依赖条件 propagate > 0 判断是否唤醒后继节点是不充分的
     */
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        /**
         * 节点 s 如果是共享类型节点，则应该唤醒该节点
         * 至于 s == null 的情况前面分析过，这里不在赘述。
         */ 
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
```

```java
/**
 * 该方法用于在 acquires/releases 存在竞争的情况下，确保唤醒动作向后传播。
 */ 
private void doReleaseShared() {
    /**
     * 下面的循环在 head 节点存在后继节点的情况下，做了两件事情：
     * 1. 如果 head 节点等待状态为 SIGNAL，则将 head 节点状态设为 0，并唤醒后继节点
     * 2. 如果 head 节点等待状态为 0，则将 head 节点状态设为 PROPAGATE，保证唤醒能够正常传播下去。
     */
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h);
            }
            /** 
             * ws = 0 的情况下，这里要尝试将状态从 0 设为 PROPAGATE，保证唤醒向后传播
             * setHeadAndPropagate 在读到 h.waitStatus < 0 时，可以继续唤醒后面的节点
             */
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
```

###### 释放共享状态

释放共享状态的主要逻辑在 `doReleaseShared` 中，上节已经分析过，这里就不赘述了。

值得一提的是，共享节点线程在获取同步状态和释放同步状态时都会调用 `doReleaseShared`，所以 `doReleaseShared` 是多线程竞争集中的地方。

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
```

### `Lock` 与 `Condition`

`Lock` 是 JDK 提供的锁的抽象，它就类似于 `synchronized`，也就是管程；而 `Condition` 解决协调线程同步问题，就相当于 `wait/notify/notifyAll` 的机制。

**有了 `synchronized`，为什么还需要 `Lock` 和 `Condition`？**

原因有以下几点：

1. `synchronized` 早期性能很差，远低于 `Lock`
2. `synchronized` 无法通过破坏不可抢占条件来避免死锁。当 `synchronized` 获取不到锁时，线程直接进入阻塞，此时该线程什么也做不了，也无法释放已经持有的资源，其他线程有可能需要这些资源，导致死锁。

与内置锁 `synchronized` 不同的是，**`Lock` 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作**，所有获取锁、释放锁的操作都是显式的操作。

- **能够响应中断**。`synchronized` 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。

  但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。

- **支持超时**。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。

- **非阻塞地获取锁**。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。

#### `Lock`

`Lock` 接口的定义如下：

```java
public interface Lock {
    void lock();
    void lockInterruptibly();
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit);
    void unlock();
    Condition newCondition();
}
```

- `lock()`：获取锁，失败则阻塞。

- `unlock()`：释放锁。

- `tryLock()`：尝试获取锁，仅当锁未被另一个线程持有的情况下，才获取该锁，失败后直接返回 false，而不是阻塞。

- `tryLock(long time, TimeUnit unit)`：和 `tryLock()` 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。

- `lockInterruptibly()`：锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。

  和 `lock` 类似，它在没有获取到锁时会阻塞，但是可以被中断，而不是一直自旋。

- `newCondition()`：返回一个绑定到 `Lock` 对象上的 `Condition` 实例。

#### `Condition`

**`Condition` 实现了管程模型里面的条件变量**。

和锁不同，条件变量是线程间通信的基础，主要用于实现等待\唤醒机制。

Java 1.5 之前，主要是利用 `Object` 类中的 `wait`、`notify`、`notifyAll` 配合 `synchronized` 来进行线程间通信。但是 `wait`、`notify`、`notifyAll` 需要配合 `synchronized` 使用，不适用于 `Lock`。

而对于使用 `Lock` 的线程，彼此间通信应该使用 `Condition`。

`Condition` 接口定义如下：

```java
public interface Condition {
    void await();
    void awaitUninterruptibly();
    long awaitNanos(long nanosTimeout);
    boolean await(long time, TimeUnit unit);
    boolean awaitUntil(Date deadline);
    void signal();
    void signalAll();
}
```

其中，`await`、`signal`、`signalAll` 与 `wait`、`notify`、`notifyAll` 相对应，功能也相似。除此以外，`Condition` 相比内置条件队列（ `wait`、`notify`、`notifyAll` ），提供了更为丰富的功能：

- 每个锁（`Lock`）上可以存在多个 `Condition`，每个 `Condition` 有自己的条件队列，这意味着锁的状态条件可以有多个，`await`、`signal`、`signalAll` 时也更有针对性。
- 支持公平的或非公平的队列操作。
- 支持不可中断的条件等待，相关方法：`awaitUninterruptibly()` 。
- 支持可定时的等待，相关方法：`awaitNanos(long)` 、`await(long, TimeUnit)`、`awaitUntil(Date)`。

#### 应用

下面是使用 `Lock` 以及 `Condition` 实现的生产者\消费者模式：

```java
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ProducerAndConsumer2 {
    private static final int QUEUE_SIZE = 10;
    private static Queue<Integer> queue = new ArrayDeque<>();
    private static Lock lock = new ReentrantLock();
    private static Condition produceCond = lock.newCondition();
    private static Condition consumeCond = lock.newCondition();

    public static void main(String[] args) {
        new Producer("生产者A").start();
        new Producer("生产者B").start();
        new Consumer("消费者A").start();
        new Consumer("消费者B").start();
    }

    static class Consumer extends Thread {
        public Consumer(String name) {
            super(name);
        }

        @Override
        public void run() {
            while (true) {
                lock.lock();
                while (queue.size() == 0) {
                    try {
                        System.out.println("队列空，等待数据");
                        produceCond.signalAll();
                        consumeCond.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        produceCond.signalAll();
                    }
                }
                queue.poll();
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + " 从队列取走一个元素，队列当前有：" + queue.size() + "个元素");
                lock.unlock();
            }
        }
    }

    static class Producer extends Thread {
        public Producer(String name) {
            super(name);
        }

        @Override
        public void run() {
            produce();
        }

        public void produce() {
            while (true) {
                lock.lock();
                while (queue.size() == QUEUE_SIZE) {
                    try {
                        System.out.println("队列满，等待有空余空间");
                        consumeCond.signalAll();
                        produceCond.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        consumeCond.signalAll();
                    }
                }
                queue.offer(1);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + " 向队列中插入一个元素，队列当前有：" + queue.size() + "个元素");
                lock.unlock();
            }
        }
    }
}
```

### `ReentrantLock`

`ReentrantLock` 类是 `Lock` 接口的具体实现，与内置锁 `synchronized` 相同的是，它是一个**可重入锁**。

相比于 `Lock`，`ReentrantLock` 提供了更多的方法：

| 方法                                          | 作用                                             |
| --------------------------------------------- | ------------------------------------------------ |
| `ReentrantLock(boolean fair)`                 | 根据传入参数构造一个公平锁或非公平锁。           |
| `int getHoldCount()`                          | 获取当前线程持有该锁的次数。                     |
| `boolean isHeldByCurrentThread()`             | 查询当前线程是否持有该锁。                       |
| `boolean isLocked()`                          | 查询该锁是否被持有。                             |
| `boolean isFair()`                            | 查询该锁是否为公平锁。                           |
| `boolean hasQueuedThreads()`                  | 查询是否有线程正在等待此锁。                     |
| `boolean hasQueuedThread(Thread thread)`      | 查询给定线程是否在等待此锁。                     |
| `int getQueueLength()`                        | 返回等待获取此锁的线程数的估计值。               |
| `boolean hasWaiters(Condition condition)`     | 查询是否有任何线程正在等待与此锁关联的给定条件。 |
| `int getWaitQueueLength(Condition condition)` | 返回等待与此锁关联的给定条件的线程数的估计值。   |

#### 原理

阅读 `ReentrantLock` 的源码，可以发现它有一个核心字段：

```java
private final Sync sync;
```

`sync` 是 `ReentrantLock` 的内部抽象类 `ReentrantLock.Sync` 对象，`Sync` 继承自 AQS。它有两个子类：

- `ReentrantLock.FairSync`：公平锁。
- `ReentrantLock.NonfairSync`：非公平锁。

查看源码可以发现，`ReentrantLock` 实现 `Lock` 接口其实是调用 `ReentrantLock.FairSync` 或 `ReentrantLock.NonfairSync` 中各自的实现，这里不一一列举。

它内部还有一个 `volatile` 字段 state，用于表示同步状态。

AQS 的原理我们之后会详细讲述，这里我们看一下公平锁和非公平锁的实现：

首先是非公平锁：

```java
static final class NonfairSync extends Sync {
    final void lock() {
        // 和公平锁相比，这里会直接先进行一次 CAS，成功就返回了
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }
    // AbstractQueuedSynchronizer.acquire(int arg)
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
/**
 * Performs non-fair tryLock.  tryAcquire is implemented in
 * subclasses, but both need nonfair try for trylock method.
 */
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 这里没有对阻塞队列进行判断
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

然后是公平锁：

```java
static final class FairSync extends Sync {
    final void lock() {
        acquire(1);
    }
    
    // AbstractQueuedSynchronizer.acquire(int arg)
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            // 和非公平锁相比，这里多了一个判断：是否有线程在等待
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}
```

公平锁和非公平锁只有两处不同：

1. 非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。
2. 非公平锁在 CAS 失败后，和公平锁一样都会进入到 `tryAcquire` 方法，在 `tryAcquire` 方法中，**如果发现锁这个时候被释放了，非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁**，乖乖排到后面。

如果非公平锁两次 CAS 都失败了，那么就和公平锁没有区别了。

### `ReentrantReadWriteLock`

`ReadWriteLock` 接口表示读写锁，内部有两个方法，分别返回一个读锁和一个写锁，接口定义如下：

```java
public interface ReadWriteLock {
    Lock readLock();

    Lock writeLock();
}
```

`ReadWriteLock` 和 `Lock` 并非继承关系，而是一种依赖关系。

`ReentrantReadWriteLock` 类是 `ReadWriteLock` 接口的具体实现，它是一个可重入的读写锁，它内部有一个 `ReadLock` 类和一个 `WriteLock` 类，都继承自 `Lock`。

所有的读写锁都遵守以下三条基本原则：

- 允许多个线程同时读共享变量，此时其他线程只可读该共享变量，而不可写
- 只允许一个线程写共享变量，此时其他线程不允许对该变量做任何操作

读写锁与互斥锁的一个重要区别就是**读写锁允许多个线程同时读共享变量**，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但**读写锁的写操作是互斥的**，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。

`ReentrantReadWriteLock` 的特性如下：

- **`ReentrantReadWriteLock` 适用于读多写少的场景**。

  如果是写多读少的场景，由于 `ReentrantReadWriteLock` 其内部实现比 `ReentrantLock` 复杂，性能可能反而要差一些。

- `ReentrantReadWriteLock` 实现了 `ReadWriteLock` 接口，支持了 `ReentrantLock` 所不具备的读写锁分离。

`ReentrantReadWriteLock` 提供了类似于 `ReentrantReadWriteLock`：

| 方法                                          | 作用                                                     |
| --------------------------------------------- | -------------------------------------------------------- |
| `ReentrantReadWriteLock(boolean fair)`        | 根据传入的参数决定构造一个非公平的读写锁还是公平的读写锁 |
| `boolean isFair()`                            | 查询该锁是否为公平锁。                                   |
| `int getReadLockCount()`                      | 查询该锁持有的读锁数量。                                 |
| `boolean isWriteLocked()`                     | 查询写锁是否被任何线程持有。                             |
| `boolean isWriteLockedByCurrentThread()`      | 查询当前线程是否持有写锁。                               |
| `int getWriteHoldCount()`                     | 查询当前线程对写锁的持有次数。                           |
| `int getReadHoldCount()`                      | 查询当前线程对读锁的持有次数。                           |
| `boolean hasQueuedThreads()`                  | 查询是否有线程正在等待获取读锁或写锁。                   |
| `boolean hasQueuedThread(Thread thread)`      | 查询给定线程是否正在等待获取读锁或写锁。                 |
| `int getQueueLength()`                        | 返回等待获取读取或写入锁的线程数的估计值。               |
| `boolean hasWaiters(Condition condition)`     | 查询是否有任何线程正在等待与写锁相关的给定条件。         |
| `int getWaitQueueLength(Condition condition)` | 返回等待与写锁相关的给定条件的线程数的估计值。           |

使用实例：

```java
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * 简单的无界缓存实现
 * <p>
 * 使用 WeakHashMap 存储键值对。WeakHashMap 中存储的对象是弱引用，JVM GC 时会自动清除没有被引用的弱引用对象。
 * </p>
 */
public class UnboundedCache<K, V> {
    private final Map<K, V> cacheMap = new WeakHashMap<>();

    private final ReadWriteLock cacheLock = new ReentrantReadWriteLock();

    public V get(K key) {
        cacheLock.readLock().lock();
        V value;
        try {
            value = cacheMap.get(key);
            String log = String.format("%s 读数据 %s:%s", Thread.currentThread().getName(), key, value);
            System.out.println(log);
        } finally {
            cacheLock.readLock().unlock();
        }
        return value;
    }

    public V put(K key, V value) {
        cacheLock.writeLock().lock();
        try {
            cacheMap.put(key, value);
            String log = String.format("%s 写入数据 %s:%s", Thread.currentThread().getName(), key, value);
            System.out.println(log);
        } finally {
            cacheLock.writeLock().unlock();
        }
        return value;
    }

    public V remove(K key) {
        cacheLock.writeLock().lock();
        try {
            return cacheMap.remove(key);
        } finally {
            cacheLock.writeLock().unlock();
        }
    }

    public void clear() {
        cacheLock.writeLock().lock();
        try {
            this.cacheMap.clear();
        } finally {
            cacheLock.writeLock().unlock();
        }
    }
}
```

#### 原理

阅读 ReentrantReadWriteLock 的源码，可以发现它有三个核心字段：

```java
private final ReentrantReadWriteLock.ReadLock readerLock;
private final ReentrantReadWriteLock.WriteLock writerLock;
final Sync sync;

public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
```

- `sync`：内部类 `ReentrantReadWriteLock.Sync` 对象。与 `ReentrantLock` 类似，它有两个子类：`ReentrantReadWriteLock.FairSync` 和 `ReentrantReadWriteLock.NonfairSync` ，分别表示公平锁和非公平锁的实现。
- `readerLock`：内部类 `ReentrantReadWriteLock.ReadLock` 对象，这是一把读锁。
- `writerLock`：内部类 `ReentrantReadWriteLock.WriteLock` 对象，这是一把写锁。

读锁和写锁的加锁和解锁代码如下：

```java
public static class ReadLock implements Lock, java.io.Serializable {
    // 调用 AQS 获取共享锁方法
    public void lock() {
        sync.acquireShared(1);
    }

    // 调用 AQS 释放共享锁方法
    public void unlock() {
        sync.releaseShared(1);
    }
}

public static class WriteLock implements Lock, java.io.Serializable {

    // 调用 AQS 获取独占锁方法
    public void lock() {
        sync.acquire(1);
    }

    // 调用 AQS 释放独占锁方法
    public void unlock() {
        sync.release(1);
    }
}
```

从这里可以看出：写锁是一个独占锁，而读锁是一个共享锁。

其他代码也都基本上是调用 AQS，这里就不详细说明了。

### `StampedLock`

`StampedLock` 在 JDK 1.8 时引入，是对读写锁 `ReentrantReadWriteLock` 的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，更细粒度控制并发。

**`StampedLock` 虽然没有像其他锁一样通过拓展 AQS 来实现，但是它内部的核心机制仍然是通过 CLH 维护等待线程。**

`ReadWriteLock` 支持两种模式：一种是读锁，一种是写锁；而 `StampedLock` 支持三种模式，分别是：**写锁**、**悲观读锁**和**乐观读**。

> 注意，这里用的是“乐观读”这个词，而不是“乐观读锁”，是要提醒你，**乐观读这个操作是无锁的**，所以相比较 `ReadWriteLock` 的读锁，乐观读的性能更好一些。

其中，写锁、悲观读锁的语义和 `ReadWriteLock` 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。

`StampedLock` 的性能之所以比 `ReadWriteLock` 还要好，其关键是 **`StampedLock` 支持乐观读**的方式。

`ReadWriteLock` 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 `StampedLock` 提供的乐观读，是**允许一个线程获取写锁**的，也就是说不是所有的写操作都被阻塞。

对于读多写少的场景 `StampedLock` 性能很好，简单的应用场景基本上可以替代 `ReadWriteLock`，但是**`StampedLock` 的功能仅仅是 `ReadWriteLock` 的子集**，在使用的时候，还是有几个地方需要注意一下：

- **`StampedLock` 不是可重入锁**
- `StampedLock` 的悲观读锁、写锁都不支持条件变量。
- 如果线程阻塞在 `StampedLock` 的 `readLock()` 或者 `writeLock()` 上时，此时调用该阻塞线程的 `interrupt()` 方法，会导致 CPU 飙升。**使用 `StampedLock` 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 `readLockInterruptibly()` 和写锁 `writeLockInterruptibly()`**。

> **乐观读**
>
> 乐观读通常是如何实现的呢？
>
> 答案是使用版本号，当修改变量时，会将版本号进行 + 1，读取时会验证版本号，以此来发现数据是否被更改。这常见于数据库的并发事务管理。

#### 应用

下面是该类提供的方法：

| 方法                                          | 作用                                               |
| --------------------------------------------- | -------------------------------------------------- |
| `long writeLock()`                            | 获取写锁                                           |
| `long tryWriteLock()`                         | 尝试获取写锁                                       |
| `long tryWriteLock(long time, TimeUnit unit)` | 在指定时间内尝试获取写锁，超过这段时间则失败       |
| `long writeLockInterruptibly()`               | 可中断的获取写锁                                   |
| `long readLock()`                             | 获取读锁                                           |
| `long tryReadLock()`                          | 尝试获取读锁                                       |
| `long tryReadLock(long time, TimeUnit unit)`  | 在指定时间内尝试获取读锁，超过这段时间则失败       |
| `long readLockInterruptibly()`                | 可中断的获取读锁                                   |
| `long tryOptimisticRead()`                    | 尝试乐观读                                         |
| `boolean validate(long stamp)`                | 如果自给定 stamp 发行以来尚未获取写锁，则返回 true |
| `void unlockWrite(long stamp)`                | 释放写锁                                           |
| `void unlockRead(long stamp)`                 | 释放读锁                                           |
| `void unlock(long stamp)`                     | 根据传入 stamp 自行判断释放锁                      |
| `long tryConvertToWriteLock(long stamp)`      | 尝试升级为写锁                                     |
| `long tryConvertToReadLock(long stamp)`       | 尝试升级为读锁                                     |
| `long tryConvertToOptimisticRead(long stamp)` | 尝试升级为乐观读                                   |
| `boolean tryUnlockWrite()`                    | 尝试释放写锁，不需要 stamp                         |
| `boolean tryUnlockRead()`                     | 尝试释放读锁，不需要 stamp                         |
| `boolean isWriteLocked()`                     | 判断是否已有线程持有写锁                           |
| `boolean isReadLocked()`                      | 判断是否已有线程持有读锁                           |
| `int getReadLockCount()`                      | 获取持有读锁的线程数量                             |
| `Lock asReadLock()`                           | 返回此 `StampedLock` 的普通 `ReadLock` 视图        |
| `Lock asWriteLock()`                          | 返回此 `StampedLock` 的普通 `WriteLock` 视图       |
| `ReadWriteLock asReadWriteLock()`             | 返回此 `StampedLock` 的普通 `ReadWriteLock` 视图   |

注意，这里获取的锁并不是一个类，而是一个长整型值作为锁，而释放时也需要对应的值来解锁，这个值被称作 stamp。

`StampdLock` 还可以作为 `ReadLock`、`WriteLock` 以及 `ReadWriteLock`，这是因为它内部有三个实现类，实现的是 `Lock` 以及 `ReadWriteLock` 的视图。

下面演示一下利用 `StampedLock` 进行读取：

```java
final StampedLock sl = new StampedLock();

// 乐观读
long stamp = sl.tryOptimisticRead();

/// ......

// 校验 stamp
if (!sl.validate(stamp)){
    // 如果失败，则升级为悲观读锁
    stamp = sl.readLock();
    try {
        // .....
    } finally {
        // 释放悲观读锁
        sl.unlockRead(stamp);
    }
}

// ...
```

下面是一个写入的示例：

```java
long stamp = sl.writeLock();
try {
    // ...
} finally {
    sl.unlockWrite(stamp);
}
```

## 原子类

在之前的学习中，我们已经见识到了 Java 提供的更高级的锁，这是相对于 `synchronized` 系列机制来说的，而对于 `volatile`，Java 也提供了它的升级版，就是原子类。

原子类比锁的粒度更细致，也更为轻量级，原子类将临界区缩小到了单个变量上。原子类提供的操作都是原子的，使用原子类就像正常使用变量一样。

原子类可以分为 4 组：

- 基本类型
  - `AtomicBoolean`：布尔类型原子类
  - `AtomicInteger`：整型原子类
  - `AtomicLong`：长整型原子类
- 引用类型
  - `AtomicReference`：引用类型原子类
  - `AtomicMarkableReference`：带有标记位的引用类型原子类
  - `AtomicStampedReference`：带有版本号的引用类型原子类
- 数组类型
  - `AtomicIntegerArray`：整形数组原子类
  - `AtomicLongArray`：长整型数组原子类
  - `AtomicReferenceArray`：引用类型数组原子类
- 属性更新器类型
  - `AtomicIntegerFieldUpdater`：整型字段的原子更新器。
  - `AtomicLongFieldUpdater`：长整型字段的原子更新器。
  - `AtomicReferenceFieldUpdater`：原子更新引用类型里的字段。

### 基本类型的原子类

`AtomicBoolean`、`AtomicInteger` 以及 `AtomicLong` 提供了基本类型的原子类。

虽然 Java 只提供了 `AtomicBoolean` 、`AtomicInteger`、`AtomicLong`，但是可以模拟其他基本类型的原子变量。要想模拟其他基本类型的原子变量，可以将 `short` 或 `byte` 等类型与 `int` 类型进行转换，以及使用 `Float.floatToIntBits` 、`Double.doubleToLongBits` 来转换浮点数。

由于 `AtomicBoolean`、`AtomicInteger`、`AtomicLong` 实现方式、使用方式都相近，所以本节仅针对 `AtomicInteger` 进行介绍。

#### 应用

下表列出了原子整型提供的方法：

| 方法                                            | 作用                              |
| ----------------------------------------------- | --------------------------------- |
| `AtomicInteger(int initialValue)`               | 以给定值初始化一个原子整型        |
| `AtomicInteger()`                               | 以 0 作为初始值初始化一个原子整型 |
| `int get()`                                     | 获取值                            |
| `void set(int newValue)`                        | 设置值                            |
| `void lazySet(int newValue)`                    | 延迟设置值                        |
| `int getAndSet(int newValue)`                   | 获取并设置值                      |
| `boolean compareAndSet(int expect, int update)` | 比较并交换值                      |
| `int getAndIncrement()`                         | 先获取值，再自增 1                |
| `int getAndDecrement()`                         | 先获取值，再自减 1                |
| `int getAndAdd(int delta)`                      | 先获取值，再自增给定的值          |
| `int incrementAndGet()`                         | 先自增 1，再返回                  |
| `int decrementAndGet()`                         | 先自减 1，再返回                  |
| `int addAndGet(int delta)`                      | 先自增给定的值，再返回            |
| `int intValue()`                                | 等价于 get                        |
| `long longValue()`                              | 拓展为 long 型后返回              |
| `float floatValue()`                            | 转换为 float 型后返回             |
| `double doubleValue()`                          | 转换为 double 型后返回            |

所有原子类都会提供 `get`、`set`、`lazySet`、`compareAndSet` 这四个基本操作，今后就不再列举出其他原子类的方法。

下面是一个简单的示例：

```java
public class AtomicIntegerDemo {

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        AtomicInteger count = new AtomicInteger(0);
        for (int i = 0; i < 1000; i++) {
            executorService.submit((Runnable) () -> {
                System.out.println(Thread.currentThread().getName() + " count=" + count.get());
                count.incrementAndGet();
            });
        }

        executorService.shutdown();
        executorService.awaitTermination(30, TimeUnit.SECONDS);
        System.out.println("Final Count is : " + count.get());
    }
}
```

#### 原理

这部分源码是实现的关键：

```java
private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

static {
	try {
		valueOffset = unsafe.objectFieldOffset
			(AtomicInteger.class.getDeclaredField("value"));
	} catch (Exception ex) { throw new Error(ex); }
}

private volatile int value;
```

* 首先，我们见到了熟悉的 `Unsafe` 类，我们之前提到过，`Unsafe` 类提供了 CAS 支持，因此本质上原子类就是通过硬件 CAS 指令来完成的。
* 然后，`value` 用来保存值，是一个 `volatile` 的变量，保证了可见性。
* 最后是一个非常重要的 `valueOffset`，这是 `value` 字段在内存中相对于实例起始地址的偏移量，可以快速定位到 `value` 字段，是实现的关键。

其他操作都是基于 CAS 等硬件原语实现的，因此不再详细讲述了。

### 引用类型的原子类

`AtomicReference`、`AtomicMarkableReference` 以及 `AtomicStampedReference` 提供了对应用类型的原子类支持。

`AtomicStampedReference` 类在引用类型原子类中，彻底地解决了 ABA 问题，其它的 CAS 能力与另外两个类相近，所以最具代表性。因此，本节只针对 `AtomicStampedReference` 进行说明。

我们在之前已经使用过原子引用类来实现一个自旋锁，源码如下：

```java
// 自己实现的自旋锁，利用 CAS
class SpinLock {
    // 原子引用，默认初始化时内部没有持有任何引用
    // 它提供了 CAS 方法，第一个参数为期望值，第二个参数为新值
    private AtomicReference<Thread> atomicReference = new AtomicReference<>();

    public void lock() {
        Thread current = Thread.currentThread();

        // 当一个线程进入该方法时，就会利用 CAS 将这个原子引用设置为自己，返回 true
        // 另一个线程进入时，由于原子引用内部已经持有引用了，因此不会设置，从而返回 false，进而自旋
        while (!atomicReference.compareAndSet(null, current)) {}
    }

    public void unlock() {
        Thread current = Thread.currentThread();
        // 解锁则是将原子引用重新设置为 null
        atomicReference.compareAndSet(current, null);
    }
}
```

原子类是基于 CAS 的，CAS 存在 ABA 问题，为了解决 ABA 问题，才有了 `AtomicMarkableReference` 和 `AtomicStampedReference`。

`AtomicMarkableReference` 使用一个布尔值作为标记，修改时在 true / false 之间切换。这种策略不能根本上解决 ABA 问题，但是可以降低 ABA 发生的几率。常用于缓存或者状态描述这样的场景。

而 **`AtomicStampedReference` 使用一个整型值做为版本号，每次更新前先比较版本号，如果一致，才进行修改**。通过这种策略，可以根本上解决 ABA 问题。

### 数组类型的原子类

`AtomicIntegerArray`、`AtomicLongArray` 以及 `AtomicReferenceArray` 对数组类型提供了原子类的支持。

已经有了针对基本类型和引用类型的原子类，为什么还要提供针对数组的原子类呢？

这是因为数组类型的原子类为**数组元素** 提供了 `volatile` 类型的访问语义，这是普通数组所不具备的特性，**`volatile` 类型的数组仅在数组引用上具有 `volatile` 语义**。

和其他引用不太一样的是，原子数组需要一个长度或者一个数组来初始化，并且转换为原子类后数组长度也是不能更改的。

下面是一个简单的示例：

```java
public class AtomicIntegerArrayDemo {

    private static AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(10);

    public static void main(final String[] arguments) throws InterruptedException {

        System.out.println("Init Values: ");
        for (int i = 0; i < atomicIntegerArray.length(); i++) {
            atomicIntegerArray.set(i, i);
            System.out.print(atomicIntegerArray.get(i) + " ");
        }
        System.out.println();

        Thread t1 = new Thread(new Increment());
        Thread t2 = new Thread(new Compare());
        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final Values: ");
        for (int i = 0; i < atomicIntegerArray.length(); i++) {
            System.out.print(atomicIntegerArray.get(i) + " ");
        }
        System.out.println();
    }

    static class Increment implements Runnable {

        @Override
        public void run() {

            for (int i = 0; i < atomicIntegerArray.length(); i++) {
                int value = atomicIntegerArray.incrementAndGet(i);
                System.out.println(Thread.currentThread().getName() + ", index = " + i + ", value = " + value);
            }
        }

    }

    static class Compare implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < atomicIntegerArray.length(); i++) {
                boolean swapped = atomicIntegerArray.compareAndSet(i, 2, 3);
                if (swapped) {
                    System.out.println(Thread.currentThread().getName() + " swapped, index = " + i + ", value = 3");
                }
            }
        }
    }
}
```

### 属性更新器

属性更新器支持基于反射机制的更新字段值的原子操作。

Java 提供了 `AtomicIntegerFieldUpdater`、`AtomicLongFieldUpdater` 以及`AtomicReferenceFieldUpdater` 用于属性更新。

这些类的使用有一定限制：

- 因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 `newUpdater()` 创建一个更新器，并且需要设置想要更新的类和属性
- 字段必须是 `volatile` 类型的
- 不能作用于静态变量（`static`）
- 不能作用于常量（`final`）

示例：

```java
public class AtomicReferenceFieldUpdaterDemo {
    static User user = new User("begin");

    static AtomicReferenceFieldUpdater<User, String> updater =
        AtomicReferenceFieldUpdater.newUpdater(User.class, String.class, "name");

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 5; i++) {
            executorService.execute(new MyThread());
        }
        executorService.shutdown();
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            if (updater.compareAndSet(user, "begin", "end")) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + " 已修改 name = " + user.getName());
            } else {
                System.out.println(Thread.currentThread().getName() + " 已被其他线程修改");
            }
        }
    }

    static class User {
        volatile String name;

        public User(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        public User setName(String name) {
            this.name = name;
            return this;
        }
    }
}
```

### 累加器

除了上述原子类之外，Java 还提供了几个累加器：

* `DoubleAccumulator`，`double` 类型的聚合器，需要传入一个 `double` 类型的二元操作，可以用来计算各种聚合操作，包括加乘等。
* `DoubleAdder`，`DoubleAccumulator` 的特例，只能计算加法。
* `LongAccumulator`，`long` 类型的聚合器，需要传入一个 `long` 类型的二元操作，可以用来计算各种聚合操作，包括加乘等。
* `LongAdder`，`LongAccumulator` 的特例，只能计算加法。

这四个类仅仅用来执行累加操作，相比原子化的基本数据类型，速度更快，但是不支持 `compareAndSet()` 方法。如果你仅仅需要累加操作，使用原子化的累加器性能会更好，代价就是会消耗更多的内存空间。

原理简述如下：

`LongAdder` 内部由一个 `base` 变量和一个 `cell[]` 数组组成。

- 当只有一个写线程，没有竞争的情况下，`LongAdder` 会直接使用 `base` 变量作为原子操作变量，通过 CAS 操作修改变量；
- 当有多个写线程竞争的情况下，除了占用 `base` 变量的一个写线程之外，其它各个线程会将修改的变量写入到自己的槽 `cell[]` 数组中。

我们可以发现，`LongAdder` 在操作后的返回值只是一个近似准确的数值，但是 `LongAdder` 最终返回的是一个准确的数值， 所以在一些对实时性要求比较高的场景下，`LongAdder` 并不能取代 `AtomicInteger` 或 `AtomicLong`。

示例：

```java
public static void main(String[] args) throws IOException {
    LongAdder longAdder = new LongAdder();
    longAdder.increment();
    longAdder.add(666);
    System.out.println(longAdder.sum());

    LongAccumulator longAccumulator = new LongAccumulator((left, right) -> left + right * 2, 666);
    longAccumulator.accumulate(1);
    longAccumulator.accumulate(3);
    longAccumulator.accumulate(-4);
    System.out.println(longAccumulator.get());
}
```

## 并发容器

我们在上一章的容器中讲到容器有四大类：`List`、`Set`、`Queue` 以及 `Map`，在 JUC 中，提供了这些接口的并发版本，它们在高并发的场景下性能很高。

* `List`：`CopyOnWriteArrayList`
* `Set`：`CopyOnWriteArraySet`、`ConcurrentSkipListSet`
* `Queue`：`ConcurrentLinkedQueue`、`ConcurrentLinkedDeque`、`ArrayBlockingQueue`、`LinkedBlockingQueue`、`PriorityBlockingQueue`、`LinkedBlockingDeque`、`DelayQueue`、`SynchronousQueue`、`LinkedTransferQueue`
* `Map`：`ConcurrentHashMap`、`ConcurrentSkipListMap`

这些容器的命名大致有三类：

* `CopyOnWrite`：写时复制，这类容器应用了写时复制技术，其核心思想是，如果有多个调用者同时请求相同资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。

* `Blocking`：阻塞，这类容器内部一般使用锁，提供阻塞的能力。

* `Concurrent`：这类型的锁竞争相对于 `CopyOnWrite` 要高一些，但写操作代价要小一些。

  此外，`Concurrent` 往往提供了较低的遍历一致性，即：**当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历**。

  代价就是，在获取容器大小 `size()` ，容器是否为空等方法，不一定完全精确，但这是为了获取并发吞吐量的设计取舍，可以理解。与之相比，如果是使用同步容器，就会出现 `fail-fast` 问题，即：检测到容器在遍历过程中发生了修改，则抛出 `ConcurrentModificationException`，不再继续遍历。

### 同步容器

在 Java 中，同步容器主要包括以下几个：

- `Vector`：`Vector` 实现了 `List` 接口。`Vector` 实际上就是一个数组，和 `ArrayList` 类似。但是 `Vector` 中的方法都是 `synchronized` 方法，即进行了同步措施。
- `Stack`：`Stack` 也是一个同步容器，它的方法也用 `synchronized` 进行了同步，它实际上是继承于 `Vector` 类。
- `Hashtable`：`Hashtable` 实现了 `Map` 接口，它和 `HashMap` 很相似，但是 `Hashtable` 进行了同步处理，而 `HashMap` 没有。

- `Collections` 类中提供的静态工厂方法创建的类（由 `Collections.synchronizedXXX` 等方法）

**同步容器的同步原理就是在其 `get`、`set`、`size` 等主要方法上用 `synchronized` 修饰**。而 `synchronized` 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 `synchronized` 的容器性能要差很多。

而且，**同步容器未必安全**，在做复合操作（非原子操作）时，仍然需要加锁来保护，常见复合操作如下：

- **迭代**：反复访问元素，直到遍历完全部元素
- **跳转**：根据指定顺序寻找当前元素的下一个（下 n 个）元素
- **条件运算**：例如若没有则添加等

下面就是一个不安全的示例：

```java
public class VectorDemo {
    static Vector<Integer> vector = new Vector<>();

    public static void main(String[] args) {
        while (true) {
            vector.clear();

            for (int i = 0; i < 10; i++) {
                vector.add(i);
            }

            Thread thread1 = new Thread() {
                @Override
                public void run() {
                    for (int i = 0; i < vector.size(); i++) {
                        vector.remove(i);
                    }
                }
            };

            Thread thread2 = new Thread() {
                @Override
                public void run() {
                    for (int i = 0; i < vector.size(); i++) {
                        vector.get(i);
                    }
                }
            };

            thread1.start();
            thread2.start();

            while (Thread.activeCount() > 10) {
                System.out.println("同时存在 10 个以上线程，退出");
                return;
            }
        }
    }
}
```

问题出在哪呢？是因为仅仅 `Vector` 的方法是安全的，但是它外部的操作代码依然不是线程安全的。

比如：

当某个线程在某个时刻执行这句时：

```java
for (int i = 0; i < vector.size(); i++) {
    vector.get(i);
}
```

假若此时 `Vector` 的 `size` 方法返回的是 10，i 的值为 9

然后另外一个线程执行了这句：

```java
for(int i = 0; i < vector.size(); i++) {
    vector.remove(i);
}
```

将下标为 9 的元素删除了。

那么通过 `get` 方法访问下标为 9 的元素肯定就会出问题了。

除此之外，在对 `Vector` 等容器并发地进行迭代修改时，会报 `ConcurrentModificationException` 异常，关于这个异常将会在后续文章中讲述，现在之需要知道的是在并发容器中不会出现这个问题。

### 并发 `Map`

Map 接口的两个并发实现是 `ConcurrentHashMap` 和 `ConcurrentSkipListMap`，它们从应用的角度来看，主要区别在于 **`ConcurrentHashMap` 的 key 是无序的，而 `ConcurrentSkipListMap` 的 key 是有序的**，就类似于 `HashMap` 和 `TreeMap`。

#### `ConcurrentHashMap`

`ConcurrentHashMap` 是线程安全的 `HashMap` ，用于替代 `Hashtable`。

`ConcurrentHashMap` 实现了 `ConcurrentMap` 接口，而 `ConcurrentMap` 接口扩展了 `Map` 接口。

```java
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentMap<K,V>, Serializable {
    // ...
}
```

`ConcurrentHashMap` 的实现包含了 `HashMap` 所有的基本特性，如：数据结构、读写策略等。

`ConcurrentHashMap` 没有实现对 `Map` 加锁以提供独占访问。因此无法通过在客户端加锁的方式来创建新的原子操作。但是，一些常见的复合操作，如：“若没有则添加”、“若相等则移除”、“若相等则替换”，都已经实现为原子操作，并且是围绕 `ConcurrentMap` 的扩展接口而实现。

我们看一下 `ConcurrentMap` 的定义：

```java
public interface ConcurrentMap<K, V> extends Map<K, V> {
    // 仅当 K 没有相应的映射值才插入
    V putIfAbsent(K key, V value);

    // 仅当 K 被映射到 V 时才移除
    boolean remove(Object key, Object value);

    // 仅当 K 被映射到 oldValue 时才替换为 newValue
    boolean replace(K key, V oldValue, V newValue);

    // 仅当 K 被映射到某个值时才替换为 newValue
    V replace(K key, V value);
}
```

不同于 `Hashtable`，`ConcurrentHashMap` 提供的迭代器不会抛出 `ConcurrentModificationException`，因此不需要在迭代过程中对容器加锁。

> **注意**
>
> 一些需要对整个 `Map` 进行计算的方法，如 `size` 和 `isEmpty` ，由于返回的结果在计算时可能已经过期，所以**并非实时的精确值**。这是一种策略上的权衡，在并发环境下，这类方法由于总在不断变化，所以获取其实时精确值的意义不大。`ConcurrentHashMap` 弱化这类方法，以换取更重要操作（如：`get`、`put`、`containesKey`、`remove` 等）的性能。

##### 应用

下面是一个简单的示例：

```java
public class ConcurrentHashMapDemo {
    public static void main(String[] args) throws InterruptedException {
        // HashMap 在并发迭代访问时会抛出 ConcurrentModificationException 异常
        // Map<Integer, Character> map = new HashMap<>();
        Map<Integer, Character> map = new ConcurrentHashMap<>();

        Thread wthread = new Thread(() -> {
            System.out.println("写操作线程开始执行");
            for (int i = 0; i < 26; i++) {
                map.put(i, (char) ('a' + i));
            }
        });
        Thread rthread = new Thread(() -> {
            System.out.println("读操作线程开始执行");
            for (Integer key : map.keySet()) {
                System.out.println(key + " - " + map.get(key));
            }
        });
        wthread.start();
        rthread.start();
        Thread.sleep(1000);
    }
}
```

##### Java 1.7 中的实现

`ConcurrentHashMap` 一直在演进，尤其在 Java 1.7 和 Java 1.8，其数据结构和并发机制有很大的差异。

- Java 1.7
  - 数据结构：**数组＋单链表**
  - 并发机制：采用分段锁机制细化锁粒度，降低阻塞，从而提高并发性。
- Java 1.8
  - 数据结构：**数组＋单链表＋红黑树**
  - 并发机制：取消分段锁，之后基于 CAS + `synchronized` 实现。

首先介绍一下 1.7 的实现，1.7 中采用了非常经典的分段锁思想，很值得学习。

分段锁是将内部进行分段（`Segment`），里面是 `HashEntry` 数组，和 `HashMap` 类似，哈希相同的条目也是以链表形式存放。 

`HashEntry` 内部使用 `volatile` 的 `value` 字段来保证可见性，也利用了不可变对象的机制，以改进利用 `Unsafe` 提供的底层能力。

###### 定义

源码如下：

```java
public class ConcurrentHashMap<K, V> extends AbstractMap<K, V>
    implements ConcurrentMap<K, V>, Serializable {
    // ...

    // 默认初始化容量，这个和 HashMap中的容量是一个概念，表示的是整个 Map的容量
    static final int DEFAULT_INITIAL_CAPACITY = 16;

    // 默认负载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    // 默认的并发级别，这个参数决定了 Segment 数组的长度
    static final int DEFAULT_CONCURRENCY_LEVEL = 16;

    // 最大的容量
    static final int MAXIMUM_CAPACITY = 1 << 30;

    // 每个 Segment 中 table 数组的最小长度为 2，且必须是 2 的 n 次幂，这个机制和 HashMap 是类似的
    static final int MIN_SEGMENT_TABLE_CAPACITY = 2;

    // 用于限制 Segment 数量的最大值，必须是 2 的 n 次幂
    static final int MAX_SEGMENTS = 1 << 16;

    // 在部分方法中，会优先采用乐观的方式不加锁，直到重试次数达到 2，才会对所有 Segment 加锁
    static final int RETRIES_BEFORE_LOCK = 2;

    // Segment 掩码值，用于根据元素的 Hash 值定位所在的 Segment 下标
    final int segmentMask;

    // 和 segmentMask 配合使用来定位 Segment 的数组下标，后边讲。
    final int segmentShift;

    // 分段锁的核心机制就是将整个 HashMap 分成几个小的 HashMap，每个 Segment 都是一个锁
    // 与 Hashtable 相比，并发粒度减小了，并发能力也就增加了
    final Segment<K,V>[] segments;

    // 本质上 Segment 类就是一个小的 HashMap，里面的 table 数组存储了各个节点的数据
    // 同时，因为继承了 ReentrantLock, 可以作为互斥锁使用，因此可以自己锁住自己，并发粒度也就是一个 Segment
    static final class Segment<K,V> extends ReentrantLock implements Serializable {
        // 在 scanAndLockForPut 方法中用到的一个参数，用于计算最大重试次数
        // 其实是根据当前可用的处理器的数量计算的，若大于 1，则返回 64，否则返回 1
        static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() > 1 ? 64 : 1;

        transient volatile HashEntry<K,V>[] table;

        // 当前 Segment 中的元素个数
        transient int count;

        // 当前 Segment 扩容的阈值，同 HashMap 计算方法一样也是容量乘以负载因子
        // 需要知道的是，每个 Segment 都是单独处理扩容的，互相之间不会产生影响
        transient int threshold;

        // 负载因子
        final float loadFactor;
        
        // ...
    }

    // 基本节点，存储 key， value 值
    static final class HashEntry<K,V> {
        final int hash;
        final K key;
        volatile V value;
        volatile HashEntry<K,V> next;
    }
}
```

整体结构如下图所示：

![image-20220306095605525](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220306095605525.png)

注意，`Segment` 的个数一旦**初始化就不能改变**，默认 `Segment` 的个数是 16 个，可以认为 `ConcurrentHashMap` 默认支持最多 16 个线程并发。但是，每个 `Segment` 内部的 `HashEntry` 的数目是可变的。

###### 构造函数

`ConcurrentHashMap` 的所有构造函数都基于这个构造函数：

```java
public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
    // 检验参数是否合法
    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    // 并发级别不能超过设置的最大值
    if (concurrencyLevel > MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    
    // 偏移量，是为了对 hash 值做位移操作，计算元素所在的 Segment 下标
    int sshift = 0;
    // 用于设定最终 Segment 数组的长度，必须是 2 的 n 次幂
    int ssize = 1;
    // 计算 ssize 和 sshift
    // 当 ssize < 并发级别时，需要移位的位数就 + 1
    while (ssize < concurrencyLevel) {
        ++sshift;
        ssize <<= 1;
    }
    // 得到偏移量，hash 值的前 sshift 位用于 Segment 定位，后 32 - sshift 位用于 HashEntry 在 Segment 中的定位
    this.segmentShift = 32 - sshift;
    // 掩码，就是 ssize - 1，也就是一个前面全 0 后面全 1 的数，和 HashMap 的机制是一样的
    this.segmentMask = ssize - 1;
    
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    
    // c 用于辅助计算 cap 的值
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
        ++c;
    // cap 用于确定单个 Segment 的容量
    int cap = MIN_SEGMENT_TABLE_CAPACITY;

    while (cap < c)
        cap <<= 1;
    
    // 创建一个Segment对象，保存到 S0 对象中。后边在 ensureSegment 方法会用到 S0 作为原型对象去创建对应的 Segment
    Segment<K,V> s0 =
        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
                         (HashEntry<K,V>[])new HashEntry[cap]);
    // 创建出长度为 ssize 的一个 Segment 数组
    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];
    // 把 S0 存到 Segment 数组中去。在这里，我们就可以发现，此时只是创建了一个 Segment 数组，但是并没有把数组中的每个 Segment 对象创建出来，仅仅创建了一个 Segment 用来作为原型对象
    UNSAFE.putOrderedObject(ss, SBASE, s0);
    this.segments = ss;
}    
```

总结流程：

1. 根据设置的并发等级和容量计算掩码和真实容量
2. 创建一个 `Segment` 数组，但是只创建一个 `Segment` 放入该数组中作为原型。

###### `put` 方法

在进行并发写操作时，`ConcurrentHashMap` 会获取 `Segment` 本身（也就是获取锁），以保证数据一致性。所以，在并发修改期间，相应 `Segment` 是被锁定的。

`put` 方法的总体流程是，

1. 通过哈希算法计算出当前 key 的 hash 值
2. 通过这个 hash 值找到它所对应的 `Segment` 数组的下标
3. 再通过 hash 值计算出它在对应 `Segment` 的 `HashEntry` 数组 的下标
4. 找到合适的位置插入元素

下面是 `put` 方法的源码：

```java
public V put(K key, V value) {
    Segment<K,V> s;
    // 不允许 null 的 value
    if (value == null)
        throw new NullPointerException();

    int hash = hash(key);
    
    // 上边我们计算出的 segmentShift 为28，因此 hash 值右移 28 位，说明此时用的是 hash 的高 4 位
    // 然后把它和掩码进行与运算，得到 Segmen 的定位
    int j = (hash >>> segmentShift) & segmentMask;
    // 获取或初始化一个 Segment
    if ((s = (Segment<K,V>) UNSAFE.getObject          
         (segments, (j << SSHIFT) + SBASE)) == null) 
        // 初始化 j 下标的 Segment
        s = ensureSegment(j);
    // 调用 Segment 的 put 方法
    return s.put(key, hash, value, false);
}
```

该方法首先定位到一个 `Segment`，然后调用了 `Segment` 的 `put` 方法，源码如下：

```java
final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry，同时上锁
    HashEntry<K,V> node = tryLock() ? null : scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry<K,V>[] tab = table;
        int index = (tab.length - 1) & hash;
        HashEntry<K,V> first = entryAt(tab, index);
        // 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。
        for (HashEntry<K,V> e = first;;) {
            if (e != null) {
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash && key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                // 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry<K,V>(hash, key, value, first);
                int c = count + 1;
                // 发现容量不够，执行扩容
                if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        // 释放锁
        unlock();
    }
    return oldValue;
}
```

在方法最开始时，它会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 `scanAndLockForPut()` 自旋获取锁，我们来看一下它是怎么实现的：

```java
private HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {
    HashEntry<K,V> first = entryForHash(this, hash);
    HashEntry<K,V> e = first;
    HashEntry<K,V> node = null;
    int retries = -1; // negative while locating node
    // 首先尝试自旋获取锁
    while (!tryLock()) {
        HashEntry<K,V> f; // to recheck first below
        if (retries < 0) {
            if (e == null) {
                if (node == null) // speculatively create node
                    node = new HashEntry<K,V>(hash, key, value, null);
                retries = 0;
            }
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        // 自旋达到指定次数后，阻塞获取锁
        else if (++retries > MAX_SCAN_RETRIES) {
            lock();
            break;
        }
        else if ((retries & 1) == 0 &&
                 (f = entryForHash(this, hash)) != first) {
            e = first = f; // re-traverse if entry changed
            retries = -1;
        }
    }
    return node;
}
```

这个方法做的操作就是不断的自旋 `tryLock()` 获取锁，当自旋次数大于指定次数时，则会使用 `lock()` 阻塞获取锁，因此不必担心会大量占用 CPU。

###### `get` 方法

`put` 方法搞明白了之后，其实 `get` 方法就很好理解了。也是先定位到 `Segment`，然后再定位到 `HashEntry`：

```java
public V get(Object key) {
    Segment<K,V> s; // manually integrate access methods to reduce overhead
    HashEntry<K,V>[] tab;
    // 计算 hash 值
    int h = hash(key);
    // 同样的先定位到 key 所在的 Segment ，然后从主内存中取出最新的节点
    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
        (tab = s.table) != null) {
        // 若 Segment 不为空，且链表也不为空，则遍历查找节点
        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
             (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            // 找到则返回它的 value 值，否则返回 null
            if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                return e.value;
        }
    }
    return null;
}
```

###### `size` 方法统计大小

并发情况下，有可能在统计期间，数组元素个数不停的变化，而且，整个表还被分成了 N个 Segment，怎样统计才能保证结果的准确性呢？

我们看一下 1.7 中是如何实现统计的：

```java
public int size() {
	// 获取 segments
    final Segment<K,V>[] segments = this.segments;
    // 统计所有 Segment 中元素的总个数
    int size;
    // 如果 size 大小超过 32 位，则标记为溢出为 true
    boolean overflow; 
    // 统计每个 Segment 中的 modCount 之和
    long sum;         
    // 上次记录的 sum 值
    long last = 0L;   
    // 重试次数，初始化为 -1
    int retries = -1; 
    try {
        for (;;) {
            // 如果超过重试次数，则不再重试，而是把所有 Segment 都加锁，再统计 size
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j < segments.length; ++j)
                    ensureSegment(j).lock();
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j < segments.length; ++j) {
                Segment<K,V> seg = segmentAt(segments, j);
                // 若当前遍历到的 Segment 不为空，则统计它的 modCount 和 count 元素个数
                if (seg != null) {
                    // 累加当前 Segment 的结构修改次数，如 put，remove 等操作都会影响 modCount
                    sum += seg.modCount;
                    int c = seg.count;
                    // 若当前 Segment 的元素个数 c 小于 0 或者 size 加上 c 的结果小于 0，则认为溢出，返回负数
                    if (c < 0 || (size += c) < 0)
                        overflow = true;
                }
            }
            // 当此次统计的 sum 值和上次统计的值相同，则说明这段时间内没有任何一个 Segment 的结构发生改变，就可以返回最后的统计结果
            if (sum == last)
                break;
            // 不相等，则说明有 Segment 结构发生了改变，则记录最新的结构变化次数之和 sum，并赋值给 last，用于下次重试的比较。
            last = sum;
        }
    } finally {
        // 如果超过了指定重试次数，则说明表中的所有 Segment 都被加锁了，因此需要把它们都解锁
        if (retries > RETRIES_BEFORE_LOCK) {
            for (int j = 0; j < segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    // 若结果溢出，则返回 int 最大值，否则正常返回 size 值 
    return overflow ? Integer.MAX_VALUE : size;
}
```

###### 扩容 `rehash` 方法

在 `put` 时，如果发现元素个数超过了阈值，则会扩容，也就是 `rehash` 方法，这一点和 `HashMap` 是一样的，我们重点看一下 `rehash` 的源码，看看多线程中的扩容是怎么样进行的：

```java
// node 参数为创建的新节点
private void rehash(HashEntry<K,V> node) {
    // 当前 Segment 中的旧表
    HashEntry<K,V>[] oldTable = table;
    // 旧的容量
    int oldCapacity = oldTable.length;
    // 新容量为旧容量的 2 倍
    int newCapacity = oldCapacity << 1;
    // 更新新的阈值
    threshold = (int)(newCapacity * loadFactor);
    // 用新的容量创建一个新的 HashEntry 数组
    HashEntry<K,V>[] newTable =
        (HashEntry<K,V>[]) new HashEntry[newCapacity];
    // 新掩码
    int sizeMask = newCapacity - 1;
    // 遍历旧表
    for (int i = 0; i < oldCapacity ; i++) {
        HashEntry<K,V> e = oldTable[i];
        // 如果 e 不为空，说明当前链表不为空
        if (e != null) {
            HashEntry<K,V> next = e.next;
            // 计算 hash 值在新数组中的下标位置
            int idx = e.hash & sizeMask;
            // 如果 e 不为空，且它的下一个节点为空，则说明这条链表只有一个节点，直接把这个节点放到新数组的对应下标位置即可
            if (next == null)   
                newTable[idx] = e;
            // 否则，处理当前链表的节点迁移操作
            else { 
                // 记录上一次遍历到的节点
                HashEntry<K,V> lastRun = e;
                // 对应上一次遍历到的节点在新数组中的新下标
                int lastIdx = idx;
                for (HashEntry<K,V> last = next;
                     last != null;
                     last = last.next) {
                    // 计算当前遍历到的节点的新下标
                    int k = last.hash & sizeMask;
                    // 若 k 不等于 lastIdx，则说明此次遍历到的节点和上次遍历到的节点不在同一个下标位置，需要把 lastRun 和 lastIdx 更新为当前遍历到的节点和下标值
                    // 若相同，则不处理，继续下一次 for 循环
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                // 把和 lastRun 节点的下标位置相同的链表最末尾的几个连续的节点放到新数组的对应下标位置
                newTable[lastIdx] = lastRun;
                // 再把剩余的节点，复制到新数组
                // 从旧数组的头结点开始遍历，直到 lastRun 节点，因为 lastRun 节点后边的节点都已经迁移完成了。
                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
                    V v = p.value;
                    int h = p.hash;
                    int k = h & sizeMask;
                    HashEntry<K,V> n = newTable[k];
                    // 用的是复制节点信息的方式，并不是把原来的节点直接迁移，区别于lastRun处理方式
                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);
                }
            }
        }
    }
    // 所有节点都迁移完成之后，再处理传进来的新的 node 节点，把它头插到对应的下标位置
    int nodeIndex = node.hash & sizeMask;
    // 头插 node 节点
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    // 更新当前 Segment 的 table 信息
    table = newTable;
}
```

这里用了一个批量复制的小技巧，使用 `lastRun` 和 `lastIdx` 记录 rehash 后一连串相同的节点的开头，然后直接把这个节点接过去，避免了大量节点的复制。

##### Java 1.8 中的实现

1.8 相比于 1.7 来说有了很大改进，具体来说：

- 数据结构改进：与 `HashMap` 一样，将原先**数组＋单链表**的数据结构，变更为**数组＋单链表＋红黑树**的结构。

  当出现哈希冲突时，数据会存入数组指定桶的单链表，当链表长度达到 8，则将其转换为红黑树结构，这样其查询的时间复杂度可以降低到 $$O(logN)$$，以改进性能。

- 并发机制改进：

  - 取消 `Segment`，直接采用 `volatile Node<K,V>[] table` 保存数据，**采用 table 数组元素作为锁，从而实现了对每一个桶数据进行加锁，进一步减少并发冲突的概率**。

  - **使用 CAS + `sychronized` 操作**，在特定场景进行无锁并发操作。部分情况下会使用 `Unsafe`、`LongAdder` 之类底层手段，进行极端情况的优化。

    现代 JDK 中，`synchronized` 已经被不断优化，可以不再过分担心性能差异，另外，**相比于 `ReentrantLock`，它可以减少内存消耗**，这是个非常大的优势。

由于1.8 的 `ConcurrentHashMap` 和 `HashMap` 结构和基本属性变量，还有初始化逻辑都差不多，只是多了一些并发情况需要用到的参数和内部类，因此，不再单独拎出来介绍，在方法中用到的时候再详细解释。

###### `put` 方法

1.8 中的 `put` 就比 1.7 中的要复杂的多，大致可以分为以下步骤：

1. 根据 key 计算出 hash 值。
2. 判断是否需要进行初始化。
3. 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。
4. 如果当前位置的 `hashcode == MOVED == -1`,则需要进行扩容。
5. 如果都不满足，则利用 `synchronized` 锁写入数据。
6. 如果数量大于 `TREEIFY_THRESHOLD` 则要转换为红黑树。

```java
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    // 计算 hash，spread 方法等价于 HashMap 中的 hash 方法
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        // 如果 table 为空，初始化，只有一个线程能够成功初始化 table
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        // 否则，根据 hash 值计算得到数组索引 i，如果 tab[i] 为空，直接新建节点 Node，然后尝试 CAS 替换即可，替换成功就可以直接跳出循环
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node<K,V>(hash, key, value, null)))
                break;                   
        }
        // hash 值为 MOVED，这并不是发生了冲突，而是当前数组正在由其他线程进行扩容，则需要当前线程帮忙迁移数据
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        // hash 冲突了，la'lian'fa
        else {
            V oldVal = null;
            // 针对首个节点进行加锁操作，而不是 1.7 中的 Segment，进一步减少线程冲突
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh >= 0) {
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            // 如果在链表中找到值为 key 的节点e，直接设置 e.val = value 即可。
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            // 如果没有找到值为 key 的节点，直接新建 Node 并加入链表即可。
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    // 如果首节点为 TreeBin 类型，说明为红黑树结构，执行 putTreeVal 操作。
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                // 如果节点数 >＝8，那么转换链表结构为红黑树结构。
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    // 计数增加1，有可能触发 transfer 操作（扩容）。
    addCount(1L, binCount);
    return null;
}
```

###### 初始化流程 `initTable`

我们首先看一下怎么初始化的：

```java
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        // 如果 sizeCtl < 0，说明已经有其他线程开始了初始化，当前线程不允许进入初始化，直接挂起
        if ((sc = sizeCtl) < 0)
            Thread.yield();
        // 如果 CAS 替换 sizeCtl 为 -1 成功，则进入初始化
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                // 重新检查，因为之前被阻塞的线程也要进入到这里，因此需要防止重复初始化
                if ((tab = table) == null || tab.length == 0) {
                    // 如果 sc 大于 0，则为 sc，否则返回默认容量 16
     				// 当调用有参构造创建 Map 时，sc 的值是大于 0 的
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings("unchecked")
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    // n 减去 1/4 n ，即为 0.75n ，即扩容阈值
                    sc = n - (n >>> 2);
                }
            } finally {
                // 更新 sizeCtl
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
```

###### 扩容机制

1.8 的扩容并没有所谓的 `rehash` 方法，而是 `transfer` 方法，并且，设计者为了加大并发，让其他线程也可以帮助 `transfer`，也就是所谓的 `helpTransfer`。

首先，要触发扩容机制，就只有在 `put` 结束后的 `addCount` 方法以及树化时 `treefiBin` 方法（size < 64 仅扩容，>= 64 树化，这一点和 `HashMap` 一样）时，才会触发该机制。

`addCount` 是给计数 + 1 的方法，但是这个方法十分的复杂，毕竟是在多线程中，想要在如此高并发度的情况下进行 count 计算也不是一件容易的事，我们在这里展示部分源码，以显示其扩容机制：

```java
// 这里的 check 是单个链表的长度
if (check >= 0) {
    Node<K,V>[] tab, nt; int n, sc;
    while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
           (n = tab.length) < MAXIMUM_CAPACITY) {
        int rs = resizeStamp(n);
        // 如果 sizeCtl < 0，说明正在扩容
        if (sc < 0) {
            // nextTable == null 说明需要扩容的新数组还未创建完成
    		// transferIndex 这个参数小于等于 0，说明已经不需要其它线程帮助扩容了，但是并不说明已经扩容完成，因为有可能还有线程正在迁移元素
            // sc 的高 16 位是数据校验标识，低 16 位代表当前有几个线程正在帮助扩容
            if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                transferIndex <= 0)
                break;
            // 到这里说明当前线程可以帮助扩容，因此 sc 值加一，代表扩容的线程数加 1
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                transfer(tab, nt);
        }
        // 这里 sc > 0，说明此时 sc 表示的是阈值，需要进行扩容
        else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                     (rs << RESIZE_STAMP_SHIFT) + 2))
            transfer(tab, null);
        s = sumCount();
    }
}
```

到这里应该已经很清楚触发 `transfer` 的时机了。

然后简述一下 `transfer` 的机制，看下面的示意图：

![image-20220503221211499](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220503221211499.png)

在多线程的环境下，每个线程会负责处理自己的那部分，此时，其它线程就不能迁移这部分数据了，只能继续寻找其它可以迁移的数据范围，且每次推进的步长为固定值 `stride`（图中以 2 为例）。如图中 B 线程发现 A 线程正在迁移 6 和 7 的数据，因此只能向前寻找，然后迁移 bound = 4 到 i = 5 的这两个数据。

当每个线程迁移完成它的范围内数据时，都会继续向前推进。那什么时候是个头呢？

这就需要维护一个全局的变量 `transferIndex`，来表示所有线程总共推进到的元素下标位置。如图，线程 A 第一次迁移成功后又向前推进，然后迁移 2 和 3 的数据。此时，若没有其他线程在帮助迁移，则 `transferIndex` 即为 2。

剩余部分等待下一个线程来迁移，或者有任何的 A 和 B 线程已经迁移完成，也可以推进到这里帮助迁移，直到 `transferIndex = 0`。

源码如下：

```java
// 这个类是一个标志，用来代表当前桶（数组中的某个下标位置）的元素已经全部迁移完成
static final class ForwardingNode<K,V> extends Node<K,V> {
    final Node<K,V>[] nextTable;
    ForwardingNode(Node<K,V>[] tab) {
        // 这个节点中并不存储有效的数据，仅仅用于把当前桶的头结点的 hash 值设置为 -1，表明已经迁移完成
        super(MOVED, null, null, null);
        this.nextTable = tab;
    }
}

// 迁移数据
private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
    int n = tab.length, stride;
    // 根据当前 CPU 核心数，确定每次推进的步长，最小值为 16
    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE;
    // 从 addCount 方法中只会有一个线程跳转到这里（其他都 CAS 失败了），初始化新数组
    if (nextTab == null) {            
        try {
            @SuppressWarnings("unchecked")
            // 新数组长度为原数组的两倍
            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
            nextTab = nt;
        } catch (Throwable ex) {      
            sizeCtl = Integer.MAX_VALUE;
            return;
        }
        // 用 nextTable 指代新数组
        nextTable = nextTab;
        // 这里就把推进的下标值初始化为原数组长度（以16为例）
        transferIndex = n;
    }
    // 新数组长度
    int nextn = nextTab.length;
    // 创建一个标志类
    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
    // 是否向前推进的标志
    boolean advance = true;
    // 是否所有线程都全部迁移完成的标志
    boolean finishing = false;
    // i 代表当前线程正在迁移的桶的下标，bound 代表它本次可以迁移的范围下限
    for (int i = 0, bound = 0;;) {
        Node<K,V> f; int fh;
        // 需要向前推进
        while (advance) {
            int nextIndex, nextBound;
            // (1). 首先看(3)。
            // i 每次自减 1，直到 bound。若超过 bound 范围，或者 finishing 标志为 true，则不用向前推进；
            // 若未全部完成迁移，且 i 并未走到 bound，则跳转到 (7)，处理当前桶的元素迁移。
            if (--i >= bound || finishing)
                advance = false;
            // (2). 每次执行，都会把 transferIndex 最新的值同步给 nextIndex
            // 若 transferIndex 小于等于 0，则说明原数组中的每个桶位置，都有线程在处理迁移了，
            // 于是，需要跳出 while 循环，并把 i 设为 -1，以跳转到 (4) 判断在处理的线程是否已经全部完成
            else if ((nextIndex = transferIndex) <= 0) {
                i = -1;
                advance = false;
            }
            // (3). 第一个线程会先走到这里，确定它的数据迁移范围。
            // nextBound 代表当次迁移的数据范围下限，减去步长即可
            else if (U.compareAndSwapInt
                     (this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex > stride ?
                                   nextIndex - stride : 0))) {
                // bound 代表当次数据迁移下限
                bound = nextBound;
                // 第一次的 i 为 15，因为长度 16 的数组，最后一个元素的下标为 15
                i = nextIndex - 1;
                // 表明不需要向前推进，只有当把当前范围内的数据全部迁移完成后，才可以向前推进
                advance = false;
            }
        }
        // (4)
        if (i < 0 || i >= n || i + n >= nextn) {
            int sc;
            // 若全部线程迁移完成
            if (finishing) {
                nextTable = null;
                // 更新 table 为新表
                table = nextTab;
                // 扩容阈值改为原来数组长度的 3/2 ，即新长度的 3/4，也就是新数组长度的 0.75 倍
                sizeCtl = (n << 1) - (n >>> 1);
                return;
            }
            // 到这，说明当前线程已经完成了自己的所有迁移（无论参与了几次迁移），则把 sc 减1，表明参与扩容的线程数减少 1。
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                // 这里就是去校验当前 sc 是否和初始值是否相等。相等，则说明全部线程迁移完成。
                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)
                    return;
                // 只有此处，才会把finishing 设置为true。
                finishing = advance = true;
                // 这里会把 i 从 -1 修改为16，目的就是让 i 再从后向前扫描一遍数组，检查是否所有的桶都已被迁移完成，参看 (6)
                i = n; 
            }
        }
        // (5). 若 i 的位置元素为空，则说明当前桶的元素已经被迁移完成，就把头结点设置为 fwd 标志。
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);
        // (6). 若当前桶的头结点是 ForwardingNode，说明迁移完成，则向前推进 
        else if ((fh = f.hash) == MOVED)
            advance = true; // already processed
        // (7).处理当前桶的数据迁移。
        else {
            // 给头结点加锁
            synchronized (f) {  
                if (tabAt(tab, i) == f) {
                    Node<K,V> ln, hn;
                    // 若 hash 值大于等于0，则说明是普通链表节点
                    if (fh >= 0) {
                        int runBit = fh & n;
                        // 这里是 1.7 的 CHM 的 rehash 方法和 1.8 HashMap的 resize 方法的结合体。
                        // 会分成两条链表，一条链表和原来的下标相同，另一条链表是原来的下标加数组长度的位置
                        // 然后找到 lastRun 节点，从它到尾结点整体迁移。
                        // lastRun 前边的节点则单个迁移，但是需要注意的是，这里是头插法。
                        // 另外还有一点和 1.7 不同，1.7 lastRun 前边的节点是复制过去的，而这里是直接迁移的，没有复制操作
                        Node<K,V> lastRun = f;
                        for (Node<K,V> p = f.next; p != null; p = p.next) {
                            int b = p.hash & n;
                            if (b != runBit) {
                                runBit = b;
                                lastRun = p;
                            }
                        }
                        if (runBit == 0) {
                            ln = lastRun;
                            hn = null;
                        }
                        else {
                            hn = lastRun;
                            ln = null;
                        }
                        for (Node<K,V> p = f; p != lastRun; p = p.next) {
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph & n) == 0)
                                ln = new Node<K,V>(ph, pk, pv, ln);
                            else
                                hn = new Node<K,V>(ph, pk, pv, hn);
                        }
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                    // 树节点
                    else if (f instanceof TreeBin) {
                        TreeBin<K,V> t = (TreeBin<K,V>)f;
                        TreeNode<K,V> lo = null, loTail = null;
                        TreeNode<K,V> hi = null, hiTail = null;
                        int lc = 0, hc = 0;
                        for (Node<K,V> e = t.first; e != null; e = e.next) {
                            int h = e.hash;
                            TreeNode<K,V> p = new TreeNode<K,V>
                                (h, e.key, e.val, null, null);
                            if ((h & n) == 0) {
                                if ((p.prev = loTail) == null)
                                    lo = p;
                                else
                                    loTail.next = p;
                                loTail = p;
                                ++lc;
                            }
                            else {
                                if ((p.prev = hiTail) == null)
                                    hi = p;
                                else
                                    hiTail.next = p;
                                hiTail = p;
                                ++hc;
                            }
                        }
                        ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                        (hc != 0) ? new TreeBin<K,V>(lo) : t;
                        hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                        (lc != 0) ? new TreeBin<K,V>(hi) : t;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                }
            }
        }
    }
}
```

最后，我们来看一下 `helpTransfer` 方法，现在来看就非常简单了：

```java
final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
    Node<K,V>[] nextTab; int sc;
    // 头结点为 ForwardingNode ，并且新数组已经初始化
    if (tab != null && (f instanceof ForwardingNode) &&
        (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
        int rs = resizeStamp(tab.length);
        while (nextTab == nextTable && table == tab &&
               (sc = sizeCtl) < 0) {
            // 若校验标识失败，或者已经扩容完成，或推进下标到头，则退出
            if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || transferIndex <= 0)
                break;
            // 当前线程需要帮助迁移，sc 值加 1
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                transfer(tab, nextTab);
                break;
            }
        }
        return nextTab;
    }
    return table;
}
```

###### `get` 方法

`get` 方法就比较简单了：

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    // 获取 hash 值
    int h = spread(key.hashCode());
    // 如果 table 不为 null，进入，否则直接退出
    // 索引处的元素如果不为 null 进入，否则退出
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        if ((eh = e.hash) == h) {
            // 如果完全相等，返回值
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        // 遇到 hash < 0 可能能有两种情况：
        // 1. 该节点是 TreeBin 节点（红黑树代理节点，其 hash 值固定为 -2）
        // 2. ConcurrentHashMap 正在扩容当中
        // 如果是 TreeBin 节点，调用 TreeBin 类的 find 方法，具体是以链表方式遍历还是红黑树方式遍历视情况而定
        // 如果正在扩容中，则跳转到扩容后的新数组上去查找，TreeBin 和 Node 节点都有对应的find方法，具体什么节点类型则调用对应节点类型的 find 方法
        else if (eh < 0)
            return (p = e.find(h, key)) != null ? p.val : null; 
        // 如果前面两种情况都不满足，说明该 hash 桶上面连接的是普通链表结构，不断向下寻找
        while ((e = e.next) != null) {
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```

#### `ConcurrentSkipListMap`

`ConcurrentSkipListMap` 是基于**跳表**实现的，它实现了 `ConcurrentNavigableMap` 接口，该接口继承自 `ConcurrentMap` 以及 `NavigableMap`，可以说，它是 `TreeMap` 的代替。

##### `ConcurrentSkipListMap` 的数据结构

首先看一下类的定义：

```java
public class ConcurrentSkipListMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentNavigableMap<K,V>, Cloneable, Serializable {
    // 特殊值，用于标记头节点
    private static final Object BASE_HEADER = new Object();

    // 头节点
    private transient volatile HeadIndex<K,V> head;
}
```

`HeadIndex` 是一个内部类：

```java
static final class HeadIndex<K,V> extends Index<K,V> {
    final int level;
    
    // ...
}
```

它有一个 `int` 值表示层级，继承自 `Index`，我们看一下 `Index` 的定义：

```java
static class Index<K,V> {
    final Node<K,V> node;
    final Index<K,V> down;
    volatile Index<K,V> right;
    
    // ...
}
```

`Node` 是真实存放数据的节点，除此之外，还有两个指针，一个指向下一层的节点，另一个指向右边的节点。

注意，**每层只需要第一个节点记录层数即可，因此每层的第一个节点都是 `HeadIndex`，之后的节点都是 `Index`**，这样做的好处就是可以节约空间。

我们看一下初始化方法：

```java
private void initialize() {
    keySet = null;
    entrySet = null;
    values = null;
    descendingMap = null;
    // head 的 value 是 BASE_HEADER
    head = new HeadIndex<K,V>(new Node<K,V>(null, BASE_HEADER, null),
                              null, null, 1);
}
```

所以，初始化以后，整个跳表结构是这样的：

![image-20220501234853679](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220501234853679.png)

##### `ConcurrentSkipListMap` 添加元素

```java
public V put(K key, V value) {
    if (value == null)
        throw new NullPointerException();
    return doPut(key, value, false);
}

private Node<K,V> findPredecessor(Object key, Comparator<? super K> cmp) {
    if (key == null)
        throw new NullPointerException(); // don't postpone errors
    // 自旋
    for (;;) {
        // 从 head 开始遍历
        for (Index<K,V> q = head, r = q.right, d;;) {
            // r 是 q 的 right，只要不为 null，就可以继续往右走
            if (r != null) {
                Node<K,V> n = r.node;
                K k = n.key;
                
                // value == null，表示该节点已经被删除了
                // 通过 unlink 删除该节点
                // unlink 实质上是 CAS 替换当前节点为其 right 节点
                if (n.value == null) {
                    if (!q.unlink(r))
                        break;           // restart
                    r = q.right;         // reread r
                    continue;
                }
                
                // 如果 key 大于 r 节点的 key 则继续向右遍历
                if (cpr(cmp, key, k) > 0) {
                    q = r;
                    r = r.right;
                    continue;
                }
            }
            // 如果 q 没有下一层了，直接返回
            if ((d = q.down) == null)
                return q.node;
            // 向下寻找
            q = d;
            r = d.right;
        }
    }
}

private V doPut(K key, V value, boolean onlyIfAbsent) {
    Node<K,V> z;             // added node
    if (key == null)
        throw new NullPointerException();
    Comparator<? super K> cmp = comparator;

    outer: for (;;) {
    	// 通过 findPredecessor 找到某个 key 的前驱
        for (Node<K,V> b = findPredecessor(key, cmp), n = b.next;;) {
            if (n != null) {
                Object v; int c;
                Node<K,V> f = n.next;
                // 读取不一致
                if (n != b.next)               // inconsistent read
                    break;
                // 节点 n 已经逻辑上删除了，执行物理删除
                if ((v = n.value) == null) {   // n is deleted
                    n.helpDelete(b, f);
                    break;
                }
                // 节点 b 已经删除了
                if (b.value == null || v == n) // b is deleted
                    break;
                // 节点大于，往后继续查找
                if ((c = cpr(cmp, key, n.key)) > 0) {
                    b = n;
                    n = f;
                    continue;
                }
                // 相等，根据参数 onlyIfAbsent 决定是否覆盖 value
                if (c == 0) {
                    if (onlyIfAbsent || n.casValue(v, value)) {
                        @SuppressWarnings("unchecked") V vv = (V)v;
                        return vv;
                    }
                    // 竞争失败，重来
                    break; // restart if lost race to replace value
                }
                // else c < 0; fall through
            }
			
            // 创建节点
            z = new Node<K,V>(key, value, n);
            // CAS 插入，如果失败，则重来
            if (!b.casNext(n, z))
                break;         // restart if lost race to append to b
            break outer;
        }
    }
	
    // 产生随机数
    int rnd = ThreadLocalRandom.nextSecondarySeed();
    // 判断是否需要添加 level
    if ((rnd & 0x80000001) == 0) { // 测试最高位和最低位
        int level = 1, max;
        // 获取 level
        while (((rnd >>>= 1) & 1) != 0)
            ++level;
        Index<K,V> idx = null;
        HeadIndex<K,V> h = head;
        
        // 如果层次 level 大于最大的层次话则需要新增一层，否则就在相应层次以及小于该 level 的层次进行节点新增处理
        
        // level 比最高层次 head.level 小，直接生成需要的 index
        if (level <= (max = h.level)) {
            for (int i = 1; i <= level; ++i)
                idx = new Index<K,V>(z, idx, null);
        }
        else { // try to grow by one level
            level = max + 1; // hold in array and later pick the one to use
            @SuppressWarnings("unchecked")Index<K,V>[] idxs =
                (Index<K,V>[])new Index<?,?>[level+1];
            for (int i = 1; i <= level; ++i) // 生成 index
                idxs[i] = idx = new Index<K,V>(z, idx, null);
            for (;;) {
                h = head;
                int oldLevel = h.level;
                // 层次扩大了，需要重新开始（其它线程改变了跳跃表）
                if (level <= oldLevel) // lost race to add level
                    break;
                HeadIndex<K,V> newh = h;
                Node<K,V> oldbase = h.node;
                // 生成新的 HeadIndex 节点
                for (int j = oldLevel+1; j <= level; ++j)
                    newh = new HeadIndex<K,V>(oldbase, newh, idxs[j], j);
                // 更新 head
                if (casHead(h, newh)) {
                    h = newh;
                    idx = idxs[level = oldLevel];
                    break;
                }
            }
        }
        // 找到插入点并拼接
        splice: for (int insertionLevel = level;;) {
            int j = h.level;
            for (Index<K,V> q = h, r = q.right, t = idx;;) {
                if (q == null || t == null)
                    break splice;
                // r 不等于 null，则已经找到
                if (r != null) {
                    Node<K,V> n = r.node;
                    // compare before deletion check avoids needing recheck
                    int c = cpr(cmp, key, n.key);
                    // 删除 r
                    if (n.value == null) {
                        if (!q.unlink(r))
                            break;
                        r = q.right;
                        continue;
                    }
                    if (c > 0) {
                        q = r;
                        r = r.right;
                        continue;
                    }
                }

                // 插入
                if (j == insertionLevel) {
                    // 链接失败，重试
                    if (!q.link(r, t))
                        break; // restart
                    if (t.node.value == null) {
                        // 查找节点，查找过程中会删除需要删除的节点
                        findNode(key);
                        break splice;
                    }
                    if (--insertionLevel == 0)
                        break splice;
                }

                // 向下继续链接其它index 层
                if (--j >= insertionLevel && j < level)
                    t = t.down;
                q = q.down;
                r = q.right;
            }
        }
    }
    return null;
}
```

插入的实际流程很长，下面是总结：

1. 通过 `findPredecessor()` 方法确认 key 要插入的位置
2. 进行数据校验，如果发现需要删除节点，则进行辅助删除，如果其他线程改变了跳跃表，则进行重试或遍历查找合适的位置。
3. 如果跳跃表中已经存在该 key,则根据 onlyIfAbsent 确定是否覆盖旧值。
4. 生成节点，插入到最底层的数据链表中。
5. 根据随机值确定是否创建索引层，如果不需要则返回，否则执行第 6 步。
6. 如果需要创建的索引层超过最大的 level，则需要创建 `HeadIndex` 索引层，否则只需要创建 `Index` 索引层即可。
7. 从 head 开始进行遍历，将每一层的新添加的 `Index` 索引层进行连接。

##### `ConcurrentSkipListMap` 删除元素

```java
public V remove(Object key) {
    return doRemove(key, null);
}
```

```java
// 指定 key 和 value 删除相应的节点
final V doRemove(Object key, Object value) {
    if (key == null)
        throw new NullPointerException();
    Comparator<? super K> cmp = comparator;
    outer: for (;;) {
        // 查找其前驱
        for (Node<K,V> b = findPredecessor(key, cmp), n = b.next;;) {
            Object v; int c;
            if (n == null) // 不存在该 key
                break outer;
            Node<K,V> f = n.next;
            // 其它线程修改了跳跃表数据结构
            if (n != b.next)                    // inconsistent read
                break;
            // 节点 n 需要被删除，进行协助删除，然后再重试   
            if ((v = n.value) == null) {        // n is deleted
                n.helpDelete(b, f);
                break;
            }
            // b 即将也被删除
            if (b.value == null || v == n)      // b is deleted
                break;
            // 不存在该 key    
            if ((c = cpr(cmp, key, n.key)) < 0)
                break outer;
            if (c > 0) { // 向后继续遍历查找
                b = n;
                n = f;
                continue;
            }
            // key 相等，value 不相等，退出
            if (value != null && !value.equals(v))
                break outer;
            // 逻辑删除，CAS 设置 value = null    
            if (!n.casValue(v, null)) 
                break;
            // 先添加删除标记，然后再进行删除操作  
            if (!n.appendMarker(f) || !b.casNext(n, f))
                findNode(key);                  // retry via findNode
            else {
                // 清除索引层
                findPredecessor(key, cmp);      // clean index
                 // 该层已经没有节点，删掉该层
                if (head.right == null)
                    tryReduceLevel();
            }
            @SuppressWarnings("unchecked") V vv = (V)v;
            return vv;
        }
    }
    return null;
}

// 所谓添加标记，实际上是 CAS 替换 f 为新节点，新节点的 next 指向 f
boolean appendMarker(Node<K,V> f) {
    return casNext(f, new Node<K,V>(f));
}

void helpDelete(Node<K,V> b, Node<K,V> f) {
    if (f == next && this == b.next) {
        //如果没有添加标记节点，那么添加标记节点
        if (f == null || f.value != f) // not already marked
            casNext(f, new Node<K,V>(f));
        else
            b.casNext(this, f.next); //执行删除操作
    }
}
```

### 并发 `List`

#### `CopyOnWriteArrayList`

`CopyOnWriteArrayList` 是 `List` 的唯一并发容器，它实现了名为写时复制的技术，好处在于**读操作是无锁的**（也就是无阻塞）。

`CopyOnWriteArrayList` **仅适用于写操作非常少的场景**，而且能够容忍读写的短暂不一致。如果读写比例均衡或者有大量写操作的话，使用 `CopyOnWriteArrayList` 的性能会非常糟糕。

##### 应用

下面是一个简单的示例：

```java
public class CopyOnWriteArrayListDemo {
    static class ReadTask implements Runnable {
        List<String> list;

        ReadTask(List<String> list) {
            this.list = list;
        }

        @Override
        public void run() {
            for (String str : list) {
                System.out.println(str);
            }
        }
    }

    static class WriteTask implements Runnable {
        List<String> list;
        int index;

        WriteTask(List<String> list, int index) {
            this.list = list;
            this.index = index;
        }

        @Override
        public void run() {
            list.remove(index);
            list.add(index, "write_" + index);
        }
    }
    
    public void run() {
        final int NUM = 10;
        // ArrayList 在并发迭代访问时会抛出 ConcurrentModificationException 异常
        // List<String> list = new ArrayList<>();
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        for (int i = 0; i < NUM; i++) {
            list.add("main_" + i);
        }
        ExecutorService executorService = Executors.newFixedThreadPool(NUM);
        for (int i = 0; i < NUM; i++) {
            executorService.execute(new ReadTask(list));
            executorService.execute(new WriteTask(list, i));
        }
        executorService.shutdown();
    }

    public static void main(String[] args) {
        new CopyOnWriteArrayListDemo().run();
    }
}
```

##### 原理

和 `ArrayList` 一样，内部维护了一个数组 `array`，同时还有一把可重入锁。定义如下：

```java
public class CopyOnWriteArrayList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
	// ...
    
    /** The lock protecting all mutators */
    final transient ReentrantLock lock = new ReentrantLock();

    /** The array, accessed only via getArray/setArray. */
    private transient volatile Object[] array;
    
    // ...
}
```

###### 读取

读操作是不同步的，因为它们在内部数组的快照上工作，所以多个迭代器可以同时遍历而不会相互阻塞。

我们看一下 `get` 方法：

```java
private E get(Object[] a, int index) {
    return (E) a[index];
}

public E get(int index) {
    return get(getArray(), index);
}

final Object[] getArray() {
    return array;
}
```

###### 写入

所有的写操作都是同步的，它们在数组的副本上工作。写操作完成后，原数组将会被替换为新数组，所以替换数组的调用是原子的。

下面是 `add` 方法的源码，并发策略非常简单，就是加锁：

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    // 加锁
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        // 拷贝新数组
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        // 释放锁
        lock.unlock();
    }
}
```

其他写入方法也是类似的，这里就不再叙述了。

### 并发 `Set`

`Set` 接口的两个实现是 `CopyOnWriteArraySet` 和 `ConcurrentSkipListSet`。

#### `CopyOnWriteArraySet`

`CopyOnWriteArraySet` 底层依赖于 `CopyOnWriteArrayList`：

```java
public class CopyOnWriteArraySet<E> extends AbstractSet<E>
        implements java.io.Serializable {
	// ...
    
    private final CopyOnWriteArrayList<E> al;
    
    // ...
}
```

原理参见 `CopyOnWriteArrayList`。

#### `ConcurrentSkipListSet`

`ConcurrentSkipListSet` 则依赖于 `ConcurrentSkipListMap`：

```java
public class ConcurrentSkipListSet<E>
    extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable {
    /**
     * The underlying map. Uses Boolean.TRUE as value for each
     * element.  This field is declared final for the sake of thread
     * safety, which entails some ugliness in clone().
     */
    private final ConcurrentNavigableMap<E,Object> m;
    
    // ...
}
```

原理参见 `ConcurrentSkipListMap`。

### 并发 `Queue`

并发 `Queue` 是所有并发容器中最多的，因为队列在并发场景下应用十分广泛。

可以从两个方面来分类，一个是阻塞与非阻塞，在队列中阻塞是指**当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞**；另一个是单端与双端，**单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队**。

JUC 中的**阻塞队列名字中都包含 `Blocking`，非阻塞队列则以 `Concurrent` 开头；单端队列使用 `Queue`，而双端队列使用 `Deque`**。

#### `ConcurrentLinkedQueue` 和 `ConcurrentLinkedDeque`

这两个类是队列中唯二的非阻塞队列，都是用链表实现的单端或双端队列。

##### 原理

`ConcurrentLinkedQueue` 以及 `ConcurrentLinkedDeque` 中，都没有使用锁而是**使用 CAS** 进行操作。

这里分析 `ConcurrentLinkedQueue` 入队和出队的源码，`ConcurrentLinkedDeque` 是类似的：

首先是入队：

```java
public boolean offer(E e) {
    checkNotNull(e);
    final Node<E> newNode = new Node<E>(e);

    for (Node<E> t = tail, p = t;;) {
        Node<E> q = p.next;
        if (q == null) {
            // p 是最后一个节点
            // 使用 CAS 将 newNode 放在 q 的后一个
            if (p.casNext(null, newNode)) {
                // 如果一次跳了两或者更多个节点
                if (p != t) 
                    // CAS 替换尾节点，因为尾节点就是它本来该在的位置
                    casTail(t, newNode);
                return true;
            }
        }
        // 如果 p == q，则说明有其他线程已经删除了，此时我们掉出了链表，选择一个节点重新开始
        else if (p == q)
            p = (t != (t = tail)) ? t : head;
        else
            // 两跳后检查尾部更新
            p = (p != t && t != (t = tail)) ? t : q;
    }
}
```

然后是出队：

```java
public E poll() {
    restartFromHead:
    for (;;) {
        for (Node<E> h = head, p = h, q;;) {
            E item = p.item;

            // CAS 替换
            if (item != null && p.casItem(item, null)) {
                // 两跳，CAS 更新头节点
                if (p != h) // hop two nodes at a time
                    updateHead(h, ((q = p.next) != null) ? q : p);
                return item;
            }
            else if ((q = p.next) == null) {
                updateHead(h, p);
                return null;
            }
            else if (p == q)
                continue restartFromHead;
            else
                p = q;
        }
    }
}
```

在队列中无锁的情况下，就要小心两跳甚至 N 跳的情况，在这个时候，需要仔细检查 CAS 后的结果，修复头和尾，整体原来还是比较简单的。

### 阻塞 `Queue`

阻塞 `Queue` 是一个接口，也就是 `BlockingQueue`。阻塞队列基本都是**基于锁实现的**，这意味着这些队列的实现相比于 CAS 实现的并发 Queue。在 `BlockingQueue` 中，**当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞**。

接口定义如下：

```java
public interface BlockingQueue<E> extends Queue<E> {
    boolean add(E e);

    boolean offer(E e);

    void put(E e) throws InterruptedException;

    boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException;

    E take() throws InterruptedException;

    E poll(long timeout, TimeUnit unit)
        throws InterruptedException;

    int remainingCapacity();

    boolean remove(Object o);

    public boolean contains(Object o);

    int drainTo(Collection<? super E> c);

    int drainTo(Collection<? super E> c, int maxElements);
}
```

除了 `Queue` 本身具有的方法，该接口还额外提供了几个方法：

* `void put(E e)`：插入元素，如果队列已满，则等待直到队列出现空闲空间
* `boolean offer(E e, long timeout, TimeUnit unit)`：插入元素，如果队列已满，则等待一段指定的时间，如果还未出现空间，则返回 false；如果有可用空间，则返回 true。
* ` E take()`：获取并移除队列头结点，如果必要，其会等待直到队列出现元素
* ` E poll(long timeout, TimeUnit unit)`：获取并移除队列头结点，如果队列空，则等待一段指定的时间，如果还未出现，则返回 false；否则返回 true。
* `int remainingCapacity()`：返回此队列理想情况下（在没有内存或资源限制的情况下）可以不阻塞地接受的元素的数量
* `int drainTo(Collection<? super E> c)`：从此队列中删除所有可用元素并将它们添加到给定集合中。
* `int drainTo(Collection<? super E> c, int maxElements)`：从此队列中删除最多给定数量个的可用元素并将它们添加到给定集合中。

JDK 提供了以下阻塞队列，其中有界和无界的区别就是大小是否有限定：

| 名称                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `ArrayBlockingQueue`    | 一个由**数组结构组成的有界队列**，此队列按照 FIFO 的原则对元素进行排序。 |
| `LinkedBlockingQueue`   | 一个由**链表结构组成的有界队列**，此队列按照 FIFO 的原则对元素进行排序，如果未指定大小，默认大小为 `Integer.MAX_VALUE`，因此也有人称它为无界。 |
| `PriorityBlockingQueue` | 一个**支持优先级排序的无界队列**，不保证同优先级元素的顺序。 |
| `DelayQueue`            | 一个由 `PriorityBlockingQueue` 实现的**可以延迟获取的无界队列**，可以指定多久之后能拿到元素，必须在经过这个时间之后才能拿到该元素 |
| `SynchronousQueue`      | 一个**不存储元素的阻塞队列**，每个 put 操作都必须等待 take 操作，否则不能添加元素。 |
| `LinkedTransferQueue`   | 一个由**链表结构组成的无界队列**，相对于 `LinkedBlockingQueue`，添加了 `transfer` 和 `tryTransfer` 方法。 |
| `LinkedBlockingDeque`   | 一个由**链表结构组成的双端无界队列**，头部和尾部都可以添加/取出元素，并发时可以将锁竞争降低最多一半。 |

#### `PriorityBlockingQueue`

`PriorityBlockingQueue` 可以视为 `PriorityQueue` 的线程安全版本，它是一个无界队列，因此 `put` 方法不会阻塞。

##### 原理简述

`PriorityBlockingQueue` 有以下几个重要成员：

```java
private transient Object[] queue; // 存储数据
private final ReentrantLock lock; // 锁
private final Condition notEmpty; // notEmpty 条件，用于唤醒消费者
private transient volatile int allocationSpinLock; // 用于分配的自旋锁，通过 CAS 获取
```

`PriorityBlockingQueue` 的容量虽然有初始化大小，但是不限制大小，如果当前容量已满，插入新元素时会自动扩容。

**其核心是利用锁来阻塞，其他操作和 `PriorityQueue` 没有什么差别。**

以入队为例：

```java
public boolean offer(E e) {
    if (e == null)
        throw new NullPointerException();
    final ReentrantLock lock = this.lock;
    // 上锁
    lock.lock();
    int n, cap;
    Object[] array;
    // 扩容
    while ((n = size) >= (cap = (array = queue).length))
        tryGrow(array, cap);
    try {
        // 上浮
        Comparator<? super E> cmp = comparator;
        if (cmp == null)
            siftUpComparable(n, e, array);
        else
            siftUpUsingComparator(n, e, array, cmp);
        size = n + 1;
        // 通过 notEmpty 条件唤醒消费者
        notEmpty.signal();
    } finally {
        // 解锁
        lock.unlock();
    }
    return true;
}
```

出队：

```java
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    E result;
    try {
        // 队列空，阻塞
        while ( (result = dequeue()) == null)
            notEmpty.await();
    } finally {
        lock.unlock();
    }
    return result;
}


// 和上面方法不一样的是，队列空时不会阻塞
public E poll() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return dequeue();
    } finally {
        lock.unlock();
    }
}

private E dequeue() {
    int n = size - 1;
    if (n < 0)
        return null;
    else {
        Object[] array = queue;
        E result = (E) array[0];
        E x = (E) array[n];
        array[n] = null;
        Comparator<? super E> cmp = comparator;
        // 下沉
        if (cmp == null)
            siftDownComparable(0, x, array, n);
        else
            siftDownUsingComparator(0, x, array, n, cmp);
        size = n;
        return result;
    }
}
```

#### `ArrayBlockingQueue`

`ArrayBlockingQueue` 是由数组结构组成的**有界阻塞队列**。

定义如下：

```java
public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, java.io.Serializable {
    // 数组的大小就决定了队列的边界，所以初始化时必须指定容量
    public ArrayBlockingQueue(int capacity);
    // fair 表示公平锁还是非公平锁
    public ArrayBlockingQueue(int capacity, boolean fair);
    public ArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c);
}
```

##### 原理简述

`ArrayBlockingQueue` 的重要成员如下：

```java
// 用于存放元素的数组
final Object[] items;
// 下一次读取操作的位置
int takeIndex;
// 下一次写入操作的位置
int putIndex;
// 队列中的元素数量
int count;

// 以下几个就是控制并发用的同步器
final ReentrantLock lock;
private final Condition notEmpty;
private final Condition notFull;
```

`ArrayBlockingQueue` 内部以 `final` 的数组保存数据，数组的大小就决定了队列的边界。

`ArrayBlockingQueue` 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。

- 如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。
- 如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除，然后唤醒写线程队列的第一个等待线程。

源码和其他队列类似，这里就不再叙述了。

#### `LinkedBlockingQueue` 与 `LinkedBlockingDeque`

`LinkedBlockingQueue` 是由链表结构组成的有界阻塞队列。容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过**如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为 `Integer.MAX_VALUE`，成为了无界队列**。

`LinkedBlockingDeque` 则是 `LinkedBlockingQueue` 的双端版本，它实现了 `BlockingDeque` 接口，这个接口相对于 `Deque`，提供了更多的方法：

* `void putFirst(E e)`
* `void putLast(E e)`
* `boolean offerFirst(E e, long timeout, TimeUnit unit)`
* `boolean offerLast(E e, long timeout, TimeUnit unit)`
* `E takeFirst()`
* `E takeLast()`
* `E pollFirst(long timeout, TimeUnit unit)`
* `E pollLast(long timeout, TimeUnit unit)`

这些方法的作用和普通队列中的类似，这里就不再重复叙述了。

##### 原理简述

以 `LinkedBlockingQueue` 为例：

```java
// 队列容量
private final int capacity;
// 队列中的元素数量
private final AtomicInteger count = new AtomicInteger(0);
// 队头
private transient Node<E> head;
// 队尾
private transient Node<E> last;

// take, poll, peek 等读操作的方法需要获取到这个锁，非公平锁
private final ReentrantLock takeLock = new ReentrantLock();
// 如果读操作的时候队列是空的，那么等待 notEmpty 条件
private final Condition notEmpty = takeLock.newCondition();
// put, offer 等写操作的方法需要获取到这个锁，非公平锁
private final ReentrantLock putLock = new ReentrantLock();
// 如果写操作的时候队列是满的，那么等待 notFull 条件
private final Condition notFull = putLock.newCondition();
```

这里用了两对 `Lock` 和 `Condition`，简单介绍如下：

- `takeLock` 和 `notEmpty` 搭配：如果要获取（take）一个元素，需要获取 `takeLock` 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（`notEmpty`）这个条件（`Condition`）。
- `putLock` 需要和 `notFull` 搭配：如果要插入（put）一个元素，需要获取 `putLock` 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（`notFull`）这个条件（`Condition`）。

我们之前讲过的 `ArrayBlockingQueue` 则是使用了一个锁，`LinkedBlockingQueue` 这样做能**大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。**

具体源码略，和其他队列也相差不大，有兴趣的读者可以自行分析。

#### `SynchronousQueue`

`SynchronousQueue` 是**不存储元素的阻塞队列**。每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。

`SynchronousQueue` 定义如下：

```java
public class SynchronousQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, java.io.Serializable {
    // ...
}
```

`SynchronousQueue` 的队列其实是虚的，即队列容量为 0。**数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。**

`SynchronousQueue` 中不能使用 `peek` 方法（在这里这个方法直接返回 `null`），`peek` 方法的语义是只读取不移除，显然，这个方法的语义是不符合 `SynchronousQueue` 的特征的。

`SynchronousQueue` 也不能被迭代，因为根本就没有元素可以拿来迭代的。

虽然 `SynchronousQueue` 间接地实现了 `Queue` 接口，属于集合框架，但是如果你将其当集合来用的话，那么集合是空的。

当然，`SynchronousQueue` 也不允许传递 `null` 值的。

##### 原理简述

以 `take` 和 `put` 为例：

```java
public E take() throws InterruptedException {
    E e = transferer.transfer(null, false, 0);
    if (e != null)
        return e;
    Thread.interrupted();
    throw new InterruptedException();
}

public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    if (transferer.transfer(e, false, 0) == null) {
        Thread.interrupted();
        throw new InterruptedException();
    }
}
```

我们发现，它就是通过一个 `Transferer` 进行传输，细节这里就不讲述了，有兴趣的读者自行阅读源码。

#### `DelayQueue`

`DelayQueue` 是一个**无界**的阻塞队列，用于放置实现了 `Delayed` 接口的对象，其中的对象只能在其到期时才能从队列中取走。

##### 原理简述

首先看一下 `Delayed` 接口：

```java
public interface Delayed extends Comparable<Delayed> {
    // 在给定的时间单位内返回与此对象关联的剩余延迟
    long getDelay(TimeUnit unit);
}
```

这个接口表示可延迟的，还继承了 `Comparable`，用于对指定的 delay 进行排序。

这个队列的定义如下：

```java
public class DelayQueue<E extends Delayed> extends AbstractQueue<E>
    implements BlockingQueue<E> {
	// 锁
    private final transient ReentrantLock lock = new ReentrantLock();
    // 使用优先队列，根据 Delayed 对象的 delay 进行排序
    private final PriorityQueue<E> q = new PriorityQueue<E>();

    // 用 leader 来减少不必要的等待时间
    private Thread leader = null;

    // 表示可用的条件
    private final Condition available = lock.newCondition();
}
```

我们注意到，它内部使用了一个优先队列对 delay 进行排序。同时，内部持有一个线程 leader，可以减少不必要的等待时间。

具体来说，如果有多个消费者，且 leader 不为空，那么可以直接进入等待，而如果为空，则说明没有线程去消费，则设置该线程为 leader，并且等待 delay。

#### `LinkedTransferQueue`

`LinkedTransferQueue` 是 `SynchronousQueue` 和 `BlockingQueue` 的结合体，当有消费者正在拿数据时，如果有数据被生产，则立刻移交给消费者，否则放入队列中。

**这使得 `LinkedTransferQueue` 的性能比普通 `BlockingQueue` 更高，而且相比于 `SynchronousQueue`，它能够存储元素**。

`LinkedTransferQueue` 实现了 `TransferQueue`，`TransferQueue` 继承自 `BlockingQueue`，我们先来看一下 `TransferQueue` 的定义：

```java
public interface TransferQueue<E> extends BlockingQueue<E> {
    // 如果可能，立即将元素转移给等待的消费者 
    // 更准确地说，如果存在消费者已经等待接收它（在take或定时poll ），则立即传送指定的元素，否则返回 false
    boolean tryTransfer(E e);

    // 将元素传输给消费者，并在必要时等待
    // 更准确地说，如果存在已经等待接收的消费者（在take或定时poll ），则立即传输指定的元素，否则等待直到消费者接收到该元素。
    void transfer(E e) throws InterruptedException;

    // 在上面方法的基础上加上定时
    boolean tryTransfer(E e, long timeout, TimeUnit unit)
        throws InterruptedException;

    // 如果至少有一位消费者在等待，则返回 true
    boolean hasWaitingConsumer();

    // 返回等待消费者人数的估计值
    int getWaitingConsumerCount();
}
```

##### 原理简述

该 `Queue` 的实现中，所有的入队和出队方法都调用了 `xfer` 方法，仅仅是参数的不同。

一张图概括其流程：

![image-20220307162411685](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220307162411685.png)

感兴趣的话可以自行阅读源码。

## 线程池

**线程池**提供了一种限制和管理资源（包括执行一个任务）。 每个**线程池**还维护一些基本统计信息，例如已完成任务的数量。

**使用线程池的好处**：

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### `Executor` 框架

`Executor` 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将**任务提交**与**任务如何运行**分离开来的机制。

`Executor` 框架**有三个重要组成部分，分别是任务、任务执行器以及任务执行结果**。

详细介绍如下：

1. **任务**。

   主要有 `Runnable` 以及 `Callable` 接口。

   **`Runnable` 接口**或 **`Callable` 接口**的实现类都可以被 **`ThreadPoolExecutor`** 或 **`ScheduledThreadPoolExecutor`** 执行。

   我们都知道 `Runnable` 接口是最基本的线程接口，而 `Callable` 接口在前面的学习中我们也已经接触过了，它的 `V call()` 方法可以获取到一个返回值。

2. **任务执行器**。

   主要是由 `Executor` 及其拓展接口、实现类组成的。

   最基本的任务执行由 `Executor` 保证，只定义了一个 `execute` 方法，用于接收一个 `Runnable` 对象：

   ```java
   public interface Executor {
       void execute(Runnable command);
   }
   ```

   而 `ExecutorService` 拓展了它，提供了更多的功能：

   ```java
   public interface ExecutorService extends Executor {
       void shutdown();
   
       List<Runnable> shutdownNow();
   
       boolean isShutdown();
   
       boolean isTerminated();
   
       boolean awaitTermination(long timeout, TimeUnit unit)
           throws InterruptedException;
   
       <T> Future<T> submit(Callable<T> task);
   
       <T> Future<T> submit(Runnable task, T result);
   
       Future<?> submit(Runnable task);
   
       <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks);
   
       <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                     long timeout, TimeUnit unit);
   
       <T> T invokeAny(Collection<? extends Callable<T>> tasks);
   
       <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                       long timeout, TimeUnit unit);
   }
   ```

   这个接口提供了以下拓展能力：

   * 支持有返回值的线程：`sumbit`、`invokeAll`、`invokeAny` 方法中都支持传入 `Callable` 对象。
   * 支持管理线程的生命周期：`shutdown`、`shutdownNow`、`isShutdown` 等方法。

   该接口有一个基本的实现类 `ThreadPoolExecutor`，这个类使用的非常频繁，是整个线程池中最核心的存在。

   除此之外，该接口还有一个拓展接口 `ScheduledExecutorService`，是 `ThreadPoolExecutor` 的子类，它提供了定期执行任务的能力：

   ```java
   public interface ScheduledExecutorService extends ExecutorService {
       public ScheduledFuture<?> schedule(Runnable command,
                                          long delay, TimeUnit unit);
   
       public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                                              long delay, TimeUnit unit);
   
       public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                     long initialDelay,
                                                     long period,
                                                     TimeUnit unit);
   
       public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
                                                        long initialDelay,
                                                        long delay,
                                                        TimeUnit unit);
   }
   ```

   这个接口也有一个基本实现类 `ScheduledThreadPoolExecutor`。

3. **任务执行结果**。

   由 `Future` 以及 `Future` 的拓展接口、实现类组成。

   `Future` 是对线程执行结果的封装，它提供了基本的任务进度查询方法以及任务结果获取方法，定义如下：

   ```java
   public interface Future<V> {
       boolean cancel(boolean mayInterruptIfRunning);
   
       boolean isCancelled();
   
       boolean isDone();
   
       V get() throws InterruptedException, ExecutionException;
   
       V get(long timeout, TimeUnit unit)
           throws InterruptedException, ExecutionException, TimeoutException;
   }
   ```

   `Future` 有几个拓展接口：

   * `RunnableFuture`：同时继承 `Runnable` 以及 `Future`，以实现 `Runnable` 的返回值。

     其最基本的实现类是 `FutureTask`，也是最常用的一个实现类，一般配合 `ExecutorService` 的实现类使用。

     它还有一个拓展接口 `RunnableScheduledFuture`，它不仅拓展了本接口，还拓展了接下来要介绍的 `ScheduledFuture`，我们等会再介绍它。

   * `ScheduledFuture`：同时继承 `Delayed` 以及 `Future`，表示在一段 delay 时间后执行。

     其唯一实现类 `ScheduledFutureTask` 是 `ScheduledThreadPoolExecutor` 的私有内部类，且继承自 `FutureTask`，`FutureTask` 完成了大部分逻辑。由于是私有的，所以此结果只能配合该类使用。

   `Future` 还有一个特殊的实现类 `CompletableFuture`，它同时实现了 `Future` 以及 `CompletionStage`，该类表示异步计算的一个阶段，它在另一个 `CompletionStage` 完成时执行一个操作或计算一个值。

使用下面这张图概括三种组件的关系：

![image-20220307220127701](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220307220127701.png)

由此我们得到线程池的使用步骤：

1. 主线程首先要创建实现 `Runnable` 或者 `Callable` 接口的任务对象。

2. 把创建完成的实现 `Runnable`/`Callable`接口的对象直接交给 `ExecutorService` 执行：

   通过 `execute` 方法执行 `Runnable`（无返回），或者通过 `submit` 方法执行 `Runnable` 和 `Callable`（有返回）。

3. 如果是 `submit` 执行，`ExecutorService` 将返回一个实现 `Future` 接口的对象。

   由于 `FutureTask` 实现了 `Runnable`，我们也可以通过创建 `FutureTask`，然后直接交给 `ExecutorService` 执行（由于 `Runnable` 没有返回值，因此创建 `FutureTask` 时会要求指定返回值类型）。

4. 最后，主线程可以执行 `Future` 的 `get`方法来等待任务执行完成；主线程也可以执行 `cancel` 方法来取消此任务的执行。


除了上述介绍的类之外，JUC 提供了 `Executors` 工具类，就像 `Collections` 和 `Arrays` 那样，全部提供静态方法来辅助开发者。

### `ThreadPoolExecutor`

`ThreadPoolExecutor` 是 `ExecutorService` 的最常用实现类，也是最核心的。

#### 应用

`Runnable` + 线程池使用示例：

```java
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolExecutorDemo {
    public static void main(String[] args) {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 500, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());

        // 每次循环创建一个新 Runnable，交给线程池执行
        for (int i = 0; i < 100; i++) {
            threadPoolExecutor.execute(new MyThread());
            String info = String.format("线程池中线程数目：%s，队列中等待执行的任务数目：%s，已执行玩别的任务数目：%s",
                    threadPoolExecutor.getPoolSize(),
                    threadPoolExecutor.getQueue().size(),
                    threadPoolExecutor.getCompletedTaskCount());
            System.out.println(info);
        }
        threadPoolExecutor.shutdown();
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " 执行");
        }
    }
}
```

`Callable` + 线程池使用示例：

```java
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.*;

class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        Thread.sleep(1000);
        // 返回执行当前 Callable 的线程名字
        return Thread.currentThread().getName();
    }
}

public class MyCallableDemo {

    private static final int CORE_POOL_SIZE = 5;
    private static final int MAX_POOL_SIZE = 10;
    private static final int QUEUE_CAPACITY = 100;
    private static final Long KEEP_ALIVE_TIME = 1L;

    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                CORE_POOL_SIZE,
                MAX_POOL_SIZE,
                KEEP_ALIVE_TIME,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(QUEUE_CAPACITY),
                new ThreadPoolExecutor.CallerRunsPolicy());

        List<Future<String>> futureList = new ArrayList<>();
        Callable<String> callable = new MyCallable();
        for (int i = 0; i < 10; i++) {
            // 提交任务到线程池
            Future<String> future = executor.submit(callable);
            // 将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值
            futureList.add(future);
        }
        for (Future<String> fut : futureList) {
            try {
                System.out.println(new Date() + "::" + fut.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
        executor.shutdown();
    }
}
```

#### 原理

`ThreadPoolExecutor` 的定义如下：

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    // ThreadPoolExecutor 使用 ctl 控制线程池状态，这是一个 Integer，共 32 位，31 ~ 29 位用于记录状态，28 ~ 0 位用于记录线程池大小
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // 这是 29，也就是我们上面介绍的位数
    private static final int COUNT_BITS = Integer.SIZE - 3;
    // 线程池真正的最大大小
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

    // 线程池状态
    // 111 表示 running
    private static final int RUNNING    = -1 << COUNT_BITS;
    // 000 表示 shutdown
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    // 001 表示 stop
    private static final int STOP       =  1 << COUNT_BITS;
    // 010 表示 tidying
    private static final int TIDYING    =  2 << COUNT_BITS;
    // 011 表示 terminated
    private static final int TERMINATED =  3 << COUNT_BITS;

    // ...

    // 工作队列
    private final BlockingQueue<Runnable> workQueue;

    // 主锁
    private final ReentrantLock mainLock = new ReentrantLock();

    // 工作线程集合
    private final HashSet<Worker> workers = new HashSet<Worker>();

    // 终止条件
    private final Condition termination = mainLock.newCondition();

    // 池曾经达到的最大大小
    private int largestPoolSize;

    // 完成任务的数目
    private long completedTaskCount;

    // 新线程的工厂。所有线程都是使用这个工厂创建的
    private volatile ThreadFactory threadFactory;

    // 拒绝策略
    private volatile RejectedExecutionHandler handler;

    // 等待工作的空闲线程超时
    private volatile long keepAliveTime;

    // 如果为 false（默认），核心线程即使在空闲时也保持活动状态。
    private volatile boolean allowCoreThreadTimeOut;

    // 核心池大小，即保持活动的最小工作者数
    private volatile int corePoolSize;

    // 池的最大大小，受限于 CAPACITY
    private volatile int maximumPoolSize;

    // ...
}
```

* `ctl` 是一个原子整数，**用于控制线程池的运行状态和线程池中的有效线程数量**。它其实包含两部分信息：

  - 线程池的运行状态 (`runState`)
  - 线程池内有效线程的数量 (`workerCount`)

  `ctl` 使用的是 `Integer` 类型来保存，共 32 位，高 3 位保存 `runState`，低 29 位保存 `workerCount`。

  所以 `COUNT_BITS` 就是 29，而 `CAPACITY` 就是 1 左移 29 位减 1（29 个 1），这个常量表示 `workerCount` 的上限值，大约是 5 亿。

  示意图如下图所示：

  ![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/dydrejap0f.png)

  > 源码中使用如下三个方法操作 ctl 这个整数：
  >
  > ```java
  > private static int ctlOf(int rs, int wc) { return rs | wc; }
  > private static int runStateOf(int c)     { return c & ~CAPACITY; }
  > private static int workerCountOf(int c)  { return c & CAPACITY; }
  > ```
  >
  > 很精妙的位运算。

* 运行状态：线程池一共有五种运行状态：

  * `RUNNING`（运行状态）：接受新任务，并且也能处理阻塞队列中的任务。

  * `SHUTDOWN`（关闭状态）：不接受新任务，但**可以处理阻塞队列中的任务**。

    * 在线程池处于 `RUNNING` 状态时，调用 `shutdown` 方法会使线程池进入到该状态。
    * `finalize` 方法在执行过程中也会调用 `shutdown` 方法进入该状态。

  * `STOP`（停止状态）：不接受新任务，也**不处理队列中的任务**。会中断正在处理任务的线程。

    在线程池处于 `RUNNING` 或 `SHUTDOWN` 状态时，调用 `shutdownNow` 方法会使线程池进入到该状态。

  * `TIDYING`（整理状态）：如果所有的任务都已终止了，`workerCount`（有效线程数）为 0，线程池进入该状态后会调用 `terminated` 方法进入 `TERMINATED` 状态。

  * `TERMINATED`（已终止状态）：在 `terminated` 方法执行完后进入该状态。默认 `terminated` 方法中什么也没有做。进入 `TERMINATED` 的条件如下：

    * 线程池不是 `RUNNING` 状态；
    * 线程池状态不是 `TIDYING` 状态或 `TERMINATED` 状态；
    * 如果线程池状态是 `SHUTDOWN` 并且 `workerQueue` 为空；
    * `workerCount` 为 0；
    * 设置 `TIDYING` 状态成功。
  
  状态转换图如下：
  
  ![image-20220501142705471](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220501142705471.png)

其他字段含义见源码中的注释，有几个重要参数将在下面的构造函数中讲解。

##### 构造方法与线程池重要参数

`ThreadPoolExecutor` 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
    // ...
}
```

这里列出来的参数是必须要掌握的，它们能够控制线程池的性能以及机制：

- `corePoolSize`：**核心线程数量**。

  当有新任务通过 `execute` 方法提交时 ，线程池会执行以下判断：
  
  - 如果运行的线程数少于 `corePoolSize`，则创建新线程来处理任务，即使线程池中的其他线程是空闲的，此时创建的线程称之为**核心线程**
  - 如果线程池中的线程数量大于等于 `corePoolSize` 且小于 `maximumPoolSize`，则只有当 `workQueue` 满时才创建新的线程去处理任务，此时创建的线程也叫**非核心线程**
  - 如果运行的线程数量大于等于 `maximumPoolSize`，这时如果 `workQueue` 已经满了，则使用 `handler` 所指定的策略来处理任务
  
  所以，任务提交时，判断的顺序为 `corePoolSize` => `workQueue` => `maximumPoolSize`。
  
  > 如果设置的 `corePoolSize` 和 `maximumPoolSize` 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 `workQueue` 未满，则将请求放入 `workQueue` 中，等待有空闲的线程去从 `workQueue` 中取任务并处理；
  
  在接下来的 `execute` 原理中你会对这个判断流程有更深刻的理解。
  
- `maximumPoolSize`：**最大线程数量**。
  
  如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。

  值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。

- `keepAliveTime` ：**线程保持活动的时间**。
  
  当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`。

  所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。

- `unit`：**`keepAliveTime` 的时间单位**。

  有 7 种取值。可选的单位有天（`DAYS`），小时（`HOURS`），分钟（`MINUTES`），毫秒（`MILLISECONDS`），微秒（`MICROSECONDS`, 千分之一毫秒）和毫微秒（`NANOSECONDS`，千分之一微秒）。

- `workQueue`：**等待执行的任务队列**，用于保存等待执行的任务的阻塞队列。 
  
  可以选择以下几个阻塞队列。

  - `ArrayBlockingQueue`：**有界阻塞队列**。
    
  - `LinkedBlockingQueue`：**无界阻塞队列**。
    
    使用 `LinkedBlockingQueue` 意味着 `maximumPoolSize` 将不起作用，线程池能创建的最大线程数为 `corePoolSize`，因为任务等待队列是无界队列。
    
  - `SynchronousQueue`：**不会保存提交的任务，而是将直接新建一个线程来执行新来的任务的队列**。
    
    使用这个队列意味着每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。
    
  - `PriorityBlockingQueue`：**具有优先级的无界阻塞队列**。
  
- `threadFactory`：**线程工厂**。

  可以通过线程工厂给每个创建出来的线程设置更有意义的名字。

  > **`ThreadFactory`**
  >
  > 这是一个接口，表示线程工厂，只定义了一个方法 `Thread newThread(Runnable r)` 用来生产线程。
  >
  > 在 `Executors` 类中提供了静态方法用于获取 JDK 实现的线程工厂。

- `handler`：**饱和策略，也叫拒绝策略**。
  
  它是 `RejectedExecutionHandler` 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：

  - `AbortPolicy`：丢弃任务并抛出异常。默认为该策略。
  - `DiscardPolicy`：丢弃任务，但不抛出异常。
  - `DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。
  - `CallerRunsPolicy`：直接在调用 `execute` 方法的线程中调用 `run` 方法并且阻塞执行。
  
  如果以上策略都不能满足需要，也可以通过实现 `RejectedExecutionHandler` 接口来定制处理策略。如记录日志或持久化不能处理的任务。

##### `execute` 原理

线程池最为核心的方法就是 `execute`，`execute` 配合内部的一个 `addWorker` 方法一起实现整个线程池的执行流程。

使用下面的这张图可以概括：

![图片](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/640)

首先是 `execute` 方法的源码：

```java
public void execute(Runnable command) {
    // 如果任务为 null，则抛出异常
    if (command == null)
        throw new NullPointerException();
    
    int c = ctl.get();
    // 如果 workerCount < 核心线程数
    if (workerCountOf(c) < corePoolSize) {
        // 新建一个线程，把任务交给它运行
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 如果 workerCount >= 核心线程数，则来到这里
    // 如果线程池处于 RUNNING 状态，才允许加入到队列中，
    if (isRunning(c) && workQueue.offer(command)) {
        // 重新检查
        int recheck = ctl.get();
        // 如果重新检查的结果是不在 RUNNING 状态，则移除
        if (! isRunning(recheck) && remove(command))
            // 通过给定的拒绝策略拒绝该任务
            reject(command);
        // 如果重新检查发现当前 workerCount 为 0，则创建新线程执行
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 到这一步时，workCount 已经 >= 核心线程数，且 workQueue.offer(command) 失败，说明队列已经满了，此时试着创建一个新线程
    // 如果创建新线程失败，执行拒绝策略
    else if (!addWorker(command, false))
        reject(command);
}
```

`addWorker` 方法并不只是简单的创建线程，还会对当前线程池的状态进行判断，源码如下：

```java
// firstTask 表示新线程应该首先运行的任务
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        // 获取线程池的状态
        int c = ctl.get();
        int rs = runStateOf(c);

        // 检查线程池状态
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            //获取线程池中工作的线程的数量
            int wc = workerCountOf(c);
            // 这里检查 wc 是否超过线程池的参数限制
            // 如果 core 参数为 true，表明使用核心线程数量判断，此时说明走了 execute 中 workerCount < 核心线程数的流程
            // 如果 core 参数为 false，表明走了 workerCount >= 核心线程数的流程，使用 maximumPoolSize 判断
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // CAS 将 workcount 的数量加 1，成功直接退出循环，否则重试
            if (compareAndIncrementWorkerCount(c))
                break retry;
            
            // 如果线程的状态改变了就再次执行上述操作
            c = ctl.get();
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }
    // 标记工作线程是否启动成功
    boolean workerStarted = false;
    // 标记工作线程是否创建成功
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            // 加锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // 获取线程池状态
                int rs = runStateOf(ctl.get());
                // rs < SHUTDOWN 表示 rs 为 RUNNING
                // (rs == SHUTDOWN && firstTask == null) 时也可以运行，因为 SHUTDOWN 表示线程池虽然关闭，但是还可以处理任务
                // 其他情况都不允许运行
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    // 更新当前工作线程的最大容量
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    // 更新标志位
                    workerAdded = true;
                }
            } finally {
                // 释放锁
                mainLock.unlock();
            }
            // 如果成功添加工作线程，则调用 Worker 内部的线程实例 t 的 start() 方法启动真实的线程实例
            if (workerAdded) {
                t.start();
                // 标记线程启动成功
                workerStarted = true;
            }
        }
    } finally {
        // 线程启动失败，需要从工作线程中移除对应的Worker
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

##### `runWorker` 原理

上面的 `addWorker` 方法中，我们看到一旦成功添加了工作线程，那么就**会调用 `Worker` 内部一个线程对象的 `start` 方法**，`Worker` 本身就是一个 `Runnable`，我们来看一下它的定义：

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
    // ...
    
    final Thread thread;
    
    Runnable firstTask;
    
    volatile long completedTasks;

   
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }
    
    public void run() {
        runWorker(this);
    }
    
    // ...
}
```

这里我们注意到，`Worker` 不仅实现了 `Runnable`，还继承了 AQS，等会我们再讨论这个问题，我们重点关注其构造函数：

```java
Worker(Runnable firstTask) {
    setState(-1); // inhibit interrupts until runWorker
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
}
```

这里是以自身为线程主体创建线程，赋给自己内部的 `thread` 变量。因此，我们上面看到的**调用 `t.start()` 实际上是最后来到了 `Worker` 的 `run` 方法**，而 `run` 方法又把自己委托给了 `runWorker` 方法，所以这个方法才是执行的核心。

源码如下：

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    
    // 首先把 firstTask 获取到，然后置为 null，防止重复获取
    Runnable task = w.firstTask;
    w.firstTask = null;
    
    w.unlock(); // 设置允许中断
    boolean completedAbruptly = true;
    try {
        // 如果存在 firstTask，或者能够获取到 task，则进入循环体执行 task
        while (task != null || (task = getTask()) != null) {
            // 设置独占锁，除了防止被其他工作线程抢占之外，还可以帮助外部根据锁的状态判断当前任务的执行情况
            w.lock();
            
            // runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))，这个条件表示线程池停止了
            // !wt.isInterrupted() 表示 worker 未被中断
            // 整个判断为真的两种情况
            // 1. 如果线程池状态大于等于 STOP 且未设置中断状态，表示要关闭线程池了
            // 2. 第一次判断的时候线程池状态不大于 STOP，且当前设置了中断状态（Thread.interrupted() 把中断状态又清除了）且设置完了之后线程池状态又大于等于 STOP 了，则还是说明线程池要关闭了，需要设置中断
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            
            try {
                // 回调
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    // 真正执行任务
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    // 回调
                    afterExecute(task, thrown);
                }
            } finally {
                // 把任务删掉
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        // 回调
        processWorkerExit(w, completedAbruptly);
    }
}
```

`getTask` 也是很关键的方法，它获取任务然后交给工作线程执行，源码如下：

```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 判断线程池是否已经关闭
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        // 获取当前 worker 数量
        int wc = workerCountOf(c);

        // 是否设置超时时间  allowCoreThreadTimeOut 默认是 false   
        // 判断线程池数量是否大于核心线程数，如果大于的话 timed 为 true
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        // wc > maximumPoolSize 说明当前的工作线程总数大于 maximumPoolSize，timed && timedOut 说明超时了，上一轮没有拿到任务
        // wc > 1 || workQueue.isEmpty() 说明此时仍然有工作线程，但是工作队列却为空
        // 满足上述两个条件，则减少工作线程数量
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            // 这里 timed 为 ture 的时候，采用阻塞队列中带超时时间的获取元素的方法，否则采取一直阻塞的方法
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
            workQueue.take();
            if (r != null)
                return r;
            // 未获取到，设置超时标记
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

注意中间那一段的 `if` 判断，如果成功减少了工程线程数量，返回了 `null`，会导致 `runWorker` 也跳出循环，之后执行 `processWorkerExit()` 方法处理后续工作，而该非核心线程对应的 `Worker` 则变成“游离对象”，等待 GC 回收。

如果 `allowCoreThreadTimeOut` 为 `true`，则无论是什么类型的工作线程都有可能被回收掉，否则只有非核心线程才会被回收掉。

### `Executors`

JDK 的 `Executors` 类中提供了几种具有代表性的线程池，这些线程池**都是基于 `ThreadPoolExecutor` 的定制化实现**。

该类提供了以下几类线程池：

* `SingleThreadExecutor`：**只包含单个线程的线程池**。

  只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。**如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它** 。

  单工作线程最大的特点是：**可保证顺序地执行各个任务**。

* `FixedThreadPool`：**固定大小的线程池**。

  **每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中**。

  `FixedThreadPool` 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。

* `CachedThreadPool`：**大小无限的、可缓存的线程池**。

  - 如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；
  - 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。

  使用 `CachedThreadPool` 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。

* `ScheduledThreadPool`：**大小无限的线程池，此线程池支持定时以及周期性执行任务的需求**。

所有上述线程池都可以通过 `ThreadPoolExecutor` 手动创建，也就是说，它们并不是单独的类，而是通过改变线程池创建时的参数得到的：

* 当核心和最大线程数都设置为 1，且未设置超时时间，阻塞队列使用 `LinkedBlockingQueue` 的默认构造函数得到（无界），则得到了一个 `SingleThreadExecutor`。

* 当核心和最大线程数都设置为传入的参数，且未设置超时时间，阻塞队列使用 `LinkedBlockingQueue` 的默认构造函数得到（无界），则得到了一个 `FixedThreadPool`。

* 当核心线程数设置为 0，最大线程数设置为 `Integer.MAX_VALUE`，且超时时间为 60s，阻塞队列使用 `SynchronousQueue`，则得到了一个 `CachedThreadPool`。

* 当核心线程数为传入的参数，最大线程数设置为 `Integer.MAX_VALUE`，且不设置超市时间，阻塞队列使用 `DelayedWorkQueue`（`SechduledThreadPoolExecutor` 的内部类），则得到 `ScheduledThreadPool`。

  换句话说，直接使用 `SechduledThreadPoolExecutor` 的构造方法就可以得到一个 `ScheduledThreadPool`。

虽然 `Executors` 提供了很多便利的方法用于产生线程池，但是阿里巴巴的开发规范中仍然要求不使用 `Executors`，而是直接通过 `ThreadPoolExecutor` 创建线程池。

`Executors` 返回的线程池对象的弊端如下：

- **`FixedThreadPool` 和 `SingleThreadExecutor`** ： 使用的队列时无界队列，也就是长度为 `Integer.MAX_VALUE`，可能堆积大量的请求，从而导致 OOM。
- **`CachedThreadPool` 和 `ScheduledThreadPool`** ： 允许传入的 maximumPoolSize 为 `Integer.MAX_VALUE`，可能会创建大量线程，从而导致 OOM。

除此之外，`Executors` 提供了**获取线程工厂**的方法以及**将 `Runnable` 转换为 `Callable` 的方法**，感兴趣的读者可以自行阅读源码以及介绍。

### 线程池最佳实践

#### 使用 `ThreadPoolExecutor` 手动创建线程池

刚才我们也说过了，使用 `Executors` 创建的线程池容易 OOM，因此我们尽量使用构造函数自己设置参数。

使用 `Executors` 创建的线程池导致 OOM 的原因就是队列无界，或者没有对线程池的最大数量作出限制，因此我们在设定参数的时候也要避免这些问题，**尽量使用有界的阻塞队列**，并且要合理的设置线程池大小（即将介绍）。

#### 确定线程池的大小

线程池大小的确定一直是困扰着程序员的一个难题，大部分程序员在设定线程池大小的时候就是随心而定。很多人甚至可能都会觉得把线程池配置过大一点比较好，但是**线程池的大小并不是越大越好的，线程数量过多会增加上下文切换成本**。

**如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。**

因此，线程池的大小既不能过大，也不能过小，下面是一个经验，可以帮助程序员确定线程池的大小：

- 对于 **CPU 密集型任务**来说，这种任务消耗的主要是 CPU 资源，**可以将线程数设置为 N（CPU 核心数）+ 1**，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- 对于 **I/O 密集型任务**来说，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，通常是 2N（CPU 核心数）。

> 但凡涉及到网络读取，文件读取这类都是 I/O 密集型任务，这类任务的特点是 CPU 计算耗费时间相比于等待 I/O 操作完成的时间来说更少，大部分时间都花在了等待 I/O 操作完成上。

#### 监测线程池运行状态

我们可以利用 `ThreadPoolExecutor` 的相关 API 对线程池做一个简陋的监控。从下图可以看出，`ThreadPoolExecutor`提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。

![image-20220501232711399](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220501232711399.png)

#### 不同的业务中使用不同的线程池

很多人在实际项目中都会有类似这样的问题：**我的项目中多个业务需要用到线程池，是为每个线程池都定义一个还是说定义一个公共的线程池呢？**

一般建议是**不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置**，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。

#### 给线程池命名

初始化线程池的时候需要显式命名（设置线程池名称前缀），如果发生了问题，则有利于定位问题的所在。

默认情况下创建的线程名字类似 pool-1-thread-n 这样的，没有业务含义，不利于我们定位问题。

给线程池里的线程命名通常有下面两种方式：

1. 利用其他工具类封装好的 API。

   比如 Google guava 的 `ThreadFactoryBuilder`：

   ```java
   ThreadFactory threadFactory = new ThreadFactoryBuilder()
                           .setNameFormat(threadNamePrefix + "-%d")
                           .setDaemon(true).build();
   ExecutorService threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)
   ```

2. 自己实现 `ThreadFactory`。

   比如：

   ```java
   public final class NamingThreadFactory implements ThreadFactory {
       private final AtomicInteger threadNum = new AtomicInteger();
       private final ThreadFactory delegate;
       private final String name;
   
       /**
        * 创建一个带名字的线程池生产工厂
        */
       public NamingThreadFactory(ThreadFactory delegate, String name) {
           this.delegate = delegate;
           this.name = name;
       }
   
       @Override 
       public Thread newThread(Runnable r) {
           Thread t = delegate.newThread(r);
           t.setName(name + " [#" + threadNum.incrementAndGet() + "]");
           return t;
       }
   }
   ```

## 其他并发工具

### `Semaphore`（信号量）

`Semaphore` 字面意思为**信号量**，用来控制某段代码块的并发数。

`Semaphore` 管理着一组虚拟的许可（permit），也就是信号量本身，permit 的初始数量可通过构造方法来指定。每次执行 `acquire` 方法可以获取一个 permit，如果没有就等待；而 `release` 方法可以释放一个 permit。

信号量的核心思想是：当 permit 大于 1 时，线程可以获取一个许可，然后将 permit - 1。直到 permit 等于 0，此时线程进入休眠状态，当某个线程释放许可后，permit + 1，之前进入休眠的线程将被唤醒并再次试图获得 permit。

![image-20220307150729974](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220307150729974.png)

信号量大量应用于操作系统的进程管理中，信号量的增加减少我们称之为 PV 操作，这是两个硬件原语，用于对具体信号量进行操作。定义如下：

* `P(S)`：将信号量 S - 1；如果 S > 0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。
* `V(S)`：将信号量 S + 1

用户在使用 PV 操作信号量时，PV 操作必须成对出现，否则可能导致死锁等问题。

> 信号量和锁/条件变量是等价的，当信号量的取值为 1 时，就是锁；而且由于信号量 < 0 时会进入休眠，则完全可以作为条件变量。

#### 应用

`Semaphore` 提供了 2 个构造方法：

```java
// 参数 permits 表示许可数目，即同时可以允许多少线程进行访问
public Semaphore(int permits);
// 参数 fair 表示是否是公平的，即等待时间越久的越先获取许可
public Semaphore(int permits, boolean fair);
```

除此之外，`Semaphore` 提供了获取和释放信号量的操作：

```java
// 获取 1 个许可
public void acquire();
// 获取 permits 个许可
public void acquire(int permits);
// 释放 1 个许可
public void release();
// 释放 permits 个许可
public void release(int permits);
```

使用示例：

```java
public class SemaphoreDemo {
    private static final int THREAD_COUNT = 30;

    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);

    private static Semaphore semaphore = new Semaphore(10);

    public static void main(String[] args) {
        for (int i = 0; i < THREAD_COUNT; i++) {
            threadPool.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        semaphore.acquire();
                        System.out.println("save data");
                        semaphore.release();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }

        threadPool.shutdown();
    }
}
```

### `CountDownLatch`（倒计时器）

字面意思为 **递减计数锁**。用于**控制一个线程等待多个线程**。

`CountDownLatch` 维护一个**计数器 count，表示需要等待的事件数量**。`countDown` 方法递减计数器，表示有一个事件已经发生。**调用 `await` 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时**。

可以用下面这张图表示其原理：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/CountDownLatch.png)

#### 应用

`CountDownLatch` 唯一的构造方法需要一个倒计时的值：

```java
// 初始化计数器
public CountDownLatch(int count);
```

`CountDownLatch` 提供了其他的一些重要方法：

* `void await()`：调用 `await()` 方法的线程会被挂起，它会等待直到 count 值为 0 才继续执行
* `boolean await(long timeout, TimeUnit unit)`：和 `await()` 类似，只不过等待一定的时间后 count 值还没变为 0 的话就会继续执行
* `void countDown()`：将统计值 count 减 1
* `long getCount()`：获取统计值

使用示例：

```java
public class CountDownLatchDemo {
    public static void main(String[] args) {
        final CountDownLatch latch = new CountDownLatch(2);

        new Thread(new MyThread(latch)).start();
        new Thread(new MyThread(latch)).start();

        try {
            System.out.println("等待2个子线程执行完毕...");
            latch.await();
            System.out.println("2个子线程已经执行完毕");
            System.out.println("继续执行主线程");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    static class MyThread implements Runnable {
        private CountDownLatch latch;

        public MyThread(CountDownLatch latch) {
            this.latch = latch;
        }

        @Override
        public void run() {
            System.out.println("子线程" + Thread.currentThread().getName() + "正在执行");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("子线程" + Thread.currentThread().getName() + "执行完毕");
            latch.countDown();
        }
    }
}
```

### `CyclicBarrier`（循环栅栏）

**`CyclicBarrier` 可以让一组线程等待至某个状态（遵循字面意思，不妨称这个状态为栅栏，也有人称它为屏障）之后再全部同时执行**。

之所以叫循环栅栏是因为：**当所有等待线程都被释放以后，`CyclicBarrier` 可以被重用**。

`CyclicBarrier` 是基于 `ReentrantLock` 和 `Condition` 实现的。

`CyclicBarrier` 应用场景：`CyclicBarrier` 在并行迭代算法中非常有用。

可以用下面这张图表示其原理：

![image-20220318163806155](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220318163806155.png)

只有 ABCD 都来到屏障后才能通过屏障，先来到屏障的线程只能 `await`。

#### 应用

`CyclicBarrier` 提供了 2 个构造方法

```java
public CyclicBarrier(int parties);
public CyclicBarrier(int parties, Runnable barrierAction);
```

参数说明：

- `parties`：`parties` 数相当于一个阈值，当有 `parties` 数量的线程在等待时， `CyclicBarrier` 处于栅栏状态（等待状态结束）。
- `barrierAction`：当 `CyclicBarrier` 处于栅栏状态时执行的动作。

其他重要方法：

* `int getParties()`：获取屏障数。

* `int await()`：等待调用 `await()` 的线程数达到屏障数。

  如果当前线程是最后一个到达的线程，并且在构造函数中提供了非空屏障操作，则当前线程在允许其他线程继续之前运行该操作。

  如果在屏障动作期间发生异常，那么该异常将在当前线程中传播并且屏障被置于断开状态。

* `int await(long timeout, TimeUnit unit)`：相比于 `await()` 方法，这个方法让这些线程等待至一定的时间，如果还有线程没有到达栅栏状态就直接让到达栅栏状态的线程执行后续任务。

* `boolean isBroken()`：查询此屏障是否处于损坏状态。

* `void reset()`：将屏障重置为初始状态。

* `int getNumberWaiting()`：返回正在 `await` 的数目。

> `CountDownLatch`  和 `CyclicBarrier` 都能够实现线程之间的等待，只不过它们侧重点不同：
>
> - `CountDownLatch` 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；
> - `CyclicBarrier` 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；
>
> 另外，`CountDownLatch` 是不可以重用的，而 `CyclicBarrier` 是可以重用的。
