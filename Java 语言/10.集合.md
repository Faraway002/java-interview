[TOC]

# 集合

## 1. 概述

Java 集合，也叫作容器，用于存放数据（对象），然后通过操作容器对这些数据进行增删改查。

Java 中还可以使用数组存储数据，二者区别如下：

* 数组长度固定，如果要变换数组长度十分麻烦；容器长度可变，更加灵活。
* 数组既可以存储基本数据类型，也可以存储类类型；而容器只能存储类类型（基本类型要存储为对应的包装类）

Java 集合是一系列接口和类组成的，也叫做集合框架。**主要是由两大接口派生而来：一个是 `Collection` 接口，主要用于存放单一元素，下面又有三个主要的子接口：`List`、`Set` 和 `Queue`；另一个是 `Map` 接口，主要用于存放键值对。**

集合框架概览图如下：

![image-20220205162259137](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220205162259137.png)

![image-20220205163936395](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220205163936395.png)

之所以这样设计容器的继承层次，是因为**容器底层的数据结构不同，在不同的场景下性能不同**。一般定义容器时，会使用 `List`、`Set`、`Queue` 以及 `Map` 这四个基本接口定义变量来接收子类对象。当场景变化时，我们可以很容易的修改这个变量的子类实现。

集合框架中，还有几个其他的工具类库：`Arrays` 类为数组提供了工具支持，而 `Collections` 类为容器提供了支持。

**所有的容器都是泛型的**。

## 2. 核心接口

Java 集合框架中的核心接口有四个：`List`、`Queue`、`Set` 以及 `Map`。所有的容器都由这四个接口派生而来。

下面列出了这四个接口的区别：

* `List`（列表）：存储的元素是**有序的、可重复的**。可以看作是更加灵活的数组，需要顺序存储元素时首选该类型的容器。

* `Set`（数学意义上的集合）：存储的元素是**无序的、不可重复的**。当存储的元素不在意顺序，并且不在乎出现的次数时，首选该类型的容器。最常见的应用是对数据去重。

* `Queue`（队列）：按**特定的排队规则来确定先后顺序**，存储的元素是有序的、可重复的。当需要一个先进先出的队列时首先该类型的容器。

* `Map`（键值对，也叫字典）：使用**键值对（key-value）存储**，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

  `Map` 可以看作是索引可以为任何类型元素的数组，访问速度很快，当需要一一对应关系时，且数组（列表）不是很好处理时，首选这类容器。

除此之外，容器中难免涉及到排序的操作，因此 `Comparable` 接口和 `Comparator` 也是必须要掌握的内容。

**`Comparable` 接口表示可比较的，它是一个泛型的函数式接口，只有一个 `int compareTo(T o)` 方法用作比较：如果返回值是负数，则表示调用者比较小；如果返回值是 0，则两者一样大；如果返回值是正数，则是调用者比较大**。如果要让容器进行排序，或者使用一个自排序的容器，容器存储的类型就必须实现该接口。

如果想要在不实现 `Comparable` 接口的情况下完成上述操作，则必须提供一个**比较器（`Comparator`）**。它也是一个泛型的**函数式接口**，但是它有很多默认方法。**开发者需要实现的只有 `int compare(T o1, T o2)` 比较方法：如果返回值是负数，则表示第一个参数更小；如果返回值是 0，则两者一样大；如果返回值是正数，则是第一个参数更大。**

很多排序方法和排序容器都支持这两种方式，更受人喜爱的是使用比较器，因为它把比较的代码和类代码解耦了。

> **并发与容器**
>
> 并发访问容器是非常危险的，有些容器本身支持并发访问，而大部分容器是不支持的。
>
> 使用 `Collections` 提供的工具方法可以获取一个并发容器，容器还有专门的同步容器，我们将在之后的并发章节详细介绍。

大部分容器还实现了迭代器模式，通过迭代器可以遍历整个容器，我们很快就要介绍它。

## 3. 迭代器

迭代器模式是一种行为型模式（参见设计模式系列教程），它的目的是**提供一种顺序访问容器的元素而不暴露其底层表示的方法**。

在 Java 中，迭代器模式由 `Iterable` 接口、`Iterator` 接口以及它们的实现类组成。所有实现了 `Iterable` 接口的类都可以通过 for-each 循环遍历，**for-each 循环的本质是通过容器中的 `Iterator` 对容器里的每个元素进行访问**。

`Iterable` 表示可迭代的，需要实现的方法为：`Iterator<T> iterator()`，用于获取一个 `Iterator`。

`Iterator` 是迭代器，通过迭代器可以实现遍历。它的定义如下：

```java
public interface Iterator<E> {
	/**
	 * 如果本次迭代中有更多元素，则返回 true
     * 可以作为迭代结束的依据
	 */
    boolean hasNext();

    /**
     * 获取本次迭代中的下一个元素
     */
    E next();

    /**
     * 移除容器中最近一次调用 next() 时的元素
     * 在某一轮中，如果只调用了 remove 而没有调用 next，或者调用 remove 限于 next，则会抛异常
     */
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    /**
     * 对剩余元素进行 action 操作，直到所有元素都执行了 action 或抛出异常了才停止
     */
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

要自己实现迭代器，必须要重写的方法是 `next` 以及 `hasNext`，这是迭代进行的必要条件。

因此，我们可以利用迭代器进行迭代，代码如下：

```java
Iterator<Integer> it = ...;
while (it.hasNext()) {
    Integer num = it.next();
    // ...
}
```

**除了 `Map` 系列的容器，其他所有容器都支持迭代器，因为 `Collection` 继承了 `Iterable` 接口。**

如果定义了自己的容器，那么要让容器支持 for-each 循环，则也需要实现 `Iterable` 接口，并且完成一个迭代器。

迭代器一般定义在容器类的内部，假设我们自己实现了一个类叫做 `ListByArray<T>`，在这里并不讲述具体实现的细节，只介绍它的功能：一个列表，底层使用数组实现。

这时，我们需要定义一个迭代器，下面是参考实现：

```java
class ListByArray<T> implements Iterable<T> {
    private T[] data;
    
    // 当前容器已经使用的长度
    private int size;

    // ...

    @Override
    public Iterator<T> iterator() {
        return null;
    }
    
    private class ListByArrayIterator implements Iterator<T> {
        // 游标
        private int cursor;
        
        @Override
        public boolean hasNext() {
            return cursor != size;
        }
        
        @Override
        public T next() {
            T cur = data[cursor];
            cursor++;
            return cur;
        }
    } 
}
```

迭代器内部应该要维护一个索引，而且每次迭代最好使用一个新的迭代器，即不要复用之前的迭代器。

> **`Enumeration`**
>
> 这个类是在 `Iterator` 未出现之前的类似迭代器的类型。在一些老式的容器中还可以见到它，新的容器都会直接使用迭代器，我们会在具体容器介绍时会说明这一点。
>
> `Enumration` 包含两个重要方法：
>
> * `E nextElement()`
> * `boolean hasMoreElements()`
>
> 这些方法和迭代器中的两个重要方法十分相似，它还可以通过 `asIterator` 方法获取一个等价的迭代器。

## 4. `Collection`

本节将从上到下介绍基于 `Collection` 的容器，对于使用的较多的容器，我们会进行源码级别的分析，源码大版本基于 JDK 8，不保证 JDK 8 之后的和 JDK 8 的一致。

`Collection` 接口是 `List`、`Queue` 以及 `Set` 的父接口，是最通用的接口。

下面介绍它的一些方法，这些方法对所有它的子类容器都适用：

| 方法                                        | 作用                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| `int size()`                                | 获取容器的大小                                               |
| `boolean isEmpty()`                         | 判断容器是否为空                                             |
| `boolean contains(Object o)`                | 判断容器中是否包含 o                                         |
| `Iterator<E> iterator()`                    | 获取容器的迭代器                                             |
| `Object[] toArray()`                        | 将容器转换为数组                                             |
| `<T> T[] toArray(T[] a)`                    | 使用一个容器的泛型类型的数组接收容器中的元素，如果数组足够大接收整个容器，数组的剩余元素会被置为 null；否则，会创建一个新的足够大的数组，接收完毕以后返回 |
| `boolean add(E e)`                          | 添加一个元素到容器中，如果此容器因此调用而更改，则返回 true  |
| `boolean remove(Object o)`                  | 从容器中删除指定元素，如果此容器因此调用而更改，则返回 true  |
| `boolean containsAll(Collection<?> c)`      | 如果调用者包含指定容器中的所有元素，则返回 true              |
| `boolean addAll(Collection<? extends E> c)` | 向调用者中添加指定容器中的所有元素，如果此容器因此调用而更改，则返回 true |
| `boolean removeAll(Collection<?> c)`        | 移除调用者中的所有的包含在指定容器中的元素，如果此容器因此调用而更改，则返回 true |
| `boolean retainAll(Collection<?> c)`        | 仅保留调用者中的包含在指定容器中的元素，如果此容器因此调用而更改，则返回 true |
| `void clear()`                              | 清空容器                                                     |

还有几个和流有关的默认方法，这里就不展示了。

对于容器的开发者来说，直接实现 `Collection` 需要实现的方法太多了，因此 Java 还提供了一个 `AbstractCollection` 抽象类，这个类除了 `size()` 和 `iterator()` 方法仍然保留未实现，其他都提供了一个默认的实现。

`AbstractCollection` 还提供了一个 `toString` 的重写，这个重写会打印容器中的所有元素，以 `,` 分隔，调试时比较友好。

> **打印数组**
>
> 数组虽然是对象，但是并未重写 `toString` 方法，这时就需要使用 `Arrays.toString` 方法，该方法接受一个一维数组，可以打印数组中的所有元素。

### 4.1 `List`

`List` 是一个接口，它继承于 `Collection`，它代表着有序的列表。

`List` 相比于 `Collection`，多了一些方法，如下表所示：

| 方法                                                   | 作用                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| `boolean addAll(int index, Collection<? extends E> c)` | 将指定容器中的所有元素插入到此列表中的指定位置               |
| `void sort(Comparator<? super E> c)`                   | 利用传入的比较器进行容器的排序                               |
| `E get(int index)`                                     | 获取指定位置上的元素                                         |
| `E set(int index, E element)`                          | 替换指定位置上的元素为指定的值                               |
| `void add(int index, E element)`                       | 在指定位置上添加指定的元素，原本该位置上的元素及其之后的元素会往后移动一格 |
| `E remove(int index)`                                  | 删除指定位置上的元素                                         |
| `int indexOf(Object o)`                                | 返回指定元素在列表中的索引，如有多个匹配，返回第一个；如果没有匹配，返回 -1 |
| `int lastIndexOf(Object o)`                            | 返回指定元素在列表中的索引，如有多个匹配，返回最后一个；如果没有匹配，返回 -1 |
| `ListIterator<E> listIterator()`                       | 获取 List 的定制迭代器                                       |
| `ListIterator<E> listIterator(int index)`              | 获取 List 的定制迭代器，该迭代器将从指定位置开始遍历         |
| `List<E> subList(int fromIndex, int toIndex)`          | 截取子列表（包括起点，不包括终点）；如果起点等于终点，返回空列表；如果起点大于终点，则抛出异常。<BR>这个子列表不是一个新的列表，对该子列表的修改会反映在调用者中 |

`AbstractList` 是一个抽象类，它继承于 `AbstractCollection`，`AbstractList` 实现了 `List` 接口中除 `size()`、`get()` 之外的方法。

#### 4.1.1 `ListIterator`

`ListIterator` 是 `Iterator` 的子接口，专用于 `List` 的容器，它允许以任意方向（向前或向后）遍历容器，并且能够增删改容器中的元素。

方法如下所示，方法的作用和它们的名字一致：

* `boolean hasNext()`
* `E next()`
* `boolean hasPrevious()`
* `E previous()`
* `int nextIndex()`
* `int previousIndex()`
* `void remove()`
* `void set(E e)`
* `void add(E e)`

#### 4.1.2 `ArrayList`

`ArrayList` 是 `List` 的主要实现，可以说是使用的最频繁的容器。它的底层采用一个 `Object[] elementData` 数组存储元素，因此数组的优良性质它都具备。它还能够自动扩容，更重要的是，在添加大量元素之前还能够调用方法进行手动扩容，以便减少自动扩容的次数，增加性能。

`ArrayList` 的定义如下：

```java
public class ArrayList<E> extends AbstractList<E> 
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {

}
```

其中，`RandomAccess` 是一个标记接口，表明实现这个这个接口的 `List` 集合支持**快速随机访问**。这是因为 `ArrayList` 底层是数组，数组本身支持快速随机访问，因此 `ArrayList` 毫无疑问也支持快速随机访问。

> **随机访问**
>
> 指的是指定一个索引能够取出容器中该索引处的元素。所有类型的 `List` 都提供了随机访问的 API，只是访问的速度不同罢了。
>
> 由于 `ArrayList` 的底层特点，它的随机访问速度非常快，因此实现了 `RandomAccess` 接口。而与它相似的 `LinkedList` 底层是链表，在头尾的访问速度很快，但是访问中间的某个元素就不那么快了，因此它并没有实现 `RandomAccess`。
>
> 实际中，我们可能接收一个 `List`，但是并不清楚它具体是什么 `List`，这时候可以使用 `instanceof RandomAccess` 来判断是否支持快速访问，以决定在代码中该如何使用这个容器。

##### 4.2.1 `ArrayList` 的底层数据结构

`ArrayList` 包含了两个重要的元素：`elementData` 和 `size`。

```java
// 默认初始化容量
private static final int DEFAULT_CAPACITY = 10;
// 对象数组
transient Object[] elementData;
// 数组长度
private int size;
```

- `DEFAULT_CAPACITY`：使用默认构造函数初始化 `ArrayList` 时底层数组的容量，默认为 10。
- `size`：是动态数组的实际大小。
- `elementData`：是一个 `Object` 数组，用于保存添加到 `ArrayList` 中的元素。

##### 4.2.2 `ArrayList` 构造方法

`ArrayList` 类实现了三个构造函数：

- 第一个是默认构造方法，`ArrayList` 会创建一个**空数组**。
- 第二个是创建 `ArrayList` 对象时，传入一个初始化值，会**立即用这个容量初始化一个数组**。
- 第三个是传入一个集合类型进行初始化。

当 `ArrayList` 新增元素时，如果所存储的元素已经超过其当前容量，它会计算容量后再进行动态扩容。数组的动态扩容会导致整个数组进行一次内存复制。因此，**初始化 `ArrayList` 时，指定数组初始大小，有助于减少数组的扩容次数，从而提高系统性能**。

相关源码分析：

```java
public ArrayList() {
    // DEFAULTCAPACITY_EMPTY_ELEMENTDATA 是一个长度为 0 的空数组
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        // 根据初始化值创建数组大小
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        // 初始化容量为 0 时，使用空数组
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
    }
}

public ArrayList(Collection<? extends E> c) {
    // 把容器转换为数组
    Object[] a = c.toArray();
    if ((size = a.length) != 0) {
        if (c.getClass() == ArrayList.class) {
            // 如果原来的容器就是 ArrayList，则直接让底层数组指向转换后的数组，因为 a 一定是 Object[]
            elementData = a;
        } else {
            // 否则，调用 Arrays.copyOf 拷贝元素，并把拷贝后的数组转换为 Object[]，因为 Collection 的 toArray 可能不返回 Object[]
            elementData = Arrays.copyOf(a, size, Object[].class);
        }
    } else {
        // replace with empty array.
        elementData = EMPTY_ELEMENTDATA;
    }
}
```

注意观察**空参数的构造函数，它并没有立即创建一个默认容量的数组**，而是用一个空的代替，之后**在第一次添加元素时才会使用默认容量进行初始化**，随后就会讲解到这一点。

##### 4.2.3 `ArrayList` 访问元素

`ArrayList` 访问元素的实现主要基于以下关键性源码：

```java
// 获取第 index 个元素
public E get(int index) {
    // 下标范围检查
    rangeCheck(index);
    return elementData(index);
}

// 从数组中取出元素
E elementData(int index) {
    return (E) elementData[index];
}
```

实现非常简单，其实就是**通过数组下标访问数组元素，其时间复杂度为 $O(1)$**。

##### 4.2.4 `ArrayList` 添加元素

`ArrayList` 添加元素有两种方法，一种是添加元素到数组末尾，另外一种是添加元素到任意位置。

源码如下：

```java
// 添加元素到数组末尾
public boolean add(E e) {
    // 确保容量足够
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

// 添加元素到任意位置
public void add(int index, E element) {
    // 边界检查
	rangeCheckForAdd(index);

    // 确保容量足够
	ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 通过数组复制后移元素，给要插入的元素腾出位置
	System.arraycopy(elementData, index, elementData, index + 1, size - index);
	elementData[index] = element;
	size++;
}
```

两种添加元素方法的**不同点**是：

- 添加元素到任意位置，会导致在**该位置后的所有元素都需要重新排列**。
- 而添加元素到数组末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。

两种添加元素方法的**共同点**是：添加元素时，会先检查容量大小，**如果发现容量不足，会自动扩容为原始大小的 1.5 倍**。

###### 4.2.4.1 `ArrayList` 的扩容

`ArrayList` 扩容实现主要基于以下关键性源码：

```java
private void ensureCapacityInternal(int minCapacity) {
    // 如果保存元素的数组是空数组
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        // 则从默认大小和传入大小中选择一个最大的作为容量，调用默认构造函数初始化后，第一次调用 add 时，minCapacity 是 size + 1 = 1，因此容量被确定为 DEFAULT_CAPACITY，也就是 10
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        // 使用 grow 方法完成扩容
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    // 旧容量
    int oldCapacity = elementData.length;
    // 新容量 = 旧容量 + 旧容量 / 2 = 1.5 倍旧容量，调用默认构造函数初始化后，第一次调用 add 时，oldCapacity 为 0，因此新容量这里计算出来等于 0
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    // 如果新容量还不足以装下，则新容量就设置为 minCapacity，调用默认构造函数初始化后，第一次调用 add 时，由于上面计算出来是 0，因此这里的分支会被执行，容量确定为 10
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    // 如果新容量超出规定的最大容量，则调用 hugeCapacity 决定一个最终容量
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
 	// 执行扩容
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

`ArrayList` 执行添加元素动作（`add` 方法）时，调用 `ensureCapacityInternal` 方法来保证容量足够。

- 如果容量足够时，将数据作为数组中 `size + 1` 位置上的元素写入，并将 `size` 自增 1。
- 如果容量不够时，需要使用 `grow` 方法进行扩容数组，新容量的大小为 `oldCapacity + (oldCapacity >> 1)`，也就是旧容量的 1.5 倍。扩容操作实际上是调用 `Arrays.copyOf()` 把原数组拷贝为一个新数组，因此最好在创建 `ArrayList` 对象时就指定大概的容量大小，减少扩容操作的次数。

##### 4.2.5 `ArrayList` 删除元素

`ArrayList` 的删除方法和添加元素到任意位置方法有些相似，因为它们都需要进行数组元素的移动。

`ArrayList` 在每一次有效的删除操作后，都要进行数组元素的前移，并且删除的元素位置越靠前，数组前移的开销就越大。具体来说，`ArrayList` 会调用 `System.arraycopy()` 将 `index + 1` 后面的元素都复制到 `index` 位置上。

```java
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved > 0)
        // 移动元素
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    // 置为 null，让 GC 把它回收掉
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
```

##### 4.2.6 容器的 Fail-Fast 机制

在 `ArrayList` 的源码中，我们看到大部分源码都修改了 `modCount`，这个变量定义在 `AbstractList` 中，**用来记录结构发生变化的次数**。

> 结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数据结构的大小，仅仅只是设置元素的值不算结构发生变化。

事实上，大部分**不支持并发的容器**都提供了 `modCount` 变量，也就是 Fail-Fast 机制**，在进行容器序列化**或者**迭代**等操作时，需要**比较操作前后 `modCount` 是否改变，如果发生改变，容器会抛出 `ConcurrentModificationException`，表示有可能发生了并发修改**。

以迭代为例，使用增强 for 循环，本质上是迭代器，迭代器在刚创建时就会拿到创建时的 `modCount` 数量，称之为 `expectedModCount`：

```java
private class Itr implements Iterator<E> {
    // ...
    
    int expectedModCount = modCount;

    // ...
}
```

每次迭代时，都会检查 `expectedModCount` 和 `modCount` 是否相等：

```java
public E next() {
    // 检查 fail-fast
    checkForComodification();
    int i = cursor;
    if (i >= size)
        throw new NoSuchElementException();
    Object[] elementData = ArrayList.this.elementData;
    if (i >= elementData.length)
        throw new ConcurrentModificationException();
    cursor = i + 1;
    return (E) elementData[lastRet = i];
}
```

如果发现不等，就直接抛出异常：

```java
final void checkForComodification() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
}
```

看下面的一个示例：

```java
public class FailFastTest {
    private static List<Integer> list = new ArrayList<>();

    private static class TraverseThread extends Thread {
        @Override
        public void run() {
            Iterator<Integer> iterator = list.iterator();
            while (iterator.hasNext()) {
                int i = iterator.next();
                System.out.println(Thread.currentThread().getName() + ":" + i);
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private static class ModifyThread extends Thread {
        @Override
        public void run() {
            list.remove(3);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            list.add(i);
        }
        new TraverseThread().start();
        new ModifyThread().start();
    }
}
```

![image-20220420170429385](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220420170429385.png)

此示例中，我们设置了两个线程，第一个线程遍历元素，为了使得并发修改能够成功，我们让第一个线程遍历完一个元素后就休息 50ms，第二个线程只是删除其中下标为 3 的元素，由于我们添加了 10 个元素，因此不会越界。

我们看到，当遍历线程遍历完第一个元素后，就进入了 50 ms 的睡眠，此时修改线程成功的修改，`modCount` 相比 `expectedModCount` 多了 1，自然不相等，于是直接抛出异常。

**如果是使用下标的基本迭代，在并发修改下则不会抛出异常，而是可能会越界**，因为使用基本的 for 循环就和迭代器没有关系了，Fail-Fast 机制也就失效了。

##### 4.2.7 数组拷贝

之前我们在反射一章中，有一个例子是扩容数组，在那个例子中，我们手动遍历原数组，然后把每一个元素设置到它在新数组中的位置上。

`System` 和 `Arrays` 都提供了拷贝数组的方法，在 `ArrayList` 中被大量使用，下面就来分析一下两个方法的异同：

* `System.arraycopy()` 是一个本地方法，签名为：

  ```java
  public static native void arraycopy(Object src, int srcPos,
                                      Object dest, int destPos,
                                      int length);
  ```

  > **本地方法**
  >
  > 本地方法是使用其他编程语言（比如 C，C++）实现的方法，通过 Java 加载动态链接库（Windows 上的 DLL 文件）以链接到 JVM 中。使用关键字 `native` 来定义本地方法，但是 `native` 不能和 `abstract` 一起使用。

  参数含义是：

  * src：原数组
  * srcPos：原数组中的起始位置
  * dest：目标数组
  * destPos：目标数组中的起始位置
  * length：要拷贝的元素数量

  在 `ArrayList` 中，`add` 方法使用了该方法：

  ```java
  // 添加元素到任意位置
  public void add(int index, E element) {
      // 边界检查
  	rangeCheckForAdd(index);
  
      // 确保容量足够
  	ensureCapacityInternal(size + 1);  // Increments modCount!!
      // 这里原数组和目标数组都是自身，而原数组的起始位置是 index，目标数组的起始位置是 index + 1，长度是 size - index
      // 这说明要把 index 后面的所有元素复制到 index + 1 开始的位置上，即全部后移一格
  	System.arraycopy(elementData, index,
                       elementData, index + 1,
  					 size - index);
  	elementData[index] = element;
  	size++;
  }
  ```

* `Arrays.copyOf()` 本质上调用了 `System.arraycopy()`，下面是它的源码：

  ```java
  /**
   * 给原有数组扩容，返回一个扩容后的新数组
   * 
   * @param original 原数组
   * @param newLength 新长度
   */
  public static int[] copyOf(int[] original, int newLength) {
      // 申请一个新的数组
      int[] copy = new int[newLength];
      // 调用 System.arraycopy，将源数组中的数据进行拷贝，并返回新的数组
      System.arraycopy(original, 0, 
                       copy, 0,
                       Math.min(original.length, newLength));
      return copy;
  }
  
  ```

  在 `ArrayList` 的 `toArray` 方法中使用了：

  ```java
  /**
   * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。
   */
  public Object[] toArray() {
      // elementData：要复制的数组；size：要复制的长度
      return Arrays.copyOf(elementData, size);
  }
  
  ```

##### 4.2.8 `ArrayList` 的其他常用方法介绍

| 方法                                   | 作用                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `void trimToSize()`                    | 把此实例的容量修剪为列表的当前大小，能够最小化该实例占用的存储空间 |
| `void ensureCapacity(int minCapacity)` | 如有必要，增加此实例的容量，以确保它至少可以容纳最小容量参数指定的元素数量 |

有些时候，为了手动扩容和手动缩容，这些方法还挺有用的。

#### 4.1.3 `LinkedList`

`LinkedList` 实现了 `AbstractSequentialList` 抽象类，此类提供 `List` 接口的骨架实现，以最大限度地减少实现此接口所需的工作，该接口由“顺序访问”数据存储（例如链表）支持；对于随机访问数据（如数组），应优先使用 `AbstractList` 而非此类。

理论上来说，`LinkedList` 添加元素很快且不需要扩容，删除元素也比 `ArrayList` 要快，尤其是在头尾的操作更是非常快，因此 `LinkedList` 也可以作为一个双端队列（`Deque`）。

`LinkedList` 的定义如下：

```JAVA
public class LinkedList<E> extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable {
}
```

##### 4.1.3.1 `LinkedList` 的底层数据结构

**`LinkedList` 内部维护了一个双向链表**。

> 在 JDK 1.6 及以前的版本中，`LinkedList` 实现为双向循环链表，1.7 取消了循环，改为双向链表。
>

`LinkedList` 通过 `Node` 类型的头尾指针（`first` 和 `last`）来访问数据。

```java
// 链表长度
transient int size = 0;
// 链表头节点
transient Node<E> first;
// 链表尾节点
transient Node<E> last;
```

`Node` 是 `LinkedList` 的内部类，它表示链表中的元素实例。Node 中包含三个元素：

- `prev` 是该节点的上一个节点
- `next` 是该节点的下一个节点
- `item` 是该节点所包含的值

源码如下所示：

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

##### 4.1.3.2 `LinkedList` 访问元素

`LinkedList` 访问元素的实现主要基于以下关键性源码：

```java
public E get(int index) {
    // 检查是否越界
	checkElementIndex(index);
   
	return node(index).item;
}

Node<E> node(int index) {
    // assert isElementIndex(index);
	// 如果 index 小于 size / 2；从前往后搜索；否则从后往前搜索
    // 虽然时间复杂度还是 O(n)，但是却缩短了一半的搜索长度
    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
```

获取 `LinkedList` 第 index 个元素的算法是：

- 判断 index 在链表前半部分，还是后半部分。
- 如果是前半部分，从头节点开始查找；如果是后半部分，从尾结点开始查找。

`LinkedList` 这种访问元素的性能是 `O(N)` 级别的（极端情况下，扫描 N/2 个元素）；相比于 `ArrayList` 的 `O(1)`，显然要慢不少。

**推荐使用迭代器遍历 `LinkedList` ，不要使用传统的 `for` 循环**。for-each 语法会被编译器转换成迭代器遍历，但是它的遍历过程中不允许修改 `List` 长度，即不能进行增删操作。

##### 4.1.3.3 `LinkedList` 添加元素

`LinkedList` 有多种添加元素方法：

- `add(E e)`：默认添加元素方法（插入尾部）
- `add(int index, E element)`：添加元素到任意位置
- `addFirst(E e)`：在头部添加元素
- `addLast(E e)`：在尾部添加元素

其中，`add` 及其重载来源于 `AbstractList`，而 `addFirst` 和 `addLast` 来源于 `Deque` 接口。我们在讲解 `Queue` 接口时还会讲到这个问题。

这些方法的源码如下：

```java
public boolean add(E e) {
    linkLast(e);
    return true;
}

public void add(int index, E element) {
    checkPositionIndex(index);

    // 如果直接在链表的最后添加元素，调用 linkLast
    if (index == size)
        linkLast(element);
    else
        // 否则，利用 node 方法找到 index 处的节点，在其前面添加，即调用 linkBefore
        linkBefore(element, node(index));
}

public void addFirst(E e) {
    linkFirst(e);
}

public void addLast(E e) {
    linkLast(e);
}
```

可以看到，它们都基于 `linkXXX` 方法，源码如下：

```java
// 头插
private void linkFirst(E e) {
    final Node<E> f = first;
    // 构造新节点，新节点 prev 不应该有任何节点，新节点 next 则是原来的头节点
    final Node<E> newNode = new Node<>(null, e, f);
    first = newNode;
    // 如果原来是空列表，则头尾节点都等于这个新节点
    if (f == null)
        last = newNode;
    else
        // 让原来的头节点的 prev 指向新节点
        f.prev = newNode;
    size++;
    modCount++;
}

// 尾插，和头插对称
void linkLast(E e) {
    final Node<E> l = last;
    // 构造新节点，新节点 next 不应该有任何节点，新节点 prev 则是原来的尾节点
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;

    // 如果原来是空列表，则头尾节点都等于这个新节点
    if (l == null)
        first = newNode;
    else
        // 原来的尾节点的 next 指向新节点
        l.next = newNode;
    size++;
    modCount++;
}

// 插在某个节点之前
void linkBefore(E e, Node<E> succ) {
    // assert succ != null;

    // succ 是当前位置上的节点，pred 就是它的前一个
    final Node<E> pred = succ.prev;
    // 新节点的 prev 指向 succ 的前一个节点，新节点的 next 指向 succ
    final Node<E> newNode = new Node<>(pred, e, succ);
    // succ 的 prev 指向新节点
    succ.prev = newNode;
    // 如果 succ 没有前面的节点，则说明 succ 是头节点，新头节点就是新节点
    if (pred == null)
        first = newNode;
    else
        // succ 的前一个节点的 next 指向新节点
        pred.next = newNode;
    size++;
    modCount++;
}
```

算法如下：

- 将新添加的数据包装为 `Node`
- 如果往头部添加元素，将头指针 `first` 指向新的 `Node`，之前的 `first` 对象的 `prev` 指向新的 `Node`
- 如果是向尾部添加元素，则将尾指针 `last` 指向新的 `Node`，之前的 `last` 对象的 `next` 指向新的 `Node`
- 如果向中间的某个位置添加元素，则将新 `Node` 的 `next` 指向原 `Node`、新 `Node` 的 `prev` 指向原 `Node` 的 `prev`；同时要修改原 `Node` 的 `prev` 和原 `Node` 的原 `prev` 的 `next`

##### 4.1.3.4 `LinkdedList` 删除元素

`LinkedList` 删除元素也有很多方法，部分来自于 `Deque` 接口，我们就不全部列举了，以最具有代表性的 `remove` 为例，它的实现主要基于以下关键性源码：

```java
public boolean remove(Object o) {
    // 有可能节点存储的元素是 null，不能对 null 调用 equals，因此要分情况讨论
    if (o == null) {
        // 遍历找到要删除的元素节点
        for (Node<E> x = first; x != null; x = x.next) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        // 遍历找到要删除的元素节点
        for (Node<E> x = first; x != null; x = x.next) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}

E unlink(Node<E> x) {
    // assert x != null;
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;

    // 如果当前节点没有头节点，则说明是删除头节点，直接让头节点指向当前节点的下一个节点
    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    // 如果当前节点没有尾节点，则说明是删除尾节点，直接让尾节点指向当前节点的上一个节点
    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
```

算法说明：

- 遍历找到要删除的元素节点，然后调用 `unlink` 方法删除节点；
- `unlink` 删除节点的方法：
  - 如果当前节点有前驱节点，则让前驱节点指向当前节点的下一个节点；否则，让头指针指向下一个节点。
  - 如果当前节点有后继节点，则让后继节点指向当前节点的前一个节点；否则，让尾指针指向上一个节点。

#### 4.1.4 `Vector` 与 `Stack`

`Vector` 是在 `ArrayList` 出现之前的数组实现的 `List`，**它实现的接口，继承的类和 `ArrayList` 一模一样**，它和 `ArrayList` 的最大区别在于 **`Vector` 支持并发访问**。还有一点细小的区别是，`Vector` 支持使用 `Enumeration` 访问，而 `ArrayList` 则不支持。

支持并发访问就意味着它的访问速度比较的慢，**访问时需要加上同步锁，离开时需要解锁**，要花费额外的时间。如果你真的需要一个列表被多个线程共享访问，才使用它。

> `Vector` 的同步原理真的就只是在所有的方法上添加 `syncronized` 关键字，没什么特别高深的地方。

`Vector` 的 API 和 `ArrayList` 基本一致，它独有的 API 我们会在下面简单的列举出来。

我们**很少使用它，因为真正需要并发访问时我们有更好的选择**。

`Vector` 特有的 API 如下：

| 方法                                     |                                             |
| ---------------------------------------- | ------------------------------------------- |
| `int capacity()`                         | 等价于 `List` 中的 `size`                   |
| `Enumeration<E> elements()`              | 获取 `Enumration` 用于遍历                  |
| `E elementAt(int index)`                 | 等价于 `List` 中的 `get`                    |
| `E firstElement()`                       | 等价于 `elementData(0)`                     |
| `E lastElement()`                        | 等价于 `elementData(capacity() - 1)`        |
| `void setElementAt(E obj, int index)`    | 等价于 `List` 中的 `set`                    |
| `void removeElementAt(int index)`        | 等价于 `List` 中的 `remove`                 |
| `void insertElementAt(E obj, int index)` | 等价于 `List` 中的 `add(int index, E elem)` |
| `void addElement(E obj)`                 | 等价于 `List` 中的 `add(E elem)`            |
| `boolean removeElement(Object obj)`      | 等价于 `List` 中的 `remove(Object obj)`     |
| `void removeAllElements()`               | 等价于 `List` 中的 `clear`                  |

如你所见，`Vector` 的 API 非常长，而且它本身实现了 `List`，意味着 `List` 中的 API 它都有，程序员完全可以使用 `List` API 而不是 `Vector` 的冗长的 API。因此我么认为这个类的 `API` 设计十分臃肿，但是这是因为 Java 为了实现兼容才不得不做出的取舍。

`Stack` 是 Java 实现的一个栈，但是**它直接继承自 `Vector`**，这意味着 `Vector` 拥有的公共方法它没有办法屏蔽，所以可以对 `Stack` 直接访问栈中间的某个元素，这违反了栈这个数据结构的规则。除此之外，`Stack` 继承自 `Vector` 也意味着它也是线程安全的，单线程环境下访问就比较慢。

`Stack` 相比 `Vector` 来说使用的还更多一点，因为对于不了解集合框架关系的开发者来说，一个编程语言有一个 `Stack` 类是非常平常的事情，因此我们有必要介绍一些 `Stack` 的 API：

| 方法              | 作用                                                     |
| ----------------- | -------------------------------------------------------- |
| `Stack()`         | 构造函数                                                 |
| `E push(E item)`  | 向栈中压入元素，并返回这个元素（不知道为什么要这么设计） |
| `E pop()`         | 移除栈顶元素，并返回这个元素                             |
| `E peek()`        | 获取栈顶元素                                             |
| `boolean empty()` | 如果栈为空，返回 true                                    |

你会发现，通过 `Vector` 和 `Deque` 也能完成 `Stack` 所能做的事情，所以对于单线程环境来说，使用双端队列（比如 `LinkedList`）来代替 `Stack` 是更好的选择。

> JDK 1.6 以来，`synchornized` 锁的性能有了很大的提高，不必要加锁的地方会取消加锁，因此单线程环境下使用 `Stack` 的性能也得到了一定的提高。

### 4.2 `Set`

`Set` 是数学意义上的集合，它继承自 `Collection`，表示无序的集合。

数学上集合有以下性质：

1. 互异性，一个集合中不会出现两个相同的元素
2. 无序性，元素之间地位相同，没有先后之分

这些性质在 `Set` 中也成立，但是无序性有少数 `Set` 容器打破了这个性质。

`Set` 相比于 `Collection`，没有添加任何自己的方法。

`AbstractSet` 是一个抽象类，它继承于 `AbstractCollection`，实现了 `Set` 中的绝大部分方法，为实现 `Set` 的实例类提供了便利。

> 很快你会看到，**`Set` 本质上全部基于 `Map`，它们并没有实现自己的数据结构，因此代码都十分简单**。
>
> 想要彻底搞懂 `Set` 底层的数据结构，就要去查看 `Map` 实现类的底层数据结构。可以这么说，`Set` 仅仅是对 `Map` 的封装，是`Collection` 和 `Map` 之间的桥梁。
>
> 特别提醒：由于这些 `Set` 实现类所依赖的 `Map` 都不是线程安全的，而这些 `Set` 也没有做同步处理，因此这些 `Set` 全都不是线程安全的。

#### 4.2.1 `HashSet`

`HashSet` 类依赖于 `HashMap`，它实际上是通过 `HashMap` 实现的。

**`HashSet` 中的元素是无序的，无序并不意味着随机，无序的含义是存储的数据在底层中并非按照顺序保存 ，而是根据数据的哈希值决定的。**

##### 4.2.1.1 `HashSet` 的原理

**`HashSet` 是基于 `HashMap` 实现的。**这意味着它仅仅是对 `HashMap` 的访问封装，它底层没有自己实现一个数据结构。

> **`HashMap`**
>
> `HashMap` 实现了名为哈希表的复杂数据结构，哈希表底层的数据结构比较复杂，我们会在讲解 `Map` 时详细说明。
>
> 现在需要知道的是，`HashMap` 存储键值对，在 `HashMap` 中不允许有相同的键存在，但是可以有相同的值。

```java
// HashSet 的核心，通过维护一个 HashMap 实体来实现 HashSet 方法
private transient HashMap<E, Object> map;

// PRESENT 是与支持 Map 中的对象关联的虚拟值
private static final Object PRESENT = new Object();
```

* `HashSet` 中维护了一个 `HashMap` 对象 map，`HashSet` 的重要方法，如 `add`、`remove`、`iterator`、`clear`、`size` 等都是通过 map 实现的
* `PRESENT` 是用于关联 map 中当前操作元素的一个虚拟值

下面是 `HashSet` 的源代码，非常简短：

```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable
{
    static final long serialVersionUID = -5024744406713321676L;

    private transient HashMap<E,Object> map;

    // 与支持 Map 中的对象关联的虚拟值
    private static final Object PRESENT = new Object();

    public HashSet() {
        map = new HashMap<>();
    }

    public HashSet(Collection<? extends E> c) {
        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }

    public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap<>(initialCapacity, loadFactor);
    }

    public HashSet(int initialCapacity) {
        map = new HashMap<>(initialCapacity);
    }

    /**
     * dummy 参数仅仅用来和其他构造函数区分开来，没有实际作用
     *
     * 这个构造函数初始化了一个 LinkedHashMap 而不是 HashMap，但是在代码中并未看到使用过这个构造函数
     * 这是因为该方法是留给子类使用的，我们很快就能看到了
     */ 
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }

    public Iterator<E> iterator() {
        return map.keySet().iterator();
    }

    public int size() {
        return map.size();
    }

    public boolean isEmpty() {
        return map.isEmpty();
    }

    public boolean contains(Object o) {
        return map.containsKey(o);
    }

    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

    public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }

    public void clear() {
        map.clear();
    }

    // ...
}
```

我们观察到，`PRESENT` 会作为每一个键的值，这说明 `HashSet` 可以看作是 `HashMap` 的只有键没有值的版本。

#### 4.2.2 `LinkedHashSet`

和 `HashSet` 类似，它也没有自己实现一个数据结构，而是持有一个 `LinkedHashMap` 的实例。

`LinkedHashSet` 直接继承自 `HashSet` 来完成绝大多数方法，由于 `HashSet` 为子类保留了一个构造函数，而这个构造函数内部是初始化了一个 `LinkedHashMap`，因此 `LinkedHashSet` 的代码就更加简单了。

> **`LinkedHashMap`**
>
> `LinkedHashMap` 可以认为是 `HashMap` 和 `LinkedList` 的结合，它既使用 `HashMap` 操作底层数据结构，又使用 `LinkedList` 维护插入元素的先后顺序。所以它是一个有序的 `HashMap`。
>
> 我们在之后会详细介绍 `LinkedHashMap` 和 `HashMap`。

##### 4.2.2.1 `LinkedHashSet` 的原理

我们就直接看代码：

```java
public class LinkedHashSet<E>
    extends HashSet<E>
    implements Set<E>, Cloneable, java.io.Serializable {

    private static final long serialVersionUID = -2851667679971038690L;

    public LinkedHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor, true);
    }

    public LinkedHashSet(int initialCapacity) {
        super(initialCapacity, .75f, true);
    }

    public LinkedHashSet() {
        super(16, .75f, true);
    }

    public LinkedHashSet(Collection<? extends E> c) {
        super(Math.max(2*c.size(), 11), .75f, true);
        addAll(c);
    }

	// ...
}
```

这些代码非常简单，构造函数全部都是调用的父类的构造函数，最后一个参数 `true` 则和父类的其他构造函数区别开来。

#### 4.2.3 `TreeSet`

`TreeSet` 实现了 `NavigableSet`，并且继承了 `AbstractSet`。`NavigableSet` 接口则是继承了 `SortedSet` 接口，`SortedSet` 继承了 `Set` 接口。

`SortedSet` 表示有序的 `Set`，既然要有序，就得对元素进行排序，`SortedSet` 定义了一个 `Comparator<? super E> comparator()` 方法获取一个比较器，也就是说，`SortedSet` 是通过比较器来对元素进行比较排序的。

它相比于 `Set`，提供了更多实用方法：

| 方法                                              | 作用                                             |
| ------------------------------------------------- | ------------------------------------------------ |
| `SortedSet<E> subSet(E fromElement, E toElement)` | 返回子集，包括起始不包括结尾                     |
| `SortedSet<E> headSet(E toElement)`               | 返回此集合中元素严格小于给定元素的元素组成的子集 |
| `SortedSet<E> tailSet(E fromElement)`             | 返回此集合中元素严格大于给定元素的元素组成的子集 |
| `E first()`                                       | 返回此集合中当前的第一个（最小）元素             |
| `E last()`                                        | 返回此集合中当前的最后一个（最大）元素           |

`NavigableSet` 继承 `SortedSet`，它提供了丰富的查找方法：

| 方法                                                         | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `E lower(E e)`                                               | 返回小于指定值的元素中最接近的元素                           |
| `E floor(E e)`                                               | 返回小于或等于指定值的元素中最接近的元素                     |
| `E ceiling(E e)`                                             | 返回大于或等于指定值的元素中最接近的元素                     |
| `E higher(E e)`                                              | 返回大于指定值的元素中最接近的元素                           |
| `E pollFirst()`                                              | 检索并移除第一个（最小的）元素                               |
| `E pollLast()`                                               | 检索并移除最后一个（最大的）元素                             |
| `NavigableSet<E> descendingSet()`                            | 返回反序排列的 `Set`                                         |
| `Iterator<E> descendingIterator()`                           | 返回反序排列的 `Set` 的迭代器                                |
| `NavigableSet<E> subSet(E fromElement, boolean fromInclusive, `<BR>`E toElement, boolean toInclusive)` | 返回子集，包不包括开头和结尾由 `fromInclusive` 和 `toInclusive` 两个值控制 |
| `NavigableSet<E> headSet(E toElement, boolean inclusive)`    | 返回此集合中元素严格小于给定元素的元素组成的子集，包不包括该元素由 `inclusive` 决定 |
| `NavigableSet<E> tailSet(E fromElement, boolean inclusive)`  | 返回此集合中元素严格大于给定元素的元素组成的子集，包不包括该元素由 `inclusive` 决定 |

`TreeSet` 是 `NavigableSet` 的具体实现类，它底层也是依赖于一个 `Map` 类的容器，叫做 `TreeMap`。

##### 4.2.3.1 `TreeSet` 的原理

`TreeSet` 的源码如下：

```java
public class TreeSet<E> extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable {
    /**
     * The backing map.
     */
    private transient NavigableMap<E, Object> m;

    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();

    TreeSet(NavigableMap<E,Object> m) {
        this.m = m;
    }

    public TreeSet() {
        this(new TreeMap<E,Object>());
    }

    public TreeSet(Comparator<? super E> comparator) {
        this(new TreeMap<>(comparator));
    }

    public TreeSet(Collection<? extends E> c) {
        this();
        addAll(c);
    }


    public TreeSet(SortedSet<E> s) {
        this(s.comparator());
        addAll(s);
    }

    public Iterator<E> iterator() {
        return m.navigableKeySet().iterator();
    }

    public Iterator<E> descendingIterator() {
        return m.descendingKeySet().iterator();
    }

    public NavigableSet<E> descendingSet() {
        return new TreeSet<>(m.descendingMap());
    }

    public int size() {
        return m.size();
    }
    
    public boolean isEmpty() {
        return m.isEmpty();
    }

    public boolean contains(Object o) {
        return m.containsKey(o);
    }

    public boolean add(E e) {
        return m.put(e, PRESENT)==null;
    }

    public boolean remove(Object o) {
        return m.remove(o)==PRESENT;
    }

    public void clear() {
        m.clear();
    }

    public  boolean addAll(Collection<? extends E> c) {
        // Use linear-time version if applicable
        if (m.size()==0 && c.size() > 0 &&
            c instanceof SortedSet &&
            m instanceof TreeMap) {
            SortedSet<? extends E> set = (SortedSet<? extends E>) c;
            TreeMap<E,Object> map = (TreeMap<E, Object>) m;
            Comparator<?> cc = set.comparator();
            Comparator<? super E> mc = map.comparator();
            if (cc==mc || (cc != null && cc.equals(mc))) {
                map.addAllForTreeSet(set, PRESENT);
                return true;
            }
        }
        return super.addAll(c);
    }

    public NavigableSet<E> subSet(E fromElement, boolean fromInclusive,
                                  E toElement,   boolean toInclusive) {
        return new TreeSet<>(m.subMap(fromElement, fromInclusive,
                                       toElement,   toInclusive));
    }

    public NavigableSet<E> headSet(E toElement, boolean inclusive) {
        return new TreeSet<>(m.headMap(toElement, inclusive));
    }

    public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
        return new TreeSet<>(m.tailMap(fromElement, inclusive));
    }

    public SortedSet<E> subSet(E fromElement, E toElement) {
        return subSet(fromElement, true, toElement, false);
    }
    
    public SortedSet<E> headSet(E toElement) {
        return headSet(toElement, false);
    }

    public SortedSet<E> tailSet(E fromElement) {
        return tailSet(fromElement, true);
    }

    public Comparator<? super E> comparator() {
        return m.comparator();
    }
    
    public E first() {
        return m.firstKey();
    }
    
    public E last() {
        return m.lastKey();
    }

    // NavigableSet API methods

    public E lower(E e) {
        return m.lowerKey(e);
    }

    public E floor(E e) {
        return m.floorKey(e);
    }

    public E ceiling(E e) {
        return m.ceilingKey(e);
    }

    public E higher(E e) {
        return m.higherKey(e);
    }

    public E pollFirst() {
        Map.Entry<E,?> e = m.pollFirstEntry();
        return (e == null) ? null : e.getKey();
    }

    public E pollLast() {
        Map.Entry<E,?> e = m.pollLastEntry();
        return (e == null) ? null : e.getKey();
    }

    // ...
}

```

我们看到，虽然它的代码比之前的两个 `Set` 要长的多，但是也都是依靠 `NavbigableMap` 操作，`TreeMap` 是其实现类。

#### 4.2.4 `EnumSet`

`EnumSet` 和其他的 `Set` 不一样，它是枚举专用的 `Set`，它是一个抽象类，直接继承自 `AbstractSet`。它的泛型限定是 `<E extends Enum<E>>`，限定了只能是枚举类型。

它没有任何公有的构造方法，只能通过静态方法来构造，返回的是 `RegularEnumSet` 或 `JumboEnumSet`，前者用于枚举常量数目少于 64 的小型枚举，后者用于大型枚举。

`EnumSet` 并未利用 `Map`，而是采用了二进制运算的方式高效实现，这里就不详细说明了。

#### 4.2.5 `BitSet`

`BitSet` 并不是传统意义的集合，它并未实现 `Set` 接口，它表示二进制位的集合，也叫做**位向量**。

它提供了 `boolean get(int i)` 方法获取一个位置上的 bit 是否为 1，如果为 1 则返回 `true`，否则返回 `false`。

除此之外，还有 `void set(int bitIndex)` 方法设置一个位置的 bit 为 1；还有 `void clear(int bitIndex)` 方法设置该位置的 bit 为 0。

它还提供了 `and`、`or`、`xor`、`andNot` 方法进行位运算。

### 4.3 `Queue`

`Queue` 接口是 `Collection` 的子接口，是对队列数据结构的抽象。

它的独特 API 如下所示：

| 方法                 | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| `boolean offer(E e)` | 将指定元素插入此队列的尾部                                   |
| `E remove()`         | 检索并删除此队列的头部元素。此方法与 `poll` 的不同之处仅在于如果此队列为空，它将引发异常 |
| `E poll()`           | 检索并删除此队列的头部元素。如果此队列为空，它返回 null      |
| `E element()`        | 检索但不删除此队列的头部元素。此方法与 `peek` 的不同之处仅在于如果此队列为空，它将引发异常 |
| `E peek()`           | 检索但不删除此队列的头部元素。如果此队列为空，它返回 null    |

#### 4.3.1 `PriorityQueue`

`PriorityQueue` 继承自 `AbstractQueue`，`AbstractQueue` 实现了较多 `Queue` 接口中的方法，最大化的减少实现 `Queue` 接口的工作量。

`PriorityQueue` 是优先队列，它会根据元素的自然顺序，或根据传入的比较器对元素进行排序。它保证队首总是优先级最高的元素。

注意，**优先队列在没有比较器的情况下，不支持存储不是 `Comparable` 的元素**。

##### 4.3.1.1 `PriorityQueue` 的底层数据结构

`PriorityQueue` 底层数据结构定义代码如下：

```java
private static final int DEFAULT_INITIAL_CAPACITY = 11;

transient Object[] queue; // non-private to simplify nested class access

private int size = 0;

private final Comparator<? super E> comparator;
```

这里我们看到，它类似于 `ArrayList`，也有一个默认的初始大小；同时，它内部存储一个比较器。

实际上，它的底层数据结构是**堆**，使用了数组用来存储数据。每一次入队或出队时总是会调整堆，在 $O(\log n)$ 的时间内把最大优先级的元素调整到队首。**默认是小顶堆**。

##### 4.3.1.2 `PriorityQueue` 的构造方法

`PriorityQueue` 是排序的容器，因此提供了额外的构造方法来从其他排序容器（`PriorityQueue` 本身以及 `SortedSet`）构造。

从其他容器构造时也比较简单，首先拿出这个容器的比较器（如果有的话），然后复制元素。

```java
// 比较器为 null，则存储的元素必须实现 Comparable
public PriorityQueue() {
    this(DEFAULT_INITIAL_CAPACITY, null);
}

// 比较器为 null，则存储的元素必须实现 Comparable
public PriorityQueue(int initialCapacity) {
    this(initialCapacity, null);
}

public PriorityQueue(Comparator<? super E> comparator) {
    this(DEFAULT_INITIAL_CAPACITY, comparator);
}

public PriorityQueue(int initialCapacity,
                     Comparator<? super E> comparator) {
    // Note: This restriction of at least one is not actually needed,
    // but continues for 1.5 compatibility
    if (initialCapacity < 1)
        throw new IllegalArgumentException();
    // 和 ArrayList 不一样，这里是立即使用初始化一个有长度的数组
    this.queue = new Object[initialCapacity];
    this.comparator = comparator;
}

public PriorityQueue(Collection<? extends E> c) {
    if (c instanceof SortedSet<?>) {
        SortedSet<? extends E> ss = (SortedSet<? extends E>) c;
        // 拿出 Set 的比较器给自己
        this.comparator = (Comparator<? super E>) ss.comparator();
        initElementsFromCollection(ss);
    }
    else if (c instanceof PriorityQueue<?>) {
        PriorityQueue<? extends E> pq = (PriorityQueue<? extends E>) c;
        // 拿出另一个优先队列的比较器给自己
        this.comparator = (Comparator<? super E>) pq.comparator();
        initFromPriorityQueue(pq);
    }
    else {
        this.comparator = null;
        initFromCollection(c);
    }
}

public PriorityQueue(PriorityQueue<? extends E> c) {
    // 拿出另一个优先队列的比较器给自己
    this.comparator = (Comparator<? super E>) c.comparator();
    initFromPriorityQueue(c);
}

public PriorityQueue(SortedSet<? extends E> c) {
    // 拿出 Set 的比较器给自己
    this.comparator = (Comparator<? super E>) c.comparator();
    initElementsFromCollection(c);
}
```

和 `ArrayList` 的初始化不同，**优先队列会立即使用默认容量（如果没有给初始容量）初始化一个数组**。

在从其他集合初始化堆时，这些集合中的元素总是要经过调整，成为一个堆。这个调整的过程涉及到下沉操作，`PriorityQueue` 封装了这个操作，调整的源码如下：

```java
// 把一个完全二叉树数组变成符合堆规则的数组
private void heapify() {
    // 从第一个非叶子节点开始下沉元素
    for (int i = (size >>> 1) - 1; i >= 0; i--)
        siftDown(i, (E) queue[i]);
}

private void siftDown(int k, E x) {
    if (comparator != null)
        siftDownUsingComparator(k, x);
    else
        siftDownComparable(k, x);
}
```

`heapify` 方法中的循环，起点为 `(size >>> 1) - 1`，这是逻辑右移 1 位以后再减 1，逻辑右移是在前面补充 0 而不是符号位，当然，`size` 总是正数，因此使用普通右移也能完成目的。这里这个表达式是为了**寻找到完全二叉树中的最后一个非叶子节点，然后往前遍历，执行下沉操作**，之前的每一个元素一定也是非叶子节点。 

`heapify` 方法还调用了一个 `siftDown` 方法，该方法是下沉的具体实现，参数 k 是位置，参数 x 是下沉的元素。

###### 4.3.1.2.1 `siftDown` 实现

下沉操作分为两种，一种是有比较器的下沉，另一种是无比较器，依靠元素自身实现 `Comparable` 进行比较。

我们分别看一下两种实现，代码其实是类似的：

```java
private void siftDownUsingComparator(int k, E x) {
    // 之前说过，size >>> 1 - 1 就是最后一个非叶子节点，那么这里就是找到第一个叶子节点
    int half = size >>> 1;
    // k < half 时，都是非叶子节点，此时 k 一定有孩子
    while (k < half) {
        // 用 child 记录两个孩子中较小的那个在数组中的位置，这里暂时记录为 k 的左孩子
        int child = (k << 1) + 1;
        // 用 c 记录两个孩子中较小的那个，这里暂时记录为左孩子
        Object c = queue[child];
        // k 的右孩子
        int right = child + 1;
        // 如果左孩子更大
        if (right < size &&
            comparator.compare((E) c, (E) queue[right]) > 0)
            // c 就记录为右孩子 
            c = queue[child = right];
        // 比较 x 和两个孩子中较小的那个，如果 x 较大，说明 x 找到了合适的位置
        if (comparator.compare(x, (E) c) <= 0)
            break;
        // 交换 k 和 k 的孩子中较小的那个
        queue[k] = c;
        // 现在 k 是交换后的节点，继续调整
        k = child;
    }
    // k 出循环时一定是一个叶子节点
    queue[k] = x;
}

private void siftDownComparable(int k, E x) {
    Comparable<? super E> key = (Comparable<? super E>)x;
    int half = size >>> 1;        // loop while a non-leaf
    while (k < half) {
        int child = (k << 1) + 1; // assume left child is least
        Object c = queue[child];
        int right = child + 1;
        if (right < size &&
            ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)
            c = queue[child = right];
        if (key.compareTo((E) c) <= 0)
            break;
        queue[k] = c;
        k = child;
    }
    queue[k] = key;
}
```

##### 4.3.1.3 `PriorityQueue` 访问队首元素

`PriorityQueue` 访问队首元素的实现主要基于以下关键性源码：

```java
public E peek() {
    return (size == 0) ? null : (E) queue[0];
}
```

其实很简单，队首就是底层数组中的首个元素（根），直接访问返回即可。

##### 4.3.1.4 `PriorityQueue` 出队

出队基于以下关键性源码：

```java
public E poll() {
    if (size == 0)
        return null;
    int s = --size;
    modCount++;
    // 队首
    E result = (E) queue[0];
    // 队尾
    E x = (E) queue[s];
    // 删除队尾
    queue[s] = null;
    if (s != 0)
        // 从队首开始调整堆，最后 x 取代队首的位置
        siftDown(0, x);
    return result;
}
```

##### 4.3.1.5 `PriorityQueue` 入队

入队基于以下关键性源码：

```java
public boolean offer(E e) {
    if (e == null)
        throw new NullPointerException();
    modCount++;
    int i = size;
    if (i >= queue.length)
        // 扩容
        grow(i + 1);
    size = i + 1;
    if (i == 0)
        queue[0] = e;
    else
        // i 此时是原来的 size，由于数组已经完成了扩容，因此可以访问到 i
        // 此时 i 就是数组的末尾，把 e 放到末尾然后上浮
        siftUp(i, e);
    return true;
}
```

其中，`siftUp` 是上浮操作，和 `siftDown` 一样有两个版本，源码如下：

```java
private void siftUp(int k, E x) {
    if (comparator != null)
        siftUpUsingComparator(k, x);
    else
        siftUpComparable(k, x);
}

private void siftUpUsingComparator(int k, E x) {
    // k > 0 意味着 k 不是根
    while (k > 0) {
        // 找到它的父亲
        int parent = (k - 1) >>> 1;
        Object e = queue[parent];
        // 比较
        if (comparator.compare(x, (E) e) >= 0)
            break;
        // 交换
        queue[k] = e;
        k = parent;
    }
    // 出循环意味着 k 是根，或者更大
    queue[k] = x;
}

private void siftUpComparable(int k, E x) {
    Comparable<? super E> key = (Comparable<? super E>) x;
    while (k > 0) {
        int parent = (k - 1) >>> 1;
        Object e = queue[parent];
        if (key.compareTo((E) e) >= 0)
            break;
        queue[k] = e;
        k = parent;
    }
    queue[k] = key;
}
```

这里还涉及到一个扩容，和 `ArrayList` 其实是类似的，源码如下：

```java
private void grow(int minCapacity) {
    int oldCapacity = queue.length;
    // 如果旧容量小于 64。那么就扩容为 2 * 旧容量 + 2，否则是 1.5 * 旧容量
    int newCapacity = oldCapacity + ((oldCapacity < 64) ?
                                     (oldCapacity + 2) :
                                     (oldCapacity >> 1));
    // overflow-conscious code
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    queue = Arrays.copyOf(queue, newCapacity);
}
```

#### 4.4 `Deque`

`Deque` 继承自 `Queue`，它代表**双端队列**的接口，双端队列意味着可以从队列的任意一边进行操作，由于链表在头尾操作效率很高，因此实现一个 `Deque` 也是很自然的事情。

`Deque` 提供如下方法，这里就简单的列举一下，方法本身比较简单：

| 增加                             | 删除                       | 获取               |
| -------------------------------- | -------------------------- | ------------------ |
| `boolean add(E e)`               | `E poll()`                 | `E element()`      |
| `void add(int index, E element)` | `E pollFirst()`            | `E get(int index)` |
| `void addFirst(E e)`             | `E pollLast()`             | `E getFirst()`     |
| `void addLast(E e)`              | `E pop()`                  | `E getLast()`      |
| `boolean offer(E e)`             | `E remove()`               | `E peek()`         |
| `boolean offerFirst(E e)`        | `E remove(int index)`      | `E peekFirst()`    |
| `boolean offerLast(E e)`         | `boolean remove(Object o)` | `E peekLast()`     |
| `void push(E e)`                 | `E removeFirst()`          |                    |
|                                  | `E removeLast()`           |                    |

有意思的是，`push` 和 `pop` 一般来说是栈（`Stack`）的方法，而 `Deque` 也提供了这些 API。

我们要注意的是当双端队列作为普通列表（使用 `add`、`remove`、`get` 方法）、普通队列（使用 `peek`、`poll`、`offer` 方法）和作为普通栈（使用 `peek`、`pop`、`push` 方法）时在双端队列哪一端进行操作：

* 作为普通列表时，`add` 等价于 `addFirst`、`remove` 等于 `removeFirst`、`get` 则可以自己选择下标。
* 作为栈时，`push` 等价于 `addFirst`、`pop` 等价于 `removeFirst`、`peek` 等价于 `peekFirst`。
* 作为队列时，`offer` 等价于 `add` 等价于 `addLast`、`poll` 等价于 `pollFirst`、`peek` 等价于 `peekFirst`。

##### 4.4.1 `LinkedList`

之前提到过 `LinkedList`，它继承了 `AbstractSequentialList` 的同时，还实现了 `Deque`。

`LinkedList` 的具体实现这里就不重复讲解了。

##### 4.4.2 `ArrayDeque`

`ArrayDeque` 是 `Deque` 的另一个实现者，是利用数组存储元素。为了方便操作头尾，内部还设置有两个指针。

###### 4.4.2.1 `ArrayDeque` 的底层数据结构

```java
// 用数组存储元素
transient Object[] elements; // non-private to simplify nested class access

// 头部元素的索引
transient int head;

// 尾部下一个将要被加入的元素的索引
transient int tail;

// 最小容量
private static final int MIN_INITIAL_CAPACITY = 8;
```

在 `ArrayDeque` 底层使用了数组来存储数据，同时用两个 `int` 值 `head` 和 `tail` 来表示头部和尾部。不过需要注意的是 **`tail` 并不是尾部元素的索引，而是尾部元素的下一位，即下一个将要被加入的元素的索引**。

底层是使用了**循环数组**的方式以充分利用数组的空间。

###### 4.4.2.2 `ArrayDeque` 的构造方法

```java
public ArrayDeque() {
    elements = new Object[16];
}

public ArrayDeque(int numElements) {
    allocateElements(numElements);
}

public ArrayDeque(Collection<? extends E> c) {
    allocateElements(c.size());
    addAll(c);
}
```

默认初始化了一个大小为 16 的数组，其他情况都调用了 `allocateElements`，这个方法很有意思：

```java
private void allocateElements(int numElements) {
    elements = new Object[calculateSize(numElements)];
}

private static int calculateSize(int numElements) {
    // 初始化容量为 8
    int initialCapacity = MIN_INITIAL_CAPACITY;
    
    // 如果传入参数大于 8
    if (numElements >= initialCapacity) {
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity >>>  1);
        initialCapacity |= (initialCapacity >>>  2);
        initialCapacity |= (initialCapacity >>>  4);
        initialCapacity |= (initialCapacity >>>  8);
        initialCapacity |= (initialCapacity >>> 16);
        initialCapacity++;

        if (initialCapacity < 0)   // Too many elements, must back off
            initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements
    }
    return initialCapacity;
}
```

注意 `calculateSize` 方法，这里当传入参数大于初始容量时，会经过一系列位操作，结果会得到什么？答案是，如果输入不是一个 $2^n$ 的数，会转换为一个 $2^n$ 的数；如果输入本身是一个 $2^n$ 的数，会变成 $2^{n+1}$。

假设变成 $2^{n+1}$ 超范围了，这时会变成负数，此时做一个逻辑右移，符号位就变为了 0，数就变成了 $2^{30}$。

所以，无论如何，`ArrayDeque` 的容量总是符合 $2^n$。

这是有原因的，**`ArrayDeque` 使用了特殊的技巧来使用循环数组，所以需要这种特殊的保持容量为 2 的 n 次幂的方法**。

###### 4.4.2.3 `ArrayDeque` 访问元素

访问元素分为头尾访问，源码如下：

```java
public E getFirst() {
    @SuppressWarnings("unchecked")
    E result = (E) elements[head];
    if (result == null)
        throw new NoSuchElementException();
    return result;
}

public E getLast() {
    @SuppressWarnings("unchecked")
    E result = (E) elements[(tail - 1) & (elements.length - 1)];
    if (result == null)
        throw new NoSuchElementException();
    return result;
}
```

总体来说就是利用指针访问数组元素，但是有一点很有意思，注意 `getLast` 中的 `(tail - 1) & (elements.length - 1)`。

我们刚才说过，`elements` 的长度永远是 2 的次方，所以 `elements.length - 1` 的二进制位是高位全 0，某一位之后是全 1。

而 `tail` 始终指向队尾的下一个位置，且**始终小于 `elements.length`**，则 `tail - 1` 才是队尾的元素，那么问题来了，由于底层是循环数组，`tail` 很有可能是 0，`tail - 1` 就是一个负数，这时怎么办？

从二进制角度看，`tail - 1` 是 -1，二进制表示是全 1，全 1 和任何数相与都是任何数，所以与出来结果就是 `elements.length - 1` 这个位置，刚好是队尾。

其他情况就更简单了，由于 `elements.length - 1` 相对于 `tail - 1` 来说就是和全 1 在做按位与，所以与出来就是 `tail - 1` 本身。

这个设计十分巧妙且高效，也正是为了维护这种设计，才会有如此复杂的构造函数保证其容量是 $2^{n}$。在该类的其他部分中还会看到大量的这种按位与操作。

###### 4.4.2.4 `ArrayDeque` 入队

源码如下：

```java
public void addFirst(E e) {
    if (e == null)
        throw new NullPointerException();
    elements[head = (head - 1) & (elements.length - 1)] = e;
    // tail 碰到了 head，直接双倍扩容，以维护容量是 2 的此次方
    if (head == tail)
        doubleCapacity();
}

public void addLast(E e) {
    if (e == null)
        throw new NullPointerException();
    elements[tail] = e;
    // tail 碰到了 head，直接双倍扩容，以维护容量是 2 的次方
    if ( (tail = (tail + 1) & (elements.length - 1)) == head)
        doubleCapacity();
}
```

这里也是使用了按位与，其含义之前也说过了，理解以后这些操作其实是十分简单的。

###### 4.4.2.5 `ArrayDeque` 出队

依旧是使用按位与：

```java
public E pollFirst() {
    int h = head;
    @SuppressWarnings("unchecked")
    E result = (E) elements[h];
    // Element is null if deque empty
    if (result == null)
        return null;
    elements[h] = null;     // Must null out slot
    head = (h + 1) & (elements.length - 1);
    return result;
}

public E pollLast() {
    int t = (tail - 1) & (elements.length - 1);
    @SuppressWarnings("unchecked")
    E result = (E) elements[t];
    if (result == null)
        return null;
    elements[t] = null;
    tail = t;
    return result;
}
```

## 5. `Map`

`Map` 是键值对容器的祖先，我们看一下它的定义：

```java
public interface Map<K,V> {
    // ...
}
```

泛型 `K` 表示键（Key），`V` 表示值（Value）。

`Map` 提供三种 `Collection`，分别是键的 `Set`、值 的`Collection` 以及键值一起的 `Set`，通过一些方法可以获取这些 `Set`。

下表列出了 `Map` 接口定义的方法：

| 方法                                             | 作用                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| `int size()`                                     | 获取该 `Map` 的大小                                          |
| `boolean isEmpty()`                              | 判断该 `Map` 是否为空                                        |
| `boolean containsKey(Object key)`                | 判断该 `Map` 是否包含指定的 key                              |
| `boolean containsValue(Object value)`            | 判断该 `Map` 是否包含指定的 value                            |
| `V get(Object key)`                              | 返回指定键映射到的值，如果此映射不包含该键的映射，则返回 null |
| `V put(K key, V value)`                          | 将键值对放入该 `Map` 中，如果之前键已经存在，则会用 value 替换掉原来的 value 并返回原来的 value；如果键之前不存在，返回 null |
| `V remove(Object key)`                           | 移除该键对应的键值对并返回值，如果键之前不存在，返回 null    |
| `void putAll(Map<? extends K, ? extends V> m)`   | 将另一个 `Map` 的所有键值对放入这个 `Map`，等价于调用多次 put 方法 |
| `void clear()`                                   | 清空 `Map`                                                   |
| `Set<K> keySet()`                                | 获取键的 `Set`                                               |
| `Collection<V> values()`                         | 获取值的 `Collection`                                        |
| `Set<Map.Entry<K, V>> entrySet()`                | 获取键值对的 `Set`                                           |
| `V getOrDefault(Object key, V defaultValue)`     | 返回指定键映射到的值，如果此 `Map` 不包含该键的映射，则返回 defaultValue |
| `V putIfAbsent(K key, V value)`                  | 如果指定的键尚未与值关联，则将其与给定值关联并返回 null ，否则返回当前值但是不关联 |
| `boolean remove(Object key, Object value)`       | 从 `Map` 中删除指定的键值对                                  |
| `boolean replace(K key, V oldValue, V newValue)` | 在 `Map` 中寻找 (key, oldValue) 的键值对，并将 oldValue 替换成 newValue |
| `V replace(K key, V value)`                      | 只要 `Map` 中存在指定的键，就把它的值替换为 value，返回之前的值 |

其中涉及到了一个 `Map.Entry`，这是 `Map` 接口的一个内部接口：

```java
interface Entry<K,V> {
    // 获取键
    K getKey();

    // 获取值
    V getValue();

    // 设置值
    V setValue(V value);

    // ...
}
```

这个接口代表了**键值对**实体，`Map` 通过 `entrySet()` 获取 `Map.Entry` 集合，从而通过该集合实现对键值对的操作。

### 5.1 `HashMap`

`HashMap` 继承自 `AbstractMap`，和其他很多抽象类一样，`AbstractMap` 提供了 `Map` 的核心实现，以最大限度地减少实现 `Map` 接口所需的工作。

`HashMap` 是最常用的 `Map` 实现类，以散列方式存储键值对，内部实现了一个哈希表。

有两个很关键的因素影响 `HashMap` 的性能：

- **容量**：**容量是哈希表中桶的数量**.

  初始容量就是哈希表创建时的容量。

- **负载因子**：也叫加载因子，是**散列表在其容量自动扩容之前被允许的最大饱和量**。

  **当哈希表中的键值对数量超过一个阈值（负载因子和当前容量的乘积）时，散列表就会被重新映射**（即重建内部数据结构），一般散列表大约是存储桶数量的两倍。

  负载因子体现了数据在底层数组中的疏密程度，越接近 1，则数组越满，查找效率就会更低；越接近 0，则数组越稀疏，空间利用率低。
  
  默认负载因子（0.75）在时间和空间成本之间提供了良好的平衡。

在设置初始容量（默认为 16）时，应考虑映射中的条目数量及其负载因子，以尽量减少重新运行操作的次数。如果初始容量大于最大入口数除以负载因子，则不会发生重新刷新操作。

> 比如，如果你想用哈希表存储 7 个元素，在你知道默认负载因子是 0.75 的情况下，你的初始容量应该设置为多少？
>
> 你可能会想到，应该是 7 / 0.75 = 9.33 应该设置为比 9 大一点的 10。
>
> 事实上，HashMap 也对容量有着 $2^n$ 的要求，因此 10 最后会转换为 16，所以，**最好一开始就设置为最接近 n / 0.75 的 2 的 n 次幂**。

如果许多映射要存储在 `HashMap` 实例中，使用足够大的容量创建映射将允许映射存储的效率高于根据需要执行自动重新散列以增长表。

**`HashMap` 不是线程安全的**。

#### 5.1.1 `HashMap` 的底层数据结构

`HashMap` 底层是哈希表，作为哈希表，底层自然是数组，同时要解决几个要点问题：

1. 哈希值的计算。
2. 冲突解决的方法。

在 `HashMap` 中，哈希值的计算如下：

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

我们知道，每个放入散列表中的类都必须实现 `hashCode` 方法，它可以作为散列表的索引，那么 `HashMap` 中为何还需要实现一个 `hash` 方法？实际上，为了防止某些实现比较差的 `hashCode` 方法导致频繁的冲突，`HashMap` 要对它进行**扰动**，因此这个函数也叫做扰动函数。

冲突解决是使用拉链法，但是并不完全是，因为**当链表的长度超过一个阈值后，会调用内部的一个 `treeifyBin` 方法，这个方法将决定链表会不会变为红黑树**。

所以一个 `HashMap` 的底层数据结构可能是这样的：

![image-20220216160940542](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220216160940542.png)

体现在源码中如下：

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {

    // 该表在初次使用时初始化，并根据需要调整大小。分配时，长度总是 2 的幂
    transient Node<K,V>[] table;
    
    // 保存缓存的 entrySet()
    transient Set<Map.Entry<K,V>> entrySet;
    
    // map 中的键值对数
    transient int size;
    
    // 这个 HashMap 被结构修改的次数结构修改是那些改变 HashMap 中的映射数量或者修改其内部结构（例如，重新散列）的修改
    transient int modCount;
    
    // 调整阈值（threshold = size * loadFactor）
    int threshold;
    
    // 散列表的加载因子
    final float loadFactor;
}
```

`table` 是一个 `Node<K, V>` 的数组，所有的键值对被存储在这里，`Node` 的定义如下：

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
    
    // ...
}
```

它实现了 `Map.Entry` 接口，这个接口我们之前介绍过了，代表键值对实体，除此之外，还有一个 next 的指针，用于链表。

接下来是一些常量的定义：

```java
// 默认初始容量
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16

// 最大容量
static final int MAXIMUM_CAPACITY = 1 << 30;

// 默认负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;

// 使用红黑树而不是链表的最大阈值
static final int TREEIFY_THRESHOLD = 8;

// 收缩时变为使用链表而不是红黑树的阈值
static final int UNTREEIFY_THRESHOLD = 6;

// 使用红黑树时最小的 table 阈值
static final int MIN_TREEIFY_CAPACITY = 64;
```

#### 5.1.2 `HashMap` 的构造函数

`HashMap` 提供了四个构造函数，源码如下：

```java
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}

public HashMap(Map<? extends K, ? extends V> m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}

public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
```

其中，如果没有指定负载因子，则设置为默认的 0.75；如果没有指定容量，则设置为默认的容量 16。注意，这些构造方法（除了从其他 `Map` 构造）并未初始化数组，这和 `ArrayList` 类似。

最根本的构造方法是第四个，在这个方法中，**`tableSizeFor` 方法用于决定阈值，它经过多次右移和位运算，最后让阈值保持 $2^n$**，这个机制类似于我们之前分析过的 `PriorityQueue`。

表明上看，我们的指定的容量被转换为最近最小的 $2^n$，并且赋给了阈值。但是实际上，在这里并未对实际数组做任何初始化，在第一次调用 `put` 以后才会初始化，初始化是 `resize` 方法实现的，详情可以看[`HashMap` 的扩容](#5.1.6 HashMap 的扩容)。

#### 5.1.3 `HashMap` 插入键值对

`HashMap` 插入键值对是使用 `put` 方法，`put` 内部调用了 `putVal` 方法：

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

所以插入键值对的核心就在 `putVal` 方法，大致的思路为：

- 对 key 的 `hashCode()` 做 hash 扰动，然后根据扰动后 hash 值再计算 `Node` 的存储位置
- 如果没有哈希碰撞，直接放到桶里；如果有哈希碰撞，则以链表节点的形式存在桶里
- 如果哈希碰撞导致链表过长（大于等于 `TREEIFY_THRESHOLD`，数值为 8），就把链表转换成红黑树
- 如果节点已经存在就替换旧值
- 桶数量超过 `容量 * 负载因子`，`HashMap` 调用 `resize` 自动扩容一倍

下面是源码解读：

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; 
    Node<K,V> p; 
    int n, i;
    // 如果 table 还没有初始化，则通过 resize 方法初始化
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // (n - 1) & hash 确定元素存放在哪个桶中，如果桶为空，新生成结点放入桶中（此时这个结点是放在数组中）
    // 注意 n 符合 2 的 n 次方，则 n - 1 的二进制表示是全 1，和 PriorityQueue 的机制是一样的
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 数组已存在该元素
    else {
        Node<K,V> e; K k;
        // 如果 hash 值相等，key 也相等，则使用 e 记录下来
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        // hash 值不相等，并且节点类型是红黑树节点
        else if (p instanceof TreeNode)
            // 放入树中
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // 在链表末尾处插入
        else {
            for (int binCount = 0; ; ++binCount) {
                // 到达链表末尾
                if ((e = p.next) == null) {
                    // 插入
                    p.next = newNode(hash, key, value, null);
                    // 如果数目超过了设置的变为红黑树的阈值，则执行 treeifyBin 方法
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        // 这个方法会根据 HashMap 数组来决定是否转换为红黑树：只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间；否则，就是只是对数组扩容
                        treeifyBin(tab, hash);
                    break;
                }
                // 如果在找链表尾部的过程中发现重复的 key，直接跳出
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
       
        // e 就是用来寻找 key 的 hash 值相同，且 key 也相同的节点的
       	// 如果 e 不为 null，则表示找到了
        // 如果 e 为 null，则啥也不做，因为之前已经做好了插入
        if (e != null) { // existing mapping for key
            // 记录原来的值，等会要返回
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                // 覆盖掉原来的值
                e.value = value;
            // 回调，HashMap 中的实现为空，其子类根据需要来实现此方法
            afterNodeAccess(e);
            // 返回旧值
            return oldValue;
        }
    }
    ++modCount;
    // 如果 size 大于阈值，扩容
    if (++size > threshold)
        resize();
    // 回调，HashMap 中的实现为空，其子类根据需要来实现此方法
    afterNodeInsertion(evict);
    return null;
}
```

链表相关的操作并不难，关键在于 `treeifyBin` 以及红黑树插入的 `putTreeVal` 方法。

##### 5.1.3.1 相关红黑树的操作在 `HashMap` 中的实现

首先是红黑树节点 `TreeNode` 的定义：

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent;  // red-black tree links
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;    // needed to unlink next upon deletion
    boolean red;

    // ...
}
```

红黑树基本的四个属性（左右孩子，父亲，颜色）它都具备，并且还有一个额外的 `prev` 指针，这是为了在构建红黑树的同时保留链表的结构，便于红黑树转回链表。

注意，它继承自 `LinkedHashMap.Entry`，我们看一下它的定义：

```java
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
```

而它又继承自 `HashMap.Node`，`HashMap.Node` 又实现自 `Map.Entry`。

这里 `TreeNode` 并未使用到 `LinkedHashMap.Entry` 的两个独特指针，那为什么还要继承它呢？实际上，这是为了子类 `LinkedHashMap` 考虑。

###### 5.1.3.1.1 左右旋转

左旋右旋是红黑树的基本操作，源码如下：

```java
/**
 * @param root 树的根节点
 * @param p 要左旋的节点
 */
static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,
                                      TreeNode<K,V> p) {
    TreeNode<K,V> r, pp, rl;
    // 如果 p 不为 null 且 p 的右子树不为 null
    if (p != null && (r = p.right) != null) {
        // 首先把 p 的右子树（新根节点）的左子树接到原本根节点的右子树上
       	// 然后用 rl 记录
        if ((rl = p.right = r.left) != null)
            // rl 的父亲指向 p
            rl.parent = p;
        // 把原根的父亲赋给新根，如果没有父亲，则说明是整棵树的根节点，要变为黑色
        if ((pp = r.parent = p.parent) == null)
            (root = r).red = false;
        // 否则，更新祖父的左右指向
        else if (pp.left == p)
            pp.left = r;
        else
            pp.right = r;
        // 把原根节点接到新根的左边
        r.left = p;
        // 更新原根的父亲指向
        p.parent = r;
    }
    return root;
}
```

右旋是对称的，这里不再讨论。

###### 5.1.3.1.2 链表转红黑树

首先，我们要分析的是 `HashMap` 中的 `treefyBin` 方法：

```java
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    // 如果 table 未初始化，或者长度不足以达到使用红黑树时最小的 table 阈值（默认是 64），则只是进行扩容
    // 注意，这个方法的前置条件是某个桶的链表长度大于阈值（默认是 8）
    // 因此，链表转红黑树的条件实际上有两个，必须同时满足
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    // 如果tab中存在该 hash 对应的键值对
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        // 定义头尾节点，因为 TreeNode 要被串成双向链表
        TreeNode<K,V> hd = null, tl = null;
        // 遍历该链表，将其转换为 TreeNode，并且链接为双向链表
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        // 把新双向链表的头节点赋给 tab[index]
        if ((tab[index] = hd) != null)
            // 对 hd 调用树化方法
            hd.treeify(tab);
    }
}
```

> **负载因子取 0.75 的原因**
>
> 默认负载因子是 0.75，这是基于大量的数据统计得出的。
>
> 我们从上面的分析中，知道了链表转红黑树的条件：
>
> 1. 表长达到 64
> 2. 链表长度达到 8
>
> 实际上，根据统计，当表的大小达到 64 时，如果负载因子是 0.75，并且链表长度达到 8 时，发生哈希冲突的概率是 0.00000006，概率表如下：
>
> ![image-20220322201722024](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220322201722024.png)
>
> 这已经是非常非常小的概率了，因此**链表的长度很难达到 8，也就是几乎不可能有转到红黑树的情况发生**。

我们可以看到，链表的节点类型 `Node` 被替换为 `TreeNode`，然后连接成 双向链表，最后把双向链表的头节点赋给数组中的对应位置，然后从这个节点开始转换成红黑树。

接下来，我们就分析 `TreeNode` 中的 `treeify` 方法：

```java
final void treeify(Node<K,V>[] tab) {
    TreeNode<K,V> root = null;
    // 遍历双向链表
    for (TreeNode<K,V> x = this, next; x != null; x = next) {
        next = (TreeNode<K,V>)x.next;
        // 初始化左右孩子为 null
        x.left = x.right = null;
        // 如果树根还是空，则让当前节点（第一个）成为树根
        if (root == null) {
            x.parent = null;
            x.red = false;
            root = x;
        }
        else {
            K k = x.key;
            int h = x.hash;
            Class<?> kc = null;
            // p 指向根
            for (TreeNode<K,V> p = root;;) {
                // dir 指示方向（左右），ph 是当前节点的 hash 值
                int dir, ph;
                K pk = p.key;
                // 如果 ph 更大，则左边
                if ((ph = p.hash) > h)
                    dir = -1;
                // 如果 ph 更小，则右边
                else if (ph < h)
                    dir = 1;
                // h 和 ph 相等，则通过其他方式比较，可以是 Comparable 比较
                // 如果这样比较下来还是相等，就通过 tieBreakOrder 比较，该方法主要是打破次序
                else if ((kc == null &&
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0)
                    dir = tieBreakOrder(k, pk);

           		// xp 表示 x 的 parent
                TreeNode<K,V> xp = p;
                if ((p = (dir <= 0) ? p.left : p.right) == null) {
                    x.parent = xp;
                  	// 分别插入到左边和右边
                    if (dir <= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    // 调整平衡
                    root = balanceInsertion(root, x);
                    break;
                }
            }
        }
    }
    // 把根节点移到最前面，因为平衡涉及旋转，根节点不一定是原来的根节点
    moveRootToFront(tab, root);
}
```

该方法遍历双向链表，对于除根节点的每一个节点，根据其 hash 值决定插到左子树还是右子树，插入完毕以后立即进行平衡的调整。

所以，我们重点分析平衡调整：

```java
static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,
                                            TreeNode<K,V> x) {
    // 新插入节点直接设置为红色
    x.red = true;
    // xp 是 x 的父亲，xpp 是祖父，xppl是祖父的左孩子，xppr 是祖父的右孩子
    for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {
        // 如果 x 是根，则 x 是黑色，并且直接返回
        if ((xp = x.parent) == null) {
            x.red = false;
            return x;
        }
        // 如果 x 的父亲是黑色，或者 xpp 是 null，直接返回根
        else if (!xp.red || (xpp = xp.parent) == null)
            return root;
        // 如果 xp 是 xpp 的左孩子
        if (xp == (xppl = xpp.left)) {
            // 如果 xppr 不为空，并且是红色，此时 xpp 一定是黑色
            if ((xppr = xpp.right) != null && xppr.red) {
                // xppr 置为黑色，等会 xpp 要变红，保持右边黑高不变
                xppr.red = false;
            	// 由于 p 是红色，因此 xp 一定要是黑色
                xp.red = false;
                // xpp 置为红色，恢复左边黑高
                xpp.red = true;
                x = xpp;
            }
            // 如果 xppr 是黑色
            else {
                // 如果 x 是 xp 的右孩子
                if (x == xp.right) {
                    // 左旋，变成 x 是 xp 的左孩子的情况
                    root = rotateLeft(root, x = xp);
                    // xp 重新指向 x 的 parent，同时更新 xpp
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                // 如果 xp 不空
                if (xp != null) {
                    // 设为黑色，左子树高度变高了
                    xp.red = false;
                    if (xpp != null) {
                        // xpp 设为红色，恢复左子树高度
                        xpp.red = true;
                        // 右旋，左子树高度不变，右子树高度恢复
                        root = rotateRight(root, xpp);
                    }
                }
            }
        }
        // 如果是右孩子，处理和左边对称
        else {
            if (xppl != null && xppl.red) {
                xppl.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
            }
            else {
                if (x == xp.left) {
                    root = rotateRight(root, x = xp);
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                if (xp != null) {
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;
                        root = rotateLeft(root, xpp);
                    }
                }
            }
        }
    }
}
```

如果对红黑树增加节点后调整平衡还不懂的话，请参阅：红黑树。

###### 5.1.3.1.3 插入节点

`putTreeVal` 方法如下，本质上和普通的二叉排序树插入没什么区别，只是多了一个平衡调整：

```java
/**
 * @param map HashMap
 * @param tab Node 的数组
 * @param h 哈希值
 * @param k Key
 * @param v Value
 */
final TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,
                               int h, K k, V v) {
    Class<?> kc = null;
    boolean searched = false;
    // 获取根
    TreeNode<K,V> root = (parent != null) ? root() : this;
    for (TreeNode<K,V> p = root;;) {
        // dir：方向，ph：parent 的 hash 值，pk：parent 的 key
        int dir, ph; K pk;
        // 如果 ph 大于传入的哈希值，则方向设置为左边
        if ((ph = p.hash) > h)
            dir = -1;
        // 否则，方向设置为右边
        else if (ph < h)
            dir = 1;
        // 如果 key 相等，直接返回
        else if ((pk = p.key) == k || (k != null && k.equals(pk)))
            return p;
        // 如果 key 不等，但是 hash 相等
        else if ((kc == null &&
                  (kc = comparableClassFor(k)) == null) ||
                 (dir = compareComparables(kc, k, pk)) == 0) {
            if (!searched) {
                TreeNode<K,V> q, ch;
                searched = true;
                // 递归寻找是否有 hash 相同且 equals 也相同的节点，如果找到了，直接返回
                if (((ch = p.left) != null &&
                     (q = ch.find(h, k, kc)) != null) ||
                    ((ch = p.right) != null &&
                     (q = ch.find(h, k, kc)) != null))
                    return q;
            }
            // 打破冲突
            dir = tieBreakOrder(k, pk);
        }

        TreeNode<K,V> xp = p;
        if ((p = (dir <= 0) ? p.left : p.right) == null) {
            Node<K,V> xpn = xp.next;
            TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);
            // 插入到左边或右边
            if (dir <= 0)
                xp.left = x;
            else
                xp.right = x;
            xp.next = x;
            x.parent = x.prev = xp;
            if (xpn != null)
                ((TreeNode<K,V>)xpn).prev = x;
            // 保持插入后平衡，并把调整后树真正的根节点放到数组中
            moveRootToFront(tab, balanceInsertion(root, x));
            return null;
        }
    }
}
```

#### 5.1.4 `HashMap` 获取键值对

`HashMap` 获取键值对主要是基于 `get` 方法：

```JAVA
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
```

我们接着看 `getNode` 方法：

```java
final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    // 如果 table 不空，并且 table[hash] 不为空
    if ((tab = table) != null && (n = tab.length) > 0 
        && (first = tab[(n - 1) & hash]) != null) {
        // 如果 hash 相等，且 key 相等，则已经找到
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        // 继续往下找
        if ((e = first.next) != null) {
            // 如果已经转换成红黑树，则调用红黑树的寻找
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            // 链表寻找
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    // 未找到，返回 null
    return null;
}
```

链表的操作依然是很简单，我们来看一下红黑树中的查找。

##### 5.1.4.1 相关红黑树的操作在 `HashMap` 中的实现

###### 5.1.4.1.1 查找节点

```java
final TreeNode<K,V> getTreeNode(int h, Object k) {
    return ((parent != null) ? root() : this).find(h, k, null);
}
```

这里调用了 `find` 方法：

```java
final TreeNode<K,V> find(int h, Object k, Class<?> kc) {
    TreeNode<K,V> p = this;
    do {
        int ph, dir; K pk;
        TreeNode<K,V> pl = p.left, pr = p.right, q;
        // 如果 ph 大于传入的 h，则左子树
        if ((ph = p.hash) > h)
            p = pl;
        // 小于则右子树
        else if (ph < h)
            p = pr;
        // hash 相等，且 key 相等，则找到了
        else if ((pk = p.key) == k || (k != null && k.equals(pk)))
            return p;
        // 如果没有左子树，则 p 只能是右子树
        else if (pl == null)
            p = pr;
        // 如果没有右子树，则只能是左子树
        else if (pr == null)
            p = pl;
        // hash 相等，但是 key 不等
        else if ((kc != null ||
                  (kc = comparableClassFor(k)) != null) &&
                 (dir = compareComparables(kc, k, pk)) != 0)
            p = (dir < 0) ? pl : pr;
        // 递归寻找
        else if ((q = pr.find(h, k, kc)) != null)
            return q;
        else
            p = pl;
    } while (p != null);
    return null;
}
```

`find` 方法也不过是普通的二叉排序树的查找实现。

#### 5.1.5 `HashMap` 删除键值对

在 `HashMap` 中，删除键值对主要通过 `remove` 方法完成：

```java
public V remove(Object key) {
    Node<K,V> e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}
```

其根本是调用了 `removeNode` 方法：

```java
final Node<K,V> removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node<K,V>[] tab; Node<K,V> p; int n, index;
    // 如果 table 不空，且 table[hash] 不空
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (p = tab[index = (n - 1) & hash]) != null) {
        // node 记录要删除的节点
        Node<K,V> node = null, e; K k; V v;
        // 如果第一个就是要找的节点，则记录
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            node = p;
        // 往下找
        else if ((e = p.next) != null) {
            // 如果是红黑树，调用红黑树的获取节点的方法
            if (p instanceof TreeNode)
                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
            // 否则，链表向下寻找
            else {
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        // 根据 key 找到了 node
        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
            // 如果是红黑树，调用红黑树删除
            if (node instanceof TreeNode)
                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
            // 如果是首节点，则让 tab[hash] = 首节点的下一个节点即可
            else if (node == p)
                tab[index] = node.next;
            // 否则，直接让 p 的 next 指向 node.next，node 相当于失联了
            else
                p.next = node.next;
            ++modCount;
            --size;
            // 回调
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
```

##### 5.1.5.1 相关红黑树的操作在 `HashMap` 中的实现

###### 5.1.5.1.1 删除节点

源码如下：

```java
final void removeTreeNode(HashMap<K,V> map, Node<K,V>[] tab,
                          boolean movable) {
    int n;
    // 判空，若空直接返回
    if (tab == null || (n = tab.length) == 0)
        return;
    // 获得索引
    int index = (n - 1) & hash;
    TreeNode<K,V> first = (TreeNode<K,V>)tab[index], root = first, rl;
    // succ 是后继，pred 是前驱
    TreeNode<K,V> succ = (TreeNode<K,V>)next, pred = prev;
    // 如果 pred 节点不存在，则意味着当前节点为根节点
    if (pred == null)
        tab[index] = first = succ;
    else
        // 如果 pred 节点存在
        // 则将 pred 节点的后节点指向 succ 节点
        pred.next = succ;
    if (succ != null)
        // 如果 succ 节点存在，则将 succ 节点的前节点指向 pred 节点
        succ.prev = pred;
    if (first == null)
        return;
    if (root.parent != null)
        // 获取真实的 root 节点
        root = root.root();
    
    // 以上都是整理链表关系
    // 下面是整理红黑树关系
    
    // 如果 root 为空或者 root 的左子树为空或者右子树为空，则无需维持红黑树结构，转为链表
    if (root == null
        || (movable
            && (root.right == null
                || (rl = root.left) == null
                || rl.left == null))) {
        tab[index] = first.untreeify(map);  // too small
        return;
    }
    // p 是当前节点，pl 是左，pr 是右，replacement 是待替换节点
    TreeNode<K,V> p = this, pl = left, pr = right, replacement;
    // 如果左右子树都不为空
    if (pl != null && pr != null) {
        TreeNode<K,V> s = pr, sl;
        // 找到右子树的最小节点（后继），用 s 记录，下面的操作是要交换 s 和 p
        while ((sl = s.left) != null) // find successor
            s = sl;
        // 交换 s 和 p 的颜色
        boolean c = s.red; s.red = p.red; p.red = c; // swap colors
        TreeNode<K,V> sr = s.right;
        TreeNode<K,V> pp = p.parent;
        // 如果 p 是 s 的父亲
        if (s == pr) { // p was s's direct parent
            p.parent = s;
            s.right = p;
        }
        // 否则
        else {
            // sp 是 s 的父亲
            TreeNode<K,V> sp = s.parent;
            // 将 p 节点的父节点指向 sp
            if ((p.parent = sp) != null) {
                // 判断 s 节点在 sp 节点的哪一侧，然后更新 sp 的指向
                if (s == sp.left)
                    sp.left = p;
                else
                    sp.right = p;
            }
            // 将 pr 节点变成 s 节点的右节点
            if ((s.right = pr) != null)
                pr.parent = s;
        }
        // 由于 s 是 p 右子树中最小的那个，因此不会有左子树
        p.left = null;
        // 更新 parent 关系
        if ((p.right = sr) != null)
            sr.parent = p;
        if ((s.left = pl) != null)
            pl.parent = s;
        if ((s.parent = pp) == null)
            root = s;
        else if (p == pp.left)
            pp.left = s;
        else
            pp.right = s;
        // 设置 replacement 节点为 sr（s 没有左子树）
        if (sr != null)
            replacement = sr;
        else
            replacement = p;
    }
    // 左子树不空，replacement 直接是左子树
    else if (pl != null)
        replacement = pl;
    // 右子树不空，replacement 直接是右子树
    else if (pr != null)
        replacement = pr;
    // 左右都空，则就为 p
    else
        replacement = p;
    // 如果 replacement 不为 p，则替换
    if (replacement != p) {
        TreeNode<K,V> pp = replacement.parent = p.parent;
        if (pp == null)
            root = replacement;
        else if (p == pp.left)
            pp.left = replacement;
        else
            pp.right = replacement;
        p.left = p.right = p.parent = null;
    }

    // 如果 p 是红色，则删除后并不影响高度，否则调整高度
    TreeNode<K,V> r = p.red ? root : balanceDeletion(root, replacement);

    if (replacement == p) {  // detach
        TreeNode<K,V> pp = p.parent;
        p.parent = null;
        if (pp != null) {
            if (p == pp.left)
                pp.left = null;
            else if (p == pp.right)
                pp.right = null;
        }
    }
    if (movable)
        moveRootToFront(tab, r);
}
```

这里也是实现了一个二叉排序树的删除，重点是删除后的调整：

```java
static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root,
                                           TreeNode<K,V> x) {
    // xp 是 x 的父亲，xpl 是 xp 左孩子，xpr 是 x 的右孩子
    for (TreeNode<K,V> xp, xpl, xpr;;) {
        // 如果 x 为根或者 x 是空，直接返回
        if (x == null || x == root)
            return root;
        // 如果 xp 为空，则 x 也是根，返回
        else if ((xp = x.parent) == null) {
            x.red = false;
            return x;
        }
        // 如果 x 是红色，返回
        else if (x.red) {
            x.red = false;
            return root;
        }
        // 如果 x 是 xp 的左孩子
        else if ((xpl = xp.left) == x) {
            // 如果兄弟不空，且为红色，此时 xp 必定是黑色，要转换为兄弟是黑色的情况处理
            // 这时，交换 xpr 和 xp 的颜色，然后左旋，来到兄弟是黑色的情况
            if ((xpr = xp.right) != null && xpr.red) {
                xpr.red = false;
                xp.red = true;
                root = rotateLeft(root, xp);
                // 更新 xpr 和 xp 的指向
                xpr = (xp = x.parent) == null ? null : xp.right;
            }
            // 如果 xpr 为 null，则 x 指向 xp 向上递归调整
            if (xpr == null)
                x = xp;
            else {
                // sl 是 xpr 的左孩子，sr 是 xpr 的右孩子
                TreeNode<K,V> sl = xpr.left, sr = xpr.right;
                // 如果 sr 和 sl 双黑
                if ((sr == null || !sr.red) &&
                    (sl == null || !sl.red)) {
                    // xpr 变红
                    xpr.red = true;
                    // x 指向 xp 递归处理
                    x = xp;
                }
                else {
                    // 如果 sr 是黑，此时 sl 是红，要变成 sr 是红的情况处理
                    if (sr == null || !sr.red) {
                        // 交换兄弟和其左孩子的颜色
                        if (sl != null)
                            sl.red = false;
                        xpr.red = true;
                        // 右旋，来到 sr 是红色的情况
                        root = rotateRight(root, xpr);
                        xpr = (xp = x.parent) == null ?
                            null : xp.right;
                    }
                    if (xpr != null) {
                        // 交换 xp 和 xpr 的颜色，这里是把 xp 的颜色赋给 xpr
                        xpr.red = (xp == null) ? false : xp.red;
                        if ((sr = xpr.right) != null)
                            // sr 变黑
                            sr.red = false;
                    }
                    if (xp != null) {
                        // xp 变成 xpr 的颜色，也就是黑色
                        xp.red = false;
                        // 左旋
                        root = rotateLeft(root, xp);
                    }
                    x = root;
                }
            }
        }
        // 对称处理
        else { // symmetric
            if (xpl != null && xpl.red) {
                xpl.red = false;
                xp.red = true;
                root = rotateRight(root, xp);
                xpl = (xp = x.parent) == null ? null : xp.left;
            }
            if (xpl == null)
                x = xp;
            else {
                TreeNode<K,V> sl = xpl.left, sr = xpl.right;
                if ((sl == null || !sl.red) &&
                    (sr == null || !sr.red)) {
                    xpl.red = true;
                    x = xp;
                }
                else {
                    if (sl == null || !sl.red) {
                        if (sr != null)
                            sr.red = false;
                        xpl.red = true;
                        root = rotateLeft(root, xpl);
                        xpl = (xp = x.parent) == null ?
                            null : xp.left;
                    }
                    if (xpl != null) {
                        xpl.red = (xp == null) ? false : xp.red;
                        if ((sl = xpl.left) != null)
                            sl.red = false;
                    }
                    if (xp != null) {
                        xp.red = false;
                        root = rotateRight(root, xp);
                    }
                    x = root;
                }
            }
        }
    }
}
```

如果对红黑树删除节点后调整平衡还不懂的话，请参阅：红黑树。

#### 5.1.6 `HashMap` 的扩容

`HashMap` 的扩容机制基于 `resize` 方法，其基本思想是把容量扩充为原来的两倍，然后重新计算索引值并移动就完成了。但是重新计算索引值的方法非常巧妙，省去了重新 hash 的时间。

具体来说，由于容量是原来的两倍，我们知道在索引时，是通过 `(n - 1) & hash` 来计算的，`(n - 1)` 中 n 的大小决定了有效位，如果 n 变为原来的两倍（即左移 1 位），那么得到的实际索引也会左移 1 位，这时就只有两种情况：

1. 左移后的第一位是 1，这时就可以加上旧容量，得到新的索引。
2. 左移后的第一位是 0，这时索引未发生改变，什么都不做。

看下面的例子：

![image-20220322211247660](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220322211247660.png)

hash1 和 hash2 是虽然是两个不同的 hash 值，但是扩容之前的有效位是一致的。左移以后，n - 1 相当于往左移了 1 位，这时 hash1 和 hash2 的有效范围又多了 1 位，二者的差距就在新加的那一位上。

以 0_0101 为例，加上原容量 1_0000，结果为 1_0101，这个值恰好为 hash2 新有效范围。这说明 hash1 + oldCap == hash2。因此在重新哈希的过程中，只需要看新增的 1 位即可决定它扩容后的位置，并且位置直接可以定在 `oldCap + hash`。

源码如下：

```java
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    // 旧容量，如果 table 未初始化，则这里是 0
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    // 旧阈值，注意，即使 table 未初始化，但是阈值是有可能初始化了的
    int oldThr = threshold;
    // 新容量和新阈值
    int newCap, newThr = 0;
    
    // 如果 table 已经初始化
    if (oldCap > 0) {
        // 旧容量超过了设定的最大值，此时就不再扩充了
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 新容量设置为原来的两倍，且旧容量没超过最大值，但是超过了默认的容量
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
            // 阈值也设置为原来的两倍
            newThr = oldThr << 1; // double threshold
    }
    // table 未初始化，且阈值大于 0，这说明构造时指定了初始容量
    else if (oldThr > 0) // initial capacity was placed in threshold
        // 新容量就等于阈值
        newCap = oldThr;
    else {
        // 默认初始化
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 如果新阈值为 0，则表示 table 未初始化，且构造时指定了初始容量
    // 那么在构造函数里，已经由初始容量得到了旧阈值，而旧阈值已经被赋给了新容量
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        // 新阈值更新为传入时容量 * 负载因子
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    // 阈值设置为新阈值
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    // 使用新容量初始化 table
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // 把每个 bucket 都移动到新的数组中
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                // 如果没有 next，则说明这个地方没有发生哈希冲突，直接赋值
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                // 如果是树节点，则拆分，甚至有可能取消树化
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>) e).split(this, newTab, j, oldCap);
                else {
                    // 链表优化，把原有链表拆分成两个链表
                    // lo 保存不用移动的 bucket
                    // hi 保存移动到原索引 + oldCap 的 bucket
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        // lo 记录不用移动的 bucket
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // hi 记录移动到原索引 + oldCap 的 bucket
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // lo 链表放到新数组里
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // hi 链表放到新数组里
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

我们从这个代码中，还得出一个重要的结论：在初始化时如果指定了容量，表面上看容量被赋给了阈值，实际上容量就是 `table` 的实际容量，在 `resize` 中会把阈值重新调整为容量 * 负载因子。所以，`HashMap` 的扩容只与 `threshold` 有关。

##### 5.1.6.1 红黑树退化为链表

在 `resize` 时，我们注意到红黑树有可能会退化回链表，这个操作是由 `split` 实现的：

```java
final void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {
    TreeNode<K,V> b = this;
    
    // 和链表一样，使用 lo 和 hi 统计需要移动的和不需要移动的 bucket
    TreeNode<K,V> loHead = null, loTail = null;
    TreeNode<K,V> hiHead = null, hiTail = null;
    int lc = 0, hc = 0;

    // 把红黑树中的结点依次添加到 low 和 high 中
    for (TreeNode<K,V> e = b, next; e != null; e = next) {
        next = (TreeNode<K,V>)e.next;
        e.next = null;
        
        // 通过位运算判断
        if ((e.hash & bit) == 0) {
            if ((e.prev = loTail) == null)
                loHead = e;
            else
                loTail.next = e;
            loTail = e;
            ++lc;
        }
        else {
            if ((e.prev = hiTail) == null)
                hiHead = e;
            else
                hiTail.next = e;
            hiTail = e;
            ++hc;
        }
    }

    if (loHead != null) {
        // 如果 low 的元素个数小于等于 6，退化成链表
        // 并插入到新数组 tab[index] 的位置上，index 是当前红黑树所在旧数组坐标
        if (lc <= UNTREEIFY_THRESHOLD)
            tab[index] = loHead.untreeify(map);
        else {
            tab[index] = loHead;
            if (hiHead != null) // (else is already treeified)
                loHead.treeify(tab);
        }
    }
    if (hiHead != null) {
        // 如果 high 的元素个数小于等于 6，退化成链表
        // 并插入到新数组 tab[index + bit] 的位置上，index 是当前红黑树所在旧数组坐标，bit 是旧数组长度
        if (hc <= UNTREEIFY_THRESHOLD)
            tab[index + bit] = hiHead.untreeify(map);
        else {
            tab[index + bit] = hiHead;
            if (loHead != null)
                hiHead.treeify(tab);
        }
    }
}
```

和 `resize` 中链表的重新放元素一样，使用 lo 和 hi 两个链表统计需要移动的和不需要移动的 bucket，但是目的是为了判断是否需要取消树化，当链表的长度小于等于退化的阈值（默认为 6）时，就可以取消树化了。

看到这里读者应该还有一个疑问，为什么链表转为二叉树的阈值是 8，而退化的阈值是 6？

这是因为**在进化和退化的阈值之间需要有一个缓冲，避免发生频繁的转换**。

### 5.2 `LinkedHashMap`

`LinkedHashMap` 继承自 `HashMap`，它**通过维护一个保存所有条目（`Entry`）的双向链表，保证了元素迭代的顺序（即插入顺序）**。

可以在构造 `LinkedHashMap` 时指定顺序，可以按照插入顺序或访问顺序排序。

`LinkedHashMap` 内部的 `Entry` 继承自 `HashMap.Node`，我们之前在介绍 `HashMap` 红黑树节点的类定义时介绍过 `LinkedHashMap.Entry`，它有一个 `before` 和 `after` 指针，这里就不重复介绍了。

#### 5.2.1 `LinkedHashMap` 的原理

> 由于有 `HashMap` 的基础，该类的原理我们不会细讲。

双向链表是有一个头尾指针的，事实上也正是如此：

```java
public class LinkedHashMap<K,V>
    extends HashMap<K,V>
    implements Map<K,V> {

    // 双链表的头指针
    transient LinkedHashMap.Entry<K,V> head;
    // 双链表的尾指针
    transient LinkedHashMap.Entry<K,V> tail;
    // 迭代排序方法：true 表示访问顺序；false 表示插入顺序
    final boolean accessOrder;
}
```

它本质上并没有改变 `HashMap` 中的结构，而是通过额外的指针信息维护一个顺序，一定要牢记这一点，否则看源码时可能会绕进去。

![image-20220423085246078](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220423085246078.png)

##### 5.2.1.1 链表的建立过程

链表的建立过程是在插入键值对节点时开始的，初始情况下，让 `LinkedHashMap` 的 `head` 和 `tail` 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 `tail` 引用指向节点的后面，即可实现链表的更新。

`LinkedHashMap` 本身并没有覆写父类的 `put` 方法，而是直接使用了父类的实现。但在 `HashMap` 中，`put` 方法插入的是 `HashMap` 内部类 `Node` 类型的节点，该类型的节点并不具备与 `LinkedHashMap` 内部类 `Entry` 及其子类型节点组成链表的能力。那么，`LinkedHashMap` 是怎样建立链表的呢？在展开说明之前，我们先看一下 `LinkedHashMap` 插入操作相关的代码：

```java
// LinkedHashMap 重写了 HashMap 中的此方法
@Override
Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
    LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<K,V>(hash, key, value, e);
    // 将 Entry 接在双向链表的尾部
    linkNodeLast(p);
    return p;
}

// LinkedHashMap 中实现
private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
    LinkedHashMap.Entry<K,V> last = tail;
    tail = p;
    // last 为 null，表明链表还未建立
    if (last == null)
        head = p;
    else {
        // 将新节点 p 接在链表尾部
        p.before = last;
        last.after = p;
    }
}
```

`newNode` 在 `HashMap` 中是创建新节点的方法，那么这里重写以后，创建的节点就是 `LinkedHashMap.Entry`，并通过 `linkNodeLast` 方法将 `Entry` 接在双向链表的尾部，实现了双向链表的建立。

##### 5.2.1.2 删除过程

与插入操作一样，`LinkedHashMap` 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 `LinkedHashMap` 所维护的双向链表，这不是它的职责。那么删除及节点后，被删除的节点该如何从双链表中移除呢？当然，办法还算是有的，我们之前在 `HashMap` 中曾经见到过，`HashMap` 为子类预留了几个回调：

```java
void afterNodeAccess(Node<K,V> p) { }
void afterNodeInsertion(boolean evict) { }
void afterNodeRemoval(Node<K,V> p) { }
```

所以，在删除节点后，回调方法 `afterNodeRemoval` 会被调用。`LinkedHashMap` 覆写该方法，并在该方法中完成了移除被删除节点的操作。相关源码如下：

```java
void afterNodeRemoval(Node<K,V> e) { // unlink
    LinkedHashMap.Entry<K,V> p =
        (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
    // 将 p 节点的前驱后后继引用置空
    p.before = p.after = null;
    // b 为 null，表明 p 是头节点
    if (b == null)
        head = a;
    else
        b.after = a;
    // a 为 null，表明 p 是尾节点
    if (a == null)
        tail = b;
    else
        a.before = b;
}
```

这和之前 `LinkedList` 删除元素的代码有几分相似，应该很容易看懂。

##### 5.2.1.3 维护访问顺序

我们在 `LinkedHashMap` 的字段中看到一个 `accessOrder` 的布尔型变量，表示是否维护访问顺序。

刚刚我们提到的其实都是默认的插入顺序的维护，访问顺序的维护要更复杂一些，但是也不是特别复杂：当我们调用 `get/getOrDefault/replace` 等方法时，只需要**将这些方法访问的节点移动到链表的尾部即可**。

相应的源码如下：

```java
// LinkedHashMap 中覆写
public V get(Object key) {
    Node<K,V> e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    // 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}

// LinkedHashMap 中覆写
void afterNodeAccess(Node<K,V> e) { // move node to last
    LinkedHashMap.Entry<K,V> last;
    if (accessOrder && (last = tail) != e) {
        LinkedHashMap.Entry<K,V> p =
            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
        p.after = null;
        // 如果 b 为 null，表明 p 为头节点
        if (b == null)
            head = a;
        else
            b.after = a;

        if (a != null)
            a.before = b;
        // 这里存疑，父条件分支已经确保节点 e 不会是尾节点，
        // 那么 e.after 必然不会为 null，不知道 else 分支有什么作用
        else
            last = b;

        if (last == null)
            head = p;
        else {
            // 将 p 接在链表的最后
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
```

##### 5.2.1.3 利用插入回调实现 LRU 缓存

三个回调中，只剩下插入回调没有讲解了，现在我们就看一下它的源码：

```java
void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry<K,V> first;
    // 根据条件判断是否移除最近最少被访问的节点
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

// 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;
}
```

我们看到，在插入之后，如果 `removeEldestEntry` 返回 true，很可能会移除最近最少使用的节点。

这不就是 LRU 机制吗，我们可以写一个子类，重写 `removeEldestEntry` 方法，就能达到缓存的目的：

```java
public class SimpleCache<K, V> extends LinkedHashMap<K, V> {

    private static final int MAX_NODE_NUM = 100;

    private int limit;

    public SimpleCache() {
        this(MAX_NODE_NUM);
    }

    public SimpleCache(int limit) {
        super(limit, 0.75f, true);
        this.limit = limit;
    }

    public V put(K key, V val) {
        return super.put(key, val);
    }

    public V get(K key) {
        return super.get(key);
    }

    public boolean exists(K key) {
        return containsKey(key);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > limit;
    }
}
```

### 5.3 `TreeMap`

与 `HashMap` 相比，`TreeMap` 是一个能比较元素大小的 `Map` 集合，会对传入的 key 进行了大小排序。其中，可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序。

`TreeMap` 实现了 `NavigableMap`，`NavigableMap` 又继承了 `SortedMap`，而 `SortedMap` 继承了 `Map` ，表示它是一个有序的 `Map`。

`SortedMap` 的排序方式有两种：**自然排序**或者**用户指定比较器**。**插入有序 `SortedMap` 的所有元素都必须实现 `Comparable` 接口（或者被指定的比较器所接受）**。

另外，所有 `SortedMap` 实现类都应该提供 4 个标准构造方法：

1. `void`（无参数）构造方法，它创建一个空的有序 `Map`，按照键的自然顺序进行排序
2. 带有一个 `Comparator` 类型参数的构造方法，它创建一个空的有序 `Map`，根据指定的比较器进行排序
3. 带有一个 `Map` 类型参数的构造方法，它创建一个新的有序 `Map`，其键-值映射关系与参数相同，按照键的自然顺序进行排序
4. 带有一个 `SortedMap` 类型参数的构造方法，它创建一个新的有序 `Map`，其键-值映射关系和排序方法与输入的有序 Map 相同。无法保证强制实施此建议，因为接口不能包含构造方法

它提供的方法如下表所示：

| 方法                                        | 作用                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| `Comparator<? super K> comparator()`        | 返回用于对该 `Map` 中的 key 进行排序的比较器                 |
| `SortedMap<K,V> subMap(K fromKey, K toKey)` | 返回子 `Map`，包括起始不包括结尾                             |
| `SortedMap<K,V> headMap(K toKey)`           | 返回此`Map` 的所有键值对中 key 严格小于给定 key 的 key 组成的子 `Map` |
| `SortedMap<K,V> tailMap(K fromKey)`         | 返回此`Map` 的所有键值对中 key 严格大于给定 key 的 key 组成的子 `Map` |
| `K firstKey()`                              | 返回此 `Map` 中当前的第一个（最小）key                       |
| `K lastKey()`                               | 返回此 `Map` 中当前的最后一个（最大）key                     |

`NavigableMap` 在 `SortedMap` 的基础上，又添加了许多查找方法：

| 方法                                                         | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Map.Entry<K,V> lowerEntry(K key)`                           | 返回键值对中 key 小于指定 key 的键值对中最接近的键值对       |
| `K lowerKey(K key)`                                          | 返回键值对中 key 小于指定 key 的键值对中最接近的 key         |
| `Map.Entry<K,V> floorEntry(K key)`                           | 返回键值对中 key 小于或等于指定 key 的键值对中最接近的键值对 |
| `K floorKey(K key)`                                          | 返回键值对中 key 小于或等于指定 key 的键值对中最接近的 key   |
| `Map.Entry<K,V> ceilingEntry(K key)`                         | 返回键值对中 key 大于或等于指定 key 的键值对中最接近的键值对 |
| `K ceilingKey(K key)`                                        | 返回键值对中 key 大于或等于指定 key 的键值对中最接近的 key   |
| `Map.Entry<K,V> higherEntry(K key)`                          | 返回键值对中 key 大于指定 key 的键值对中最接近的键值对       |
| `K higherKey(K key)`                                         | 返回键值对中 key 大于指定 key 的键值对中最接近的 key         |
| `Map.Entry<K,V> firstEntry()`                                | 返回 key 最小的键值对                                        |
| `Map.Entry<K,V> lastEntry()`                                 | 返回 key 最大的键值对                                        |
| `Map.Entry<K,V> pollFirstEntry()`                            | 检索并移除 key 最小的键值对                                  |
| `Map.Entry<K,V> pollLastEntry()`                             | 检索并移除 key 最大的键值对                                  |
| `NavigableMap<K,V> descendingMap()`                          | 返回反序排列的 `Map`                                         |
| `NavigableSet<K> navigableKeySet()`                          | 返回此 `Map`  key 的 `NavigableSet` 表示                     |
| `NavigableSet<K> descendingKeySet()`                         | 返回此 `Map`  key 的反序的 `NavigableSet` 表示               |
| `NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive);` | 返回子 `Map`，包不包括开头和结尾由 `fromInclusive` 和 `toInclusive` 两个值控制 |
| `NavigableMap<K,V> headMap(K toKey, boolean inclusive)`      | 返回此 `Map` 中 key 严格小于给定 key 的键值对组成的子 `Map`，包不包括该元素由 `inclusive` 决定 |
| `NavigableMap<K,V> tailMap(K fromKey, boolean inclusive)`    | 返回此 `Map` 中 key 严格大于给定 key 的键值对组成的子 `Map`，包不包括该元素由 `inclusive` 决定 |

#### 5.3.1 `TreeMap` 的原理

`TreeMap` 的底层是红黑树，其实现方式和之前 `HashMap` 中的差不太多，首先看一下节点定义：

```java
private static final boolean RED   = false;
private static final boolean BLACK = true;

static final class Entry<K,V> implements Map.Entry<K,V> {
    K key;
    V value;
    Entry<K,V> left;
    Entry<K,V> right;
    Entry<K,V> parent;
    boolean color = BLACK;
    
    // ...
}
```

与红黑树相关的方法如下，这里只列出方法及作用，源码请自行阅读，建议配合我写的红黑树教程一起阅读：

* `Entry<K,V> successor(Entry<K,V> t)`，找到 t 的后继
* `Entry<K,V> predecessor(Entry<K,V> t)`，找到 t 的前驱
* `void rotateLeft(Entry<K,V> p)`，左旋
* `void rotateRight(Entry<K,V> p)`，右旋
* `void fixAfterInsertion(Entry<K,V> x)`，插入后平衡调整
* `void fixAfterDeletion(Entry<K,V> x)`，删除后平衡调整
* `Entry<K,V> getEntry(Object key)`，红黑树查找
* `V put(K key, V value)`，红黑树插入
* `void deleteEntry(Entry<K,V> p)`，红黑树删除

### 5.4 其他键值对相关容器

#### 5.4.1 `WeakHashMap`

`WeakHashMap` 是弱引用的 `HashMap`。首先介绍引用的概念。

##### 5.4.1.1 引用

引用这个概念是与JAVA虚拟机的垃圾回收有关的，不同的引用类型对应不同的垃圾回收策略或时机。

垃圾回收的大致思路是：当Java虚拟机觉得内存不够用的时候，会触发垃圾回收操作（GC），清除无用的对象，释放内存。

可是如何判断一个对象是否是垃圾呢？其中的一个方法是**引用计数**：计算指向该对象的引用数量，如果引用数量为 0，那么该对象就为垃圾（`Thread` 对象是例外），否则还有用处，不能被回收。

但这种引用计数不能解决循环引用的问题，现在 JVM 使用的是**可达性分析算法**。常见的情况是：一个对象并不是从根部直接引用的，而是一个对象被其他对象引用，甚至同时被几个对象所引用，从而构成一个以根集为顶的树形结构，当某个对象不可到达（即这个对象不能通过引用获得这个对象时），这个对象及被这个对象所引用的其他对象都将视作垃圾，此内存接下来很可能被 JVM 所回收。

在 JVM 中，引用分为四种：

1. 强引用：Java 中默认声明的就是强引用。

   强引用具备以下特点：

   1. 强引用可以直接访问目标对象

   2. 强引用所指向的对象在任何时候都不会被系统回收

      JVM 宁愿抛出 `OutOfMemoryError` 也不会回收强引用所指向的对象

   3. 强引用可能导致内存泄漏

      程序员编写代码的时候，有时为了防止内存泄漏，需要将引用显式地赋空。

2. 软引用：一个持有软引用的对象，它不会被 JVM 很快回收，JVM 会根据当前堆的使用情况来判断何时回收：当堆使用率临近阙值时，才会去回收软引用的对象。

   只要有足够的内存，软引用便可能在内存中存活相当长一段时间。因垃圾回收器会保证在抛出 OOM 之前，回收掉所有软引用可达的对象。程序所要做的是保证软引用可达的对象被垃圾回收器回收之后，程序也能正常工作。

3. 弱引用：弱引用是一种比软引用较弱的引用类型，不管系统堆空间是否足够，都会将对象进行回收。如果一个对象的引用只有弱引用，那么它就会被清除。

4. 虚引用：是强度最弱的引用，虚引用的主要目的是在一个对象所占的内存被实际回收之前得到通知，从而可以进行一些相关的清理工作。

##### 5.4.1.2 `WeakHashMap` 的原理

它和 `HashMap` 类似，也有默认的初始容量，最大容量，负载因子等等，但是它并不会把链表转换为红黑树。它的 key 被设置为 `WeakReference`，并且通过一个 `ReferenceQueue` 管理弱引用。

当某**弱键**不再被其它对象引用，它就会从 `WeakHashMap` 中自动移除，并且 GC 会回收。

原理简单描述为：GC 回收时，这个**弱键**也同时会被添加到 `ReferenceQueue` 队列中，当下一次我们需要操作 `WeakHashMap` 时，会先同步底层的 table 和 queue。table 中保存了全部的键值对，而 queue 中保存被 GC 回收的键值对；同步它们，就是删除 table 中被 GC 回收的键值对。

#### 5.4.2 `IdentityHashMap`

`IdentityHashMap` 和 `HashMap` 类似，最大的区别在于它能够存储 key 相等的键值对。

在 `HashMap` 比较时，首先比较 key 的 hash 值，然后通过 `==` 和 `equals` 比较它们是否是同一个 key；`IdentityHashMap` 比较只通过 `==` 比较，只有 `==` 比较相同的才被认为是相同。

我们可以测试一下：

```java
class Demo {
    private int i;
    public Demo(int i) {
        this.i = i;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Demo demo = (Demo) o;
        return i == demo.i;
    }

    @Override
    public int hashCode() {
        return Objects.hash(i);
    }
}
```

```javascript
Map<String, String> identityHashMap = new IdentityHashMap<>();
identityHashMap.put(new String("a"), "1");
identityHashMap.put(new String("a"), "2");
identityHashMap.put(new String("a"), "3");
System.out.println(identityHashMap.size()); // 3

Map<Demo, String> hashMap = new HashMap<>();
identityHashMap2.put(new Demo(1), "1");
identityHashMap2.put(new Demo(1), "2");
identityHashMap2.put(new Demo(1), "3");
System.out.println(identityHashMap2.size()); // 1
```

#### 5.4.3 `Hashtable`

`Hashtable` 和 `HashMap` 的关系就像 `Vector` 和 `ArrayList` 的关系，`Hashtable` 是很早之前就出现的容器，它和 `HashMap` 的不同之处在于它是线程安全的容器，且它是数组 + 链表的实现，并不会转换为红黑树。

`Hashtable` 的线程安全实现方式是使用 `synchronized` 关键字，效率十分低下，有更好的 `ConcurrentHashMap` 容器作为替代，目前已经很少使用。

`Hashtable` 继承自 `Dictionary` 抽象类，它是 JDK 1.0 定义的操作键值对的抽象类，它包括了操作键值对的基本方法，目前已经很少使用，了解即可。

##### 5.4.3.1 `Properties`

`Properties` 继承自 `Hashtable`，可以看作是键值都是 `String` 的 `Hashtable`，表示一个持久的属性集。许多类都使用了这个类，比如 `System` 类提供了 `getProperties` 方法获取系统属性。

`Properties` 类定义了两个构造方法：第一个构造方法是默认的，没有参数；第二个构造方法使用另一个 `Properties` 初始化它。

除了从 `Hashtable` 中所定义的方法，`Properties` 还定义了以下常用方法：

| 方法                                                     | 作用                                           |
| -------------------------------------------------------- | ---------------------------------------------- |
| `String getProperty(String key)`                         | 根据键获取某一个属性                           |
| `String getProperty(String key, String defaultProperty)` | 根据键获取某一个属性，如果没有取到，则取默认值 |
| `Object setProperty(String key, String value)`           | 设置一个属性                                   |
| `void list(PrintWriter streamOut)`                       | 将属性列表输出到指定的输出流                   |
| `void list(PrintStream streamOut)`                       | 将属性列表输出到指定的输出流                   |
| `void load(InputStream streamIn)`                        | 从输入流中读取属性列表                         |

##### 5.4.3.2 .properties 配置文件

Java 有一个独特的配置文件，叫做属性文件，后缀是 `.properties`，形式是 `key=value`，下面是一个示例，你可以将它命名为 `name.properties`：

```properties
name=wzy
age=18
```

可以通过输入输出流加载某个属性文件，可以直接获得一个 `Properties` 类的对象，然后获取到这些配置。

配置文件中还可以使用 `#` 写注释，注释的内容不会被加载到 `Properties` 对象中。

`System` 类持有一个 `Properties` 对象，可以查看它的内容：

![image-20220223152505582](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220223152505582.png)

## 6. 泛型算法

### 6.1 `Arrays`

`Arrays` 封装了许多和数组有关的算法，包括排序、查找、比较、复制、填充、转换为列表等。

下表列出了这些方法，其中 `type` 代表各种可比较的数值类型，比如 `int`、`long`、`float` 等：

| 方法                                                         | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `void sort(type[] a)`                                        | 对数组进行排序                                               |
| `void sort(type[] a, int fromIndex, int toIndex)`            | 对数组进行排序，可以指定开始和结束的位置                     |
| `void sort(T[] a, Comparator<? super T> c)`                  | 对对象数组进行排序，需要一个比较器                           |
| `void sort(T[] a, int fromIndex, int toIndex, Comparator<? super T> c)` | 对对象数组进行排序，可以指定开始和结束的位置，需要一个比较器 |
| `void parallelSort(type[] a)`                                | 对数组进行排序，使用多线程                                   |
| `void parallelSort(type[] a, int fromIndex, int toIndex)`    | 对数组进行排序，可以指定开始和结束的位置，使用多线程         |
| `void parallelSort(T[] a, Comparator<? super T> c)`          | 对对象数组进行排序，需要一个比较器，使用多线程               |
| `void parallelSort(T[] a, int fromIndex, int toIndex)`       | 对对象数组进行排序，可以指定开始和结束的位置，需要一个比较器，使用多线程 |
| `int binarySearch(type[] a, type key)`                       | 在数组中使用二分搜索 key，在搜索之前会进行排序，返回下标     |
| `int binarySearch(type[] a, int fromIndex, int toIndex, type key)` | 在数组中使用二分搜索 key，在搜索之前会进行排序，可以指定开始和结束的位置，返回下标 |
| `int binarySearch(T[] a, T key, Comparator<? super T> c)`    | 在有序对象数组中使用二分搜索 key，在搜索之前会进行排序，返回下标 |
| `int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator<? super T> c)` | 在有序对象数组中使用二分搜索 key，在搜索之前会进行排序，可以指定开始和结束的位置，返回下标 |
| `boolean equals(type[] a, type[] a2)`                        | 比较两个数组的内容是否一致，可以是对象类型（会调用 `equals` 方法） |
| `boolean deepEquals(Object[] a1, Object[] a2)`               | 比较两个多维数组的内容是否一致，可以是对象类型（会调用 `equals` 方法） |
| `void fill(type[] a, type val)`                              | 使用指定的值填充数组，可以是对象类型                         |
| `void fill(type[] a, int fromIndex, int toIndex, type val)`  | 使用指定的值填充数组，可以指定开始和结束的位置，可以是对象类型 |
| `type[] copyOf(type[] original, int newLength)`              | 复制指定的数组，用空字符截断或填充                           |
| `type[] copyOfRange(type[] original, int from, int to)`      | 复制数组，可以指定开始和结束的位置                           |
| `int hashCode(type a[])`                                     | 根据指定数组的内容返回哈希码，可以是对象类型                 |
| `int deepHashCode(Object a[])`                               | 根据指定多维数组的内容返回哈希码                             |
| `String toString(type[] a)`                                  | 返回指定数组内容的字符串表示形式，可以是对象类型             |
| `String deepToString(Object[] a)`                            | 返回指定多维数组内容的字符串表示形式                         |
| `List<T> asList(T... a)`                                     | 返回数组的列表表示                                           |

值得注意的是 `asList`，它返回的列表的类型是 `ArrayList`，但不是我们平常使用的 `ArrayList`，而是 `Arrays` 的一个内部类 `ArrayList`，这个类只实现了少部分 `List` 接口的方法，其中不包括 `add` 等能够影响集合长度的方法。正如其方法名 `asList`，只能让一个数组作为列表使用，但是还是保持着数组的性质。

### 6.2 `Collections`

`Collections` 封装的是和集合有关的算法。

下表列出了这些方法：

| 方法                                                         | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `void sort(List<T> list)`                                    | 对列表排序，其中泛型必须实现 `Comparable` 接口               |
| `void sort(List<T> list, Comparator<? super T> c)`           | 对列表排序，需要比较器                                       |
| `int binarySearch(List<? extends Comparable<? super T>> list, T key)` | 在列表中使用二分搜索 key，在搜索之前会进行排序，列表中的元素类型必须实现 `Comparable` 接口 |
| `int binarySearch(List<? extends T> list, T key, Comparator<? super T> c)` | 在列表中使用二分搜索 key，在搜索之前会进行排序，需要比较器   |
| `void reverse(List<?> list)`                                 | 反转列表                                                     |
| `void shuffle(List<?> list)`                                 | 打乱列表的顺序                                               |
| `void swap(List<?> list, int i, int j)`                      | 交换列表中两个元素                                           |
| `void fill(List<? super T> list, T obj)`                     | 使用指定的元素填充列表                                       |
| `void copy(List<? super T> dest, List<? extends T> src)`     | 将一个列表中的所有元素复制到另一个列表中                     |
| `T min(Collection<? extends T> coll)`                        | 根据元素的自然顺序返回给定集合的最小元素，其中 T 必须实现 `Comparable` 接口 |
| `T min(Collection<? extends T> coll, Comparator<? super T> comp)` | 根据元素的自然顺序返回给定集合的最小元素，需要一个比较器     |
| `T max(Collection<? extends T> coll)`                        | 根据元素的自然顺序返回给定集合的最大元素，其中 T 必须实现 `Comparable` 接口 |
| `T max(Collection<? extends T> coll, Comparator<? super T> comp)` | 根据元素的自然顺序返回给定集合的最大元素，需要一个比较器     |
| `void rotate(List<?> list, int distance)`                    | 将列表中的所有元素移动指定的距离，如果是正数就是向右移，否则是向左移<BR>比如有一个 abcd 的列表，distance 为 1，则移动后是 dabc |
| `boolean replaceAll(List<T> list, T oldVal, T newVal)`       | 将列表中一个指定值的所有出现替换为另一个，如果 list 中真的包含 oldVal 并且替换成功，则返回 true；否则返回 false |
| `int indexOfSubList(List<?> source, List<?> target)`         | 查找子列表 target 在 source 中第一次出现的位置，如果未出现，返回 -1 |
| `int lastIndexOfSubList(List<?> source, List<?> target)`     | 查找子列表 target 在 source 中最后一次出现的位置，如果未出现，返回 -1 |
| `Type unmodifiableType(Type t)`                              | 返回指定容器的不可更改的版本（视图），Type 表示容器接口类型（比如 `List`、`Map`） |
| `Type synchronizedType(Type t)`                              | 返回指定容器的线程安全的版本（视图），Type 表示容器接口类型（比如 `List`、`Map`） |
| `Type checkedType(Type t, Class cls)`                        | 返回指定容器的检查型版本（视图），Type 表示容器接口类型（比如 `List`、`Map`） |
| `Type emptyType()`                                           | 返回一个空的不可变容器，Type 表示容器接口类型（比如 `List`、`Map`） |
| `Set<T> singleton(T o)`                                      | 返回只有一个元素的不可变的 `Set`                             |
| `List<T> singletonList(T o)`                                 | 返回只有一个元素不可变的 `List`                              |
| `Map<K,V> singletonMap(K key, V value)`                      | 返回只有一对键值对不可变的 `Map`                             |
| `List<T> nCopies(int n, T o)`                                | 返回由 n 个指定的元素组成的不可变 `List`                     |
| `Comparator<T> reverseOrder()`                               | 返回一个与自然顺序相反的比较器                               |
| `Comparator<T> reverseOrder(Comparator<T> cmp)`              | 返回一个与指定比较器顺序相反的比较器                         |
| `int frequency(Collection<?> c, Object o)`                   | 返回 c 中 o 出现的次数                                       |
| `boolean disjoint(Collection<?> c1, Collection<?> c2)`       | 如果 c1 和 c2 中没有共同的元素，返回 true                    |
| `boolean addAll(Collection<? super T> c, T... elements)`     | 将指定的所有元素添加到集合中，如果集合因调用而更改，则返回 true |
| `Set<E> newSetFromMap(Map<E, Boolean> map)`                  | 从指定 `Map` 中获得一个 `Set`，得到的 `Set` 会保持原有 `Map` 的性质，调用时此 `Map` 必须为空；如果已经有对应的 `Set`（比如 `HashMap` 和 `HashSet`），则不需要此方法 |
| `Queue<T> asLifoQueue(Deque<T> deque)`                       | 返回双端队列的后进先出版本（视图），需要一个栈时此方法很有效 |

这些方法有一些很令人在意，它们都涉及视图这个概念，下面介绍一下集合的视图。

### 6.3 集合视图

通过一个集合导出的另一个集合能够操作原集合，这样的导出的集合叫做视图。

视图有以下五种：

1. 小集合：在 Java 9 之后，`Set`、`List` 以及 `Map` 接口提供了静态方法，它们可以根据传入的值创建不可修改的集合，也叫做小集合。

   其中，`List` 和 `Set` 提供了 11 个 `of` 方法用于创建小集合，分别接收 0 个到 10 个参数，还有额外的一个接收可变参数的 `of` 方法，之所以提供这么多方法是为了加快小集合的创建。

   `Map` 也提供了 11 个方法，分别接受 0、2、4、...、20 个参数，表示 K, V，但是它并不能提供一个可变参数的方法。为此，`Map` 提供了 `ofEntries` 方法构造小集合，接收可变个 `Map.Entry` 对象，还提供了 `entry` 方法创建 `Map.Entry` 对象。

2. 子集合：

   许多集合提供了方法来创建子集合，对子集合的操作会反映到父集合中。

   其中，`List` 提供了 `subList` 方法；`Set` 的子接口 `SortedSet` 和 `NavigableSet` 提供了 `subSet`、`tailSet` 和 `headSet` 方法；`Map` 的子接口 `SortedMap` 和 `NavigableMap` 提供了 `subMap`、`tailMap` 和 `headMap` 方法。

   另外，`Map` 提供了三个方法分别返回完整的键集合（`keySet`），值集合（`values`）以及键值对集合（`entrySet`）。

3. 不可修改的集合：

   `Collections` 提供了以 `unmodifiable` 开头，接口名结尾的方法，用于构建不可修改的集合。一旦修改，就抛出一个异常。

4. 同步集合：

   大部分集合都是非线程安全的，因此 `Collections` 提供了以 `synchronized` 开头，接口名结尾的方法，用于构建同步的集合。

5. 检查型集合：

   检查型视图用来对泛型类型可能出现的问题提供调试支持。比如：

   ```java
   ArrayList<String> strings = new ArrayList<>();
   ArrayList rawList = strings;
   rawLisr.add(new Date()); // 警告，但并不报错
   ```

   为了解决这种情况，可以使用检查型视图，`Collections` 提供了以 `checked` 开头，接口名结尾的方法，用于构建检查型的集合。

   ```java
   List<String> safeStrings = Collections.checkedList(strings, String.class);
   ArrayList rawList = strings;
   rawList.add(new Date()); // 立即报错
   ```

   
