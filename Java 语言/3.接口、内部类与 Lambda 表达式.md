# 接口、内部类与 Lambda 表达式

## 接口

**接口用于描述类应该做什么，而不指定它们具体该如何做**。

**一个类可以实现一个或多个接口**。接口可以继承自其他接口，和类不同的是，**接口可以多继承**；但是接口不能反过来继承某个类。

接口使用 `interface` 而不是 `class` 关键字进行定义，接口本质上是抽象类，定义在接口中的所有方法都是抽象方法，且默认 `public`。**接口和抽象类最大的区别就是一个类只能继承一个抽象类，但是可以实现多个接口。**

> **注意事项**
>
> 实现接口时要注意，因为接口的方法全是默认 `public` 的，所以子类中要显式的说明方法是 `public`。如果没有显式说明，那么 Java 会认为具有默认的访问权限，导致子类重写的访问权限低于父类而报错。
>
> 可以使用 IDE 的功能来帮你实现接口的签名部分，这样就可以减少这类错误的产生。

接口中，还可以定义常量，常量默认是 `public static final` ，因此无需额外加上这几个关键字。

接口中不允许定义实例字段，因为所有字段默认是 `public static final`，所以也不可能定义实例字段。

下面是一个接口的实例：

```java
public interface BasicDAO {
    String DEFAULT_SELECT_SQL_PREFIX = "select * ";
    
    Object select(Object params);
}
```

在 Java 8 及之后的版本中，接口可以有默认方法 `default` 和 `static` 方法，在 Java 9 及之后的版本中可以有 `private` 方法。这些方法都需要立即实现，而不能像抽象方法一样不实现。

默认方法指的是接口方法的默认实现，如果某方法是默认方法，那么子类在实现接口后，就不必复写这个方法。

> 默认方法更多应用于**接口演化**。以前的老接口没有默认方法时，假设有 100 个方法，那么它的实现类就要全部重写。但是可能这个子类可能只需要其中的 20 个方法作为它的功能，那么其他的 80 个方法都需要提供默认的空实现，而且对调用者需要加上 javadoc 进行说明。
>
> 因此，以前的设计方法都是提供一个 `abstract` 的实现，重写所有方法为默认空实现，如果要进一步拓展，就继承这个抽象实现类。
>
> 现在有了默认方法，那么以前的老接口就可以把这些方法都设置为默认空实现，甚至可以添加新的默认方法，而不会对它的原本的实现类造成任何影响。

`private` 方法是接口可以拥有的实例方法，很不常见。子类即使实现了接口也不能调用它，甚至不能重写它，它仅用于辅助默认方法的实现，而默认方法的实现不会这么复杂，因此实际上基本看不到这种用法。

### 实现接口

实现接口需要使用 `implements` 关键字。

如果一个类实现了接口，但是没有打算重写方法，那么就需要把方法和类声明为 `abstract`。

和抽象类一样，虽然不能实例化，但是可以声明一个接口变量，并把一个实现类的实例赋给它。

**一个类可以实现多个接口，但是只能继承自一个父类。**实现多个接口时，接口之间以 `,` 分隔开。

#### 方法冲突

既然一个类可以实现多个接口，假设多个接口都具有同名的方法 `f`，重写时会冲突吗？

答案是不会，首先看签名不同的情况，这种情况下，实现类很容易区分；签名相同的情况下，由于接口无法实例化，再加上动态绑定，所有对接口变量的该方法的调用实际上都会调用子类的实现方法。这种情况下，**就需要看接口的实际意义来决定实现是否正确**，一般不会出现这种情况，这是错误的设计。

现在把问题复杂化，假设一个类有一个超类，且这个类实现了两个接口，且它们都具有同样的方法名 `f`，其中一个接口还是默认方法，这时又怎么样呢。

事实上，它们需要遵守如下规则：

1. 超类优先。
2. 如果超类没有该方法，则重写接口中的同名方法，即使其中一个接口中的是默认方法。

### 接口回调

回调是一种常见的程序设计模式，在这种模式中，可以指定某个事件发生时应该采取的动作。

具体来说，当程序运行时，会发生某个事件，我们需要响应这个事件。

一般会使用事件发布-监听的机制来实现，使用一个监听器来自定义动作来响应事件。这个监听器一般是预设好的接口，开发者通过实现该接口来书写自己的动作。

比如图形界面中的点击事件：

```java
interface ClickListener {
    void onClick(ClickEvent e);
}
```

当用户执行点击时，会产生一个 ClickEvent，传给监听器接口变量，通过动态绑定找到实现类中的实现方法处理该事件。

当事件发生时，程序会调用预先设定好的接口的实现方法，叫做接口回调。

### Java 中的接口

Java 标准库中有很多接口，这些接口包括负责定义常量的常量接口、对某一类事物的根本抽象接口、全是静态方法的工具接口、能够标记类具有某一种属性的标记接口、作为监听器的监听器接口.....

和我们自定义类最相关的就是标记接口，它表示我们的类具有某一种属性，比如 `Comparable`、`Cloneable`、`Serializable` 等。分别表示类具有可比较性，可克隆性以及可序列化性。

本节重点介绍 `Cloneable` 接口，它和 `Object` 类的 `clone` 方法息息相关。

#### `Object` 的 `clone` 方法

`clone` 方法是 `Object` 类中的一个 `protected` 方法，这意味着你不能在你的代码中调用这个方法，只有自己或自己的子类可以克隆。

默认的实现是对对象进行一个**浅拷贝**，即对所有的字段进行简单的拷贝，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址。假设有一个这样的类：

```java
public class Person implements Cloneable {
    public int age;
    public Car car;

    public void cloneTest() throws CloneNotSupportedException {
        Person person = new Person();
        Car car = new Car();
        car.brand = "宝马";
        person.age = 18;
        person.car = car;

        System.out.println(person + "; " + person.age + "; " + person.car);
        Person clone = (Person) person.clone();
        System.out.println(clone + "; " + clone.age + "; " + clone.car);
    }
}

public class Car implements Cloneable {
    public String brand;
}
```

进行测试：

![image-20220128113658419](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220128113658419.png)

可以看到，克隆后的 person 的地址发生了改变，说明确实创造了一个新的 Person 对象，且对其中的值的复制。但是注意，Person 持有一个 Car 类对象，它的地址没有改变，说明克隆后的 Person 持有的 Car 对象和之前一致，`Object` 的 `clone` 仅仅把对象变量中的值（地址）复制了一份。这就是浅拷贝的含义。

很多时候，我们需要的是**深拷贝，即完全的复制整个对象**。事实上，对于每一个类，我们都需要确定：

1. 默认的 `clone` 方法是否满足要求。
2. 是否可以在可变的子对象上调用 `clone` 来修补默认的 `clone` 方法。
3. 是否不该使用 `clone`。

对于所有类，第三点都是默认为是，**只有继承了 `Cloneable` 接口的类才被允许克隆**。继承了 `Cloneable` 类就意味着你需要提供安全的完备的且为 `public` 的 `clone` 方法。

即使浅拷贝能够满足你的需求，你也需要重写 `clone` 方法，把访问修饰符置为 `public`，返回值置为该类的类型，然后调用 `super.clone()`。

`clone` 方法总是会声明可能抛出一个 `CloneNotSupporttedException` 异常，这个异常最好让他继续声明抛出而不是捕获，除非该类是 `final` 的。

## 内部类

内部类指的是定义在类内部的类。内部类具有如下的好处：

1. 可以对同一个包中的其他类隐藏。
2. 内部类可以很方便的访问它外部的类中的所有数据，包括私有的数据。

下面是一个简单的例子：

```java
public class Outer {
    private int num;
    
    public void setNum(int num) {
        this.num = num;
    }
    
    public int getNum() {
        return num;
    }
    
    public class Inner {
        public void innerTest() {
            System.out.println(num);
        }
    }
}
```

注意，**内部类可以是任意访问权限的，而普通的外部类只能是 `public` 或默认权限的**。对于私有的内部类，外部类以外的类不能访问。

**内部类可以随意访问外部类的数据**，这意味着总是存在一个类似于 `this` 的隐式引用指向外部类实例。事实也的确如此，**在内部类中使用 `this` 访问本类实例，而使用 `外部类名.this` 访问外部类的实例，甚至可以访问到外部类的 `super` 引用。**

**要访问内部类的构造器，则需要使用 `外部类实例.new 内部类构造器` 来访问**，比如对于上面的例子要构造一个 Inner 对象，则：

```java
public class MainClass {
    public static void main(String[] args) {
        Outer.Inner inner = new Outer().new Inner();
    }
}
```

**对于可被外部类以外的类访问到的内部类，需要使用 `外部类.内部类` 来表示类型。**而**在外部类中，可以只使用内部类名来表示**，并且在外部类中实例化一个内部类的语法就和实例化一个普通类的语法一样，比如：

```java
public class Outer {
    private int num;

    public void setNum(int num) {
        this.num = num;
    }

    public int getNum() {
        return num;
    }

    public class Inner {
        public void innerTest() {
            System.out.println(num);
        }
    }

    public void test() {
        Inner inner = new Inner();
    }
}
```

**内部类中，不允许出现 `static` 方法，所有的 `static` 变量必须是 `final`。**

> **内部类的实质**
>
> **内部类在编译时会被转换为常规的类文件**，使用 `$` 分隔外部类名和内部类名。所以在运行时，JVM 对它是否为内部类是一无所知的。
>
> 编译器在编译时，会为内部类生成一个外部类的实例字段，所有对外部类的访问都通过这个来实现。
>
> 但是这样很明显只能访问外部类的非 `private` 成员，对于 `private` 成员，内部类是如何访问到的？答案是编译时为外部类生成额外的方法，供内部类使用。
>
> 总而言之，内部类的本质上是正常的类，它对外部类的访问权限来自于对编译器对字节码的额外修改。
>
> **那么私有内部类是如何实现的？**
>
> 实际上，在 JVM 中确实不存在私有类，私有内部类的构造器会被转换成私有的构造器。当然私有访问属性的构造器没人能够访问，因此还需要一个具有最小访问权限，但是又能够让外部类访问到的构造器，也就是具有默认访问权限的构造器。
>
> 细心的同学已经发现了，如果构造器带有参数，那么合成的默认权限构造器和私有构造器签名相同，会产生冲突。为此，编译器还额外生成了一个类，作为包访问权限的构造器的最后一个参数。这个类仅仅用于区分构造器，实际上调用时这个地方会传入 `null`。

### 局部内部类

内部类可以定义在方法里，这说明这个类只是临时在方法中使用，这种叫做局部内部类。比如：

```java
public void test(int num) {
    class Inner {
        public void test() {
            System.out.println(num);
        }
    }
    
    new Inner().test();
}
```

**局部内部类不能有访问修饰符**，作用域被限定在块中，除了这个块之外，没有人知道它的存在。

局部内部类的一大优点是它们不仅可以访问外部类中的内容，而且可以访问方法中的局部变量，前提是这些局部变量是**事实最终变量**，事实最终变量意味着它们一旦被赋值就不会再改变，即使它们没有 `final` 修饰。

> 局部内部类也会由编译器来合成一个暂时的普通类，并且通过**修改字节码**的手段使得普通类能够访问变量。

### 匿名内部类

**匿名内部类是特殊的局部内部类**，假如只是需要一个局部内部类的一个对象，那么甚至不需要给这个类起名字，前提是这个类必须承担某一个职责，这意味着这个类需要继承类或实现接口，比如：

```java
public void test() {
    Runnable thread1 = new Runnable() {
        @Override
        public void run() {
            System.out.println("线程 1 正在运行");
        }
    };

    new Thread(thread1).start();
}
```

这里是一个多线程的例子，我们之后会详细讲解多线程编程。现在需要知道的是，每一个线程都需要实现 `Runnable` 接口，重写其中的 `run` 方法。

但是如果只需要一个使用一次的线程，再为它写一个类就没有太大的必要，因此可以使用局部内部类。再进一步，就可以使用匿名内部类。

**由于构造器的名字需要和类名相同，而匿名内部类没有名字，因此也就不能有构造器。可以使用初始化块作为代替。**

匿名内部类是使用频率很高的一种内部类，在一些 GUI 编程中是十分常见的。现在更推荐使用即将讲解的 Lambda 表达式，Lambda 表达式本质上是特殊的匿名内部类。

### 静态内部类

静态内部类是指内部类有 `static` 的修饰，这种情况下，**由于类是静态的，因此不会持有外部类的实例引用**。

静态内部类不能访问外部类的非静态对象，这实际上和普通的类没有任何区别，因此有些程序员也把它们叫做嵌套类。静态内部类可以有静态方法和字段。

**在接口中声明的内部类全都是 `public static` 修饰的静态内部类**。

## Lambda 表达式

Lambda 表达式是一个可传递的代码块，可以在之后执行一次或多次。这个特性在 Java 8 及之后的版本存在。

Lambda 表达式的基本形式是：

```java
(参数类型 参数1, 参数类型 参数2) -> {
    // 代码
}
```

参数的声明很像函数的参数声明，箭头后的花括号内可以写多行代码。

即使 Lambda 表达式不需要参数，也需要提供空括号。

如果可以推导一个 Lambda 表达式的参数类型，则可以省略参数类型。如果只有一个参数，并且可以推倒出类型，那么甚至可以省略圆括号，比如：

```java
event -> {
    System.out.println("123123");
}
```

如果只有一行代码，甚至可以省略花括号：

```java
event -> System.out.println("123123");
```

无需指定返回类型，因为 Lambda 表达式会自动推导。

> 如果你尝试着去写一个 Lambda 表达式，即使你的语法是对的，也有很大的可能会报错。这是因为 **Lambda 表达式仅仅适用于需要函数式接口的地方**。

### 函数式接口

**如果一个接口只有一个抽象方法，那么可以给这个需要这个接口的地方提供一个 Lambda 表达式，这样的接口叫做函数式接口**，可以使用 `@FunctionalInterface` 注解修饰它。

Lambda 表达式在 Java 中本质上就是一个匿名内部类，它实现的是函数式接口，仅此而已。

在 `java.uitl.function` 包中存在很多函数式接口，有很多 Java API 会使用这些接口作为参数，这时就可以使用 Lambda 表达式而不是匿名内部类。

事实上，Lambda 表达式能做的，匿名内部类都能做；反过来，匿名内部类能做的，Lambda 表达式不一定能做。

### 方法引用

如果 Lambda 表达式中仅涉及一个方法，那么就可以使用方法引用。

比如：

```java
ActionListener listener = System.out::println;
```

这里，`ActionListener` 是一个函数式接口，只有一个方法，参数是 `ActionEvent`，这表示要把这个类的对象传入到 `System.out.println` 方法中用于打印。

假设这个方法没有参数，这样依然是可以生效的，表示调用无参数的 `System.out.println` 方法，仅仅打印一个回车。这里也是使用了函数调用的机制，会最佳匹配一个函数进行调用。

方法引用有三种情况：

1. `对象实例::成员方法`
2. `类名::成员方法`
3. `类名::静态方法`

第一种情况下，方法引用等价于向方法中传递参数的 Lambda 表达式；第二种情况下，第一个参数会成为该成员方法的调用者；第三种情况下，所有的参数都会被传入 `static` 方法中，某种意义上等价于第一种情况。

还可以使用 `this::` 和 `super::` 来进行方法引用。

#### 构造器引用

构造器引用是特殊的方法引用，这个时候的方法名为 `new`。

比如在 Java 的流中：

```java
ArrayList<String> names = ...; // 初始化一个 name 的列表
Stream<Person> stream = names.stream().map(Person::new);
List<Person> people = stream.collect(Collectors.toList());
```

你需要知道的是，`map` 方法会为列表中的每一个对象调用传入的函数。这里是根据每一个名字创建一个 Person 新对象，组成一个 Person 的流，然后转换成列表。

还可以为数组类型进行方法引用，比如：`int[]::new` 表示创建一个 `int` 类型的数组。

### 捕获变量

在 Lambda 表达式中，可以引用外部的变量，前提是这些变量都是事实最终变量。

**虽然 Lambda 表达式可能要在构造它的函数结束后很久才可能被调用（比如监听器），但是这个函数中被 Lambda 使用的变量必须被保存，这是由 Lambda 来完成的，我们说这个变量被 Lambda 捕获了**。

如果 Lambda 表达式在内部修改变量的值，那么将不能通过编译，这是由 Lambda 表达式的用途决定的。Lambda 表达式的用途一般有：

1. 在单独的线程中运行。
2. 多次运行。
3. 在算法的适当位置运行。
4. 发送某种情况时执行。
5. 必要时才执行。

在众多函数式接口中，上述用途的接口都存在。

#### 作用域

**Lambda 的作用域和它所处的块一致**，也就是说，在 Lambda 中使用 `this`，会直接访问到当前类实例。而不是  Lambda 的父接口。（事实上，接口不存在 `this`）

这就意味着如果在方法中定义 Lambda，那么 Lambda 的参数名不能和局部变量或函数参数一致。
