[TOC]

# I/O

## 1. 概述

I/O（Input/Output） 即**输入/输出**。

* 从计算机结构的角度看，**I/O 描述了计算机系统与外部设备的通信过程**。

* 从应用程序的角度看，由于操作系统将进程的地址空间划分为用户空间和内核空间，一般的程序运行在用户空间，只有在涉及到系统级别的资源（如文件管理、进程间通信、网络通信等）才会通过系统调用，让操作系统将我们的程序陷入到内核中执行。

  也就是说，**我们的应用程序在 I/O 时实际上只是发起了 I/O 操作的调用而已，具体 I/O 的执行是由操作系统的内核来完成的。**

  当应用程序发起 I/O 调用后，会经历两个步骤：

  1. 内核等待 I/O 设备（比如网卡、磁盘）准备好数据；
  2. 内核将数据从内核空间拷贝到用户空间。

从上面的叙述可以看出，I/O 未完成时应用程序拿不到数据，也就无法执行接下来的代码，所以 **I/O 通常是现代应用程序的瓶颈**。

现代应用程序主要是进行网络 I/O 以及磁盘 I/O，这两者的速度通常比内存的速度要慢上 10 ~ 10w 倍，更不用与 CPU 的速度对比了，因此，如何优化 I/O 是现代应用程序的一大难题。

从操作系统相关知识中，我们得知通常存在 5 种 I/O 模型，分别是：阻塞 I/O、非阻塞 I/O、多路复用 I/O、信号驱动 I/O、异步 I/O，其中，**前 4 个为同步 I/O 模型**。

在 Java 中，实现了上面的其中 4 种 I/O 模型（除了信号驱动 I/O），其中性能最好的莫过于多路复用 I/O，对应于 Java 中的 NIO。基于 Java NIO，也有一个著名的高性能网络框架 Netty，它被广泛应用于各大框架中，如果你要实现一个高性能服务器，那么基于 Netty 开发几乎是首选。

## 2. Java 的三种 I/O 模型概述

![image-20220309153234659](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220309153234659.png)

### 2.1 BIO（Blocking I/O）

阻塞 I/O，`java.io` 包中的类提供了这些功能，**交互方式是同步、阻塞的**。

也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的**线性顺序**。

很多时候，人们也把 `java.net` 下面提供的部分网络 API，比如 `Socket`、`ServerSocket`、`HttpURLConnection` 也归类到同步阻塞 I/O 类库，因为网络通信同样是 I/O 行为。

- **优点**：代码比较简单、直观；
- **缺点**： I/O 的效率和扩展性很低，容易成为应用性能瓶颈；服务端针对每一个连接都需要开启一个新线程来处理。
- **适用场景**：适合用在活动连接数较少的场景中。活动连接多的时候需要频繁切换线程。

> **多线程 BIO 的性能如何？**
>
> 采用 BIO 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端连接。
>
> 服务端一般在 `while(true)` 循环中调用 `accept()` 方法等待客户端的连接请求，一旦接收到一个连接请求，就可以建立 `Socket`，并基于这个 `Socket` 进行读写操作，此时，服务端就不能再接收其他客户端连接请求，只能等待当前连接的操作执行完成。
>
> 如果要让服务端能够处理多个请求，则可以使用多线程，在高并发的场景下，创建多个线程的开销是非常大的，很消耗操作系统资源，即使可以采用线程池优化，进行线程的复用，但是并发量过大时，**开销仍然是难以接受的，严重时甚至会发生 OOM**。

### 2.2 NIO（Non-Blocking I/O）

在 JDK 1.4 之后，引入非阻塞 I/O，在 `java.nio` 中的类为 NIO 提供了支持。

`java.nio` 包提供了 `Channel`、`Selector`、`Buffer` 等新的抽象，可以构建**多路复用的**、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。

- **优点**：性能更高，单个线程可以处理多个 I/O 请求，减少线程间的切换。
- **缺点**：原生编程相对复杂。
- **适用场景**：适合用在存在大量活动连接时。

### 2.3 AIO（Asynchronous I/O）

Java 7 中引入了 NIO 的改进版 NIO 2，它是异步 I/O 模型，所以也叫 AIO。

异步 I/O 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

现在 AIO 使用的不是很广泛，因为相比于成熟的 NIO，使用 AIO 性能也不见得会提升。

## 3. BIO 框架

### 3.1 I/O 工具类

#### 3.1.1 `File`

`File` 类是对文件和目录路径的抽象表示，如果希望在程序中操作文件和目录，则可以通过该类来完成。

注意，`File` 类仅仅能够操作文件，而不能访问文件本身的内容（要访问文件请使用 I/O 流），这是因为 `File` 类是对文件和目录的**路径**的封装。

##### 3.1.1.1 构造方法

`File` 提供了四个构造方法：

* `File(String path)`：从给定的路径名字符串创建一个新的 `File` 实例。
* `File(String parent, String child)`：从父路径字符串和子路径字符串创建一个新的 `File` 实例。
* `File(File parent, String child)`：从父文件和子路径字符串创建一个新的 `File` 实例。
* `File(URI uri)`：从给定的 `file:` URI 来创建一个新的 `File` 实例。

注意，**传入的路径可以是不存在的**，比如 Windows 系统上有 C, D 两个盘，但是创建的是 E 盘下的文件路径，或者是 C 盘中不存在的文件夹路径，也是合法的，**只有当实际操作该对象时（比如删除）才会抛出异常**。

为了不抛出异常，可以在实际操作前使用下面即将要介绍的信息获取方法来判断是否可以操作。

路径既可以是绝对路径，也可以是相对路径：

* 绝对路径：指的是文件在硬盘上的真实路径，比如在 Windows 操作系统中，一个绝对路径可能是这样的：

  `"C:\Users\94585\1.txt"`。

  注意，在 Windows 以 `\` 表示路径，而在编程语言中，`\` 是转义字符，因此在编程语言中，一般会使用 `"C:\\Users\\94585\\1.txt"` 这样的字符串来表示 Windows 的文件路径。

  而在 Linux/Unix 文件系统中，以 `/` 表示路径，因此不必转义。

* 相对路径：指的是以当前目录为根目录的文件路径，比如当前目录是 `C:\Users\94585`，则 `123` 表示 `C:\Users\94585\123` 这个目录。

  在相对路径中，有几个特殊的符号：

  * `.`：表示当前目录，上面的例子中 `123` 也可以写成 `.\\123`。
  * `..`：表示当前目录的上一级目录，上面的例子中 `123` 也可以写成 `..\\94585\\123`。

>**Windows 文件路径和 Linux 文件路径**
>
>标准的 Windows 文件路径由以下三部分组成：
>
>- 卷号或驱动器号，后跟卷分隔符 (`:`)。
>- 目录名称。 目录分隔符用来分隔嵌套目录层次结构中的子目录。
>- 可选的文件名。 目录分隔符用来分隔文件路径和文件名。
>
>如果以上三项都存在，则为绝对路径；如未指定卷号或驱动器号，且目录名称的开头是目录分隔符，则路径属于当前驱动器根路径上的相对路径；否则路径相对于当前目录。
>
>而 Linux 中，`/` 表示根目录，所以 `/usr` 表示根目录下的 usr 目录，而 `/usr/bin` 表示根目录下的 usr 目录下的 bin 目录。所以，Linux 的绝对路径以总是以 `/` 开头，否则则是以当前目录为根目录的相对路径。

##### 3.1.1.2 常量

`File` 类还提供了几个常量：

* `File.pathSeparator`：分隔路径的路径分隔符，Linux 上是 `:`，而 Windows 上是 `;`。
* `File.separator`：分隔目录的目录分隔符，Linux 上是 `/`，而 Windwos 上是 `\`。

在路径拼接时，请使用这些常量，以避免操作系统不同导致的路径问题。

##### 3.1.1.3 信息获取

`File` 提供了许多方法获取文件或目录的信息：

* `String getName()`：获取文件或目录的名称，一般是路径中的最后一个目录分隔符的后面的部分。
* `String getParent()`：获取父目录，如果没有父目录，返回 `null`。
* `File getParentFile()`：获取上一个方法的 `File` 封装，如果没有父目录，返回 `null`。
* `String getPath()`：获取路径，一般是构造时传入的路径。
* `boolean isAbsolute()`：判断是否为绝对路径。
* `String getAbsolutePath()`：获取绝对路径。
* `File getAbsoluteFile()`：获取上一个方法的 `File` 封装。
* `String getCanonicalPath()`：获取规范的路径。
* `File getCanonicalFile()`：获取上一个方法的 `File` 封装。
* `boolean canRead()`：判断是否可读。
* `boolean canWrite()`：判断是否可写。
* `boolean canExecute()`：判断是否可执行。
* `boolean exists()`：判断是否路是否真实存在。
* `boolean isDirectory()`：判断是否为目录。
* `boolean isFile()`：判断是否为文件。
* `boolean isHidden()`：判断是否为隐藏文件或隐藏目录。
* `long lastModified()`：获取上一次修改的时间。
* `long length()`：获取文件的大小（以字节为单位）。
* `String[] list()`：返回目录下所有文件和目录，如果不为目录，则返回 `null`。
* `String[] list(FilenameFilter filter)`：上面方法的过滤器版本，可以应用一个文件名过滤器。
* `File[] listFiles()`：返回目录下所有文件和目录，并封装成 `File` 返回。
* `File[] listFiles(FilenameFilter filter)`：上面方法的过滤器版本，可以应用一个文件名过滤器。
* `File[] listFiles(FileFilter filter)`：上面方法的过滤器版本，可以应用一个文件过滤器。
* `static File[] listRoots()`：列出可用的文件系统根。
* `long getTotalSpace()`：返回由此抽象路径名命名的分区的大小（以字节为单位）。
* `long getFreeSpace()`：返回由此抽象路径名命名的分区中未分配的字节数。
* `long getUsableSpace()`：返回由此抽象路径名命名的分区中已分配的字节数。

##### 3.1.1.4 操作

* `boolean createNewFile()`：仅当文件不存在时，创建新文件
* `boolean delete()`：删除文件或目录，如果是目录，则要求目录为空才能删除。
* `void deleteOnExit()`：退出程序时删除该文件。
* `boolean mkdir()`：创建目录，创建成功返回 `true`。
* `boolean mkdirs()`：创建目录，包括目录的父目录。如果此操作最后失败，但是也有可能创建好了部分父目录。
* `boolean renameTo(File dest)`：重命名。
* `boolean setLastModified(long time)`：设置最近一次更改的时间。
* `boolean setReadOnly()`：设置为只读。
* `boolean setWritable(boolean writable, boolean ownerOnly)`：设置可写，ownerOnly 表示是否应用于全部用户，如果为 `false`，则表示应用到全部用户，否则只应用于当前用户。
* `boolean setWritable(boolean writable)`：设置可写。
* `boolean setReadable(boolean readable, boolean ownerOnly)`：设置可读，ownerOnly 表示是否应用于全部用户，如果为 `false`，则表示应用到全部用户，否则只应用于当前用户。
* `boolean setReadable(boolean readable)`：设置可读。
* `boolean setExecutable(boolean executable, boolean ownerOnly)`：设置可执行，ownerOnly 表示是否应用于全部用户，如果为 `false`，则表示应用到全部用户，否则只应用于当前用户。
* `boolean setExecutable(boolean executable)`：设置可执行。
* `static File createTempFile(String prefix, String suffix, File directory)`：在指定目录下创建临时文件。
* `static File createTempFile(String prefix, String suffix)`：创建临时文件。

##### 3.1.1.5 应用示例

下面使用广度优先搜索列出某目录下的所有文件：

```java
public class BFSListFiles {
    public static void main(String[] args) throws IOException {
        File diskD = new File("D:\\Study");
        Queue<File> queue = new ArrayDeque<>();
        queue.add(diskD);
        while (!queue.isEmpty()) {
            File curFile = queue.poll();
            if (curFile.isFile()) {
                System.out.println(curFile.getCanonicalPath());
            } else {
                queue.addAll(Arrays.asList(curFile.listFiles()));
            }
        }
    }
}
```

#### 3.1.2 `RandomAccessFile`

`RandomAccessFile` 类是随机读取类，它是一个完全独立的类，和 `File` 没有直接关系。

它适用于由**大小已知**的记录组成的文件，所以我们可以使用 `seek()` 将记录从一处转移到另一处，然后读取或者修改记录。

文件中记录的大小不一定都相同，只要能够确定哪些记录有多大以及它们在文件中的位置即可。

##### 3.1.2.1 构造函数

`RandomAccessFile` 提供了如下构造函数：

* `RandomAccessFile(String name, String mode)`：使用 mode 模式打开 name 文件。
* `RandomAccessFile(File file, String mode)`：使用 mode 模式打开文件。

如果文件未找到，则会抛出 `FileNotFoundException`。

mode 是指打开文件的模式，有四种模式：

* r：只读
* rw：读写，如果文件不存在，则会创建文件
* rwd：读写，立即将文件内容写入磁盘
* rws：读写，立即将文件内容和文件描述符写入磁盘

rw 是会使用缓存的，只有缓存满了才会写入到磁盘中，这对于调试时很不友好，文件内容可能并不会立刻反映到文件中；rws 则是立即更新到磁盘中，性能就会稍微差一点；而 rwd 是一个折中的选择，会立即写入文件内容，但是不会及时更新文件描述符。

##### 3.1.2.2 信息获取

* `FileDescriptor getFD()`：获取文件描述符。
* `long getFilePointer()`：获取当前读写进度中的文件指针的位置。
* `long length()`：获取文件大小。

`FileDescriptor ` 表示文件描述符，当应用程序请求内核打开/新建一个文件时，内核会返回一个文件描述符用于对应这个打开/新建的文件，文件描述符本质上就是一个非负整数。**操作系统为每一个进程维护了一个文件描述符表，所以需要使用进程的 PID + FD 来唯一描述一个文件**。

我们的 I/O 流和 `RandomAccessFile` 都是基于文件描述符实现文件读写的，原理就是通过文件描述符向操作系统申请系统调用。

##### 3.1.2.3 读写文件

`RandomAccessFile` 提供了以下方法用于文件读取：

* `int read()`：读取一个字节。
* `int read(byte b[], int off, int len)`：读取 len 个字节到 b 中，第一个读取到的字节放在 b[off] 中。
* `int read(byte b[])`：读取 b.length 个字节到 b 中。
* `void readFully(byte b[])`：读取 b.length 个字节到 b 中，如果文件大小小于该数组的长度，则会重复读取直到读满。
* `void readFully(byte b[], int off, int len)`：读取 len 个字节到 b 中，第一个读取到的字节放在 b[off] 中，如果文件大小小于该数组的长度，则会重复读取直到读满。
* `int skipBytes(int n)`：尝试跳过 n 个字节。返回实际跳过的字节数。
* `Type readType()`：读取一个 Type 类型的值并返回。Type 可以是八大基本类型中的任意类型或者是 `String` 类型。

提供了以下方法用于写入：

* `void write(int b)`：写入一个字节。
* `void write(byte b[])`：写入给定的字节数组。
* `void write(byte b[], int off, int len)`：从 b[off] 开始写入 len 个字节。
* `void writeType(Type t)`：写入一个 Type 类型的变量到文件中。Type 可以是八大基本类型中的任意类型或者是 `String` 类型。

除上述方法之外，还可以使用 `void seek(long pos)` 方法移动文件指针。

##### 3.1.2.4 应用

```java
public class RandomAccessFileDemo01 {
    public static void main(String args[]) throws IOException {
        File f = new File("d:" + File.separator + "test.txt"); 
        RandomAccessFile rdf = null; 
        rdf = new RandomAccessFile(f, "rw");
        String name = null;
        int age = 0;
        name = "zhangsan"; 
        age = 30; 
        rdf.writeBytes(name);
        rdf.writeInt(age); 
        name = "lisi    "; 
        age = 31; 
        rdf.writeBytes(name); 
        rdf.writeInt(age); 
        name = "wangwu  "; 
        age = 32; 
        rdf.writeBytes(name);
        rdf.writeInt(age);
        rdf.close();
    }
}
```

```java
public class RandomAccessFileDemo02 {

    public static void main(String args[]) throws IOException {
        File f = new File("d:" + File.separator + "test.txt");  
        RandomAccessFile rdf = null;       
        rdf = new RandomAccessFile(f, "r");
        String name = null;
        int age = 0;
        byte b[] = new byte[8];    
        // 读取第二个人的信息，意味着要空出第一个人的信息
        rdf.skipBytes(12);        
        for (int i = 0; i < b.length; i++) {
            b[i] = rdf.readByte();    
        }
        name = new String(b);    
        age = rdf.readInt();    
        System.out.println("第二个人的信息 --> 姓名：" + name + "；年龄：" + age);
        
        // 读取第一个人的信息
        rdf.seek(0);    // 指针回到文件的开头
        for (int i = 0; i < b.length; i++) {
            b[i] = rdf.readByte();    
        }
        name = new String(b);    
        age = rdf.readInt();    
        System.out.println("第一个人的信息 --> 姓名：" + name + "；年龄：" + age);
        rdf.skipBytes(12);    
        for (int i = 0; i < b.length; i++) {
            b[i] = rdf.readByte();    
        }
        name = new String(b);    
        age = rdf.readInt();    
        System.out.println("第三个人的信息 --> 姓名：" + name + "；年龄：" + age);
        
        rdf.close();                
    }
}
```

#### 3.1.3 `System`

`System` 类中提供了大量的静态方法，可以获取系统相关的信息或系统级操作，其中提供了三个常用于 I/O 的静态成员：

- `System.out`：一个 `PrintStream` 流。

  `System.out` 一般会把你写到其中的数据输出到控制台上，通常仅用在类似命令行工具的控制台程序上，也经常用于打印程序的调试信息（尽管它可能并不是获取程序调试信息的最佳方式）。

- `System.err`：一个 `PrintStream` 流。

  `System.err` 与 `System.out` 的运行方式类似，但它更多的是用于打印错误文本。一些 IDE 为了让错误信息更加显眼，会将错误信息以红色文本的形式通过 `System.err` 输出到控制台上。

- `System.in`：一个典型的连接控制台程序和键盘输入的 `InputStream` 流。

  通常用于当数据是通过命令行参数或者配置文件传递给命令行 Java 程序的时候。

`System` 提供了方法修改这些流，使得它们可以被重定向到其他流。

示例：

```java
public class SystemInDemo {
    public static void main(String args[]) throws IOException {
        InputStream input = System.in;
        StringBuffer buf = new StringBuffer();
        System.out.print("请输入内容：");
        int temp = 0;
        while ((temp = input.read()) != -1) {
            char c = (char) temp;
            if (c == '\n') {
                break;
            }
            buf.append(c);
        }
        System.out.println("输入的内容为：" + buf);
        input.close();
    }
}
```

#### 3.1.4 `Scanner`

**`Scanner` 可以获取用户的输入，并对数据进行校验**。

`Scanner` 提供了 `nextType` 方法获取一个 Type 类型的值，Type 可以是八大基本类型的任意一种或者 `String`。

示例：

```java
public class ScannerDemo {
    public static void main(String args[]) {
        Scanner scan = new Scanner(System.in);    
        int i = 0;
        float f = 0.0f;
        System.out.print("输入整数：");
        if (scan.hasNextInt()) {    // 判断输入的是否是整数
            i = scan.nextInt();    // 接收整数
            System.out.println("整数数据：" + i);
        } else {
            System.out.println("输入的不是整数！");
        }

        System.out.print("输入小数：");
        if (scan.hasNextFloat()) {    // 判断输入的是否是小数
            f = scan.nextFloat();    // 接收小数
            System.out.println("小数数据：" + f);
        } else {
            System.out.println("输入的不是小数！");
        }

        Date date = null;
        String str = null;
        System.out.print("输入日期（yyyy-MM-dd）：");
        if (scan.hasNext("^\\d{4}-\\d{2}-\\d{2}$")) {    // 判断
            str = scan.next("^\\d{4}-\\d{2}-\\d{2}$");    // 接收
            try {
                date = new SimpleDateFormat("yyyy-MM-dd").parse(str);
            } catch (Exception e) {}
        } else {
            System.out.println("输入的日期格式错误！");
        }
        System.out.println(date);
    }
}
```

### 3.2 I/O 流

流从概念上来说是一个**连续的数据流**。可以把流想象为一个水管，源头和目的地是两个水桶，水就是数据；在两个水桶中，水通过水管流动，每个水滴就是一个字符或一个字节。

在流中，有一个指针指向当前操作位置，指针可以向前或向后移动，表示数据的流向。

BIO 中提供了完备的 I/O 流操作，共几十个类，看起来杂乱无章，实际上是非常有规则的：

* 根据流向划分，可以分为**输入流**以及**输出流**。

  * 输入流：只能从中读取数据。
  * 输出流：只能向其写入数据。
  
* 根据操作单元划分，可以分为**字符流**以及**字节流**。

  * 字符流：以字符为单元，只能操作纯字符数据。
  * 字节流：以字节为单元，可操作任何数据。
  
* 根据流的角色划分，可以分为**节点流**和**处理流**。

  * 节点流：可以从/向一个特定的 I/O 设备（如磁盘，网络）读/写数据的流。
* 处理流：用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写功能。

下表列出了 BIO 中所有的流及其分类：

| 分类               | 字节输入流             | 字节输出流              | 字符输入流          | 字符输出流           |
| ------------------ | ---------------------- | ----------------------- | ------------------- | -------------------- |
| 抽象基类           | `InputStream`          | `OutputStream`          | `Reader`            | `Writer`             |
| 过滤流基类         | `FilterInputStream`    | `FilterOutputStream`    | `FilterReader`      | `FilterWriter`       |
| 文件流             | `FileInputStream`      | `FileOutputStream`      | `FileReader`        | `FileWriter`         |
| 数组流             | `ByteArrayInputStream` | `ByteArrayOutputStream` | `CharArrayReader`   | `CharArrayWriter`    |
| 管道流             | `PipedInputStream`     | `PipedOutputStream`     | `PipedReader`       | `PipedWriter`        |
| 字符串流           |                        |                         | `StringReader`      | `StringWriter`       |
| 缓冲流             | `BufferedInputStream`  | `BufferedOutputStream`  | `BufferedReader`    | `BufferedWriter`     |
| 序列化流           | `ObjectInputStream`    | `ObjectOutputStream`    |                     |                      |
| 打印流             |                        | `PrintStream`           |                     | `PrintWriter`        |
| 字节到字符的转换流 |                        |                         | `InputStreamReader` | `OutputStreamWriter` |
| 推回输入流         | `PushbackInputStream`  |                         | `PushbackReader`    |                      |
| 数据操作流         | `DataInputStream`      | `DataOutputStream`      |                     |                      |
| 跟踪行号的流       |                        |                         | `LineNumberReader`  |                      |
| 串联流             | `SequenceInputStream`  |                         |                     |                      |

#### 3.2.1 资源关闭

在 I/O 操作时，会占用系统资源，并且在占用某资源时其他进程/线程不能占用，因此如果一直占用资源而不关闭（释放），那么其他程序可能永远无法获取到资源。此外，如果忘记关闭资源程序直接退出了的话，JVM 虽然会回收对象占用的内存，但是对象占用的系统资源却不能释放掉，造成资源浪费。

对于类的编写者来说，有关系统资源的类都需要实现 `Closeable` 或 `AutoCloseable` 接口，并且实现其 `close` 方法；对于调用者来说，使用完以后一定要通过调用 `close` 方法来主动释放资源。

一般来说，I/O 操作都可能会抛出异常，包括 `close` 方法，这就导致 I/O 操作可能是这样的：

```java
try {
    // I/O 操作
} catch (IOException e) {

} finally {
    try {
        // 调用流的 close()
    } catch (IOException e) {

    }
}
```

这是非常繁琐的，还记得我们在异常章节讲过的 try-with-resources 语法吗？这个语法就是专门为关闭资源而生的。

> **提示**
>
> 这个语法是在 JDK 7 提供的，实现了 `AutoCloseable` 的类才能被该语法自动关闭，但是许多之前定义的类只实现了 `Closeable` 接口，因此 JDK 让 `Closeable` 继承自 `AutoCloseable`，这样就维持了对之前的兼容。

#### 3.2.2 字节流

字节流主要操作字节数据或二进制对象。

字节流有两个核心抽象类：`InputStream` 和 `OutputStream`。所有的字节流类都继承自这两个抽象类。

`InputStream` 提供了以下方法：

* `int read()`：从输入流中读取数据的下一个字节。值字节以 `int` 形式返回，范围 0 到 255。

  如果由于到达流的末尾而没有可用的字节，则返回 -1。

* `int read(byte b[])`：从输入流中读取一些字节并将它们存储到缓冲区数组 b 中。

  如果 b 的长度为零，则不读取任何字节并返回 0；否则至少尝试读取一个字节。

* `int read(byte b[], int off, int len)`：从输入流中读取最多 len 个字节的数据到一个字节数组中，读取的第一个字节存储到元素 b[off] 中。

* `long skip(long n)`：跳过并丢弃此输入流中的 n 字节数据，返回跳过的实际字节数。

* `int available()`：返回可以从此输入流中读取（或跳过）的字节数的估计值。

* `void close()`：关闭此输入流并释放与该流关联的所有系统资源。

`OutputStream` 提供了以下方法：

* `void write(int b)`：将指定字节写入此输出流。要写入的字节是参数 b 的低 8 位。 b 的高 24 位被忽略。
* `void write(byte b[])`：将指定字节数组中的 `b.length` 个字节写入此输出流。
* `void write(byte b[], int off, int len)`：将指定字节数组中的 len 个字节写入此输出流，将从 b[off] 开始写入，最后一个写入的字节是 b[off + len - 1]。
* `void flush()`：刷新此输出流并强制写出任何缓冲的输出字节。
* `void close()`：关闭此输出流并释放与该流关联的所有系统资源。

#### 3.2.3 字符流

字符流主要操作字符，一个字符等于两个字节。

字符流有两个核心类：`Reader` 类和 `Writer` 。所有的字符流类都继承自这两个抽象类。

`Reader` 类提供了以下方法：

* `int read()`：从输入流中读取数据的下一个字符。值字节以 `int` 形式返回，范围 0 到 255。

  如果由于到达流的末尾而没有可用的字节，则返回 -1。

* `int read(char cbuf[])`：从输入流中读取一些字符并将它们存储到缓冲区数组 cbuf 中。

  如果 b 的长度为零，则不读取任何字节并返回 0；否则至少尝试读取一个字节。

* `int read(char cbuf[], int off, int len)`：从输入流中读取最多 len 个字符的数据到一个字符数组中，读取的第一个字符存储到元素 cbuf[off] 中。

* `long skip(long n)`：跳过并丢弃此输入流中的 n 字符数据，返回跳过的实际字符数。

* `boolean ready()`：判断该流是否已经准备好。

* `void close()`：关闭此输入流并释放与该流关联的所有系统资源。

`Writer` 提供了以下方法：

* `void write(int c)`：将指定字符写入此输出流。要写入的字符是参数 c 的低 16 位。 c 的高 16 位被忽略。

* `void write(char cbuf[])`：将指定字符数组中的 `cbuf.length` 个字符写入此输出流。

* `void write(char cbuf[], int off, int len)`：将指定字符数组中的 len 个字符写入此输出流，将从 cbuf[off] 开始写入，最后一个写入的字符是 cbuf[off + len - 1]。

* `void write(String str)`：将给定的字符串写入到流中。

* `void write(String str, int off, int len)`：从给定的字符串的第 off 个字符开始，写入 len 个字符到流中。

* `Writer append(CharSequence csq)`：将指定的字符序列附加到此 `Writer`，和对应的 `void write(String) str` 方法的行为完全相同，只不过此方法可以链式调用。

* `Writer append(CharSequence csq, int start, int end)`：将指定的字符序列的子序列附加到此 `Writer`，和对应的 `void write(String str, int off, int len)` 方法的行为完全相同，只不过此方法可以链式调用。

  子序列包含 start，不包含 end。

* `Writer append(char c)`：将指定的字符附加到这个 `Writer`，和对应的 `void write(int c)` 方法的行为完全相同，只不过此方法可以链式调用。

* `void flush()`：刷新此输出流并强制写出任何缓冲的输出字节。

* `void close()`：关闭此输出流并释放与该流关联的所有系统资源。

#### 3.2.4 字符流和字节流的选择

字节流和字符流都有 `read()`、`write()`、`flush()`、`close()` 这样的方法，这决定了它们的操作方式近似，但是不同点也是很明显的：

- 数据类型
  - 字节流的数据是字节（二进制对象）。
  - 字符流的数据是字符，一个字符等于两个字节。
- 缓冲区
  - 字节流在操作时本身不会用到缓冲区（内存），是直接操作的。
  - 字符流在操作时是使用了缓冲区，通过缓冲区再操作。

所有的文件在硬盘或传输时都是以字节方式保存的，例如图片，影音文件等都是按字节方式存储的，因此字符流无法读写这些文件。

所以，**除了纯文本数据文件使用字符流以外，其他文件类型都应该使用字节流方式**。

#### 3.2.5 过滤流

过滤流是处理流，**需要从其他流构造一个过滤流**。

过滤流提供了对**其基本流的数据的进一步处理，为程序提供更强大的读写功能**，为此，过滤流并不提供新的方法，而是专注于重写父类的基本方法以增强功能。

字节过滤流都是非抽象类，但是其构造方法为 `protected`，换句话说，字节过滤流是字节流的基本实现类，而没有做任何增强，但是外部不能直接实例化；而字符过滤流都是抽象类。因此，所有的过滤流都需要通过其子类使用。

字符过滤流的子类只有推回输入流，而字节过滤流有：缓冲流、数据操作流、推回输入流、打印流。当然，字符流也有这些类型，虽然不是继承自过滤流，但是其思想是一致的，因此会统一进行介绍。

##### 3.2.5.1 缓冲流

缓冲流**通过内置一个缓冲数组，通过读写缓冲区，来减少操作系统的 I/O 次数，从而提升性能**。

在构造缓冲流时，可以指定缓冲区的大小。

字符缓冲流为了方便操作文本文件，还提供了按行操作的方法，比如 `BufferedReader` 提供了 `readLine` 读取一整行，而 `BufferedWriter` 提供了 `writeLine` 写入一整行，`newLine` 来写一个空行。

##### 3.2.5.2 数据操作流

数据操作流提供了格式化读入和输出某一类数据的方法。通过 `writeType` 和 `readType` 方法可以写入或读取 Type 类型的数据。Type 是八大基本类型以及 `String` 类型中的任意一个。

示例：

```java
public class DataStreamDemo {
    public static final String FILEPATH = "temp.log";

    public static void main(String[] args) throws IOException {
        write(FILEPATH);
        read(FILEPATH);
    }

    private static void write(String filepath) throws IOException {
        File f = new File(filepath);

        DataOutputStream dos = new DataOutputStream(new FileOutputStream(f));

        String[] names = { "衬衣", "手套", "围巾" };
        float[] prices = { 98.3f, 30.3f, 50.5f };
        int[] nums = { 3, 2, 1 };
        for (int i = 0; i < names.length; i++) {
            dos.writeChars(names[i]);
            dos.writeChar('\t');
            dos.writeFloat(prices[i]);
            dos.writeChar('\t');
            dos.writeInt(nums[i]);
            dos.writeChar('\n');
        }

        dos.close();
    }

    private static void read(String filepath) throws IOException {
        File f = new File(filepath);

        DataInputStream dis = new DataInputStream(new FileInputStream(f));

        String name = null; 
        float price = 0.0f; 
        int num = 0; 
        char[] temp = null; 
        int len = 0; 
        char c = 0;
        try {
            while (true) {
                temp = new char[200]; 
                len = 0;
                while ((c = dis.readChar()) != '\t') { 
                    temp[len] = c;
                    len++; 
                }
                name = new String(temp, 0, len); 
                price = dis.readFloat(); 
                dis.readChar(); 
                num = dis.readInt(); 
                dis.readChar();
                System.out.printf("名称：%s；价格：%5.2f；数量：%d\n", name, price, num);
            }
        } catch (EOFException e) {
            System.out.println("结束");
        } catch (IOException e) {
            e.printStackTrace();
        }

        dis.close();
    }
}
```

##### 3.2.5.3 推回输入流

推回输入流**可以给调用者第二次读取的机会，调用者通过推回字节（字符）到缓冲区中，就可以重新读取**。

在 `PushbackInputStream` 中，提供了 `unread` 系列方法用来回退：

* `void unread(int b)`：通过将一个字节 b 写回到缓冲区来回推，下次调用 read 时就会读取到 b。
* `void unread(byte[] b, int off, int len)`：通过将一个字节数组中从 off 开始的 len 个字节写回到缓冲区来回推。
* `void unread(byte[] b)`：通过将一个字节数组 b 写回到缓冲区来回推。

同理，`PushbackReader` 也提供了 `unread` 系列方法，参数由字节变为字符。

示例：

```java
public class PushbackDemo {
    public static void main(String[] args) throws IOException {
        String str = "www.baidu.com";

        PushbackInputStream in = new PushbackInputStream(new ByteArrayInputStream(str.getBytes()));

        int ch;
        while ((ch = in.read()) != -1) {
            if (ch == '.') {
                in.unread('x');
                ch = in.read();
                System.out.println("回推了：" + (char) ch);
                System.out.print("..");
            } else {
                System.out.print((char) ch);
            }
        }

        in.close();
    }
}
```

##### 3.2.5.4 打印输出流

打印输出流**提供了许多打印方法，是打印输出信息最方便的类**。

`PrintStream` 和 `PrintWriter` 提供了一系列 `print`、`println`、`printf` 方法，用于将数据打印到流中，实际上，这些 `print` 方法都是调用 `write` 方法。

关于格式化的 `printf` 方法，实际上是调用 `String` 的 `format` 方法，我们已经详细讲述过了。

值得一提的是，在它们的构造函数中可以传入一个文件路径，能够直接写入一个文件。

#### 3.2.6 跟踪行号的流

跟踪行号的流是基于缓冲流的，可以一行一行的读取，内部会有数值变量跟踪其行号，通过 `getLineNumber` 获取行号，而可以使用 `setLineNumber`，但是它并不能起到跳转的作用，仅仅是设置行号。

```java
public class LineNumberDemo {
    public static void main(String[] args) throws IOException {
        File file = new File("temp.log");
        LineNumberReader in = new LineNumberReader( new FileReader(file));

        String line = null;
        while ((line = in.readLine()) != null) {
            System.out.println(in.getLineNumber() + ":" + line);
        }
    }
}
```

#### 3.2.7 文件流

**`FileOutputStream` 和 `FileInputStream` 提供了读写字节到文件的能力；而 `FileReader` 和 `FileWriter` 提供了读写字符到文件的能力**。

一般来说，使用文件字节流一般是操作二进制文件，比如音乐，图片等，而文本文件则使用字符流。

文件操作一般步骤：

1. 使用 `File` 类封装一个路径，并调用相关方法确认该文件确实存在且确实是文件，如果不存在则要创建。
2. 把 `File` 绑定在文件流上。
3. 通过流提供的方法读取或写入数据。
4. 关闭流。

一般来说，写入到文件有追加模式和覆盖模式，追加模式是在已存在的文件末尾追加要写入的数据，而覆盖模式则是先把已存在文件清空，然后从头开始写入。

默认是覆盖模式，可以通过构造函数指定成追加模式。

示例：

```java
public class FileStreamDemo {
    private static final String FILEPATH = "temp.log";

    public static void main(String[] args) throws Exception {
        write(FILEPATH);
        read(FILEPATH);
    }

    public static void write(String filepath) throws IOException {
        File f = new File(filepath);

        OutputStream out = new FileOutputStream(f);

        String str = "Hello World\n";
        byte[] bytes = str.getBytes();
        out.write(bytes);

        out.close();
    }

    public static void read(String filepath) throws IOException {
        File f = new File(filepath);

        InputStream input = new FileInputStream(f);

        byte[] bytes = new byte[(int) f.length()];
        int len = input.read(bytes); // 读取内容
        System.out.println("读入数据的长度：" + len);

        input.close();
        System.out.println("内容为：\n" + new String(bytes));
    }
}
```

```java
public class FileReadWriteDemo {
    private static final String FILEPATH = "temp.log";

    public static void main(String[] args) throws IOException {
        write(FILEPATH);
        System.out.println("内容为：" + new String(read(FILEPATH)));
    }

    public static void write(String filepath) throws IOException {
        File f = new File(filepath);

        Writer out = new FileWriter(f);

        String str = "Hello World!!!\r\n";
        out.write(str);

        out.flush();
        out.close();
    }

    public static char[] read(String filepath) throws IOException {
        File f = new File(filepath);

        Reader input = new FileReader(f);

        int temp = 0; 
        int len = 0; 
        char[] c = new char[1024];
        while ((temp = input.read()) != -1) {
            c[len] = (char) temp;
            len++;
        }
        System.out.println("文件字符数为：" + len);

        input.close();
        
        return c;
    }
}
```

#### 3.2.8 数组流

也叫内存流，**通过在 `byte\char` 数组上建立流实现读写**。

一般在生成一些临时信息时，才会考虑使用数组流，如果临时信息保存在文件中，还需要在有效期过后删除文件，这样比较麻烦。

使用示例：

```java
public class ByteArrayStreamDemo {

    public static void main(String[] args) {
        String str = "HELLOWORLD"; 
        ByteArrayInputStream bis = new ByteArrayInputStream(str.getBytes());
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        // 准备从内存 ByteArrayInputStream 中读取内容
        int temp = 0;
        while ((temp = bis.read()) != -1) {
            char c = (char) temp; 
            bos.write(Character.toLowerCase(c)); // 将字符变为小写
        }
        
        String newStr = bos.toString(); 
        try {
            bis.close();
            bos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(newStr);
    }
}
```

#### 3.2.9 管道流

管道流多**用于线程间通信**，在并发章节中我们已经涉及到了。

Java 中的管道实际上是内存中的一个数组，在创建管道流时，可以指定管道的大小。

除此之外，**一个管道输入流必须和一个管道输出流相连**，这可以通过 `connect` 方法实现，也可以通过在构造时传递另一个管道流来连接。

如果一个管道流已经和另一个管道流连接了，其他管道流就不能连接到它们中的任意一个，否则会引发 `IOException`。

示例：

```java
public class PipedStreamDemo {
    public static void main(String[] args) {
        Send s = new Send();
        Receive r = new Receive();
        try {
            s.getPos().connect(r.getPis()); // 连接管道
        } catch (IOException e) {
            e.printStackTrace();
        }
        new Thread(s).start(); // 启动线程
        new Thread(r).start(); // 启动线程
    }

    static class Send implements Runnable {
        private PipedOutputStream pos = null;

        Send() {
            pos = new PipedOutputStream();
        }

        @Override
        public void run() {
            String str = "Hello World!!!";
            try {
                pos.write(str.getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                pos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        PipedOutputStream getPos() {
            return pos;
        }
    }

    static class Receive implements Runnable {
        private PipedInputStream pis = null;

        Receive() {
            pis = new PipedInputStream();
        }

        @Override
        public void run() {
            byte[] b = new byte[1024];
            int len = 0;
            try {
                len = pis.read(b);
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                pis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            System.out.println("接收的内容为：" + new String(b, 0, len));
        }

        PipedInputStream getPis() {
            return pis;
        }
    }
}
```

#### 3.2.10 序列化流

详见[序列化](#3.3 序列化)。

#### 3.2.11 串联流

串联流可以将多个 `InputStream` 合并成一个 `InputStream`，它一般应用在多个输入一个输出的场景，比如多个日志合并为一个日志。

```java
public class SequenceInputStreamDemo {
    public static void main(String[] args) throws Exception {
        InputStream is1 = new FileInputStream("temp1.log");
        InputStream is2 = new FileInputStream("temp2.log");
        SequenceInputStream sis = new SequenceInputStream(is1, is2);

        int temp;
        OutputStream os = new FileOutputStream("temp3.log");
        while ((temp = sis.read()) != -1) {
            os.write(temp);
        }

        sis.close();
        is1.close();
        is2.close();
        os.close();
    }
}
```

#### 3.2.12 字符串流

字符串流是建立在字符串的字符流，用于修改和构造字符串。

```java
public class StringReadWriteDemo {
    public static void main(String[] args) throws IOException {
        StringReader in = new StringReader("123456789");

        int ch;
        while ((ch = in.read()) != -1) {
            System.out.println((char) ch);
        }

        StringWriter out = new StringWriter();
        for (int i = 0; i < 10; i++) {
            out.write("gekki");
        }

        System.out.println(out);
    }
}
```

#### 3.2.13 转换流

转换流可以将一个字节流转换为一个字符流，其中 `InputStreamReader` 可以把一个字节读取流转换为字符读取流，而 `OutputStreamWriter` 可以把一个字节写入流转换为字符写入流。

```java
public class OutputStreamWriterDemo {
    public static void main(String[] args) throws IOException {
        File f = new File("temp.log");
        Writer out = new OutputStreamWriter(new FileOutputStream(f));
        out.write("hello world!!");
        out.close();
    }
}
```

```java
public class InputStreamReaderDemo {
    public static void main(String[] args) throws IOException {
        File f = new File("temp.log");
        Reader reader = new InputStreamReader(new FileInputStream(f));
        char[] c = new char[1024];
        int len = reader.read(c);
        reader.close();
        System.out.println(new String(c, 0, len));
    }
}
```

### 3.3 序列化

**序列化指的是将 Java 对象转换为字节流；而反序列化指的是将字节流转换为对象**。

序列化的用途十分广泛：

* 序列化可以将对象的字节序列持久化（如保存在内存、文件、数据库中）。
* 在网络上传送对象的字节序列。
* RMI（Remote Method Invocation），远程方法调用。

使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，**对象序列化不会关注类中的静态变量**。

Java 通过对象输入输出流来实现序列化和反序列化：

- `ObjectOutputStream` 类的 `writeObject()` 方法可以实现序列化；
- `ObjectInputStream` 类的 `readObject()` 方法用于实现反序列化。

序列化流也是处理流，因此要建立在其他流之上。

简单示例：

```java
public class SerializeDemo01 {
    enum Sex {
        MALE,
        FEMALE
    }

    static class Person implements Serializable {
        private static final long serialVersionUID = 1L;
        private String name = null;
        private Integer age = null;
        private Sex sex;

        public Person() { }

        public Person(String name, Integer age, Sex sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
        }

        @Override
        public String toString() {
            return "Person{" + "name='" + name + '\'' + ", age=" + age + ", sex=" + sex + '}';
        }
    }

    private static void serialize(String filename) throws IOException {
        File f = new File(filename); 
        OutputStream out = new FileOutputStream(f); 
        ObjectOutputStream oos = new ObjectOutputStream(out); 
        oos.writeObject(new Person("Jack", 30, Sex.MALE));
        oos.close();
        out.close();
    }

    private static void deserialize(String filename) throws IOException, ClassNotFoundException {
        File f = new File(filename); 
        InputStream in = new FileInputStream(f); 
        ObjectInputStream ois = new ObjectInputStream(in); 
        Object obj = ois.readObject(); 
        ois.close();
        in.close();
        System.out.println(obj);
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        final String filename = "text.dat";
        serialize(filename);
        deserialize(filename);
    }
}
```

#### 3.3.1 `Serializable`

**被序列化的类必须属于 `Enum`、`Array` 和 `Serializable` 类型其中的任何一种，否则将抛出 `NotSerializableException` 异常**。

这是因为 Java 在序列化的过程中，会对类型进行检查，如果不满足上述类型要求，则不允许序列化。

`Serializable` 是一个标记接口，它没有定义任何方法，仅仅用于标记一个类可以被序列化。

##### 3.3.1.1 `serialVersionUID`

你可能在其他库文件中看到过这样一个字段：`public static final long serialVersionUID = xxx`，这是 **Java 为每个序列化类产生的版本标识**，它可以用来保证在反序列化时，发送方发送的和接受方接收的是可兼容的对象。

如果接收方接收的类的 `serialVersionUID` 与发送方发送的 `serialVersionUID` 不一致，会抛出 `InvalidClassException`。

**如果可序列化类没有显式声明 `serialVersionUID`，则序列化运行时将基于该类的各个方面计算该类的默认 `serialVersionUID` 值**。尽管这样，还是**建议在每一个序列化的类中显式指定 `serialVersionUID` 的值**。因为不同的 jdk 编译很可能会生成不同的 `serialVersionUID` 默认值，从而导致在反序列化时抛出 `InvalidClassExceptions` 异常。

需要注意的是，该变量必须是 `static final long` 型，访问权限则不做要求。

##### 3.3.1.2 序列化机制

###### 3.3.1.2.1 默认序列化机制

如果仅仅只是让某个类实现 `Serializable` 接口，而没有其它任何处理的话，那么就会使用**默认序列化机制**。

默认序列化机制是：在序列化对象时，**不仅会序列化当前对象本身，还会对其父类的字段以及该对象引用的其它对象也进行序列化，这些其它对象引用的另外对象也将被序列化，以此类推**。

所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。

注意，由于默认机制会序列化父类以及其他引用对象，因此它们也必须满足序列化要求。

###### 3.3.1.2.2 `transient`

**使用 `transient` 修饰的字段不会被默认序列化机制所序列化。**

当反序列化时，该字段的值会为默认值。

在集合框架中，我们看到底层存储数据的成员都加上了这个关键字，目的就是为了防止默认序列化机制序列化一个集合而导致开销过大。那么就出现问题了，集合不能序列化吗？答案当然是可以的，集合框架中的类都实现了自定义序列化机制，我们很快就会了解到。

###### 3.3.1.2.3 自定义序列化机制

序列化和反序列化是由 JVM 执行的，在序列化和反序列化过程中，如果被序列化的类中含有 `void readObject(ObjectInputStream in)` 和 `void writeObject(ObjectOutputStream out)` 方法，那么会被 JVM 优先调用，进行用户自定义逻辑的序列化。

注意，这两个方法不要求是 `public`，它们会由 JVM 通过反射进行调用。

如果没有这样的两个方法，则会调用 `ObjectOutputStream` 的 `defaultWriteObject` 方法以及 `ObjectInputStream` 的 `defaultReadObject` 方法，也就是默认的序列化机制。

#### 3.3.2 `Externalizable`

JDK 中提供了另一个序列化接口 `Externalizable`，**可序列化类实现 `Externalizable` 接口之后，基于 `Serializable` 接口的默认序列化机制就会失效**。

这个接口和 `Serializable` 最大的区别就是它提供了序列化方法 `writeExternal` 和反序列化方法 `readExternal`，实现该接口的类必须重写这两个方法，JVM 在进行实际操作时就会调用这两个方法。

这也意味着使用该接口进行序列化时，序列化的细节由程序员控制。

另外，**若使用 `Externalizable` 进行序列化，当读取对象时，会调用被序列化类的无参构造方法去创建一个新的对象；然后再将被保存对象的字段的值分别填充到新对象中**。由于这个原因，**实现 `Externalizable` 接口的类必须要提供一个无参的构造方法，且它的访问权限为 `public`**。

示例：

```java
public class ExternalizeDemo {
    static class Person implements Externalizable {
        transient private Integer age = null;

        // 其他字段

        @Override
        public void writeExternal(ObjectOutput out) throws IOException {
            out.writeObject(name);
            out.writeInt(age);
        }

        @Override
        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            name = (String) in.readObject();
            age = in.readInt();
        }
    }

    // 其他内容
}
```

#### 3.3.3 `readResolve` 方法

当我们使用 Singleton 模式时，应该是期望某个类的实例应该是唯一的，但如果该类是可序列化的，那么情况可能会略有不同。

当单例的对象被反序列化时，和单例对象实际上是不一样的，这样就违反了单例模式的规则，这时，可以使用**`readResolve()` 方法**，在该方法中直接返回单例对象，就可以保持在序列化的同时，保持单例的特性。

#### 3.3.4 Java 序列化机制存在的问题

Java 的序列化能保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是难以处理：

- 父类是 `Serializable`，所有子类都可以被序列化；子类是 `Serializable`，父类不是，则子类可以正确序列化，但父类的属性不会被序列化（不报错，但是数据会丢失）。
- 如果序列化的属性是对象，则这个对象也必须是 `Serializable` ，否则报错。
- 反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。
- 反序列化时，如果 `serialVersionUID` 被修改，则反序列化会失败。

同时，还存在一些缺陷：

- **无法跨语言**：Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。
- **容易被攻击**：对象是通过在 `ObjectInputStream` 上调用 `readObject()` 方法进行反序列化的，它可以将类路径上几乎所有实现了 `Serializable` 接口的对象都实例化。这意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。对于需要长时间进行反序列化的对象，不需要执行任何代码，也可以发起一次攻击。攻击者可以创建循环对象链，然后将序列化后的对象传输到程序中反序列化，这种情况会导致 `hashCode` 方法被调用次数呈次方爆发式增长, 从而引发栈溢出异常。
- **序列化后的流太大**：Java 序列化中使用了 `ObjectOutputStream` 来实现对象转二进制编码，编码后的数组很大，非常影响存储和传输效率。
- **序列化性能太差**：Java 的序列化耗时比较大。序列化的速度也是体现序列化性能的重要指标，如果序列化的速度慢，就会影响网络通信的效率，从而增加系统的响应时间。

因此，对于序列化，实践中会使用第三方的序列化的技术：

* thrift、protobuf：适用于对性能敏感，对开发体验要求不高的程序。
* hessian：适用于对开发体验敏感，性能有要求的程序。
* jackson、gson、fastjson：适用于对序列化后的数据要求有良好的可读性（转为 JSON、XML 形式）的程序。

我们最常用的就是 JSON 序列化方式，各种流行的框架都支持 JSON 序列化，JSON 在数据传输方面有**占用空间小**这一大优点，并且，JSON 是能够直接转化成 JS 对象的，因此在 Web 应用程序种经常用到；缺点则是不方便修改某一个具体属性的值。

### 3.4 网络编程

网络编程主要是对运输层的封装，包括 TCP 和 UDP，这些都是通过套接字（Socket）实现的，通过底层操作系统的套接字接口来获取报文。

- **TCP**：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP/ IP。
- **UDP**：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。

#### 3.4.1 TCP 支持

`Socket` 和 `ServerSocket` 提供了对 TCP 的支持，其中 `Socket` 用于 TCP 客户端，而 `ServerSocket` 用于 TCP 服务端。

TCP 连接的建立基本流程如下：

- 服务器实例化一个 `ServerSocket` 对象，表示服务器绑定一个端口。
- 服务器调用 `ServerSocket` 的 `accept()` 方法，该方法将一直等待，直到客户端连接到服务器的绑定端口（即监听端口）。
- 服务器监听端口时，客户端实例化一个 `Socket` 对象，指定服务器名称和端口号来请求连接。
- `Socket` 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 `Socket` 对象能够与服务器进行通信。
- 在服务器端，`accept()` 方法返回服务器上一个新的 `Socket` 引用，该引用连接到客户端的 `Socket`。

* 连接建立后，可以通过使用 I/O 流进行通信。每一个 `Socket` 都有一个输出流和一个输入流。客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。

由于 TCP 是一个全双工的协议，因此两边都可以同时发送数据/接收数据。

##### 3.4.1.1 `ServerSocket`

服务器程序通过使用 `ServerSocket` 类绑定一个端口，并且监听客户端请求连接此端口的请求。

`ServerSocket` 有多个构造方法：

| 方法                                                       | 描述                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| `ServerSocket()`                                           | 创建非绑定服务器套接字。                                     |
| `ServerSocket(int port)`                                   | 创建绑定到特定端口的服务器套接字。                           |
| `ServerSocket(int port, int backlog)`                      | 利用指定的 `backlog` 创建服务器套接字并将其绑定到指定的本地端口号。 |
| `ServerSocket(int port, int backlog, InetAddress address)` | 使用指定的端口、监听 `backlog` 和要绑定到的本地 IP 地址创建服务器。 |

backlog 指的是套接字上**请求的最大挂起连接数**，也就是所谓的半连接队列长度。

如果成功创建一个 `ServerSocket` 而没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。

`ServerSocket` 的常用方法如下：

| 方法                                         | 描述                                                  |
| -------------------------------------------- | ----------------------------------------------------- |
| `int getLocalPort()`                         | 返回此套接字在其上侦听的端口。                        |
| `Socket accept()`                            | 监听并接受到此套接字的连接。                          |
| `void setSoTimeout(int timeout)`             | 通过指定超时值启用/禁用 `SO_TIMEOUT`，以毫秒为单位。  |
| `void bind(SocketAddress host, int backlog)` | 将 `ServerSocket` 绑定到特定地址（IP 地址和端口号）。 |

服务端示例：

```java
public class HelloServer {
    public static void main(String[] args) throws Exception {
        // Socket 服务端
        // 服务器在8888端口上监听
        ServerSocket server = new ServerSocket(8888);
        System.out.println("服务器运行中，等待客户端连接。");
        // 得到连接，程序进入到阻塞状态
        Socket client = server.accept();
        // 打印流输出最方便
        PrintStream out = new PrintStream(client.getOutputStream());
        // 向客户端输出信息
        out.println("hello world");
        client.close();
        server.close();
        System.out.println("服务器已向客户端发送消息，退出。");
    }
}
```

##### 3.4.1.2 `Socket`

`Socket` 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 `Socket` 对象通过实例化 ，而 服务器获得一个 `Socket` 对象则通过 `accept()` 方法 a 的返回值。

`Socket` 类有 5 个构造方法：

| 方法                                                         | 描述                                                     |
| ------------------------------------------------------------ | -------------------------------------------------------- |
| `Socket()`                                                   | 通过系统默认类型的 `SocketImpl` 创建未连接套接字         |
| `Socket(String host, int port)`                              | 创建一个流套接字并将其连接到指定主机上的指定端口号。     |
| `Socket(InetAddress host, int port)`                         | 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。   |
| `Socket(String host, int port, InetAddress localAddress, int localPort)` | 创建一个套接字并将其连接到指定远程主机上的指定远程端口。 |
| `Socket(InetAddress host, int port, InetAddress localAddress, int localPort)` | 创建一个套接字并将其连接到指定远程地址上的指定远程端口。 |

当 `Socket` 构造方法返回，并没有简单的实例化了一个 `Socket` 对象，它实际上会尝试连接到指定的服务器和端口。

下表列出了常用方法：

| 方法                                            | 描述                                                  |
| ----------------------------------------------- | ----------------------------------------------------- |
| `void connect(SocketAddress host, int timeout)` | 将此套接字连接到服务器，并指定一个超时值。            |
| `InetAddress getInetAddress()`                  | 返回套接字连接的地址。                                |
| `int getPort()`                                 | 返回此套接字连接到的远程端口。                        |
| `int getLocalPort()`                            | 返回此套接字绑定到的本地端口。                        |
| `SocketAddress getRemoteSocketAddress()`        | 返回此套接字连接的端点的地址，如果未连接则返回 null。 |
| `InputStream getInputStream()`                  | 返回此套接字的输入流。                                |
| `OutputStream getOutputStream()`                | 返回此套接字的输出流。                                |
| `void close()`                                  | 关闭此套接字。                                        |

客户端示例：

```java
public class HelloClient {
    public static void main(String[] args) throws Exception {
        // Socket 客户端
        Socket client = new Socket("localhost", 8888);
        InputStreamReader inputStreamReader = new InputStreamReader(client.getInputStream());
        // 一次性接收完成
        BufferedReader buf = new BufferedReader(inputStreamReader);
        String str = buf.readLine();
        buf.close();
        client.close();
        System.out.println("客户端接收到服务器消息：" + str + "，退出");
    }
}
```

#### 3.4.2 UDP 支持

Java 通过 `DatagramSocket` 和 `DatagramPacket` 实现对 UDP 协议的支持。

- `DatagramPacket`：数据包类
- `DatagramSocket`：通信套接字类

基本的使用方式是：

- 实例化一个 `DatagramSocket` 对象，绑定一个端口，之后可以通过该对象发送或接收数据包。
- 实例化一个 `DatagramPacket` 对象，用来存储数据。

UDP 服务端示例：

```java
public class UDPServer {
    public static void main(String[] args) throws Exception { 
        String str = "hello World!!!";
        DatagramSocket ds = new DatagramSocket(3000);
        DatagramPacket dp =
            new DatagramPacket(str.getBytes(), str.length(), InetAddress.getByName("localhost"), 9000); 
        System.out.println("发送信息。");
        ds.send(dp);
        ds.close();
    }
}
```

UDP 客户端示例：

```java
public class UDPClient {
    public static void main(String[] args) throws Exception { 
        byte[] buf = new byte[1024]; 
        DatagramSocket ds = new DatagramSocket(9000); 
        DatagramPacket dp = new DatagramPacket(buf, 1024); 
        ds.receive(dp); // 接收数据
        String str = new String(dp.getData(), 0, dp.getLength()) + "from " + dp.getAddress().getHostAddress() + "："
            + dp.getPort();
        System.out.println(str); 
    }
}
```

#### 3.4.3 `InetAddress`

`InetAddress` 类表示 IP 地址。

没有公有的构造函数，只能通过静态方法来创建实例。

```java
InetAddress.getByName(String host);
InetAddress.getByAddress(byte[] address);
```

该类一般只用于构造各种套接字。

## 4. NIO 框架

NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 `java.nio` 包，提供了 `Channel` 、`Selector`、`Buffer` 等抽象。NIO 中的 N 可以理解为 Non-blocking，它支持面向缓冲的，基于通道的 I/O 操作方法。

通常来说 NIO 中的所有 I/O 都是从 `Channel`（通道）开始的。

- 从通道进行数据读取 ：创建一个缓冲区（`Buffer`），然后请求通道读取数据。
- 从通道进行数据写入 ：创建一个缓冲区（`Buffer`），填充数据，并要求通道写入数据。

NIO 中最核心的三个组件：

- **`Channel`（通道）**
- **`Buffer`（缓冲区）**
- **`Selector`（选择器）**

> **BIO 和 NIO**
>
> BIO 在 NIO 推出以后，已经使用 NIO 重新实现过了，大多数情况下 BIO 的性能还要更好，但是这**仅限于文件 I/O**。
>
> 在网络 I/O 中，NIO 的优势就非常大了，我们很快就会涉及到。

### 4.1 `Buffer`

`Buffer`（缓冲区） 用于和 `Channel`（通道）进行交互，**数据是从通道读入缓冲区，从缓冲区写入到通道中的**。

缓冲区本质上是**一块可以写入数据，然后可以从中读取数据的内存**，这块内存被包装成 NIO `Buffer` 对象，并提供了一组方法，用来方便的访问该块内存。

在 NIO 中，**所有数据都是用缓冲区处理的**：在读取数据时，它是直接读到缓冲区中的；在写入数据时，它也是写入到缓冲区中的。

`Buffer` 和八大基本类型中的除了 `boolean` 的其他类型是一一对应的：

- `ByteBuffer`
- `CharBuffer`
- `ShortBuffer`
- `IntBuffer`
- `LongBuffer`
- `FloatBuffer`
- `DoubleBuffer`

最常用的是 `ByteBuffer`，它表示字节缓冲区，还衍生出了 `MappedByteBuffer`、`HeapByteBuffer`、`DirectByteBuffer`，我们之后再详细讲述。

使用 `Buffer` 时有几个重要的状态变量需要关注：

- `capacity`：最大容量，一般在初始分配时就要设定好；
- `position`：当前已经读写的字节数；
- `limit`：还可以读写的字节数。
- `mark`：上一个 position 的值，默认为 -1。只有在调用 `mark` 方法后才会设置该值。

**在读取或写入过程中，一旦 position 超过了 limit，则会抛出异常**，因此一定需要注意 `Buffer` 的边界。

#### 4.1.1 构建 `Buffer`

`Buffer` 无法直接通过构造函数构造，需要使用具体 `Buffer` 提供的静态方法 `allocate` 直接分配一块内存，也可以使用 `wrap` 从一个数组构造一个 `Buffer`。

静态方法签名如下：

* `allocate(int capacity)`
* `wrap(Type[] array)`
* `wrap(Type[] array, int offset, int length)`

其中 Type 表示八大基本类型中除了 `boolean` 的其他类型。

#### 4.1.2 写入到 `Buffer` 中

如果有 `Channel`，则可以把 `Buffer` 作为 `Channel` 的 `read` 方法的参数来把数据写入到 `Buffer` 中。

如果要手动写入，则需要使用 `put` 方法，这是所有 `Buffer` 都有的方法；而 `ByteBuffer` 的特殊之处就在于它可以容纳任意类型的数据，因此还提供了 `putType` 系列方法。

示例：

```java
ByteBuffer buffer = ByteBuffer.allocate(1024);
buffer.put((byte) 126);
buffer.putInt(2137483647);
buffer.putDouble(3.14);
```

#### 4.1.3 从 `Buffer` 中读取数据

如果有 `Channel`，则可以把 `Buffer` 作为 `Channel` 的 `write` 方法的参数，此时 `Buffer` 的数据会被读取到 `Channel` 中。

如果要手动读取，则需要使用 `get` 方法，这是所有 `Buffer` 都有的方法；而 `ByteBuffer` 的特殊之处就在于它可以容纳任意类型的数据，因此还提供了 `getType` 系列方法。

示例：

```java
public class BufferDemo {
    public static void main(String[] args) {
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        buffer.put((byte) 126);
        buffer.putInt(2137483647);
        buffer.putDouble(3.14);

        buffer.flip();

        byte b = buffer.get();
        int i = buffer.getInt();
        double d = buffer.getDouble();
        System.out.println(b);
        System.out.println(i);
        System.out.println(d);
    }
}
```

#### 4.1.4 `Buffer` 中的状态变化

在上面的示例中，我们注意到了一个重要方法 **`flip`（翻转），它的作用是重置 `Buffer` 的 position 为 0，并将 limit 设置为上一个 position 的值**。

在刚才的示例中，如果我们不调用该方法，则无法读取到任何数据（读取到的全是 0），这是因为在一段写入数据之后，`Buffer` 中的 position 来到了 13 这个位置：

![image-20220312160436917](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220312160436917.png)

如果不重置 position 为 0，往后读自然读不到任何数据。

翻转以后，就可以从头开始读了，此时 limit 由 1024 变成了 13：

![image-20220312160622429](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220312160622429.png)

执行完全部的读取操作后，position 和 limit 重合，此时如果再读一个数据，就会抛出 `BufferOverflowException`。

这时再次翻转也没有用，因为 limit 还是指向 13（如果没有到 limit 就翻转，则会缩的更小），为此，还有另外一个 `Buffer limit(int newLimit)` 方法，将 limit 指向新的 limit。该方法一般配合 `int capacity()` 方法使用，该方法获取 `Buffer` 的 capacity，因此可以直接将 limit 指向到 capcity。

总结一下有关状态的方法：

获取状态：

* `int capacity()`：获取 capacity。
* `int position()`：获取当前 position。
* `int limit()`：获取当前 limit。
* `int remaining()`：获取 position 和 limit 之间的剩余字节。
* `boolean hasRemaining()`：判断 position 和 limit 之间还有没有剩余的字节。

改变状态：

* `Buffer position(int newPosition)`：将 position 置为新的 position。
* `Buffer limit(int newLimit)`：将 limit 置为新的 limit。
* `Buffer mark()`：记录 mark 为当前 position。
* `Buffer reset()`：将 position 置为 mark，如果之前从未调用过 `mark` 方法，调用此方法就会抛出异常。
* `Buffer clear()`：重置缓冲区的状态，即将 position 置为 0，将 limit 置为 capacity，并将 mark 置为 -1。注意，此方法不会将缓冲区的内容也清空。
* `Buffer rewind()`：将 position 置为 0，并将 mark 置为 -1。
* `Buffer flip()`：将 limit 设置为 position，然后将 position 置为 0，将 mark 置为 -1。

#### 4.1.5 缓冲区分片

也叫做子缓冲区，通过 `slice` 方法获取这个子缓冲区。起始位置为当前 position，结束位置为当前 limit。

注意，`slice` 返回的仅仅是一个视图，在子缓冲区上修改数据也会影响到父缓冲区。

示例：

```java
ByteBuffer buffer = ByteBuffer.allocate(10);

for (int i = 0; i < buffer.capacity(); i++) {
    buffer.put((byte)i);
}

// 创建子缓冲区
buffer.position(3);
buffer.limit(7);
ByteBuffer slice = buffer.slice();

// 改变子缓冲区内容
for (int i = 0; i <slice.capacity() ; i++) {
    byte b = slice.get(i);
    b *=10;
    slice.put(i,b);
}

buffer.position(0);
buffer.limit(buffer.capacity());

while(buffer.remaining()>0) {
    System.out.println(buffer.get());
}
```

#### 4.1.6 只读缓冲区

可以通过调用 `asReadOnlyBuffer` 方法获取一个只读的缓冲区视图。由于是只读视图，因此其他人不能通过该视图修改数据，但是原缓冲区修改了数据以后，此视图也能反映出来。

```java
ByteBuffer buffer = ByteBuffer.allocate(10);
for (int i = 0; i < buffer.capacity(); i++) {
    buffer.put((byte)i);
}
// 创建只读缓冲区
ByteBuffer readonly = buffer.asReadOnlyBuffer();
for (int i = 0; i < buffer.capacity(); i++) {
    byte b = buffer.get(i);
    b *=10;
    buffer.put(i,b);
}
readonly.position(0);
readonly.limit(buffer.capacity());
while (readonly.remaining()>0) {
    System.out.println(readonly.get());
}
```

如果尝试修改只读缓冲区的内容，则会报 `ReadOnlyBufferException` 异常。

#### 4.1.7 直接缓冲区

直接缓冲区是为加快 I/O 速度，使用一种特殊方式为其分配内存的缓冲区，JDK 文档中的描述为：给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。

也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前（或之后），尝试避免将缓冲区的内容拷贝到一个中间缓冲区中或者从一个中间缓冲区中拷贝数据。

要分配直接缓冲区，需要调用 `allocateDirect` 方法而不是 `allocate` 方法。

直接缓冲区的使用方式与普通缓冲区并无区别。

实际上，直接缓冲区的实现类是 `DirectByteBuffer`，而普通缓冲区的实现类是 `HeapByteBuffer`，在即将要介绍的 `FileChannel` 中，会看到最后一种 `ByteBuffer`，即 `MappedByteBuffer`。

### 4.2 `Channel`

通道（`Channel`）是对 BIO 中的 I/O 流的模拟，可以通过通道来读写数据。

`Channel` 其实类似于操作系统上的文件描述符，是 NIO 中被用来支持批量式 I/O 操作的一种抽象。

`File` 与 `Socket` 通常被认为是比较高层次的抽象，而 `Channel` 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。

这些不同层次的抽象是相互关联的，比如我们可以通过 `Socket` 获取 `Channel`，反之亦然。

通道与流的不同之处在于：

- **流是单向的**：一个流只能单纯的负责读或写。
- **通道是双向的**：一个通道可以同时用于读写。

NIO 中，`Channel` 有以下几个大类型：

- `FileChannel`：从文件中读写数据；
- `DatagramChannel`：通过 UDP 读写网络中数据；
- `SocketChannel`：通过 TCP 读写网络中数据；
- `ServerSocketChannel`：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 `SocketChannel`。

一般来说，`Channel` 不提供构造方法，而是通过静态方法来获取的。

要使用 `Channel`，就必须使用 `Buffer`，`Channel` 中的数据总是要先读到一个 `Buffer`，或者总是要从一个 `Buffer` 中写入。

#### 4.2.1 `FileChannel`

用于文件 I/O 的 `Channel`，对应于 BIO 中的文件流。

使用 `FileChannel` 的流程是：

1. 获取一个 `FileChannel`，并准备好一个 `Buffer`。
2. 如果要写入数据到 `FileChannel` 中，则先往 `Buffer` 中写数据，然后作为 `FileChannel` 的 `write` 方法的参数。由于无法保证一次性写入多少个字节，因此需要重复调用 `write` 直到 `Buffer` 中没有还未被写入到 `Channel` 中的字节。
3. 如果要从 `FileChannel` 中读取数据，则将 `Buffer` 作为 `FileChannel` 的 `read` 方法的参数。同样的，一次性不知道能够读取多少字节，因此需要重复调用直到该方法返回 -1，表示达到文件末尾。
   4. 关闭 `FileChannel`。

##### 获取 `FileChannel`

要获取一个 `FileChannel`，可以从一个 `FileInputStream` 或 `FileOutputStream` 调用 `getChannel` 方法得到（`RandomAccessFile` 也有 `getChannel` 方法）。

更一般的情况是，通过 `FileChannel` 提供的静态方法 `open` 来获取一个 `Channel`：

* `FileChannel open(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs)`
* `FileChannel open(Path path, OpenOption... options)`

`Path` 类代表操作系统中的路径，我们可以从其他类（如 `File`）提供的方法获取一个 `Path` 对象，比如 `File` 的 `toPath` 方法。

`OpenOptions` 是打开文件的选项，`StandardOpenOption` 枚举中定义了如下的选项：

![image-20220312170926826](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220312170926826.png)

##### 读写数据

`FileChannel` 使用 `read` 读取数据，而使用 `write` 写入数据：

* `int read(ByteBuffer dst)`：从此通道中读取一个字节序列到给定的缓冲区中，返回实际读取到的字节数，可能是 0，如果到达文件末尾，则是 -1。
* `int write(ByteBuffer src)`：从此通道中写入一个字节序列到给定的缓冲区中，返回实际写入的字节数，可能是 0。

使用示例：

```java
public class FileChannelReadDemo {
    public static void main(String[] args) throws Exception {
        RandomAccessFile file = new RandomAccessFile("temp.log", "rw");
        FileChannel channel = file.getChannel();

        ByteBuffer buf = ByteBuffer.allocate(16);

        int bytesRead;
        while ((bytesRead = channel.read(buf)) != -1) {
            System.out.println("读取了：" + bytesRead + " 个字节");

            // 将 limit 置为 position，position 置为 0
            // 从头开始读取
            buf.flip();

            // 判断有没有剩余内容
            while (buf.hasRemaining()) {
                System.out.print((char) buf.get());
            }
            System.out.println();
            buf.clear();
        }
        file.close();
    }
}
```

```java
public class FileChannelWriteDemo {
    public static void main(String[] args) throws Exception {
        RandomAccessFile file = new RandomAccessFile("temp.log", "rw");
        FileChannel channel = file.getChannel();

        ByteBuffer buffer = ByteBuffer.allocate(1024);

        String newData = "data hello world";
        buffer.clear();

        buffer.put(newData.getBytes());

        buffer.flip();

        while (buffer.hasRemaining()) {
            channel.write(buffer);
        }

        channel.close();
    }
}
```

##### 通道状态

在通道中，也有一个 position 变量记录通道当前的位置，可以使用 `long position()` 获取当前位置，也可以使用 `FileChannel position(long newPosition)` 把 position 设置为指定的值。

比如：

```java
long pos = channel.position();
channel.position(pos + 123);
```

关于设置的新位置有几个需要注意的地方：

- 如果将位置设置在文件结束符之后，然后从通道中读数据，读方法将返回 -1（文件结束标志）。
- 如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，即文件中写入的数据之间有空隙。

为了方便从某个指定的位置读写数据，`FileChannel` 还提供了重载：

* `int read(ByteBuffer dst, long position)`
* `int write(ByteBuffer src, long position)`

除了 position 之外，还可以使用 `long size()` 方法获取通道的总大小。

##### 截断文件

可以使用 `truncate` 方法可以截断一个文件：

* `FileChannel truncate(long size)`

文件中指定的 size 后的部分将被丢弃。

##### 通道间的数据传输

如果有多个通道，其中一个是 `FileChannel`，则可以从把一个通道的数据直接转移到另一个通道中。

* `long transferTo(long position, long count, WritableByteChannel target)`：把该 `FileChannel` 中的数据转移到一个可写的 `Channel`。

  可写的 `Channel` 包括：

  * `FileChannel`
  * `SocketChannel`
  * `DatagramChannel`

* `long transferFrom(ReadableByteChannel src, long position, long count)`：从可读的 `Channel` 中的数据转移到该 `FileChannel` 中。

  可读的 `Channel` 包括：

  * `FileChannel`
  * `SocketChannel`
  * `DatagramChannel`

注意，虽然三大类 `Channel` 都是可读写的，但是只有 `FileChannel` 具有转移的方法。

示例：

```java
RandomAccessFile aFile = new RandomAccessFile("1.txt","rw");
FileChannel fromChannel = aFile.getChannel();

RandomAccessFile bFile = new RandomAccessFile("2.txt","rw");
FileChannel toChannel = bFile.getChannel();

long position = 0;
long size = fromChannel.size();
toChannel.transferFrom(fromChannel, position, size);

aFile.close();
bFile.close();
```

##### 强制写入磁盘

出于性能方面的考虑，操作系统通常会将数据缓存在内存中，所以无法保证写入到 `FileChannel` 里的数据一定会即时写到磁盘上。要保证这一点，需要调用 `force` 方法。

使用该方法还有一个折中的选择，`force` 需要一个 `boolean` 的参数，表示指定是否及时更新文件元数据。

如果选择不及时更新元数据，则这样做可以及时更新磁盘上的文件，但是文件元数据可能不会及时更新，从而在性能和准确性上得到一个折中。

* `void force(boolean metaData)`

##### 文件锁

文件锁在操作系统中很常见，如果多个程序同时访问、修改同一个文件，很容易因为文件数据不同步而出现问题。

这时就需要给文件加一个锁：同一时间，只能有一个程序修改此文件，或者程序都只能读此文件，这就解决了同步问题。

**文件锁是进程级别的，不是线程级别的**。文件锁可以解决多个进程并发访问、修改同一个文件的问题，但不能解决多线程并发访问、修改同一文件的问题。使用文件锁时，同一进程内的多个线程，可以同时访问、修改此文件。

因此，文件锁是 JVM 持有的，一旦获取到文件锁，要主动调用 `release`，或者关闭对应的 `FileChannel` 对象，或者当前 JVM 退出，才会释放这个锁。

这个锁不是可重入的。

文件锁也分独占锁和共享锁。

获取锁有四种方法，和 JUC 中的 `Lock` 操作其实是类似的：

* `FileLock lock()`：阻塞的获取锁，锁住整个文件，这样获取到的锁是独占锁。
* `FileLock lock(long position, long size, boolean shared)`：阻塞的获取锁，可以只锁住文件的一部分。可以指定为获取共享锁。
* `FileLock tryLock()`：尝试获取锁（非阻塞），锁住整个文件，这样获取到的锁是独占锁。
* `FileLock tryLock(long position, long size, boolean shared)`：尝试获取锁（非阻塞），可以只锁住文件的一部分。可以指定为获取共享锁。

`FileLock` 就代表了文件锁，但是它并非基于我们熟悉的 AQS，这也和它的属性有关，AQS 只能构建线程级别的锁。

示例：

```java
public class FileLockDemo {

    public static void main(String[] args) throws Exception {
        String input = "hello";
        System.out.println("input:" + input);

        ByteBuffer buffer = ByteBuffer.wrap(input.getBytes());

        String filePath = "temp.log";
        Path path = Paths.get(filePath);

        FileChannel channel = FileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
        channel.position(channel.size() - 1);

        // 加锁
        FileLock lock = channel.lock();
        System.out.println("是否共享锁：" + lock.isShared());

        channel.write(buffer);
        channel.close();

        // 读文件
        readFile(filePath);
    }

    private static void readFile(String filePath) throws Exception {
        FileReader fileReader = new FileReader(filePath);
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        String tr = bufferedReader.readLine();
        System.out.println("读取出内容：");
        while (tr != null) {
            System.out.println(tr);
            tr = bufferedReader.readLine();
        }
        fileReader.close();
        bufferedReader.close();
    }
}
```

##### 内存映射文件 I/O

内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快的多。

内存映射文件 I/O 是通过**使文件中的数据转换为内存数组的内容**来完成的，这其初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。

**`FileChannel` 中，可以使用 `map` 方法获取一个 `MappedByteBuffer`，这个缓冲区就表示文件映射到内存中的内存数组**：

* `MappedByteBuffer map(MapMode mode, long position, long size)`

`MapMode` 是映射模式，有如下几种：

* `READ_ONLY`：只读
* `READ_WRITE`：读写
* `PRIVATE`：私有

特别注意私有模式，此时的缓冲区既可读又可写，但是仅仅是缓冲区发送变化，而文件不会有丝毫的变化。

#### 4.2.2 Scatter/Gather 机制

Scatter（分散）指的是从通道中读取到的数据被分散写入到多个 `Buffer` 中。

通道提供了这样的方法：

```java
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body = ByteBuffer.allocate(1024);
ByteBuffer[] bufferArray = { header, body };

channel.read(bufferArray);
```

而 Gather（聚集）指的是向通道中写入数据时可以把多个 `Buffer` 中的数据写入到同一个通道中。

通道也对这样的方法提供支持：

```java
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body = ByteBuffer.allocate(1024);
ByteBuffer[] bufferArray = { header, body };

channel.write(bufferArray);
```

Scatter/Gather 经常用于**需要将传输的数据分开处理**的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的缓冲区中，这样你可以方便的处理消息头和消息体。

* `long read(ByteBuffer[] dsts)`
* `long read(ByteBuffer[] dsts, int offset, int length)`
* `long write(ByteBuffer[] srcs)`
* `long write(ByteBuffer[] srcs, int offset, int length)`

实际上，**实现了 `GatheringByteChannel` 和 `ScatteringByteChannel` 的通道都具备这样的能力**。

#### 4.2.3 `SocketChannel` 和 `ServerSocketChannel`

这两个类对应于 `Socket` 和 `ServerSocket`，为 TCP 提供了支持。

`ServerSocketChannel` 允许我们监听 TCP 请求（服务端），每监听到一个请求，都创建一个 `SocketChannel` 对象从客户端读/写数据。

`SocketChannel` 则可以用于创建 TCP 客户端。

##### `ServerSocketChannel`

`ServerSocketChannel` 是一个基于通道的 socket 监听器，它和我们熟知的 `ServerSocket` 执行相同的任务，由于它基于通道，因此既可以在非阻塞模式下运行，也可以在阻塞模式下运行。

`ServerSocket` 和 `ServerSocketChannel` 可以互相转换。

使用流程：

1. 通过 `open` 方法获取一个 `ServerSocketChannel`。
2. 通过 `bind` 方法绑定一个 `SocketAddress`，此类表示一个 IP 地址 + 端口号。
3. 使用一个无限循环，在其中调用 `accept` 方法监听 TCP 请求。
4. 通过 `accept` 获取到的 `SocketChannel` 读写数据。

方法列举：

* `static ServerSocketChannel open()`
* `ServerSocketChannel bind(SocketAddress local)`
* `SocketChannel accept()`
* `ServerSocket socket()`
* `SocketAddress getLocalAddress()`

使用示例：

```java
public class ServerSocketChannelDemo {
    public static void main(String[] args) throws Exception {
        ByteBuffer buffer = ByteBuffer.allocate(1024);

        ServerSocketChannel server = ServerSocketChannel.open();
        server.bind(new InetSocketAddress(8080));
        server.configureBlocking(false);

        while (true) {
            System.out.println("Waiting for connections");
            // 非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接，返回的将是 null
            SocketChannel client = server.accept();
            if (client == null) {
                Thread.sleep(2000);
            } else {
                System.out.println("Incoming connection from: " + client.socket().getRemoteSocketAddress());
                int bytesRead;
                while ((bytesRead = client.read(buffer)) != -1) {
                    System.out.println("接收了：" + bytesRead + " 个字节");

                    buffer.flip();

                    while (buffer.hasRemaining()) {
                        System.out.print((char) buffer.get());
                    }
                    System.out.println();
                    buffer.clear();
                }
                client.close();
            }
        }
    }
}
```

##### `SocketChannel`

`SocketChannel` 是 `Socket` 对应的 `Channel`，表示 TCP 的客户端。

使用流程：

1. 通过 `open` 方法获取一个 `SocketChannel`。如果在 `open` 时未传入 IP 地址 + 端口号，即未打开连接，则之后需要打开连接。
2. 如果已打开连接，则跳到第三步；否则，调用 `bind` 或 `connect` 方法打开连接。
3. 使用 `write` 或 `read` 方法读写数据。

注意事项：

1. 对于已经存在的 `Socket` 不能再创建 `SocketChannel`。
2. 如果对一个未连接的 `SocketChannel` 进行读写，则会抛出 `NotYetConnectedException`。

3. `SocketChannel` 可以异步关闭，如果 `SocketChannel` 在一个线程上 `read` 阻塞，另一个线程对该 `SocketChannel` 调用 `shutdownInput` 方法，则读阻塞的线程将返回 -1 表示没有读取任何数据；如果 `SocketChannel` 在一个线程上 `write` 阻塞，另一个线程对该 `SocketChannel` 调用 `shutdownWrite`，则写阻塞的线程将抛出 `AsynchronousCloseException`。

`SocketChannel` 还提供了连接校验的方法，确保已经打开连接。

使用示例：

```java
public class SocketChannelDemo {
    public static void main(String[] args) throws IOException {
        SocketChannel sc = SocketChannel.open(new InetSocketAddress("localhost", 8080));
        sc.configureBlocking(false);

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        buffer.put("hello world".getBytes());
        buffer.flip();
        while (buffer.hasRemaining()) {
            sc.write(buffer);
        }

        sc.close();
    }
}
```

#### 4.2.5 `DatagramChannel`

类似于 `DatagramSocket`，对 UDP 提供了支持。

正如 `SocketChannel` 对应 `Socket`，`ServerSocketChannel` 对应 `ServerSocket`，每一个 `DatagramChannel` 对象也有一个关联的 `DatagramSocket` 对象。

使用示例：

```java
public class DatagramChannelDemo {
    public static void main(String[] args) throws Exception {
        new Thread(() -> {
            try {
                sendDatagram();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
        new Thread(() -> {
            try {
                receiveDatagram();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }

    public static void receiveDatagram() throws Exception {
        DatagramChannel receiveChannel = DatagramChannel.open();
        InetSocketAddress receiveAddress = new InetSocketAddress(9999);
        receiveChannel.bind(receiveAddress);

        ByteBuffer receiveBuffer = ByteBuffer.allocate(1024);

        while (true) {
            receiveBuffer.clear();
            SocketAddress socketAddress = receiveChannel.receive(receiveBuffer);
            receiveBuffer.flip();

            System.out.println(socketAddress.toString());
            System.out.println(StandardCharsets.UTF_8.decode(receiveBuffer));
        }
    }

    public static void sendDatagram() throws Exception {
        DatagramChannel sendChannel = DatagramChannel.open();
        InetSocketAddress sendAddress = new InetSocketAddress("127.0.0.1", 9999);

        while (true) {
            ByteBuffer buffer = ByteBuffer.wrap("hello from send thread".getBytes(StandardCharsets.UTF_8));
            sendChannel.send(buffer, sendAddress);
            System.out.println("已经完成发送");
            Thread.sleep(1000);
        }
    }
}
```

### 4.3 `Selector`

`Selector` 一般指选择器，也被叫做多路复用器，可以说它才是 NIO 的灵魂，它检查一个或多个 `Channel` 的状态。

`Channel` 和 `Selector` 一起实现了 I/O 多路复用中的 Reactor 模型：

- 一个线程（`Thread`）使用一个**选择器 `Selector` 通过轮询的方式去监听多个通道 `Channel` 上的事件（`accpet`、`read`）**，如果某个 `Channel` 上面发生监听事件，这个 `Channel` 就处于就绪状态，然后进行 I/O 操作。
- 通过**配置监听的通道 `Channel` 为非阻塞**，那么当 `Channel` 上的 I/O 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 `Channel`，找到 I/O 事件已经到达的 `Channel` 执行。
- 因为创建和切换线程的开销很大，因此使用**一个线程来处理多个事件**而不是一个线程处理一个事件具有更好的性能。

#### 4.3.1 `SelectableChannel`

不是所有 `Channel` 都能被 `Selector` 监听，比如 `FileChannel` 就不能。

要判断一个 `Channel` 能否被 `Selector` 复用，则可以看它**是否继承了 `SelectableChannel`**。

一个可选择的通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。在注册的时候，需要指定通道的哪些操作是 `Selector` 感兴趣的。

注意，通道必须被设置为非阻塞的，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。

`SelectableChannel` 提供了 `regisiter` 方法用于注册一个 `Channel` 到 `Selector`：

* `SelectionKey register(Selector sel, int ops)`

* `SelectionKey register(Selector sel, int ops, Object att)`

ops 表示可以供选择器查询的通道操作，指定操作就表示使用者关注这些操作。

操作包括以下四种：

- 可读 : `SelectionKey.OP_READ`
- 可写 : `SelectionKey.OP_WRITE`
- 连接 : `SelectionKey.OP_CONNECT`
- 接收 : `SelectionKey.OP_ACCEPT`

这些操作都只是把二进制位置位，因此可以使用 `|` 将它们组合起来。

#### 4.3.2 `SelectionKey`

`SelectionKey` 表示 `SelectableChannel` 向 `Selector` 注册的令牌，注册完成以后，会得到这个令牌。

选择器会不断地查询注册成功的 `Channel` 的状态，并且只查询注册时声明的操作，一旦就绪，就会被 `Selector` 选择，然后放入一个集合中。

`SelectionKey` 更类似于事件，但是由于不是被动触发，因此不把它叫做事件。

#### 4.3.3 选择器的基本使用

使用步骤如下

1. 通过静态 `open` 方法可以打开一个选择器：
   * `static Selector open()`
2. 注册非阻塞的通道到选择器中，并指定 `Selector` 要关注该通道的哪些操作。
3. 循环调用 `select` 方法获取准备好的 `SelectionKey` 的数目，检测通道的就绪状况。`select` 方法会阻塞直到有通道准备好。
   * `int select()`
   * `int select(long timeout)`：定时版 `select`
   * `int selectNow()`：非阻塞版 `select`
   * `Selector wakeup()`：使前一个未返回的 `select` 立即返回
4. 一旦进入循环，就调用 `selectKeys` 方法获取就绪集合。
   * `Set<SelectionKey> selectedKeys()`
5. 遍历就绪集合，通过判断方法来判断 `SelectionKey` 处于何种状态，然后根据业务逻辑处理状态即可。
6. 不需要选择器时，关闭它，此时所有的 `Channel` 将被注销，所有阻塞的线程会被唤醒。

使用示例：

```java
public class SelectorDemo {
    public static void serverDemo() throws Exception {
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.configureBlocking(false);
        serverSocketChannel.bind(new InetSocketAddress(8080));
        Selector selector = Selector.open();
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        while (selector.select() > 0) {
            Set<SelectionKey> selectionKeys = selector.selectedKeys();
            Iterator<SelectionKey> selectionKeyIterator = selectionKeys.iterator();
            while (selectionKeyIterator.hasNext()) {
                SelectionKey next = selectionKeyIterator.next();
                if (next.isAcceptable()) {
                    SocketChannel accept = serverSocketChannel.accept();
                    accept.configureBlocking(false);
                    accept.register(selector, SelectionKey.OP_READ);
                } else if (next.isReadable()) {
                    SocketChannel channel = (SocketChannel) next.channel();
                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                    int length;
                    while ((length = channel.read(byteBuffer)) > 0) {
                        byteBuffer.flip();
                        System.out.println(new String(byteBuffer.array(), 0, length));
                        byteBuffer.clear();
                    }
                }
                selectionKeyIterator.remove();
            }
        }
    }

    public static void clientDemo() throws Exception {
        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 8080));
        socketChannel.configureBlocking(false);
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        byteBuffer.put(new Date().toString().getBytes());
        byteBuffer.flip();
        socketChannel.write(byteBuffer);
        byteBuffer.clear();
    }

    public static void main(String[] args) throws IOException {
        new Thread(() -> {
            try {
                serverDemo();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(() -> {
            try {
                clientDemo();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

### 4.4 `Pipe`

NIO 中的管道是 2 个线程之间的单向数据连接。

`Pipe` 有一个 source 通道和一个 sink 通道，数据会被写到 sink 通道，从 source 通道读取。

![image-20220313231337885](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220313231337885.png)

使用步骤：

1. 通过 `Pipe.open()` 方法打开管道。
2. 通过 `sink()` 方法获取 sink 通道，然后通过该通道的 `write` 方法写入数据。
3. 通过 `source()` 方法获取 source 通道，然后通过该通道的 `read` 方法读取数据。

示例：

```java
public class PipeDemo {
    public static void main(String[] args) throws IOException {
        Pipe pipe = Pipe.open();

        Pipe.SinkChannel sinkChannel = pipe.sink();

        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        byteBuffer.put("hello".getBytes());
        byteBuffer.flip();

        sinkChannel.write(byteBuffer);

        Pipe.SourceChannel sourceChannel = pipe.source();

        ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);
        int length = sourceChannel.read(byteBuffer2);
        System.out.println(new String(byteBuffer2.array(),0,length));

        sourceChannel.close();
        sinkChannel.close();
    }
}
```

### 4.5 AIO

在 JDK 7 时，NIO 添加了 `AsynchronousChannel`，也就是异步通道，提供了对 AIO（异步 I/O）的基本支持。

`AsyncronousChannel` 的实现类有三种：

* `AsynchronousFileChannel`：异步文件通道
* `AsynchronousServerSocketChannel`：异步 TCP 服务端套接字通道
* `AsynchronousSocketChannel`：异步 TCP 客户端套接字通道

通道的使用方式和之前讲过的类似，但是由于是异步，因此在读取和写入方面和普通 NIO 有所差别。

#### 4.5.1 使用 `Future`

`Future` 是线程池三大组件中的一种，表示线程异步执行的结果。

在 AIO 通道中，提供了 `write` 以及 `read` 的重载版本，返回一个 `Future`。

* `Future<Integer> read(ByteBuffer dst)`
* `Future<Integer> write(ByteBuffer src)`

注意到这个 `Future` 的泛型是 `Integer`，它表示读取/写入的字节数。

示例：

```java
public void writeAsyncFileFuture() throws IOException {
    Path path = Paths.get("temp.log");
    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);

    ByteBuffer buffer = ByteBuffer.allocate(1024);

    buffer.put("hello ".getBytes());
    buffer.flip();
    Future<Integer> future = fileChannel.write(buffer, 0);

    while(!future.isDone());

    buffer.clear();
}
```

```java
public void readAsyncFileChannelFuture() throws Exception {
    Path path = Paths.get("temp.log");
    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);
    
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    
    Future<Integer> future = fileChannel.read(buffer, 0);
    while(!future.isDone());
    
    buffer.flip();
    
    byte[] data = new byte[buffer.limit()];
    buffer.get(data);
    System.out.println(new String(data));
    buffer.clear();
}
```

#### 4.5.2 使用 `CompletionHandler`

`CompletionHandler<V, A>` 是定义在 NIO 包中的，使用异步 I/O 操作结果的处理程序。

泛型 V 表示 I/O 的结果，一般是 `Integer`，表示 I/O 的字节数；A 表示附加到 I/O 的对象类型，一般是 `Buffer`。

它的定义如下：

```java
public interface CompletionHandler<V,A> {
    void completed(V result, A attachment);

    void failed(Throwable exc, A attachment);
}
```

当 I/O 完成时，会回调 `completed` 方法，失败时会回调 `failed` 方法。

示例：

```java
public void readAsyncFileChannelComplate() throws Exception {
    Path path = Paths.get("temp.log");
    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);

    ByteBuffer buffer = ByteBuffer.allocate(1024);

    fileChannel.read(buffer, 0, buffer, new CompletionHandler<Integer, ByteBuffer>() {
        @Override
        public void completed(Integer result, ByteBuffer attachment) {
            System.out.println("result: " + result);
            attachment.flip();
            byte[] data = new byte[attachment.limit()];
            attachment.get(data);
            System.out.println(new String(data));
            attachment.clear();
        }

        @Override
        public void failed(Throwable exc, ByteBuffer attachment) {
			System.out.println("Error!");
        }
    });
}
```

```java
public void writeAsyncFileComplate() throws IOException {
    Path path = Paths.get("temp.log");
    AsynchronousFileChannel fileChannel =
            AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);

    ByteBuffer buffer = ByteBuffer.allocate(1024);

    buffer.put("hellohello".getBytes());
    buffer.flip();

    fileChannel.write(buffer, 0, buffer, new CompletionHandler<Integer, ByteBuffer>() {
        @Override
        public void completed(Integer result, ByteBuffer attachment) {
            System.out.println("bytes written: " + result);
        }

        @Override
        public void failed(Throwable exc, ByteBuffer attachment) {
			System.out.println("Error!");
        }
    });
}
```

## 5. NIO 和 BIO 的对比

BIO 与 NIO 最重要的区别是数据打包和传输的方式：**BIO 以流的方式处理数据，而 NIO 以块的方式处理数据**。

- **面向流的 BIO 一次处理一个字节数据**：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。
- **面向块的 NIO 一次处理一个数据块**：按块处理数据比按流处理数据要快得多。但是面向块的 NIO 缺少一些面向流的 BIO 所具有的优雅性和简单性。

BIO 模式：

![image-20220313231229544](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220313231229544.png)

NIO 模式：

![image-20220313231250871](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220313231250871.png)	