# Redis 内存淘汰

- **最大缓存** - Redis 允许通过 `maxmemory` 参数来设置内存最大值。
- **失效时间** - 作为一种定期清理无效数据的重要机制，在 Redis 提供的诸多命令中，`EXPIRE`、`EXPIREAT`、`PEXPIRE`、`PEXPIREAT` 以及 `SETEX` 和 `PSETEX` 均可以用来设置一条键值对的失效时间。而一条键值对一旦被关联了失效时间就会在到期后自动删除（或者说变得无法访问更为准确）。
- **淘汰策略** - 随着不断的向 Redis 中保存数据，当内存剩余空间无法满足添加的数据时，Redis 内就会施行数据淘汰策略，清除一部分内容然后保证新的数据可以保存到内存中。内存淘汰机制是为了更好的使用内存，用一定得 miss 来换取内存的利用率，保证 Redis 缓存中保存的都是热点数据。
- **非精准的 LRU** - 实际上 Redis 实现的 LRU 并不是可靠的 LRU，也就是名义上我们使用 LRU 算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的。

## 过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

可以使用 `EXPIRE` 或 `EXPIREAT` 来为 key 设置过期时间。

## 过期策略

### 定期删除

Redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。

Redis 默认会每秒进行十次过期扫描（100ms 一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。

1. 从过期字典中随机 20 个 key；
2. 删除这 20 个 key 中已经过期的 key；
3. 如果过期的 key 比率超过 1/4，那就重复步骤 1；

Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 Redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。

### 惰性删除

所谓惰性策略就是在客户端访问这个 key 的时候，Redis 对 key 的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。

定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被 Redis 给删除掉。这就是所谓的惰性删除，即当你主动去查过期的 key 时，如果发现 key 过期了，就立即进行删除，不返回任何东西。	

## 淘汰策略

不管是定期删除还是惰性删除都不是一种完全精准的删除，就还是会存在 key 没有被删除掉的场景，所以就需要内存淘汰策略进行补充。而且，Redis 所占的内存不能超过阈值，必须淘汰某些 key 为新的 key 腾出空间。

内存淘汰只是 Redis 提供的一个功能，为了更好地实现这个功能，必须为不同的应用场景提供不同的策略，内存淘汰策略讲的是为实现内存淘汰我们具体怎么做，要解决的问题包括淘汰键空间如何选择？在键空间中淘汰键如何选择？

Redis 提供了下面几种内存淘汰策略供用户选择：

- **`noeviction`**：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。
- **`allkeys-lru`**：在主键空间中，优先移除最近未使用的 key。
- **`allkeys-random`**：在主键空间中，随机移除某个 key。
- **`volatile-lru`**：在设置了过期时间的键空间中，优先移除最近未使用的 key。
- **`volatile-random`**：在设置了过期时间的键空间中，随机移除某个 key。
- **`volatile-ttl`**：在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。

## 如何选择淘汰策略

- 如果**数据呈现幂等分布（存在热点数据，部分数据访问频率高，部分数据访问频率低），则使用 `allkeys-lru`**。
- 如果**数据呈现平等分布（数据访问频率大致相同），则使用 `allkeys-random`**。
- 如果希望**使用不同的 TTL 值向 Redis 提示哪些 key 更适合被淘汰，请使用 `volatile-ttl`**。
- **`volatile-lru` 和 `volatile-random` 适合既应用于缓存和又应用于持久化存储的场景**，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。
- **将 key 设置过期时间实际上会消耗更多的内存，因此建议使用 `allkeys-lru` 策略从而更有效率的使用内存**。