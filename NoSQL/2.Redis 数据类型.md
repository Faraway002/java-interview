# Redis 数据类型

Redis 有五种基本数据类型：

* String
* Hash
* List
* Set
* Zset

| 结构类型 | 结构存储的值                               | 结构的读写能力                                               |
| -------- | ------------------------------------------ | ------------------------------------------------------------ |
| String   | 可以是字符串、整数或浮点数                 | 对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作； |
| List     | 一个链表，链表上的每个节点都包含一个字符串 | 对链表的两端进行 push 和 pop 操作，读取单个或多个元素；根据值查找或删除元素； |
| Set      | 包含字符串的无序集合                       | 字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等 |
| Hash     | 包含键值对的无序散列表                     | 包含方法有添加、获取、删除单个元素                           |
| Zset     | 和散列一样，用于存储键值对                 | 字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素 |

除了这些之外，还有三种高级数据类型：

* Bitmap
* HyperLogLog
* GEO

对 Redis 来说，**所有的 key 都是字符串**，我们在谈数据结构时，讨论的是存储值的数据类型。

在介绍数据类型之前，首先介绍一下 Redis 的 DB 是如何实现的。

## KV 数据库的原理

Redis 是使用了一个**哈希表**保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。

哈希桶存放的是指向键值对数据的指针，这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 `void* key` 和 `void* value` 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 `void* value` 指针找到：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/f302fce6c92c0682024f47bf7579b44c.png)

最核心的结构就是 `dictEntry`，表示哈希表节点，结构里存放了 `void* key` 和 `void* value` 指针，**key 指向的是 String 对象，而 value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象**。

特别说明下，`void* key` 和 `void* value` 指针指向的是 **Redis 对象**，Redis 中的每个对象都由 redisObject 结构表示：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/58d3987af2af868dca965193fb27c464.png)

key 的 redisObject 的 prt 指针始终指向字符串，也就是 SDS。

## 基本数据类型

### String

String 是 Redis 中最基本的数据类型，一个 key 对应一个 value。

String 类型是二进制安全的，意思是 Redis 的 String 可以包含任何数据，如数字，字符串，图片或者序列化的对象。 

常用命令表如下：

| 命令   | 简述                   | 使用              |
| ------ | ---------------------- | ----------------- |
| GET    | 获取存储在给定键中的值 | GET name          |
| SET    | 设置存储在给定键中的值 | SET name value    |
| DEL    | 删除存储在给定键中的值 | DEL name          |
| INCR   | 将键存储的值加1        | INCR key          |
| DECR   | 将键存储的值减1        | DECR key          |
| INCRBY | 将键存储的值加上整数   | INCRBY key amount |
| DECRBY | 将键存储的值减去整数   | DECRBY key amount |

应用场景：

* **缓存**： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到 Redis 中，Redis 作为缓存层，MySQL 做持久化层，降低 MySQL 的读写压力。
* **计数器**：Redis 是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。
* **Session**：常见方案 Spring Session + Redis 实现 Session 共享

#### 简单动态字符串

Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 `char*` 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（Simple Dynamic String，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。

C 语言字符串结构如下：

![image-20220402210636396](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220402210636396.png)

在 C 语言里，对字符串操作时，`char*` 指针只是指向字符数组的起始位置，而**字符数组的结尾位置就用 `\0` 表示，意思是指字符串的结束**。

因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 `\0` 来决定要不要停止操作。

C 语言字符串用 `\0` 字符作为结尾标记有个缺陷。假设有个字符串中有个 `\0` 字符，这时在操作这个字符串时就会**提早结束**。这个限制使得 C 语言的字符串只能保存文本数据，**不能保存像图片、音频、视频文化这样的二进制数据**。

除此之外，C 语言的字符串还有以下缺点：

- 获取字符串长度的时间复杂度为 O（N）
- 字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止

SDS 解决了上面的缺点，数据结构如下图所示：

![image-20220402210913417](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220402210913417.png)

结构中的每个成员变量分别介绍下：

- **`len`，记录了字符串长度**。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。
- **`alloc`，分配给字符数组的空间长度**。这样在修改字符串的时候，可以通过 `alloc - len` 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。
- **`flags`，用来表示不同类型的 SDS**。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面再说明区别。
- **`buf[]`，字符数组，用来保存实际数据**。不仅可以保存字符串，也可以保存二进制数据。

flags 表示类型，这五种类型的主要区别在于**它们数据结构中的 len 和 alloc 成员变量的数据类型不同**。

比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：

```c
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;
    uint16_t alloc; 
    unsigned char flags; 
    char buf[];
};


struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;
    uint32_t alloc; 
    unsigned char flags;
    char buf[];
};
```

- sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。
- sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。

**之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间**。

除了设计不同类型的结构体，Redis 在编程上还**使用了专门的编译优化来节省内存空间**，即在 struct 声明了 `__attribute__ ((packed))` ，它的作用是：**告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐**。

### List

使用 List 结构，我们可以轻松地实现最新消息排队功能。List 的另一个应用就是消息队列，可以利用 List 的 PUSH 操作，将任务存放在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。

常用命令表如下：

| 命令   | 简述                                                         | 使用            |
| ------ | ------------------------------------------------------------ | --------------- |
| RPUSH  | 将给定值推入到列表右端                                       | RPUSH key value |
| LPUSH  | 将给定值推入到列表左端                                       | LPUSH key value |
| RPOP   | 从列表的右端弹出一个值，并返回被弹出的值                     | RPOP key        |
| LPOP   | 从列表的左端弹出一个值，并返回被弹出的值                     | LPOP key        |
| LRANGE | 获取列表在给定范围上的所有值                                 | LRANGE key 0 -1 |
| LINDEX | 通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 | LINEX key index |

使用列表的技巧

- lpush + lpop = 栈
- lpush + rpop = 队列
- lpush + brpop = 消息队列

> brpop 是阻塞版的 rpop

#### 双向链表

List 由链表实现。

```c
typedef struct listNode {
    //前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
} listNode;
```

这是一个**双向链表**：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/4fecbf7f63c73ec284a4821e0bfe2843.png)

Redis 在 `listNode` 结构体基础上又封装了 `list` 这个数据结构，这样操作起来会更方便，链表结构如下：

```c
typedef struct list {
    //链表头节点
    listNode *head;
    //链表尾节点
    listNode *tail;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值比较函数
    int (*match)(void *ptr, void *key);
    //链表节点数量
    unsigned long len;
} list;
```

Redis 的链表实现优点如下：

- listNode 链表节点的结构里带有 prev 和 next 指针，**获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表**；
- list 结构因为提供了表头指针 head 和表尾节点 tail，所以**获取链表的表头节点和表尾节点的时间复杂度只需O(1)**；
- list 结构因为提供了链表节点数量 len，所以**获取链表中的节点数量的时间复杂度只需O(1)**；
- listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此**链表节点可以保存各种不同类型的值**；

链表的缺陷也是有的：

- 链表每个节点之间的内存都是不连续的，意味着**无法很好利用 CPU 缓存**。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。
- 还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，**内存开销较大**。

因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用**压缩列表**作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。

不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 `quicklist`，并将 List 对象的底层数据结构改由 `quicklist` 实现。

然后在 Redis 5.0 设计了新的数据结构 `listpack`，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 `listpack` 实现。

#### 压缩列表

压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。

但是，压缩列表的缺陷也是有的：

- 不能保存过多的元素，否则查询效率就会降低；
- 新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。

所以，当 List、Hash 和 Zset 包含的元素**数量较少**，或者元素**值不大的**情况才会使用压缩列表作为底层数据结构。

压缩列表是 Redis 为了节约内存而开发的，它是**由连续内存块组成的顺序型数据结构**，有点类似于数组。

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/ab0b44f557f8b5bc7acb3a53d43ebfcb.png)

压缩列表在表头有三个字段：

- **zlbytes**，记录整个压缩列表**占用的字节数**；
- **zltail**，记录压缩列表尾部节点距离起始地址由多少字节，也就是**列表尾的偏移量**；
- **zllen**，记录压缩列表**包含的节点数量**；
- **zlend**，标记压缩列表的结束点，固定值 0xFF（十进制255）。

在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而**查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素**。

另外，压缩列表节点（entry）的构成如下：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/a3b1f6235cf0587115b21312fe60289c.png)

压缩列表节点包含三部分内容：

- **prevlen**，记录了「前一个节点」的长度；
- **encoding**，记录了当前节点实际数据的类型以及长度；
- **data**，记录了当前节点的实际数据；

当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，**这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的**。

分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。

压缩列表里的每个节点中的 prevlen 属性都记录了前一个节点的长度，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：

- 如果**前一个节点的长度小于 254 字节**，那么 prevlen 属性需要用 **1 字节的空间**来保存这个长度值；
- 如果**前一个节点的长度大于等于 254 字节**，那么 prevlen 属性需要用 **5 字节的空间**来保存这个长度值；

encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关：

- 如果**当前节点的数据是整数**，则 encoding 会使用 **1 字节的空间**进行编码。
- 如果**当前节点的数据是字符串，根据字符串的长度大小**，encoding 会使用 **1 字节/2字节/5字节的空间**进行编码。

### Set

Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。

常用命令表如下：

| 命令      | 简述                                  | 使用                 |
| --------- | ------------------------------------- | -------------------- |
| SADD      | 向集合添加一个或多个成员              | SADD key value       |
| SCARD     | 获取集合的成员数                      | SCARD key            |
| SMEMBER   | 返回集合中的所有成员                  | SMEMBER key member   |
| SISMEMBER | 判断 member 元素是否是集合 key 的成员 | SISMEMBER key member |

实战场景

- **标签**（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。
- **点赞，或点踩，收藏等**，可以放到 Set 中实现

Set 的底层实现有即将介绍的哈希表，也有整数集合。

#### 整数集合

当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。

整数集合本质上是一块连续内存空间，它的结构定义如下：

```c
typedef struct intset {
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组
    int8_t contents[];
} intset;
```

可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如：

- 如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每一个元素的类型都是 int16_t；
- 如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每一个元素的类型都是 int32_t；
- 如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每一个元素的类型都是 int64_t；

不同类型的 contents 数组，意味着数组的大小也会不同。

整数集合还有一个升级操作，就是**当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级**，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。

扩容过程示例如下：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/e84b052381e240eeb8cc97d6b729968b.png)

**一旦对数组进行了升级，就会一直保持升级后的状态。**

### Hash

Hash 就是我们熟知的哈希表。

常用命令表如下：

| 命令    | 简述                                     | 使用                          |
| ------- | ---------------------------------------- | ----------------------------- |
| HSET    | 添加键值对                               | HSET hash-key sub-key1 value1 |
| HGET    | 获取指定散列键的值                       | HGET hash-key key1            |
| HGETALL | 获取散列中包含的所有键值对               | HGETALL hash-key              |
| HDEL    | 如果给定键存在于散列中，那么就移除这个键 | HDEL hash-key sub-key1        |

#### 哈希表

Hash 和 Set 底层都是使用了哈希表，哈希表的原理我们就不再叙述了，要知道的是 Redis 的哈希表使用了拉链法解决哈希冲突。

Redis 的哈希表结构如下：

```c
typedef struct dictht {
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;  
    //哈希表大小掩码，用于计算索引值
    unsigned long sizemask;
    //该哈希表已有的节点数量
    unsigned long used;
} dictht;
```

哈希表的桶是 `dictEntry`：

```c
typedef struct dictEntry {
    //键值对中的键
    void *key;
  
    //键值对中的值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    //指向下一个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

dictEntry 结构里键值对中的值是一个**联合**体 v 定义的，因此，键值对中的值可以是一个指向实际值的指针，或者是一个无符号的 64 位整数或有符号的 64 位整数或 double 类的值。这么做的好处是可以节省内存空间，因为当值是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。

### Zset

Redis 有序集合和集合一样也是 string 类型元素的集合，且不允许重复的成员，不同的是**每个元素都会关联一个 double 类型的分数**，Redis 正是通过分数来为集合中的成员进行从小到大的排序。

常用命令表：

| 命令   | 简述                                                     | 使用                           |
| ------ | -------------------------------------------------------- | ------------------------------ |
| ZADD   | 将一个带有给定分值的成员添加到哦有序集合里面             | ZADD zset-key 178 member1      |
| ZRANGE | 根据元素在有序集合中所处的位置，从有序集合中获取多个元素 | ZRANGE zset-key 0-1 withccores |
| ZREM   | 如果给定元素成员存在于有序集合中，那么就移除这个元素     | ZREM zset-key member1          |

实战场景

- **排行榜**：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。

#### 跳表

Redis 只有在 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。

Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。

```c
typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```

Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。

**跳表是在链表基础上改进过来的，实现了一种多层的有序链表**，这样的好处是能快读定位数据。

那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/2ae0ed790c7e7403f215acb2bd82e884.png)

跳表节点如下：

```c
typedef struct zskiplistNode {
    //Zset 对象的元素值
    sds ele;
    //元素权重值
    double score;
    //后向指针
    struct zskiplistNode *backward;
  
    //节点的level数组，保存每层上的前向指针和跨度
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;
```

Zset 对象要同时保存元素和元素的权重，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。每个跳表节点都有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。

跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的 **zskiplistLevel 结构体类型的 level 数组**。

跨度的作用如下：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/a5b6512be0da36f87c5d906cc278526c.png)

**跨度实际上是为了计算这个节点在跳表中的排位**。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。

跳表结构体如下：

```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```

## 特殊类型

