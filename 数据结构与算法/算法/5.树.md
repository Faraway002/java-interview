# 树

## 二叉树

### 基础

二叉树（递归）解题的思维模式分两类：

1. **是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫遍历的思维模式**。

   这种思维模式也对应**回溯法**的思维模式。

2. **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫分解问题的思维模式。

   这种思维模式也对应**动态规划**的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

注意二叉树的三种遍历方式，**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

* 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
* 后序位置的代码在将要离开一个二叉树节点的时候执行；
* 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作**。

后序遍历的位置是很特殊的，**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

**换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。

#### 力扣 104 二叉树的最大深度

![image-20220410095235374](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220410095235374.png)

* 遍历的思路：使用一个全局变量记录达到的最大深度。

  ```java
  private int curDepth = 0;
  private int maxDepth = 0;
  
  public int maxDepth(TreeNode root) {
      traverse(root);
      return maxDepth;
  }
  
  private void traverse(TreeNode root) {
      if (root == null) {
          maxDepth = Math.max(curDepth, maxDepth);
          return;
      }
      
      curDepth++;
      traverse(root.left);
      traverse(root.right);
      curDepth--;
  }
  ```

* 子问题的思路：求出左右子树的最大深度，然后取其中一方最大的 + 1。

  ```java
  public int maxDepth(TreeNode root) {
      if (root == null) {
          return 0;
      }
      
      int ld = maxDepth(root.left);
      int rd = maxDepth(root.right);
      
      return ld > rd ? ld + 1 : rd + 1;
  }
  ```

#### 力扣 543 二叉树的直径

![image-20220410100243101](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220410100243101.png)

二叉树的直径定义为任意两个节点之间的边数，可以经过根也可以不经过根。

要求最大的直径，我们可以像求最大深度一样，求出每个节点的左子树的最大深度和右子树的最大深度，然后相加，用一个变量记录即可。

这里最好是后序遍历，因为后序位置能够接收到返回值。

```java
private int ans;

public int diameterOfBinaryTree(TreeNode root) {
    traverse(root);
    return ans;
}

public int traverse(TreeNode root) {
    if (root == null) {
        return 0;
    }
    
    int ld = traverse(root.left);
    int rd = tarverse(root.right);
    
    ans = Math.max(ld + rd, ans);
    
    return ld > rd ? ld + 1 : rd + 1;
}
```

#### 力扣 226 翻转二叉树

![image-20220411195647122](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411195647122.png)

从遍历的角度，遍历每一个节点，交换其左右子树即可：

```java
public TreeNode invertTree(TreeNode root) {
	traverse(root);
    
    return root;
}

private void traverse(TreeNode root) {
    if (root == null) {
        return;
    }

    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;

    invertTree(root.left);
    invertTree(root.right);
}
```

从递归的角度，先翻转好左右子树，然后交换左右子树即可：

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    root.left = right;
    root.right = left;

    return root;
}
```

#### 力扣 100 相同的树

![image-20220411203617431](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411203617431.png)

本题不是一棵树，是两棵树的比较，但是也是使用递归的思想，需要考虑节点是否为空：

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    
    if (p == null || q == null) {
        return false;
    }
    
    if (p.val != q.val) {
        return false;
    }
    
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

#### 力扣 101 对称二叉树

![image-20220411203321481](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411203321481.png)

本题和上一题类似的，最后递归比较的是一棵树的左子树和另一棵树的右子树：

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }

    return compare(root.left, root.right);
}

private boolean compare(TreeNode p, TreeNode q) {
    if (p != null || q != null) {
        return false;
    }

    if (p == null && q == null) {
        return true;
    }

    if (p.val != q.val) {
        return false;
    }

    return compare(p.left, q.right) && compare(p.right, q.left);
}
```

#### 力扣 111 二叉树的最小深度

![image-20220411210743989](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411210743989.png)

这题看似和 104 相似，但是有一个最大的区别，就是**最小深度的路径上一定要有一个叶子节点**，也就是至少都为 1，因此如果根节点没有左孩子，但是有右孩子的话，就只能取右孩子的深度：

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    
    if (root.left == null && root.right != null) {
        return 1 + minDepth(root.right);
    }
    
    if (root.right == null && root.left != null) {
        return 1 + minDepth(root.left);
    }
    
    return Math.min(minDepth(root.left) + 1, minDepth(root.right) + 1);
} 
```

#### 力扣 222 完全二叉树的节点个数

![image-20220411211123071](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411211123071.png)

本题可以使用一般二叉树求节点个数的方法，先求左子树节点个数，再求右子树节点个数，然后加起来 + 1 即可：

```java
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

但是本题是完全二叉树，完全二叉树的特点就是最后一层之前的每一层都是满的，最后一层是从左到右摆的，因此可以利用这个特性。

首先求根节点的左右子树高度，如果相等，说明至少左子树满了；否则说明至少右子树满了：

```java
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int lh = getHeight(root.left);
    int rh = getHeight(root.right);

    // 左右高度相等，说明至少左子树满了；不等则说明至少右子树满了
    if (lh == rh) {
        return (1 << lh) + countNodes(root.right);
    } else {
        return (1 << rh) + countNodes(root.left);
    }
}

private int getHeight(TreeNode root) {
    int ans = 0;
    while (root != null) {
        ans++;
        root = root.left;
    }
    return ans;
}
```

#### 力扣 114 二叉树展开为链表

![image-20220411212246743](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411212246743.png)

本题需要原地连接，因为给定的函数没有返回值。

如果可以使用额外空间的话，使用遍历的思想，那么我们只要设置一个全局的虚拟头节点，然后在前序的位置把链表头的右指针指向 root，就可以了；

```java
TreeNode dummy = new TreeNode(-1);

TreeNode p = dummy;

public void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    p.right = new TreeNode(root.val);
    p = p.right;

    traverse(root.left);
    traverse(root.right);
}
```

可惜，本题需要原地连接，这时就需要递归的思想：

首先把左子树拉成链表，然后把右子树拉成链表，现在头节点的左右指针分别指向了两个链表，先用一个指针记录头节点的右边，然后把头节点的右指针指向头节点的左边；最后从头节点右边遍历到底部，接上刚刚记录的右边即可：

```java
public void flatten(TreeNode root) {
    if (root == null) {
        return;
    }

    flatten(root.left);
    flatten(root.right);

    TreeNode r = root.right;
    root.right = root.left;
    root.left = null;

    TreeNode p = root;
    while (p.right != null) {
        p = p.right;
    }

    p.right = r;
}
```

### 构造二叉树专题

二叉树如果知道前序和中序，或者后序和中序的遍历序列，是可以还原出一棵独一无二的二叉树的，这是因为这两个组合都可以唯一确定根节点。

但是，后序和前序遍历虽然可以确定根节点，但是你无法确定左右子树到底有哪些节点，可能会有多种情况。

对于构造二叉树来说，一般都采用递归的思想，即先构造根节点，然后构造左子树，最后构造右子树。

#### 力扣 105 从前序和中序遍历序列构造二叉树

![image-20220411213736604](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411213736604.png)

知道前序和中序该怎么还原二叉树呢？实际上，前序序列的第一个一定是根节点，而中序序列的根节点是在中间遍历到的，因此中序序列根节点的左边部分就是左子树，右边部分就是右子树。

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null || preorder.length == 0) {
        return null;
    }

    if (inorder == null || inorder.length == 0) {
        return null;
    }

    // 构造根节点
    TreeNode root = new TreeNode(preorder[0]);

    // 在中序遍历中找到根节点的位置
    int leftIndex = -1;
    for (int i = 0; i < inorder.length; i++) {
        if (inorder[i] == root.val) {
            leftIndex = i;
            break;
        }
    }

    // 分割中序序列为左右子树的中序序列
    int[] leftInorder = Arrays.copyOfRange(inorder, 0, leftIndex);
    int[] rightInorder = Arrays.copyOfRange(inorder, leftIndex + 1, inorder.length);
    // 分割前序序列为左右子树的前序序列（长度和中序子树的长度一样）
    int[] leftPreorder = Arrays.copyOfRange(preorder, 1, 1 + leftIndex);
    int[] rightPreorder = Arrays.copyOfRange(preorder, 1 + leftIndex, preorder.length);

    // 构建左右子树
    root.left = buildTree(leftPreorder, leftInorder);
    root.right = buildTree(rightPreorder, rightInorder);
    
    return root;
}
```

#### 力扣 106 从中序和后序遍历序列构造二叉树

![image-20220411214317826](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411214317826.png)

后序的最后一个节点就是根节点，因此和前面题思路类似：

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    if (inorder == null || inorder.length == 0) {
        return null;
    }

    if (postorder == null || postorder.length == 0) {
        return null;
    }

    TreeNode root = new TreeNode(postorder[postorder.length - 1]);

    int leftIndex = -1;
    for (int i = 0; i < inorder.length; i++) {
        if (inorder[i] == root.val) {
            leftIndex = i;
            break;
        }
    }

    int[] leftInorder = Arrays.copyOfRange(inorder, 0, leftIndex);
    int[] rightInorder = Arrays.copyOfRange(inorder, leftIndex + 1, inorder.length);
    int[] leftPostorder = Arrays.copyOfRange(postorder, 0, leftIndex);
    int[] rightPostorder = Arrays.copyOfRange(postorder, leftIndex, postorder.length - 1);

    root.left = buildTree(leftInorder, leftPostorder);
    root.right = buildTree(rightInorder, rightPostorder);

    return root;
}
```

#### 力扣 654 最大二叉树

![image-20220411214506156](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411214506156.png)

本题其实也很简单，根据题目的意思来即可：

```java
public TreeNode constructMaximumBinaryTree(int[] nums) {
    if (nums == null || nums.length == 0) {
        return null;
    }

    int maxIdx = 0;
    for (int i = 1; i < nums.length; ++i) {
        if (nums[maxIdx] < nums[i]) {
            maxIdx = i;
        }
    }

    TreeNode root = new TreeNode(nums[maxIdx]);
    root.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, 0, maxIdx));
    root.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIdx + 1, nums.length));

    return root;
}
```

#### 力扣 889 根据前序和后序遍历构造二叉树

![image-20220411214758281](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411214758281.png)

本题只需要返回一个答案，因此我们可以采取如下思路：

1. 首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。
2. 然后把前序遍历结果的第二个元素作为左子树的根节点的值。
3. 在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

```java
public TreeNode constructFromPrePost(int[] pre, int[] post) {
    int n = pre.length;
    if (n == 0) {
        return null;
    }

    TreeNode root = new TreeNode(pre[0]);
    if (n == 1) {
        return root;
    }

    int l = 0;
    // 在后序中找到左子树根
    for (int i = 0; i < n; ++i) {
        if (post[i] == pre[1]) {
            l = i + 1;
        }
    }

    root.left = constructFromPrePost(Arrays.copyOfRange(pre, 1, l + 1),
                                     Arrays.copyOfRange(post, 0, l));
    root.right = constructFromPrePost(Arrays.copyOfRange(pre, l + 1, n),
                                      Arrays.copyOfRange(post, l, n - 1));
    
    return root;
}
```

#### 力扣 297 二叉树的序列化和反序列化

![image-20220411221345586](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411221345586.png)

本题就是要能够把二叉树变成字符串，然后再变回去，说是字符串操作也不为过。

具体考察的就是二叉树的遍历，本题使用什么遍历顺序都可以，主要是要记得加分隔符，空节点也要有一个占位符表示：

```java
public class Codec {
    private static final String SEP = ",";

    private static final String NULL = "#";

    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();

        serialize(root, sb);

        return sb.toString();
    }

    private void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL)
                .append(SEP);

            return;
        }

        // 前序序列化，记得加分隔符
        sb.append(root.val)
            .append(SEP);

        serialize(root.left, sb);
        serialize(root.right, sb);
    }
    
    // 反序列化就是把字符串分隔形成多个字符串以后，根据字符串的值判断是否为空节点，然后前序遍历回去
    public TreeNode deserialize(String data) {
        LinkedList<String> nodes = new LinkedList<>();

        for (String s : data.split(SEP)) {
            nodes.addLast(s);
        }

        return deserialize(nodes);
    }

    private TreeNode deserialize(LinkedList<String> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }

        String value = nodes.removeFirst();
        // 为空就不用继续反序列化了
        if (value.equals(NULL)) {
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(value));

        root.left = deserialize(nodes);
        root.right = deserialize(nodes);

        return root;
    }
}
```

### 层序遍历专题

层序遍历就是非递归形式的了，是广度优先遍历，需要利用队列实现，模板如下：

```java
public void traverse(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    TreeNode pRoot = root;
    
    if (root == null) {
        return root;
    }
    
    queue.offer(pRoot);
    
    while (!queue.isEmpty()) {
        List<TreeNode> level = new ArrayList<>();
        
        int len = queue.size();
        while (len-- > 0) {
            TreeNode cur = queue.poll();
            level.add(cur);
            
            if (cur.left != null) {
                queue.add(cur.left);
            }
            
            if (cur.right != null) {
                queue.add(cur.right);
            }
        }
        
        // 层序处理
    }
}
```

#### 力扣 116 & 117 填充节点的右侧指针（Ⅱ）

![image-20220411200713868](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411200713868.png)

本题递归不太好写，反而是使用层序遍历可以秒杀：

```java
public Node connect(Node root) {
    Queue<Node> queue = new ArrayDeque<>();
    Node pRoot = root;

    if (pRoot == null) {
        return root;
    }

    queue.offer(pRoot);

    while (!queue.isEmpty()) {
        List<Node> level = new ArrayList<>();

        int len = queue.size();
        while (len-- > 0) {
            Node cur = queue.poll();
            level.add(cur);

            if (cur.left != null) {
                queue.offer(cur.left);
            }

            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }

        for (int i = 0; i < level.size() - 1; ++i) {
            level.get(i).next = level.get(i + 1);
        }
        level.get(level.size() - 1).next = null;
    }

    return root;
}
```

#### 力扣 199 二叉树的右视图

![image-20220411201447112](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411201447112.png)

本题选择每层的最后一个节点即可：

```java
public List<Integer> rightSideView(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    List<Integer> ans = new ArrayList<>();

    if (root == null) {
        return ans;
    }

    queue.offer(root);

    while (!queue.isEmpty()) {
        int len = queue.size();
        List<Integer> level = new ArrayList<>();
        while (len-- > 0) {
            TreeNode cur = queue.poll();

            if (cur.left != null) {
                queue.offer(cur.left);
            }

            if (cur.right != null) {
                queue.offer(cur.right);
            } 

            level.add(cur.val);
        }
        ans.add(level.get(level.size() - 1));
        
        
    }
    return ans;
}
```

如果是左视图，则改为选择每层的第一个节点。

## 二叉搜索树

## 前缀树

Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。

字典树经常用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

**Trie 树本质上就是一棵从二叉树衍生出来的多叉树**。

假设二叉树结点定义是这样的：

```java
class Node {
    int val;
    Node left, right;
}
```

那么多叉树就是：

```java
class Node {
    int val;
    Node[] children;
}
```

字典树中的每个节点也是一个多叉树节点，但是数组大小是固定的：

```java
class TrieNode {
    boolean end
    TrieNode[] children = new TrieNode[256];
}
```

长度为 256，表示 ASCII 字符一共有 256 个，如果选用其他字符集，则可以设置的更大，当然，如果只保存小写英文字母，则可以更小。

**但是和之前的普通多叉树节点不同，`TrieNode` 中 `children` 数组的索引是有意义的，代表键中的一个字符**。

比如说 `children[97]` 如果非空，说明这里存储了一个字符 `'a'`，因为 `'a'` 的 ASCII 码为 97。

一棵字典树可能是这样的：

![image-20220422164634188](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422164634188.png)

省略空节点不画，一棵经典的字典树长这样：

![image-20220422195712566](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422195712566.png)

字典树是共享前缀的，这意味着节点需要有一个标志来保存它是否是一个插入的单词，我们可以用一个布尔型的量完成这个操作。

### 力扣 208 实现 Trie（前缀树）

![image-20220422232025566](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422232025566.png)

根据上面的理论，实现代码如下：

```java
class Trie {
    private static class TrieNode {
        boolean end;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode p = root;
        for (char ch : word.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                p.children[ch - 'a'] = new TrieNode();
            }
            p = p.children[ch - 'a'];
        }
        p.end = true;
    }
    
    public boolean search(String word) {
        TrieNode p = root;
        for (char ch : word.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                return false;
            } 
            p = p.children[ch - 'a'];
        }
        return p.end;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (char ch : prefix.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                return false;
            }
            p = p.children[ch - 'a'];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

注意，end 标志是用于标识单词的，假设插入了 apple 这个单词，但是没有插入 app 这个单词，那么虽然它们前缀相同，但是搜索 app 时不能返回 true。

### 力扣 211 添加与搜索单词 - 数据结构设计

![image-20220422231958387](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422231958387.png)

本题的难点在于通配符匹配，当碰到通配符时，必须搜索该层每一个不为空的孩子，因此可以采取深度优先搜索的方式：

```java
private boolean dfs(String word, TrieNode node, int idx) {
    if (idx == word.length()) {
        return node.end;
    }

    char ch = word.charAt(idx);
    if (ch == '.') {
        for (int i = 0; i < 26; i++) {
            if (node.children[i] != null && dfs(word, node.children[i], idx + 1)) {
                return true;
            }
        }
        return false;
    } else {
        if (node.children[ch - 'a'] == null) {
            return false;
        }
        return dfs(word, node.children[ch - 'a'], idx + 1);
    }
}
```

其他代码就和 Trie 没什么差别了：

```java
class WordDictionary {
    private static class TrieNode {
        boolean end;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();

    }
    
    public void addWord(String word) {
        TrieNode p = root;
        for (char ch : word.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                p.children[ch - 'a'] = new TrieNode();
            }
            p = p.children[ch - 'a'];
        }
        p.end = true;
    }
    
    public boolean search(String word) {
        return dfs(word, root, 0);
    }
    
    // ...
}
```

### 力扣 677 键值映射

![image-20220422231925006](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422231925006.png)

本题可以使用 DFS 或 BFS 解决：

```java
class MapSum {
    private static class TrieNode {
        int val;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public MapSum() {
        root = new TrieNode();
    }

    public void insert(String key, int val) {
        TrieNode p = root;
        for (char ch : key.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                p.children[ch - 'a'] = new TrieNode();
            }
            p = p.children[ch - 'a'];
        }
        p.val = val;
    }

    public int sum(String prefix) {
        TrieNode p = root;
        for (char ch : prefix.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                return 0;
            }
            p = p.children[ch - 'a'];
        }

        int sum = 0;
        Deque<TrieNode> queue = new ArrayDeque<>();
        queue.add(p);

        while (!queue.isEmpty()) {
            int sz = queue.size();
            while (sz-- > 0) {
                TrieNode cur = queue.poll();
                for (TrieNode node : cur.children) {
                    if (node != null) {
                        queue.add(node);
                    }
                }
                sum += cur.val;
            }
        }

        return sum;
    }
}
```

### 力扣 648 单词替换

![image-20220422231813380](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422231813380.png)

本题很明显需要使用前缀树，但是需要一点特殊的处理，具体来说，在进行前缀搜索时，如果搜索到最小前缀，要立即返回；如果未搜索到前缀，返回原本的单词。

```java
class TrieTree {
    static class TrieNode {
        boolean end;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode head;

    public TrieTree() {
        head = new TrieNode();
    }

    public void insert(String key) {
        TrieNode p = head;
        for (char ch : key.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                p.children[ch - 'a'] = new TrieNode();
            }
            p = p.children[ch - 'a'];
        }
        p.end = true;
    }

    public String search(String key) {
        TrieNode p = head;
        StringBuilder prefix = new StringBuilder();
        for (char ch : key.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                return key;
            }
            p = p.children[ch - 'a'];
            prefix.append(ch);
            if (p.end) {
                return prefix.toString();
            }
        }
        return prefix.toString();
    }
}
```

```java
public String replaceWords(List<String> dictionary, String sentence) {
    TrieTree trie = new TrieTree();
    for (String s : dictionary) {
        trie.insert(s);
    }

    StringBuilder sb = new StringBuilder();
    for (String word : sentence.split(" ")) {
        String prefix = trie.search(word);
        sb.append(prefix + " ");
    }
    return sb.deleteCharAt(sb.length() - 1).toString();
}
```
