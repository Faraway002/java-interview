[TOC]

# 树

## 1. 二叉树

二叉树（递归）解题的思维模式分两类：

1. **是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫遍历的思维模式**。

   这种思维模式也对应**回溯法**的思维模式。

2. **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫分解问题的思维模式。

   这种思维模式也对应**动态规划**的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

注意二叉树的三种遍历方式，**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

* 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
* 后序位置的代码在将要离开一个二叉树节点的时候执行；
* 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

**二叉树的所有问题，就是让你在前/中/后序位置注入巧妙的代码逻辑，去达到自己的目的**，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

需要注意的是，后序遍历的位置是很特殊的，**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。

### 1.1 基础

#### 力扣 144. 二叉树的前序遍历

![image-20220723110920459](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723110920459.png)

二叉树的基础，所谓前序，就是最先处理根节点，再处理左右孩子。

代码实现如下：

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();

    preorder(ans, root);

    return ans;
}

private void preorder(List<Integer> list, TreeNode root) {
    if (root == null) {
        return;
    }
    list.add(root.val);
    preorder(list, root.left);
    preorder(list, root.right);
}
```

#### 力扣 94. 二叉树的中序遍历

![image-20220723111254541](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723111254541.png)

所谓中序，就是最先处理左孩子，再处理根节点，最后处理右孩子。

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();

    inorder(ans, root);

    return ans;
}

private void inorder(List<Integer> list, TreeNode root) {
    if (root == null) {
        return;
    }
    
    inorder(list, root.left);
    list.add(root.val);
    inorder(list, root.right);
}
```

#### 力扣 145. 二叉树的后序遍历

![image-20220723111437661](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723111437661.png)

所谓后序，就是最先处理左孩子，再处理右孩子，最后处理根节点。

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();

    postorder(ans, root);

    return ans;
}

private void postorder(List<Integer> list, TreeNode root) {
    if (root == null) {
        return;
    }
    
    postorder(list, root.left);
    postorder(list, root.right);
    list.add(root.val);
}
```

#### 力扣 589. N 叉树的前序遍历

![image-20220724133452007](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724133452007.png)

前序就是根节点最先处理。

```java
private List<Integer> ans = new ArrayList<>();

public List<Integer> preorder(Node root) {
    if (root == null) {
        return ans;
    }

    ans.add(root.val);
    for (Node child : root.children) {
        preorder(child);
    }

    return ans;
}
```

#### 力扣 590. N 叉树的后序遍历

![image-20220724133420914](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724133420914.png)

后序就是根节点最后处理。

```java
private List<Integer> ans = new ArrayList<>();

public List<Integer> postorder(Node root) {
    if (root == null) {
        return ans;
    }

    for (Node child : root.children) {
        postorder(child);
    }
    ans.add(root.val);

    return ans;
}
```

#### 剑指 Offer 55 - I. 二叉树的深度 & 力扣 104. 二叉树的最大深度

![image-20220707145505466](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220707145505466.png)

* 遍历的思路：使用一个全局变量记录达到的最大深度。

  ```java
  private int curDepth = 0;
  private int maxDepth = 0;
  
  public int maxDepth(TreeNode root) {
      traverse(root);
      return maxDepth;
  }
  
  private void traverse(TreeNode root) {
      if (root == null) {
          maxDepth = Math.max(curDepth, maxDepth);
          return;
      }
      
      curDepth++;
      traverse(root.left);
      traverse(root.right);
      curDepth--;
  }
  ```

* 子问题的思路：求出左右子树的最大深度，然后取其中一方最大的 + 1。

  ```java
  public int maxDepth(TreeNode root) {
      if (root == null) {
          return 0;
      }
      
      int ld = maxDepth(root.left);
      int rd = maxDepth(root.right);
      
      return ld > rd ? ld + 1 : rd + 1;
  }
  ```

#### 力扣 559. N 叉树的最大深度

![image-20220724125737138](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724125737138.png)

本题和上一题类似，遍历每一个子节点，求出这些子节点的最大深度，然后 + 1 即可。

代码实现如下：

```JAVA
public int maxDepth(Node root) {
    if (root == null) {
        return 0;
    }

    int max = 0;
    for (Node child : root.children) {
        max = Math.max(maxDepth(child), max);
    }

    return max + 1;
}
```

#### 剑指 Offer 55 - II. 平衡二叉树 & 力扣 110. 平衡二叉树

![image-20220707150709133](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220707150709133.png)

本题只需要遍历所有树节点，求出以这个节点为根节点的左右子树的深度，检查它们的差的绝对值是否超过 1 即可。

既然要接收返回值，那么就需要使用后序遍历。

代码实现如下：

```java
private boolean isBalanced = true;

public boolean isBalanced(TreeNode root) {
    depth(root);

    return isBalanced;
}

private int depth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int ld = depth(root.left);
    int rd = depth(root.right);

    if (Math.abs(ld - rd) > 1) {
        isBalanced = false;
    }

    return 1 + Math.max(ld, rd);
}
```

#### 力扣 543. 二叉树的直径

![image-20220724134939168](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724134939168.png)

注意，二叉树的直径定义为任意两个节点之间的边数，**可以经过根也可以不经过根**。

那么一棵树的最长直径一定是所有节点的左右子树深度之和的最大值，那么我们遍历就可以了。

这里最好是后序遍历，因为后序位置能够接收到返回值。

```java
private int ans;

public int diameterOfBinaryTree(TreeNode root) {
    traverse(root);
    return ans;
}

public int traverse(TreeNode root) {
    if (root == null) {
        return 0;
    }
    
    int ld = traverse(root.left);
    int rd = tarverse(root.right);
    
    ans = Math.max(ld + rd, ans);
    
    return ld > rd ? ld + 1 : rd + 1;
}
```

#### 剑指 Offer 27. 二叉树的镜像 & 力扣 226. 翻转二叉树

![image-20220724115807567](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724115807567.png)

从遍历的角度，遍历每一个节点，交换其左右子树即可：

```java
public TreeNode invertTree(TreeNode root) {
    if (root== null) {
        return root;
    }

    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    invertTree(root.left);
    invertTree(root.right);

    return root;
}
```

从递归的角度，先翻转好左右子树，然后交换左右子树即可：

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    root.left = right;
    root.right = left;

    return root;
}
```

#### 力扣 100. 相同的树

![image-20220724132748505](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724132748505.png)

本题不是一棵树，而是两棵树的比较，但是也是使用递归的思想，需要考虑节点是否为空：

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }

    if (p == null && q != null) {
        return false;
    }

    if (p != null && q == null) {
        return false;
    }

    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

#### 剑指 Offer 28. 对称二叉树 & 力扣 101. 对称二叉树

![image-20220724125244575](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724125244575.png)

本题和上一题类似的，如果根节点为空，那么说明它是空树，是对称的；如果不为空，则比较它的左右子树是否相同就好了。

代码实现：

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }

    return compare(root.left, root.right);
}

private boolean compare(TreeNode a, TreeNode b) {
    if (a == null && b == null) {
        return true;
    }

    if ((a != null && b == null) || (a == null && b != null)) {
        return false;
    }

    return a.val == b.val && compare(a.left, b.right) && compare(a.right, b.left);
}
```

#### 力扣 572. 另一棵树的子树

![image-20220724134544248](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724134544248.png)

本题有上面题目的基础很简单，如果一棵树 A 是另一棵树 B 的子树，则：

1. 要么 A 就是 B
2. 要么 A 是 B 左子树的子树
3. 要么 A 是 B 右子树的子树

这就是一个递归的过程，同时也需要借助两棵树是否相等的函数来判断。

```java
public boolean isSubtree(TreeNode root, TreeNode subRoot) {
    if (root == null) {
        return subRoot == null;
    }

    // 判断以 root 为根的二叉树是否和 subRoot 相同
    if (isSameTree(root, subRoot)) {
        return true;
    }
    
    // 去左右子树中判断是否有和 subRoot 相同的子树
    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
}

public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }

    if (p == null && q != null) {
        return false;
    }

    if (p != null && q == null) {
        return false;
    }

    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

#### 力扣 257. 二叉树的所有路径

![image-20220724131250742](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724131250742.png)

本题是经典的 DFS 在树上的应用，套 DFS 模板即可。

```java
private List<String> ans = new ArrayList<>();

private LinkedList<String> path = new LinkedList<>();

public List<String> binaryTreePaths(TreeNode root) {
    dfs(root);
    return ans;
}

private void dfs(TreeNode root) {
    if (root == null) {
        return;
    }

    if (root.left == null && root.right == null) {
        path.addLast(root.val + "");
        ans.add(String.join("->", path));
        path.removeLast();
        return;
    }

    path.addLast(root.val + "");
    dfs(root.left);
    dfs(root.right);
    path.removeLast();
}
```

#### 剑指 Offer 34. 二叉树中和为某一值的路径 & 力扣 113. 路径总和 II

![image-20220701160002868](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220701160002868.png)

注意，本题是根节点到叶子节点的路径，不是只要达到了 targetSum 就可以算一条路径的。

本题可以使用 dfs，从根节点开始，遍历所有路径。

```java
private List<List<Integer>> ans = new ArrayList<>();

private Deque<Integer> path = new ArrayDeque<>();

public List<List<Integer>> pathSum(TreeNode root, int target) {
    dfs(root, target, 0);

    return ans;
}

private void dfs(TreeNode root, int target, int cur) {
    if (root == null) {
        return;
    }

    if (root.left == null && root.right == null) {
        if (cur + root.val == target) {
            path.addLast(root.val);
            ans.add(new ArrayList<>(path));
            path.removeLast(); // 记得这里也要回溯
        }
        return;
    }

    path.addLast(root.val);
    dfs(root.left, target, cur + root.val);
    dfs(root.right, target, cur + root.val);
    path.removeLast();
}
```

#### 力扣 437. 路径总和 III

![image-20220717160735819](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220717160735819.png)

本题最直观的想法就是遍历每一个节点，从每一个节点开始计算路径总和，一旦发现一条路径就让计数器 + 1。

但是我们要知道的是，这里其实暗含了两个 dfs，一个是遍历所有节点；另一个是计算路径总和，这个 dfs 相当于路径总和 II，因为我们是把当前遍历到的节点作为根节点计算。

所以，我们写代码时要理清 dfs 的逻辑，不要乱掉：

```java
private int target;
private int ans;

public int pathSum(TreeNode root, int target) {
    this.target = target;

    // 从根节点开始遍历
    dfs(root);
    return ans;
}

private void dfs(TreeNode root) {
    if (root == null) {
        return;
    }

    pathSumRecursive(root, 0);
    dfs(root.left);
    dfs(root.right);
}

private void pathSumRecursive(TreeNode root, long cur) {
    if (root == null) {
        return;
    }

    if (cur + root.val == target) {
        ans++;
    }

    pathSumRecursive(root.left, cur + root.val);
    pathSumRecursive(root.right, cur + root.val);
}
```

#### 力扣 222. 完全二叉树的节点个数

![image-20220712142744867](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712142744867.png)

本题可以使用一般二叉树求节点个数的方法，先求左子树节点个数，再求右子树节点个数，然后加起来 + 1 即可，时间复杂度 $O(n)$：

```java
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

但是本题是完全二叉树，意味着本题是要你**利用完全二叉树的特点**。

完全二叉树的特点就是最后一层之前的每一层都是满的，最后一层是从左到右摆的，因此可以利用这个特性。

首先求根节点的左右子树高度：

* 如果相等，说明至少左子树是填满的，此时就可以利用公式 $n = 2 ^ {h} - 1$ 次方求得左子树的节点数量；
* 否则，说明至少右子树满了，此时右子树的节点数量就可以利用上述公式求。

代码实现如下：

```java
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int cnt = 1;
    int ld = depth(root.left);
    int rd = depth(root.right);

    if (ld == rd) {
        cnt += (int) Math.pow(2, ld) - 1;
        cnt += countNodes(root.right);
    } else {
        cnt += (int) Math.pow(2, rd) - 1;
        cnt += countNodes(root.left);
    }

    return cnt;
}   

private int depth(TreeNode root) {
    int ans = 0;
    while (root != null) {
        ans++;
        root = root.left;
    }
    return ans;
}
```

#### 力扣 114 二叉树展开为链表

![image-20220411212246743](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411212246743.png)

本题需要原地连接，因为给定的函数没有返回值。

如果可以使用额外空间的话，使用遍历的思想，那么我们只要设置一个全局的虚拟头节点，然后在前序的位置把链表头的右指针指向 root，就可以了；

```java
TreeNode dummy = new TreeNode(-1);

TreeNode p = dummy;

public void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    p.right = new TreeNode(root.val);
    p = p.right;

    traverse(root.left);
    traverse(root.right);
}
```

可惜，本题需要原地连接，这时就需要递归的思想：

首先把左子树拉成链表，然后把右子树拉成链表，现在头节点的左右指针分别指向了两个链表，先用一个指针记录头节点的右边，然后把头节点的右指针指向头节点的左边；最后从头节点右边遍历到底部，接上刚刚记录的右边即可：

```java
public void flatten(TreeNode root) {
    if (root == null) {
        return;
    }

    flatten(root.left);
    flatten(root.right);

    TreeNode r = root.right;
    root.right = root.left;
    root.left = null;

    TreeNode p = root;
    while (p.right != null) {
        p = p.right;
    }

    p.right = r;
}
```

#### 剑指 Offer 26. 树的子结构

![image-20220703094750127](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703094750127.png)

本题注意不是判断 B 是否为 A 的子树，而是子结构，这意味着左子树有一部分相同，右子树也有一部分相同时，也算是子结构。

首先，题目明确要求，空树不是任何树的子结构，因此这里直接返回 false 即可。

然后，如果 B 树是 A 树的子结构，意味着 B 树的根节点一定是 A 树中的某一个节点，因此我们遍历整棵树，对每一个节点调用 `isContain` 函数判断是否为子结构。

`isContain` 函数怎么实现呢？

* 如果 A 为空，且 B 为空，说明遍历到底了，返回 true
* 如果 A 为空，但 B 不为空，这很明显不匹配，返回 false
* 如果 A 不为空，但是 B 为空，这说明 B 是 A 的子结构，返回 true
* 如果 A B 都不为空，则取决于 A 和 B 节点的值，相等则继续看左右子树；否则直接返回 false

代码实现如下：

```java
private boolean isContain(TreeNode A, TreeNode B) {
    if (A == null && B == null) {
        return true;
    }

    if (A == null && B != null) {
        return false;
    }

    if (A != null && B == null) {
        return true;
    }

    return A.val == B.val && isContain(A.left, B.left) && isContain(A.right, B.right);
}
```

整体代码：

```java
public boolean isSubStructure(TreeNode A, TreeNode B) {
    if (A == null || B == null) {
        return false;
    }

    return isSubStructure(A.left, B) || isSubStructure(A.right, B) || isContain(A, B);
}
```

#### 剑指 Offer 68 - II. 二叉树的最近公共祖先 & 力扣 236. 二叉树的最近公共祖先

![image-20220706102618445](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706102618445.png)

这一题比剑指 Offer 68 - I. 二叉搜索树的最近公共祖先要难一点，虽然确定 LCA（公共祖先）的理论是一致的，但是由于二叉搜索树的特殊性质，我们可以很轻松的确定 p，q 到底位于 root 的左边还是右边，但是普通二叉树没有这样的性质。

那么，我们可以额外增加一个函数，判断节点到底在左边还是在右边即可，这个函数实现如下：

```java
private boolean contains(TreeNode root, TreeNode p) {
		if (root == null) {
      	return false;
    }
  
  	if (root.val == p.val) {
      	return true;
    }
  
  	return contains(root.left, p) || contains(root.right, p);
}
```

完整代码：

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) {
        return null;
    }

    if (root.val == p.val || root.val == q.val) {
        return root;
    }

    if (contains(root.left, p) && contains(root.left, q)) {
        return lowestCommonAncestor(root.left, p, q);
    }

    if (contains(root.right, p) && contains(root.right, q)) {
        return lowestCommonAncestor(root.right, p, q);
    }

    return root;
}
```

### 1.2 构造二叉树专题

二叉树如果知道前序和中序，或者后序和中序的遍历序列，是可以还原出一棵独一无二的二叉树的，这是因为这两个组合都可以唯一确定根节点。

但是，后序和前序遍历虽然可以确定根节点，但是你无法确定左右子树到底有哪些节点，可能会有多种情况。

对于构造二叉树来说，一般都采用递归的思想，即先构造根节点，然后构造左子树，最后构造右子树。

#### 力扣 105 从前序和中序遍历序列构造二叉树 & 剑指 Offer 07.重建二叉树

![image-20220411213736604](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411213736604.png)

知道前序和中序该怎么还原二叉树呢？实际上，前序序列的第一个一定是根节点，而中序序列的根节点是在中间遍历到的，因此中序序列根节点的左边部分就是左子树，右边部分就是右子树。

那么，左右子树又是一棵完整的树，那我们递归就完成了。

代码实现如下：

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null || preorder.length == 0 || inorder == null || inorder.length == 0) {
        return null;
    }

    TreeNode root = new TreeNode(preorder[0]);

    // 在中序遍历中找到根节点的位置
    int rootIndex = -1;
    for (int i = 0; i < inorder.length; i++) {
        if (inorder[i] == root.val) {
            rootIndex = i;
            break;
        }
    }

    // 分别拆分出左右子树
    int[] leftInOrder = Arrays.copyOfRange(inorder, 0, rootIndex);
    int[] rightInOrder = Arrays.copyOfRange(inorder, rootIndex + 1, inorder.length);

    int[] leftPreOrder = Arrays.copyOfRange(preorder, 1, 1 + rootIndex);
    int[] rightPreOrder = Arrays.copyOfRange(preorder, 1 + rootIndex, preorder.length);

    // 分别构建左右子树
    root.left = buildTree(leftPreOrder, leftInOrder);
    root.right = buildTree(rightPreOrder, rightInOrder);

    return root;
}
```

#### 力扣 106 从中序和后序遍历序列构造二叉树

![image-20220411214317826](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411214317826.png)

后序的最后一个节点就是根节点，因此和前面题思路类似：

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    if (inorder == null || inorder.length == 0) {
        return null;
    }

    if (postorder == null || postorder.length == 0) {
        return null;
    }

    TreeNode root = new TreeNode(postorder[postorder.length - 1]);

    int leftIndex = -1;
    for (int i = 0; i < inorder.length; i++) {
        if (inorder[i] == root.val) {
            leftIndex = i;
            break;
        }
    }

    int[] leftInorder = Arrays.copyOfRange(inorder, 0, leftIndex);
    int[] rightInorder = Arrays.copyOfRange(inorder, leftIndex + 1, inorder.length);
    int[] leftPostorder = Arrays.copyOfRange(postorder, 0, leftIndex);
    int[] rightPostorder = Arrays.copyOfRange(postorder, leftIndex, postorder.length - 1);

    root.left = buildTree(leftInorder, leftPostorder);
    root.right = buildTree(rightInorder, rightPostorder);

    return root;
}
```

#### 力扣 654 最大二叉树

![image-20220411214506156](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411214506156.png)

本题其实也很简单，根据题目的意思来即可：

```java
public TreeNode constructMaximumBinaryTree(int[] nums) {
    if (nums == null || nums.length == 0) {
        return null;
    }

    int maxIdx = 0;
    for (int i = 1; i < nums.length; ++i) {
        if (nums[maxIdx] < nums[i]) {
            maxIdx = i;
        }
    }

    TreeNode root = new TreeNode(nums[maxIdx]);
    root.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, 0, maxIdx));
    root.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIdx + 1, nums.length));

    return root;
}
```

#### 力扣 889 根据前序和后序遍历构造二叉树

![image-20220411214758281](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220411214758281.png)

本题只需要返回一个答案，因此我们可以采取如下思路：

1. 首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。
2. 然后把前序遍历结果的第二个元素作为左子树的根节点的值。
3. 在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

```java
public TreeNode constructFromPrePost(int[] pre, int[] post) {
    int n = pre.length;
    if (n == 0) {
        return null;
    }

    TreeNode root = new TreeNode(pre[0]);
    if (n == 1) {
        return root;
    }

    int l = 0;
    // 在后序中找到左子树根
    for (int i = 0; i < n; ++i) {
        if (post[i] == pre[1]) {
            l = i + 1;
        }
    }

    root.left = constructFromPrePost(Arrays.copyOfRange(pre, 1, l + 1),
                                     Arrays.copyOfRange(post, 0, l));
    root.right = constructFromPrePost(Arrays.copyOfRange(pre, l + 1, n),
                                      Arrays.copyOfRange(post, l, n - 1));
    
    return root;
}
```

#### 剑指 Offer 37. 序列化二叉树 & 力扣 297 二叉树的序列化和反序列化

![image-20220701182035704](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220701182035704.png)

本题**不能忽视叶子结点的左右（null）节点**，因为如果忽视了 null 节点的话，那么序列化后的结果就可能像这样：[1,2,3,4,5]，但是即使知道这个序列是怎么遍历出来的，也无法复原，因为可以找出很多棵这样的树。

其他的就是考察二叉树的遍历，本题使用什么遍历顺序都可以，要记得加分隔符。

代码实现如下：

```java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();

        serialize(root, sb);
        sb.deleteCharAt(sb.length() - 1);

        System.out.println(sb);
        return sb.toString();
    }

    private void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append("null,");
            return;
        }

        sb.append(root.val)
          .append(",");
        serialize(root.left, sb);
        serialize(root.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        Deque<String> nodeList = new LinkedList<>();
        String[] nodeArr = data.split(",");

        for (String node : nodeArr) {
            nodeList.addLast(node);
        }
        
        return deserialize(nodeList);
    }

    private TreeNode deserialize(Deque<String> nodeList) {
        if (nodeList == null || nodeList.size() == 0) {
            return null;
        }

        String nodeVal = nodeList.removeFirst();
        if ("null".equals(nodeVal)) {
            return null;
        }

        TreeNode root = new TreeNode(Integer.parseInt(nodeVal));
        root.left = deserialize(nodeList);
        root.right = deserialize(nodeList);

        return root;
    }

}
```

### 1.3 层序遍历专题

层序遍历就是非递归形式的了，是广度优先遍历，需要利用队列实现，模板如下：

```java
public void traverse(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    TreeNode pRoot = root;
    
    if (root == null) {
        return;
    }
    
    queue.offer(pRoot);
    
    while (!queue.isEmpty()) {
        List<TreeNode> level = new ArrayList<>();
        
        int len = queue.size();
        while (len-- > 0) {
            TreeNode cur = queue.poll();
            level.add(cur);
            
            if (cur.left != null) {
                queue.add(cur.left);
            }
            
            if (cur.right != null) {
                queue.add(cur.right);
            }
        }
        
        // 层序处理
    }
}
```

#### 力扣 102. 二叉树的层序遍历

![image-20220723111938142](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723111938142.png)

套上面的模板可以秒杀。

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();

    if (root == null) {
        return ans;
    }

    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        
        int len = queue.size();
        while (len-- > 0) {
            TreeNode cur = queue.poll();
            level.add(cur.val);
            
            if (cur.left != null) {
                queue.add(cur.left);
            }
            
            if (cur.right != null) {
                queue.add(cur.right);
            }
        }
        
        ans.add(new ArrayList<>(level));
    }

    return ans;
}
```

#### 力扣 107. 二叉树的层序遍历 II

![image-20220723112351100](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723112351100.png)

本题和上一题类似，只需要把最后的结果翻转一下就好了：

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();

    if (root == null) {
        return ans;
    }

    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        
        int len = queue.size();
        while (len-- > 0) {
            TreeNode cur = queue.poll();
            level.add(cur.val);
            
            if (cur.left != null) {
                queue.add(cur.left);
            }
            
            if (cur.right != null) {
                queue.add(cur.right);
            }
        }
        
        ans.add(new ArrayList<>(level));
    }

    Collections.reverse(ans);

    return ans;
}
```

#### 剑指 Offer 32 - I. 从上到下打印二叉树

![image-20220630115632168](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220630115632168.png)

本题和力扣 102 基本一样，唯一的不同就在于返回值不同，一个是返回 `List`，一个是返回 `int[]`。

代码实现如下：

```java
public int[] levelOrder(TreeNode root) {
    if (root == null) {
        return new int[] {};
    }

    List<Integer> ans = new ArrayList<>();
    Deque<TreeNode> queue = new ArrayDeque<>();

    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode cur = queue.poll();
        ans.add(cur.val);
        if (cur.left != null) {
            queue.offer(cur.left);
        }
        if (cur.right != null) {
            queue.offer(cur.right);
        }
    }

    return ans.stream().mapToInt(Integer::intValue).toArray();
}
```

#### 剑指 Offer 32 - II. 从上到下打印二叉树 II

![image-20220630120424250](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220630120424250.png)

本题和上一题的差别仅在于每一层都需要单独成一个列表，那我们也单独处理即可：

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();

    if (root == null) {
        return ans;
    }

    Deque<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int sz = queue.size();

        List<Integer> level = new ArrayList<>();
        while (sz-- > 0) {
            TreeNode cur = queue.poll();
            level.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        ans.add(level);
    }

    return ans;
}
```

#### 剑指 Offer 32 - III. 从上到下打印二叉树 III

![image-20220630120844468](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220630120844468.png)

在上一题的基础上加一个奇数标志即可：

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();

    if (root == null) {
        return ans;
    }

    Deque<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);

    boolean odd = true;
    while (!queue.isEmpty()) {
        int sz = queue.size();

        List<Integer> level = new ArrayList<>();
        while (sz-- > 0) {
            TreeNode cur = queue.poll();
            level.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        if (!odd) {
            Collections.reverse(level);
        }
        odd = !odd;
        ans.add(level);
    }

    return ans;
}
```

#### 力扣 647. 二叉树的层平均值

![image-20220724103015560](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724103015560.png)

本题进行层序遍历后，统计每一层列表的和，然后求平均值即可。

```java
public List<Double> averageOfLevels(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    List<Double> ans = new ArrayList<>();

    if (root == null) {
        return ans;
    }

    queue.offer(root);

    while (!queue.isEmpty()) {
        int len = queue.size();
        List<Integer> level = new ArrayList<>();
        while (len-- > 0) {
            TreeNode cur = queue.poll();

            if (cur.left != null) {
                queue.offer(cur.left);
            }

            if (cur.right != null) {
                queue.offer(cur.right);
            }
            level.add(cur.val);
        }

        double sum = 0.0;
        for (int val : level) {
            sum += val;
        }
        ans.add(sum / level.size());
    }

    return ans;
}
```

#### 力扣 429. N 叉树的层序遍历

![image-20220724113748110](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724113748110.png)

N 叉树和二叉树层序遍历思想是一致的，都需要借助队列，不同的是二叉树只需要遍历左右结点，而 N 叉树要遍历每一个孩子。

代码实现如下：

```java
public List<List<Integer>> levelOrder(Node root) {
  	Queue<Node> queue = new ArrayDeque<>();

  	List<List<Integer>> ans = new ArrayList<>();

  	if (root == null) {
    		return ans;
  	}

  	queue.offer(root);

  	while (!queue.isEmpty()) {
    		List<Integer> level = new ArrayList<>();

    		int len = queue.size();
    		while (len-- > 0) {
      			Node cur = queue.poll();

      			level.add(cur.val);

      			for (Node child : cur.children) {
        				if (child != null) {
          					queue.offer(child);
        				}
      			}
    		}

    		ans.add(level);
  	}

  	return ans;
}
```

#### 力扣 515. 在每个树行中找最大值

![image-20220724114749595](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724114749595.png)

层序遍历，找每层的最大值即可。

```java
public List<Integer> largestValues(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();

    List<Integer> ans = new ArrayList<>();

    if (root == null) {
        return ans;
    }

    queue.offer(root);

    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();

        int len = queue.size();
        while (len-- > 0) {
            TreeNode cur = queue.poll();

            level.add(cur.val);

            if (cur.left != null) {
                queue.offer(cur.left);
            }

            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }

        ans.add(Collections.max(level));
    }

    return ans;
}
```

#### 力扣 116. 填充节点的右侧指针 & 力扣 117. 填充节点的右侧指针Ⅱ

![image-20220724115050224](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724115050224.png)

117 题和这题唯一的区别就在于这里是完美二叉树，而 117 是普通二叉树，但是两者都可以使用层序遍历的方法秒杀。

使用层序遍历保存每一层的节点，之后统一处理即可：

```java
public Node connect(Node root) {
    Queue<Node> queue = new ArrayDeque<>();
    Node pRoot = root;

    if (pRoot == null) {
        return root;
    }

    queue.offer(pRoot);

    while (!queue.isEmpty()) {
        List<Node> level = new ArrayList<>();

        int len = queue.size();
        while (len-- > 0) {
            Node cur = queue.poll();
            level.add(cur);

            if (cur.left != null) {
                queue.offer(cur.left);
            }

            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }

        // 每层的每个节点都处理一下
        for (int i = 0; i < level.size() - 1; ++i) {
            level.get(i).next = level.get(i + 1);
        }
        level.get(level.size() - 1).next = null;
    }

    return root;
}
```

#### 力扣 199. 二叉树的右视图

![image-20220723112636637](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220723112636637.png)

本题选择每层的最后一个节点即可：

```java
public List<Integer> rightSideView(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    List<Integer> ans = new ArrayList<>();

    if (root == null) {
        return ans;
    }

    queue.offer(root);

    while (!queue.isEmpty()) {
        int len = queue.size();
        List<Integer> level = new ArrayList<>();
        while (len-- > 0) {
            TreeNode cur = queue.poll();

            if (cur.left != null) {
                queue.offer(cur.left);
            }

            if (cur.right != null) {
                queue.offer(cur.right);
            } 

            level.add(cur.val);
        }
      
        ans.add(level.get(level.size() - 1));  
    }
    return ans;
}
```

如果是左视图，则改为选择每层的第一个节点。

#### 力扣 111. 二叉树的最小深度

![image-20220724130725224](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220724130725224.png)

本题和求最大深度思路是不一样的，因为最大深度只要一直往里钻就好了，因此是深度优先的思想。

而本题要求最小深度，最小深度是根节点到最近的叶子结点的节点数量，而不是到空节点，因此使用 DFS 递归的方法可能不太好求。

于是我们考虑使用 BFS，由于 BFS 的特性，我们很快能找到离根节点最近的叶子结点，因此 BFS 是比较适合本题的。

代码实现如下：

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    Queue<TreeNode> q = new ArrayDeque<>();
    q.offer(root);
    int depth = 1;

    while (!q.isEmpty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            if (cur.left == null && cur.right == null) {
                return depth;
            }
            if (cur.left != null) {
                q.offer(cur.left);
            }
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
        depth++;
    }
    
    return depth;
}
```

## 2. 二叉搜索树

### 力扣 108. 将有序数组转换为二叉搜索树

![image-20220712155432853](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712155432853.png)

这题是二叉搜索树如何建立的基本操作，由于数组是已排序的，我们每次取中点作为 root，然后递归构造即可：

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return buildTree(nums, 0, nums.length - 1);
}

private TreeNode buildTree(int[] nums, int start, int end) {
    if (start > end) {
        return null;
    }

    int mid = start + (end - start) / 2;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = buildTree(nums, start, mid - 1);
    root.right = buildTree(nums, mid + 1, end);

    return root;
}
```

### 力扣 700. 二叉搜索树中的搜索

![image-20220712150504600](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712150504600.png)

本题可以说是二叉搜索树的基本操作了，二叉搜索树最大的好处就是它可以像二分查找一样在树中查找。

代码实现如下：

```java
public TreeNode searchBST(TreeNode root, int val) {
    if (root == null) {
        return null;
    }

    if (root.val == val) {
        return root;
    } else if (root.val > val) {
        return searchBST(root.left, val);
    } else {
        return searchBST(root.right, val);
    }
}
```

这里使用的是递归法，也可以使用迭代法：

```java
public TreeNode searchBST(TreeNode root, int val) {
  	while (root != null) {
        if (root.val == val) {
            return root;
        } else if (root.val > val) {
						root = root.left;
        } else {
            root = root.right;
        }
    }
  
  	return null;
}
```

### 力扣 98. 验证二叉搜索树

![image-20220712152305416](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712152305416.png)

本题需要验证一棵树是否为二叉搜索树，灵活运用二叉搜索树的性质即可。

但是请注意，并不能使用 `root.val > root.left.val` 且 `root.val < root.right.val` 来判断是否为合法的二叉搜索树，因为二叉搜索树的根节点应该要比左子树所有的节点都大，比右子树所有节点都小，如果使用上面这种方式，就很容易误判。

比如 `[5,4,6,null,null,3,7]` 这个用例，它长这个样子：

![image-20220712153609749](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712153609749.png)

注意这个 3，你单独看 6 3 7 这棵子树是合法的，但是你整体来看就不对了，因为它比根（3）要小。

正确的代码应该这样写：

```java
public boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    if (root == null) {
        return true;
    }

    if (min != null && root.val <= min.val) {
        return false;
    }

    if (max != null && root.val >= max.val) {
        return false;
    }

    return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);
}
```

### 力扣 701. 二叉搜索树中的插入操作

![image-20220712150837775](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712150837775.png)

本题是二叉搜索树的又一基本操作，在二叉搜索树插入时要注意保持二叉搜索树的性质，因此要先查找到一个合适的位置，再进行插入。

代码实现如下：

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }

    TreeNode cur = root;
    TreeNode pre = root;
    while (cur != null) {
        pre = cur;
        if (cur.val > val) {
            cur = cur.left;
        } else {
            cur = cur.right;
        }
    }

    if (val > pre.val) {
        pre.right = new TreeNode(val);
    } else {
        pre.left = new TreeNode(val);
    }

    return root;
}
```

这里使用的是迭代法，也可以使用下面的递归法：

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
  	if (root == null) {
    		return new TreeNode(val);
  	}

  	if (root.val > val) {
    		root.left = insertIntoBST(root.left, val);
  	} else {
    		root.right = insertIntoBST(root.right, val);
  	}

  	return root;
}
```

### 剑指 Offer II 053. 二叉搜索树中的中序后继

![image-20220712155331148](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712155331148.png)

本题要搜寻一个节点的中序后继，我们知道二叉搜索树的中序遍历是一个有序序列，因此最直接的办法就是中序遍历一遍后产生一个序列，然后在序列中利用二分搜索找到目标节点的下标，之后再找到它的前一个节点，时间和空间复杂度均为 $O(n)$。

但是，由于本题强调目标节点和返回值都是 TreeNode 类型，因此上述方法有些麻烦，我们考虑其他办法，是否能够在中序遍历时就找到这个节点呢？

答案肯定是可以的，根据二叉搜索树的性质，首先我们要在二叉搜索树中找到目标节点，

### 力扣 450. 删除二叉搜索树中的节点

![image-20220712154231078](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712154231078.png)

删除二叉搜索树的节点也是二叉搜索树的基本操作了，但是却比其他基本草最都要复杂一些。

删除二叉搜索树的基本方法有两种：

* 找到待删除节点的**右子树的最左边的节点** x，让 x 和待删除节点交换，这样待删除节点就在最后一层了，此时删掉待删除节点
* 找到待删除节点的**左子树的最右边的节点** x，让 x 和待删除节点交换，这样待删除节点就在最后一层了，此时删掉待删除节点



### 剑指 Offer 33.二叉搜索树的后序遍历序列

![image-20220701150238120](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220701150238120.png)

我们首先思考一下后序遍历的特性，它是：左->右->根的顺序遍历，所以树根一定是最后一个元素。

再来思考一下二叉搜索树的特性，左边比根小，右边比根大；结合后序遍历的特性，我们知道左子树一定都比根小，那么找到第一个比根大的就是右子树的开始。

二叉搜索树还有一个特性就是它的左右子树也都是二叉搜索树，因此我们可以递归验证。

那么怎么样才算是无效的二叉搜索树呢？我们找到右子树的开头后，再搜索一遍右子树，如果右子树里有比根小的，我们就认为它不是一棵二叉搜索树。

代码实现如下：

```java
public boolean verifyPostorder(int[] postorder) {
    return verifyPostorder(postorder, 0, postorder.length - 1);
}

private boolean verifyPostorder(int[] postorder, int start, int end) {
    if (start >= end) {
        return true;
    }

    int rightIdx = start;
    while (postorder[rightIdx] < postorder[end]) {
        rightIdx++;
    }

    int t = rightIdx;
    while (t < end && postorder[t] > postorder[end]) {
        t++;
    }
    if (t != end) {
        return false;
    }

    return verifyPostorder(postorder, start, rightIdx - 1) && verifyPostorder(postorder, rightIdx, end - 1);
}
```

### 剑指 Offer 36. 二叉搜索树与双向链表

![image-20220703094156300](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703094156300.png)

本题要将一棵二叉搜索树转换为一个有序的双向链表，我们立马想到 BST 的中序遍历的结果就是一个有序序列，因此本题采用中序序列；本题还要求我们返回最小的那个节点（链表的头节点），因此我们需要借助全局变量来实现。

具体来说，设置一个 pre 变量记录当前节点的前一个遍历到的节点，然后设置一个 head 作为头节点。

对于任意一个当前遍历到的节点 cur，pre 是它的前一个，因此 pre.right = cur，cur.left = pre，然后 pre = cur 即可。

但是，pre 有可能为空，什么情况为空呢？就是第一次遍历到最左边的节点的时候，此时我们才刚刚找到 head，因此此时做特殊处理。

代码实现如下：

```java
private Node pre;

private Node head;

public Node treeToDoublyList(Node root) {
    if (root == null) {
        return null;
    }

    dfs(root);

    head.left = pre;
    pre.right = head;

    return head;
}

private void dfs(Node cur) {
    if (cur == null) {
        return;
    }

    dfs(cur.left);

    if (pre == null) {
        head = cur;
    } else {
        pre.right = cur;
    }
    cur.left = pre;
    pre = cur;

    dfs(cur.right);
}
```

### 剑指 Offer 54. 二叉搜索树的第k大节点

![image-20220707151309228](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220707151309228.png)

本题只要掌握了二叉搜索树的性质，就可以秒杀。

二叉搜索树的中序遍历是递增的，因此我们中序遍历一遍就可以得到结果了。

代码实现如下：

```java
private List<Integer> list = new ArrayList<>();

public int kthLargest(TreeNode root, int k) {
    inorder(root);
    return list.get(list.size() - k);
}

private void inorder(TreeNode root) {
    if (root == null) {
        return;
    }

    inorder(root.left);

    list.add(root.val);

    inorder(root.right);
}
```

### 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 & 力扣 235. 二叉搜索树的最近公共祖先

![image-20220706101344016](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706101344016.png)

要找两个节点的公共祖先，通常会有三种情况：

1. p，q 分别在 root 的两边，比如题目给的例子的 2 和 8，或者 2 和 9,4 和 7 等等，它们的祖先就是 root。
2. p，q 在 root 的左侧，此时，如果 p，q 有一个就是 root，那么祖先就是它，否则，还要递归左子树寻找。
3. p，q 在 root 的右侧，此时，如果 p，q 有一个就是 root，那么祖先就是它，否则，还要递归右子树寻找。

那么根据上面的分析，我们就可以写出代码：

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) {
        return null;
    }

    if (root.val == p.val) {
        return p;
    }

    if (root.val == q.val) {
        return q;
    }

    if ((root.val > p.val && root.val < q.val) || (root.val < p.val && root.val > q.val)) {
        return root;
    } else if (root.val > p.val && root.val > q.val) {
        return lowestCommonAncestor(root.left, p, q);
    } else {
        return lowestCommonAncestor(root.right, p, q);
    }
}
```

### 力扣 95. 不同的二叉搜索树 II

![image-20220712144043884](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220712144043884.png)

本题主要是需要灵活运用二叉搜索树的性质。

二叉搜索树的性质为：

1. 二叉搜索树的左右子树都比根小
2. 二叉搜索树的左右子树也是二叉搜索树

而由于节点都是给定且连续的，因此一旦选择一个数 i 作为树根，那么它的左右子树有哪些节点我们很快就能得出。

基于此，我们可以写出递归算法：

```java
public List<TreeNode> generateTrees(int n) {
    if (n == 0) {
        return new ArrayList<TreeNode>();
    }

    return buildTree(1, n);
}

private List<TreeNode> buildTree(int start, int end) {
    List<TreeNode> ans = new ArrayList<>();

    if (start > end) {
        ans.add(null);
        return ans;
    }

    for (int root = start; root <= end; ++root) {
      	// 构建所有的左子树
        List<TreeNode> leftTrees = buildTree(start, root - 1);
      
      	// 构建所有的右子树
        List<TreeNode> rightTrees = buildTree(root + 1, end);

      	// 将左右子树组合起来
        for (TreeNode left : leftTrees) {
            for (TreeNode right : rightTrees) {
                    TreeNode rootNode = new TreeNode(root);
                    rootNode.left = left;
                    rootNode.right = right;
                    ans.add(rootNode);
            }
        }
    }

    return ans;
}
```

## 3. 前缀树

Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。

字典树经常用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

**Trie 树本质上就是一棵从二叉树衍生出来的多叉树**。

假设二叉树结点定义是这样的：

```java
class Node {
    int val;
    Node left, right;
}
```

那么多叉树就是：

```java
class Node {
    int val;
    Node[] children;
}
```

字典树中的每个节点也是一个多叉树节点，但是数组大小是固定的：

```java
class TrieNode {
    boolean end
    TrieNode[] children = new TrieNode[256];
}
```

长度为 256，表示 ASCII 字符一共有 256 个，如果选用其他字符集，则可以设置的更大，当然，如果只保存小写英文字母，则可以更小。

**但是和之前的普通多叉树节点不同，`TrieNode` 中 `children` 数组的索引是有意义的，代表键中的一个字符**。

比如说 `children[97]` 如果非空，说明这里存储了一个字符 `'a'`，因为 `'a'` 的 ASCII 码为 97。

一棵字典树可能是这样的：

![image-20220422164634188](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422164634188.png)

省略空节点不画，一棵经典的字典树长这样：

![image-20220422195712566](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422195712566.png)

字典树是共享前缀的，这意味着节点需要有一个标志来保存它是否是一个插入的单词，我们可以用一个布尔型的量完成这个操作。

### 力扣 208 实现 Trie（前缀树）

![image-20220422232025566](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422232025566.png)

根据上面的理论，实现代码如下：

```java
class Trie {
    private static class TrieNode {
        boolean end;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode p = root;
        for (char ch : word.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                p.children[ch - 'a'] = new TrieNode();
            }
            p = p.children[ch - 'a'];
        }
        p.end = true;
    }
    
    public boolean search(String word) {
        TrieNode p = root;
        for (char ch : word.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                return false;
            } 
            p = p.children[ch - 'a'];
        }
        return p.end;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (char ch : prefix.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                return false;
            }
            p = p.children[ch - 'a'];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

注意，end 标志是用于标识单词的，假设插入了 apple 这个单词，但是没有插入 app 这个单词，那么虽然它们前缀相同，但是搜索 app 时不能返回 true。

### 力扣 211 添加与搜索单词 - 数据结构设计

![image-20220422231958387](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422231958387.png)

本题的难点在于通配符匹配，当碰到通配符时，必须搜索该层每一个不为空的孩子，因此可以采取深度优先搜索的方式：

```java
private boolean dfs(String word, TrieNode node, int idx) {
    if (idx == word.length()) {
        return node.end;
    }

    char ch = word.charAt(idx);
    if (ch == '.') {
        for (int i = 0; i < 26; i++) {
            if (node.children[i] != null && dfs(word, node.children[i], idx + 1)) {
                return true;
            }
        }
        return false;
    } else {
        if (node.children[ch - 'a'] == null) {
            return false;
        }
        return dfs(word, node.children[ch - 'a'], idx + 1);
    }
}
```

其他代码就和 Trie 没什么差别了：

```java
class WordDictionary {
    private static class TrieNode {
        boolean end;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();

    }
    
    public void addWord(String word) {
        TrieNode p = root;
        for (char ch : word.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                p.children[ch - 'a'] = new TrieNode();
            }
            p = p.children[ch - 'a'];
        }
        p.end = true;
    }
    
    public boolean search(String word) {
        return dfs(word, root, 0);
    }
    
    // ...
}
```

### 力扣 677 键值映射

![image-20220422231925006](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422231925006.png)

本题可以使用 DFS 或 BFS 解决：

```java
class MapSum {
    private static class TrieNode {
        int val;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public MapSum() {
        root = new TrieNode();
    }

    public void insert(String key, int val) {
        TrieNode p = root;
        for (char ch : key.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                p.children[ch - 'a'] = new TrieNode();
            }
            p = p.children[ch - 'a'];
        }
        p.val = val;
    }

    public int sum(String prefix) {
        TrieNode p = root;
        for (char ch : prefix.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                return 0;
            }
            p = p.children[ch - 'a'];
        }

        int sum = 0;
        Deque<TrieNode> queue = new ArrayDeque<>();
        queue.add(p);

        while (!queue.isEmpty()) {
            int sz = queue.size();
            while (sz-- > 0) {
                TrieNode cur = queue.poll();
                for (TrieNode node : cur.children) {
                    if (node != null) {
                        queue.add(node);
                    }
                }
                sum += cur.val;
            }
        }

        return sum;
    }
}
```

### 力扣 648 单词替换

![image-20220422231813380](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220422231813380.png)

本题很明显需要使用前缀树，但是需要一点特殊的处理，具体来说，在进行前缀搜索时，如果搜索到最小前缀，要立即返回；如果未搜索到前缀，返回原本的单词。

```java
class TrieTree {
    static class TrieNode {
        boolean end;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode head;

    public TrieTree() {
        head = new TrieNode();
    }

    public void insert(String key) {
        TrieNode p = head;
        for (char ch : key.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                p.children[ch - 'a'] = new TrieNode();
            }
            p = p.children[ch - 'a'];
        }
        p.end = true;
    }

    public String search(String key) {
        TrieNode p = head;
        StringBuilder prefix = new StringBuilder();
        for (char ch : key.toCharArray()) {
            if (p.children[ch - 'a'] == null) {
                return key;
            }
            p = p.children[ch - 'a'];
            prefix.append(ch);
            if (p.end) {
                return prefix.toString();
            }
        }
        return prefix.toString();
    }
}
```

```java
public String replaceWords(List<String> dictionary, String sentence) {
    TrieTree trie = new TrieTree();
    for (String s : dictionary) {
        trie.insert(s);
    }

    StringBuilder sb = new StringBuilder();
    for (String word : sentence.split(" ")) {
        String prefix = trie.search(word);
        sb.append(prefix + " ");
    }
    return sb.deleteCharAt(sb.length() - 1).toString();
}
```

### 力扣 139. 单词拆分

![image-20220714105758404](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714105758404.png)

本题看到字符串和前缀匹配，就立马想到字典树，先实现一个再说：

```java
class Trie {
    static class Node {
        boolean end;
        Node[] children = new Node[256];
    }

    private Node root;

    public Trie() {
        root = new Node();
    }

    public void insert(String word) {
        Node pRoot = root;
        char[] chs = word.toCharArray();

        for (char ch : chs) {
            if (pRoot.children[ch - 'a'] == null) {
                pRoot.children[ch - 'a'] = new Node();
            }
            pRoot = pRoot.children[ch - 'a'];
        }
        pRoot.end = true;
    }

    public boolean search(String word) {
        Node pRoot = root;
        char[] chs = word.toCharArray();

        for (char ch : chs) {
            if (pRoot.children[ch - 'a'] == null) {
                return false;
            }
            pRoot = pRoot.children[ch - 'a'];
        }
        return pRoot.end;
    }
}
```

然后，我们考虑怎么匹配。

首先，使用把 wordDict 的每个单词都添加到字典树中，完成字典树的初始化。

之后，我们使用回溯进行搜索，对于每个单词来说，如果当前目标串的长度还不到单词的长度，那么肯定不是，直接返回 false；如果长度大于或等于，则可以进行前缀判定，如果按照当前单词的长度截取目标串在字典树中能够搜寻到，那么就认为当前可以被拆分。

拆分后继续 dfs 搜索即可。

需要注意的是，这个过程中包含了大量重复判断，因此我们可以使用一个 Map 来记忆化搜索，实现如下：

```java
public boolean wordBreak(String s, List<String> wordDict) {
    Trie root = new Trie();

    for (String word : wordDict) {
        root.insert(word);
    }

    Map<String, Boolean> cache = new HashMap<>();
    return dfs(root, s, wordDict, cache);
}

private boolean dfs(Trie root, String target, List<String> wordDict, Map<String, Boolean> cache) {
    if (cache.containsKey(target)) {
        return cache.get(target);
    }

    if (target.length() == 0) {
        return true;
    }

    boolean flag = false;

    for (String word : wordDict) {
        if (word.length() > target.length()) {
            continue;
        }

        if (root.search(target.substring(0, word.length()))) {
            flag = flag || dfs(root, target.substring(word.length()), wordDict, cache);
            if (flag) {
                break;
            }
        }
    }

    cache.put(target, flag);

    return flag;
}
```

