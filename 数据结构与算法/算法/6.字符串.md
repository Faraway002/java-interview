# 字符串

字符串本质上是字符数组，因此适用于数组的方法也一般适用于字符串，但是字符串还是有独属于字符串的特殊算法。

## 力扣 344 反转字符串

![image-20220418203832700](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220418203832700.png)

本题可以说是前后指针的入门题，设置一前一后两个指针，在相遇之前不断交换即可：

```java
public void reverseString(char[] s) {
    int left = 0, right = s.length - 1;
    // 闭区间，left == right 时就需要退出
    while (left < right) {
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;

        left++;
        right--;
    }
}
```

## 力扣 541 反转字符串Ⅱ

![image-20220418214853767](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220418214853767.png)

344 的升级版，直接按照题意模拟即可：

```java
public String reverseStr(String s, int k) {
    char[] chs = s.toCharArray();

    for (int i = 0; i < chs.length; i += 2 * k) {
        if (i + k <= s.length()) {
            reverseStr(chs, i, i + k - 1);
            continue;
        }
        reverseStr(chs, i, chs.length - 1);
    }

    return new String(chs);
}

private void reverseStr(char[] arr, int start, int end) {
    while (start < end) {
        char temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;

        start++;
        end--;
    }
}
```

## 剑指 Offer 05 替换空格

![image-20220418204054030](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220418204054030.png)

本题比较巧妙，首先统计空格的数量，因为空格要被替换为 `%20`，因此一个空格需要额外的两个空间，统计空格的数量后就可以不浪费空间分配一个新数组。

然后，从原数组的最后开始遍历，设置一个指针，并且在新数组最后也设置一个指针，当原数组指针碰到空格时，新数组直接写入 `%20` 三个字符，这样的话两个指针的位置最后会重合，此时没遍历到的字符里就不会存在空格了。

```java
public String replaceSpace(String s) {
    char[] chs = s.toCharArray();

    int cnt = 0;
    for (char ch : chs) {
        if (ch == ' ') {
            cnt++;
        }
    }

    char[] ans = new char[chs.length + cnt * 2];
    int ansIdx = ans.length - 1;
    int chsIdx = chs.length - 1;
    while (ansIdx != chsIdx) {
        if (chs[chsIdx] != ' ') {
            ans[ansIdx--] = chs[chsIdx--];
        } else {
            ans[ansIdx--] = '0';
            ans[ansIdx--] = '2';
            ans[ansIdx--] = '%';
            chsIdx--;
        }
    }

    while (ansIdx >= 0) {
        ans[ansIdx--] = chs[chsIdx--];
    }

    return new String(ans);
}
```

## 剑指 Offer Ⅱ 58 左旋转字符串

![image-20220418214611867](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220418214611867.png)

本题很有意思，可以证明，先反转字符串的前一部分，再反转字符串的后一部分，最后整体反转，就是左旋的结果。

```java
public String reverseLeftWords(String s, int n) {
    char[] ch = s.toCharArray();
    reverse(ch, 0, n - 1);
    reverse(ch, n, ch.length - 1);
    reverse(ch, 0, ch.length - 1);

    return new String(ch);
}

private void reverse(char[] ch, int start, int end) {
    while (start < end) {
        char temp = ch[start];
        ch[start++] = ch[end];
        ch[end--] = temp;
    }
}
```

## 力扣 151 颠倒字符串里的单词

![image-20220418215121362](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220418215121362.png)

本题和上一题相反，先反转整个字符串，再把每个单词反转就 OK 了；当然，也可以先反转每个字符串，再整个反转。

本题还有一个难点，就是单词之间的空格必须只能有一个，整个字符串的首尾也不允许有多余的空格存在，那么首先我们要做的就是把字符串多余的空格清除掉。这也是有技巧的，首先利用前后指针去除多余空格，然后利用快慢指针去除重复空格：

```java
private char[] removeSpace(char[] ch) {
    int l = 0, r = ch.length - 1;
    while (ch[l] == ' ') {
        l++;
    }

    while (ch[r] == ' ') {
        r--;
    }

    int slow = l, fast = l;
    while (fast < r + 1) {
        if (ch[fast] == ' ') {
            while (fast + 1 <= r && ch[fast + 1] == ' ') {
                fast++;
            }
        }
        ch[slow++] = ch[fast++];
    }
    return Arrays.copyOf(ch, slow);
}
```

单个单词的反转很好写：

```java
private void reverseWord(char[] arr, int start, int end) {
    while (start < end) {
        char temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;

        start++;
        end--;
    }
}
```

整体流程：

```java
public String reverseWords(String s) {
    char[] ch = s.strip().toCharArray();

    ch = removeSpace(ch);

    // 整体反转
    reverseWord(ch, 0, ch.length - 1);

    int start = 0;
    for (int i = 0; i < ch.length; ++i) {
        if (ch[i] == ' ') {
            reverseWord(ch, start, i - 1);
            start = i + 1;
        }
    }

    // 反转最后一个单词
    reverseWord(ch, start, ch.length - 1);

    return new String(ch);
}
```

## 力扣 28 实现 strStr()

![image-20220419105102673](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220419105102673.png)

本题考点在于字符串匹配的 KMP 算法，我们已经讲过 KMP 算法的原理和实现，下面直接给出代码：

```java
public int strStr(String mainStr, String subStr) {
    if ("".equals(subStr)) {
        return 0;
    }

    if ("".equals(mainStr)) {
        return -1;
    } 

    char[] mainChars = mainStr.toCharArray();
    char[] subChars = subStr.toCharArray();

    return kmp(mainChars, subChars);
}

private int kmp(char[] main, char[] sub) {
    // 获取部分匹配表
    int[] next = getNextArray(sub);

    for (int i = 0, j = 0; i < main.length; i++){
        // 当字符不匹配时，不断回溯 j 使得有一个 j 能够和主串匹配
        // 或者 j = 0 时，此时子串指针已经回到了最初的位置，不用继续回溯了
        while (j > 0 && main[i] != sub[j]) {
            // 注意，虽然图解中计算公式是 j 往前移动“已匹配长度 - next[j - 1]”
            // 即 (j - next[j - 1])，因为 j 是数组下标，表示长度的时候要 + 1，而已匹配的最后一个字符的下标是 j - 1，因此已匹配长度就是 j
            // 这是往前移动的步数，因此真正的位置就是：j - (j - next[j - 1]) = next[j - 1]
            j = next[j - 1];
        }
        // 如果匹配，子串指针向前移动
        if (main[i] == sub[j]){
            j++;
        }

        // 说明：走到这里时，有可能 i 和 j 都还没有移动，这是因为首字母就不匹配，需要找到一个匹配的字符才能继续

        // 如果子串指针来到了最终位置，说明匹配完成，返回结果
        if (j == sub.length){
            return i - j + 1;
        }
    }

    return -1;
}

private int[] getNextArray(char[] str) {
    int[] next = new int[str.length];

    // next[0] 一定为 0
    next[0] = 0;

    // 从 next[1] 开始计算
    for (int i = 1, j = 0; i < str.length; ++i) {
        // 如果 str[i] != str[j]，说明前后字符不同
        // 让 j = next[j - 1]，即让前面的指针向前回溯一部分，直到 j 回到起点，说明没有重复的字符了；或者找到了重复的字符
        while (j > 0 && str[i] != str[j]) {
            j = next[j - 1];
        }

        // 相同，可以直接 + 1
        if (str[i] == str[j]) {
            j++;
        }

        // j 此时有可能是 0，说明没有重复的字符
        next[i] = j;
    }

    return next;
}
```

## 力扣 459 重复的子字符串

![image-20220419105853359](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220419105853359.png)

本题需要对 KMP 算法的 next 数组有深刻的理解，比如字符串 `ababababab`，它是一个符合要求的字符串，我们来看一下它的 next 数组：

| a    | ab   | aba  | abab | ababa | ababab | abababa | abababab | ababababa | ababababab |
| ---- | ---- | ---- | ---- | ----- | ------ | ------- | -------- | --------- | ---------- |
| 0    | 0    | 1    | 2    | 3     | 4      | 5       | 6        | 7         | 8          |

如果一个字符串有重复，则整个字符串的最长相同前后缀的长度一定是之前重复的部分。

这可以直接使用字符串长度减去最长相同前后缀的长度，最后得到的部分能够被字符串长度整除，则说明重复。

```java
public boolean repeatedSubstringPattern(String s) {
    int n = s.length();

    if (n == 1) {
        return false;
    }

    int[] next = getNext(s.toCharArray());

    if (next[n - 1] != 0 && n % (n - next[n - 1]) == 0) {
        return true;
    } else {    
        return false;
    }
}

private int[] getNext(char[] s) {
    int[] next = new int[s.length];

    next[0] = 0;
    for (int i = 1, j = 0; i < s.length; ++i) {
        while (j > 0 && s[j] != s[i]) {
            j = next[j - 1];
        }

        if (s[j] == s[i]) {
            j++;
        }

        next[i] = j;
    }

    return next;
}
```

