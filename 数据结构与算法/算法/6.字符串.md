# 字符串

字符串本质上是字符数组，因此适用于数组的方法也一般适用于字符串，但是字符串还是有独属于字符串的特殊算法。

## 力扣 344 反转字符串

![image-20220418203832700](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220418203832700.png)

本题可以说是前后指针的入门题，设置一前一后两个指针，在相遇之前不断交换即可：

```java
public void reverseString(char[] s) {
    int left = 0, right = s.length - 1;
    // 闭区间，left == right 时就需要退出
    while (left < right) {
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;

        left++;
        right--;
    }
}
```

## 力扣 541 反转字符串Ⅱ

![image-20220418214853767](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220418214853767.png)

344 的升级版，直接按照题意模拟即可：

```java
public String reverseStr(String s, int k) {
    char[] chs = s.toCharArray();

    for (int i = 0; i < chs.length; i += 2 * k) {
        if (i + k <= s.length()) {
            reverseStr(chs, i, i + k - 1);
            continue;
        }
        reverseStr(chs, i, chs.length - 1);
    }

    return new String(chs);
}

private void reverseStr(char[] arr, int start, int end) {
    while (start < end) {
        char temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;

        start++;
        end--;
    }
}
```

## 剑指 Offer 05.替换空格

![image-20220418204054030](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220418204054030.png)

本题比较巧妙，首先统计空格的数量，因为空格要被替换为 `%20`，因此一个空格需要额外的两个空间，统计空格的数量后就可以不浪费空间分配一个新数组。

然后，从原数组的最后开始遍历，设置一个指针，并且在新数组最后也设置一个指针，当原数组指针碰到空格时，新数组直接写入 `%20` 三个字符，这样的话两个指针的位置最后会重合，此时没遍历到的字符里就不会存在空格了。

```java
public String replaceSpace(String s) {
    char[] chs = s.toCharArray();

    int cnt = 0;
    for (char ch : chs) {
        if (ch == ' ') {
            cnt++;
        }
    }

    char[] ans = new char[chs.length + cnt * 2];
    int ansIdx = ans.length - 1;
    int chsIdx = chs.length - 1;
    while (ansIdx != chsIdx) {
        if (chs[chsIdx] != ' ') {
            ans[ansIdx--] = chs[chsIdx--];
        } else {
            ans[ansIdx--] = '0';
            ans[ansIdx--] = '2';
            ans[ansIdx--] = '%';
            chsIdx--;
        }
    }

    while (ansIdx >= 0) {
        ans[ansIdx--] = chs[chsIdx--];
    }

    return new String(ans);
}
```

## 剑指 Offer 20.表示数值的字符串

![image-20220629161356476](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220629161356476.png)

![image-20220629161418911](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220629161418911.png)

本题是经典的确定有限自动机的应用，确定有限状态自动机（DFA）是一类计算模型。它包含一系列状态，这些状态中：

* 有一种特殊的状态，被称作初始状态。
* 还有一系列状态被称为接受状态，它们组成了一个特殊的集合。

其中，一个状态可能既是初始状态，也是接受状态。

起初，这个自动机处于初始状态。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的**转移规则**，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。

当字符串全部读取完毕后，如果自动机处于某个接受状态，则判定该字符串被接受；否则，判定该字符串被拒绝。

自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。

按照字符串从左到右的顺序，定义以下 9 种状态：

* 开始的空格
* 幂符号前的正负号
* 小数点前的数字
* 小数点、小数点后的数字
* 当小数点前为空格时，小数点、小数点后的数字
* 幂符号
* 幂符号后的正负号
* 幂符号后的数字
* 结尾的空格

![image-20220629162129467](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220629162129467.png)

最后处理完所有的字符，如果状态处于 2 3 7 8，则认为是正确的字符串。

代码实现如下：

```java
public boolean isNumber(String s) {
  	Map[] states = {
    		new HashMap<>() {{ put(' ', 0); put('s', 1); put('d', 2); put('.', 4); }}, // 0.
    		new HashMap<>() {{ put('d', 2); put('.', 4); }},                           // 1.
    		new HashMap<>() {{ put('d', 2); put('.', 3); put('e', 5); put(' ', 8); }}, // 2.
    		new HashMap<>() {{ put('d', 3); put('e', 5); put(' ', 8); }},              // 3.
    		new HashMap<>() {{ put('d', 3); }},                                        // 4.
    		new HashMap<>() {{ put('s', 6); put('d', 7); }},                           // 5.
    		new HashMap<>() {{ put('d', 7); }},                                        // 6.
    		new HashMap<>() {{ put('d', 7); put(' ', 8); }},                           // 7.
    		new HashMap<>() {{ put(' ', 8); }}                                         // 8.
  	};
  	int p = 0;
  	char t;
  	for (char c : s.toCharArray()) {
    		if (c >= '0' && c <= '9') {
          	t = 'd';
        }
    		else if (c == '+' || c == '-') {
          	t = 's';
        }
    		else if (c == 'e' || c == 'E') {
          	t = 'e';
        }
    		else if (c == '.' || c == ' ') {
          	t = c;
        }
    		else {
          	t = '?';
        }
      
    		if (!states[p].containsKey(t)) {
          	return false;
        }
    		p = (int) states[p].get(t);
  	}
  
  	return p == 2 || p == 3 || p == 7 || p == 8;
}
```

如果觉得这样太复杂，也有比较直观的代码：

```java
public boolean isNumber(String s) {
    // 去除首尾空格
    s = s.trim();

    char[] chs = s.toCharArray();

    // 使用三个标记记录是否遇到数字，遇到 .，遇到 e 或 E
    boolean isNum = false, isDot = false, isE = false;

    for (int i = 0; i < chs.length; ++i) {
        if (chs[i] >= '0' && chs[i] <= '9') {
            isNum = true;
        } else if (chs[i] == '+' || chs[i] == '-') {
            // 如果遇到 + 或 -，则它只能出现在第一个或 e 的后面一个
            if (i != 0 && chs[i - 1] != 'e' && chs[i - 1] != 'E') {
                return false;
            }
        } else if (chs[i] == '.') {
            // 如果遇到 . ，则前面不能有 . ，也不能出现 e 或 E
            if (isDot || isE) {
                return false;
            }
            isDot = true;
        } else if (chs[i] == 'e' || chs[i] == 'E') {
            // 如果遇到 e 或 E，则前面不能再出现 e 或 E，并且前面必须有数字
            if (isE || !isNum) {
                return false;
            }
            isE = true;
            // e 之后必须也是数字
            isNum = false;
        } else {
            return false;
        }
    }

    return isNum;

}
```

## 剑指 Offer 58 - II. 左旋转字符串

![image-20220418214611867](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220418214611867.png)

本题很有意思，可以证明，先反转字符串的前一部分，再反转字符串的后一部分，最后整体反转，就是左旋的结果。

```java
public String reverseLeftWords(String s, int n) {
    char[] chs = s.toCharArray();

    reverse(chs, 0, n - 1);
    reverse(chs, n, chs.length - 1);
    reverse(chs, 0, chs.length - 1);

    return new String(chs);
}

private void reverse(char[] chs, int l, int r) {
    while (l <= r) {
        char temp = chs[l];
        chs[l] = chs[r];
        chs[r] = temp;

        l++;
        r--;
    }
}
```

## 力扣 151 颠倒字符串里的单词

![image-20220418215121362](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220418215121362.png)

本题和上一题相反，先反转整个字符串，再把每个单词反转就 OK 了；当然，也可以先反转每个字符串，再整个反转。

本题还有一个难点，就是单词之间的空格必须只能有一个，整个字符串的首尾也不允许有多余的空格存在，那么首先我们要做的就是把字符串多余的空格清除掉。这也是有技巧的，首先利用前后指针去除多余空格，然后利用快慢指针去除重复空格：

```java
private char[] removeSpace(char[] ch) {
    int l = 0, r = ch.length - 1;
    while (ch[l] == ' ') {
        l++;
    }

    while (ch[r] == ' ') {
        r--;
    }

    int slow = l, fast = l;
    while (fast < r + 1) {
        if (ch[fast] == ' ') {
            while (fast + 1 <= r && ch[fast + 1] == ' ') {
                fast++;
            }
        }
        ch[slow++] = ch[fast++];
    }
    return Arrays.copyOf(ch, slow);
}
```

单个单词的反转很好写：

```java
private void reverseWord(char[] arr, int start, int end) {
    while (start < end) {
        char temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;

        start++;
        end--;
    }
}
```

整体流程：

```java
public String reverseWords(String s) {
    char[] ch = s.strip().toCharArray();

    ch = removeSpace(ch);

    // 整体反转
    reverseWord(ch, 0, ch.length - 1);

    int start = 0;
    for (int i = 0; i < ch.length; ++i) {
        if (ch[i] == ' ') {
            reverseWord(ch, start, i - 1);
            start = i + 1;
        }
    }

    // 反转最后一个单词
    reverseWord(ch, start, ch.length - 1);

    return new String(ch);
}
```

## 力扣 28 实现 strStr()

![image-20220419105102673](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220419105102673.png)

本题考点在于字符串匹配的 KMP 算法，我们已经讲过 KMP 算法的原理和实现，下面直接给出代码：

```java
public int strStr(String mainStr, String subStr) {
    if ("".equals(subStr)) {
        return 0;
    }

    if ("".equals(mainStr)) {
        return -1;
    } 

    char[] mainChars = mainStr.toCharArray();
    char[] subChars = subStr.toCharArray();

    return kmp(mainChars, subChars);
}

private int kmp(char[] main, char[] sub) {
    // 获取部分匹配表
    int[] next = getNextArray(sub);

    for (int i = 0, j = 0; i < main.length; i++){
        // 当字符不匹配时，不断回溯 j 使得有一个 j 能够和主串匹配
        // 或者 j = 0 时，此时子串指针已经回到了最初的位置，不用继续回溯了
        while (j > 0 && main[i] != sub[j]) {
            // 注意，虽然图解中计算公式是 j 往前移动“已匹配长度 - next[j - 1]”
            // 即 (j - next[j - 1])，因为 j 是数组下标，表示长度的时候要 + 1，而已匹配的最后一个字符的下标是 j - 1，因此已匹配长度就是 j
            // 这是往前移动的步数，因此真正的位置就是：j - (j - next[j - 1]) = next[j - 1]
            j = next[j - 1];
        }
        // 如果匹配，子串指针向前移动
        if (main[i] == sub[j]){
            j++;
        }

        // 说明：走到这里时，有可能 i 和 j 都还没有移动，这是因为首字母就不匹配，需要找到一个匹配的字符才能继续

        // 如果子串指针来到了最终位置，说明匹配完成，返回结果
        if (j == sub.length){
            return i - j + 1;
        }
    }

    return -1;
}

private int[] getNextArray(char[] str) {
    int[] next = new int[str.length];

    // next[0] 一定为 0
    next[0] = 0;

    // 从 next[1] 开始计算
    for (int i = 1, j = 0; i < str.length; ++i) {
        // 如果 str[i] != str[j]，说明前后字符不同
        // 让 j = next[j - 1]，即让前面的指针向前回溯一部分，直到 j 回到起点，说明没有重复的字符了；或者找到了重复的字符
        while (j > 0 && str[i] != str[j]) {
            j = next[j - 1];
        }

        // 相同，可以直接 + 1
        if (str[i] == str[j]) {
            j++;
        }

        // j 此时有可能是 0，说明没有重复的字符
        next[i] = j;
    }

    return next;
}
```

## 力扣 459 重复的子字符串

![image-20220419105853359](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220419105853359.png)

本题需要对 KMP 算法的 next 数组有深刻的理解，比如字符串 `ababababab`，它是一个符合要求的字符串，我们来看一下它的 next 数组：

| a    | ab   | aba  | abab | ababa | ababab | abababa | abababab | ababababa | ababababab |
| ---- | ---- | ---- | ---- | ----- | ------ | ------- | -------- | --------- | ---------- |
| 0    | 0    | 1    | 2    | 3     | 4      | 5       | 6        | 7         | 8          |

如果一个字符串有重复，则整个字符串的最长相同前后缀的长度一定是之前重复的部分。

这可以直接使用字符串长度减去最长相同前后缀的长度，最后得到的部分能够被字符串长度整除，则说明重复。

```java
public boolean repeatedSubstringPattern(String s) {
    int n = s.length();

    if (n == 1) {
        return false;
    }

    int[] next = getNext(s.toCharArray());

    if (next[n - 1] != 0 && n % (n - next[n - 1]) == 0) {
        return true;
    } else {    
        return false;
    }
}

private int[] getNext(char[] s) {
    int[] next = new int[s.length];

    next[0] = 0;
    for (int i = 1, j = 0; i < s.length; ++i) {
        while (j > 0 && s[j] != s[i]) {
            j = next[j - 1];
        }

        if (s[j] == s[i]) {
            j++;
        }

        next[i] = j;
    }

    return next;
}
```

