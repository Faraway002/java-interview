# BFS

BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用队列这种数据结构，每次将一个节点周围的所有节点加入队列。

BFS 相对 DFS 的最主要的区别是：**BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多**。

BFS 的框架其实就是二叉树层序遍历的框架：

```java
public void BFS(Node start, Node target) {
    Queue<Node> q = new ArrayDeque<>(); 
    Set<Node> visited = new HashSet<>();
    
    // 将起点加入队列
    if (start == null) {
        return;
    }
    q.offer(start); 
    visited.add(start);

    while (q not empty) {
        int sz = q.size();
        // 将当前队列中的所有节点向四周扩散
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            // 划重点：这里判断是否到达终点
            if (cur is target) {
                // 处理
            }
            // 将 cur 的相邻节点加入队列
            for (Node x : cur.adj()) {
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
        }

        // mei'yi'c
    }
}
```

## 力扣 752 打开转盘锁

![image-20220412112521615](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412112521615.png)

本题直接套框架，BFS 能够保证第一个满足条件的一定是最小的：

```java
public int openLock(String[] deadends, String target) {
    Set<String> deads = new HashSet<>();
    for (String deadend : deadends) {
        deads.add(deadend);
    }

    Set<String> visited = new HashSet<>();
    Queue<String> queue = new LinkedList<>();

    int step = 0;
    queue.offer("0000");
    visited.add("0000");

    while (!queue.isEmpty()) {
        int sz = queue.size();

        for (int i = 0; i < sz; ++i) {
            String cur = queue.poll();

            if (deads.contains(cur)) {
                continue;
            }

            if (cur.equals(target)) {
                return step;
            }

            for (int j = 0; j < 4; ++j) {
                String up = up(cur, j);

                if (!visited.contains(up)) {
                    queue.offer(up);
                    visited.add(up);
                }

                String down = down(cur, j);

                if (!visited.contains(down)) {
                    queue.offer(down);
                    visited.add(down);
                }
            }
        }
        step++;
    }

    return -1;
}

private String up(String s, int i) {
    char[] ch = s.toCharArray();
    if (ch[i] == '9') {
        ch[i] = '0';
    } else {
        ch[i] += 1;
    }
    return new String(ch);
}

private String down(String s, int i) {
    char[] ch = s.toCharArray();
    if (ch[i] == '0') {
        ch[i] = '9';
    } else {
        ch[i] -= 1;
    }
    return new String(ch);
}
```

## 力扣 773 滑动谜题

![image-20220415105614149](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220415105614149.png)

本题需要一些技巧。

首先是 BFS，因为只有 0 这个位置能和周围的位置交换，因此首先找出 0 的位置，然后尝试和旁边的数交换：

![image-20220415105729435](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220415105729435.png)

但是这样非常低效，因为队列需要记录整个棋盘的情况。

我们想到把二维数组拉平，上图中可以拉平成 241503，但是又有一个新问题，怎么知道现在 0 的邻居呢？

由于本题棋盘的样子是固定的，因此每个位置的邻居下标也是固定的，因此可以提前记录好。

```java
private static int[][] neiborMap = {{1, 3}, {0, 2, 4}, {1, 5}, {0, 4}, {1, 3, 5}, {2, 4}};

public int slidingPuzzle(int[][] board) {  
    StringBuilder sb = new StringBuilder();
    for (int[] row : board) {
        for (int num : row) {
            sb.append(num);
        }
    }
    String boardStr = sb.toString();
    String target = "123450";

    Queue<String> queue = new LinkedList<>();
    Set<String> visited = new HashSet<>();
    int step = 0;
    queue.offer(boardStr);
    visited.add(boardStr);

    while (!queue.isEmpty()) {
        int sz = queue.size();

        for (int i = 0; i < sz; ++i) {
            String cur = queue.poll();

            if (cur.equals(target)) {
                return step;
            }

            int zeroIndex = cur.indexOf("0");
            for (int j = 0; j < neiborMap[zeroIndex].length; ++j) {
                String newBoard = swap(cur, zeroIndex, neiborMap[zeroIndex][j]);

                if (!visited.contains(newBoard)) {
                    visited.add(newBoard);
                    queue.add(newBoard);
                }
            }
        }

        step++;
    }

    return -1;
}

private String swap(String s, int i, int j) {
    char[] chs = s.toCharArray();
    char temp = chs[i];
    chs[i] = chs[j];
    chs[j] = temp;

    return new String(chs);
}
```

