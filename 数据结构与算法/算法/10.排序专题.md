# 排序专题

## 排序算法实现

数组的排序通常是通过交换两个元素来实现的，辅助方法：

```java
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

排序算法有稳定性一说，含义是如果存在多个相同的元素，排序后这几个元素的相对位置不变，那么就是稳定的排序算法。

### 冒泡排序

思想：进行 N - 1 趟排序，每一趟都从最开始和它右边的元素进行比较，交换更大的元素到后面，直到末尾。

实现：

```java
public void bubbleSort(int[] arr) {
    for (int i = arr.length - 1; i > 0; --i) {
        for (int j = 0; j < i; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
            }
        }
    }
}
```

时间复杂度：$O(n^2)$

稳定性：从实现中我们可以看出，如果碰到相等的元素，是不会进行交换的，因此它是**稳定**的排序算法。

### 选择排序

思想：首先在未排序序列中找到最小元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾，重复这个过程，就排好了。

实现：

```java
public void selectionSort(int[] arr) {
    for (int i = 1; i < arr.length; ++i) {
        int minIdx = i - 1;
        for (int j = i; i < arr.length; ++j) {
            if (arr[minIdx] > arr[j]) {
                minIdx = j;
            }
        }
        swap(arr, minIdx, i - 1);
    }
}
```

时间复杂度：$O(n^2)$

稳定性：选择排序是**不稳定**的排序算法，比如 `[5，8，5，2，9]` 这组数据，首先找到了 2 这个最小数据，然后和第一个 5 进行了交换，导致第一个 5 落在了第二个 5 的后面，所以不是稳定的排序算法。

### 插入排序

思想：将第一个元素看作一个有序序列，从第二个元素开始在有序序列中找到一个合适的位置插入，这样前两个元素都成为了有序序列，然后再从第三个元素开始...

实现：

```java
public void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; ++i) {
        int cur = arr[i];
        int j = i;
        for (; j > 0 && cur < arr[j - 1]; --j) {
            arr[j] = arr[j - 1];
        }
        arr[j] = cur;
    }
}
```

时间复杂度：最好情况下是全部有序的，第二轮循环在开始比较时就不满足条件结束了，因此是 $O(n)$，最坏情况下，很明显是 $O(n^2)$

稳定性：插入排序会在碰到相同元素后停止寻找，因此是**稳定**的排序算法。

### 希尔排序

希尔排序是插入排序的一种更高效的改进版本。

思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行直接插入排序。

时间复杂度：最好的情况下，

### 归并排序



### 快速排序



### 堆排序



### 计数排序



### 桶排序



### 基数排序

## 排序算法应用

### 力扣 4 寻找两个正序数组的中位数

![image-20220427102817089](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220427102817089.png)

本题涉及到两个有序数组的合并，这就是归并排序的归并过程，因此直接使用归并即可：

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int n1 = nums1.length, n2 = nums2.length;
    int[] merge = new int[n1 + n2];
    
    int i = 0, j = 0, k = 0;
    while (i < n1 && j < n2) {
        if (nums1[i] < nums2[j]) {
            merge[k++] = nums1[i++];
        } else {
            merge[k++] = nums2[j++];
        }         
    }
    
    while (i < n1) {
        merge[k++] = nums[i++];
    }
    
    while (j < n2) {
        merge[k++] = nums[j++];
    }
    
    if (k % 2 == 0) {
        return (merge[k / 2] + merge[k / 2 - 1]) / 2.0;
    } else {
        return merge[(int) k / 2];
    }
}
```

### 剑指 Offer 40.最小的k个数

![image-20220610104623223](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220610104623223.png)

这题最容易想到的就是排序，我们采取常用的快排即可。

本题其实还有优化空间，我们快排的要点有两个，一个是基于哨兵的划分，另一个就是递归。

如果某一轮划分结束后，哨兵恰好就处于 k + 1 的位置，那么它的前面就是我们要找到的数组，此时可以直接结束。	

### 力扣 148 排序链表

