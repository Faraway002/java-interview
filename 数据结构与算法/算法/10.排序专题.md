[TOC]

# 排序专题

## 1. 排序算法实现

数组的排序通常是通过交换两个元素来实现的，辅助方法：

```java
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

排序算法有稳定性一说，含义是如果存在多个相同的元素，排序后这几个元素的相对位置不变，那么就是稳定的排序算法。

### 冒泡排序

思想：进行 N - 1 趟排序，每一趟都从最开始和它右边的元素进行比较，交换更大的元素到后面，直到末尾。

实现：

```java
public void bubbleSort(int[] arr) {
    for (int i = arr.length - 1; i > 0; --i) {
        for (int j = 0; j < i; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
            }
        }
    }
}
```

时间复杂度：$O(n^2)$

稳定性：从实现中我们可以看出，如果碰到相等的元素，是不会进行交换的，因此它是**稳定**的排序算法。

### 选择排序

思想：首先在未排序序列中找到最小元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾，重复这个过程，就排好了。

实现：

```java
public void selectionSort(int[] arr) {
    for (int i = 1; i < arr.length; ++i) {
        int minIdx = i - 1;
        for (int j = i; i < arr.length; ++j) {
            if (arr[minIdx] > arr[j]) {
                minIdx = j;
            }
        }
        swap(arr, minIdx, i - 1);
    }
}
```

时间复杂度：$O(n^2)$

稳定性：选择排序是**不稳定**的排序算法，比如 `[5，8，5，2，9]` 这组数据，首先找到了 2 这个最小数据，然后和第一个 5 进行了交换，导致第一个 5 落在了第二个 5 的后面，所以不是稳定的排序算法。

### 插入排序

思想：将第一个元素看作一个有序序列，从第二个元素开始在有序序列中找到一个合适的位置插入，这样前两个元素都成为了有序序列，然后再从第三个元素开始...

实现：

```java
public void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; ++i) {
        int cur = arr[i];
        int j = i;
        for (; j > 0 && cur < arr[j - 1]; --j) {
            arr[j] = arr[j - 1];
        }
        arr[j] = cur;
    }
}
```

时间复杂度：最好情况下是全部有序的，第二轮循环在开始比较时就不满足条件结束了，因此是 $O(n)$，最坏情况下，很明显是 $O(n^2)$

稳定性：插入排序会在碰到相同元素后停止寻找，因此是**稳定**的排序算法。

### 希尔排序

希尔排序是插入排序的一种更高效的改进版本。

思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行直接插入排序。

时间复杂度：最好的情况下，

### 归并排序



### 快速排序



### 堆排序



### 计数排序



### 桶排序



### 基数排序

## 2. 排序相关题型

### 力扣 4. 寻找两个正序数组的中位数

![image-20220427102817089](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220427102817089.png)

本题涉及到两个有序数组的合并，这就是归并排序的归并过程，因此直接使用归并即可：

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int n1 = nums1.length, n2 = nums2.length;
    int[] merge = new int[n1 + n2];
    
    int i = 0, j = 0, k = 0;
    while (i < n1 && j < n2) {
        if (nums1[i] < nums2[j]) {
            merge[k++] = nums1[i++];
        } else {
            merge[k++] = nums2[j++];
        }         
    }
    
    while (i < n1) {
        merge[k++] = nums[i++];
    }
    
    while (j < n2) {
        merge[k++] = nums[j++];
    }
    
    if (k % 2 == 0) {
        return (merge[k / 2] + merge[k / 2 - 1]) / 2.0;
    } else {
        return merge[(int) k / 2];
    }
}
```

### 剑指 Offer 45. 把数组排成最小的数

![image-20220709105300397](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220709105300397.png)

本题本质是是一个排序问题，我们举个例子分析一下：

比如原数组是 3、30、34、1、9

* 3 和 30 的位置应该互换一下，因为 330 大于 303 ----> 30、3、34、1、9
* 3 和 34 的位置不需要换，因为 334 小于 343 ----> 30、3、34、1、9
* 34 和 1 的位置需要互换，因为 341 大于 134 ----> 30、3、1、34、9
* 34 和 9 的位置不需要换，因为 349 小于 934 ----> 30、3、1、34、9

这样其实就是一次循环走完，但是我们发现，这个 1，是不是应该放到第 1 位可能更好呢，所以，这样的循环还得再来几次，这实际上就是一个比较然后排序的过程，只不过排序规则和以前稍有不同。

排序规则为：有两个数 x 和 y，如果 "xy" > "yx"，则 x 大于 y，这里的大于的意思是应该摆在 y 前面。

那么，我们就借助 Java 内置的排序实现：

```java
public String minNumber(int[] nums) {
    String[] strs = new String[nums.length];

    for (int i = 0; i < nums.length; ++i) {
        strs[i] = String.valueOf(nums[i]);
    }

    // Java 里用 + 来完成字符串拼接
    // String.compareTo 是按字典序排序的，如果拼接起来更小，则字典序更前，反而会更大
    Arrays.sort(strs, (x, y) -> (x + y).compareTo(y + x));

    StringBuilder ans = new StringBuilder();
    for (String num : strs) {
        ans.append(num);
    }
    return ans.toString();
}
```

### 剑指 Offer 51. 数组中的逆序对

![image-20220707112833831](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220707112833831.png)

本题最直观的想法就是暴力，时间复杂度 $O(n^2)$。但是本题数据量比较大，因此肯定会超时的。

本题可以借助归并排序，归并排序在 merge 的时候正好可以统计两边的逆序对。

比如有 [1, 4, 8] 和 [0, 2, 3] 两个待合并的数组，进度已经合并到了 [0, 1, 2]，现在指针 1 指向 4，指针 2 指向 3，已经统计的逆序对数记作 cnt。

那么，现在我们知道 3 是小于 4 的，这意味着 4 及其之后的 8 都比 3 大，那么 cnt 就可以加上 2。

实现如下：

```java
private int cnt = 0;

public int reversePairs(int[] nums) {
    mergeSort(nums, 0, nums.length - 1);

    return cnt;
}

private void mergeSort(int[] nums, int start, int end) {
    if (start >= end) {
        return;
    }

    int mid = start + (end - start) / 2;
    mergeSort(nums, start, mid);
    mergeSort(nums, mid + 1, end);
    merge(nums, start, mid, end);
}

private void merge(int[] nums, int start, int mid, int end) {
    int[] temp = new int[end - start + 1];
    int i = start, j = mid + 1;
    int tempIdx = 0;
    while (i <= mid && j <= end) {
        if (nums[i] <= nums[j]) {
            temp[tempIdx++] = nums[i++];
        } else {
            temp[tempIdx++] = nums[j++];
          
          	// 这里统计逆序对
            cnt += mid - i + 1;
        }
    }

    while (i <= mid) {
        temp[tempIdx++] = nums[i++];
    }

    while (j <= end) {
        temp[tempIdx++] = nums[j++];
    }

    for (int k = 0; k < end - start + 1; ++k) {
        nums[start + k] = temp[k];
    }
}
```

### topK 问题

#### 剑指 Offer 40. 最小的k个数

![image-20220610104623223](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220610104623223.png)

本题是经典的 topK 问题，类似的题目还有找最大的 N 个数等。

以本题为例，我们来讲解一下通用的 topK 解决办法。

#### 力扣 215. 数组中的第K个最大元素

![image-20220706120341875](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706120341875.png)

#### 力扣 347. 前K个高频元素

![image-20220706120353857](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706120353857.png)

