[TOC]

# 数组

## 1. 双指针

数组题也可以使用双指针，而且一般有前后指针和快慢指针两种。

### 1.1 快慢指针

#### 力扣 26. 删除有序数组中的重复项

![image-20220406111300750](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220406111300750.png)

本题可以使用快慢指针。

设置两个指针 fast 和 slow，让 fast 指针去前面探路，**slow 指针维护不重复的数组项**，当发现 slow 和 fast 不相同时，slow++，然后就把 fast 指针的值赋给 slow，这样 fast 到最后时，arr[0 ~ slow] 数组就是一个无重复元素的数组。

代码实现如下：

```java
public int removeDuplicates(int[] nums) {
    int n = nums.length;
    int slow = 0, fast = 0;

    while (fast < n) {
        if (nums[slow] == nums[fast]) {
            fast++;
        } else {
            slow++;
            nums[slow] = nums[fast];
            fast++;
        }
    }

    return slow + 1;
}
```

#### 力扣 27. 移除元素

![image-20220406114128651](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220406114128651.png)

本题和上一题的思路类似：快指针如果碰到了 val，就往前走直到碰到一个非 val 的值为止，此时说明快指针和慢指针之间全部都是需要移除的元素，此时交换 slow 和 fast 对应的数组值，完成后两者都往前走，那么从 0 到慢指针之间的元素都是不用被删除的元素。

代码实现：

```java
public int removeElement(int[] nums, int val) {
    int n = nums.length;

    int slow = 0, fast = 0;

    while (fast < n) {
        if (nums[fast] == val) {
            fast++;
        } else {
            swap(nums, slow, fast);
            slow++;
            fast++;
        }
    }

    return slow;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

#### 力扣 283. 移动零

![image-20220406114433802](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220406114433802.png)

这题跟上一题区别就在于值固定为 0。

代码实现：

```java
public void moveZeroes(int[] nums) {
    int n = nums.length;

    int slow = 0, fast = 0;

    while (fast < n) {
        if (nums[fast] == 0) {
            fast++;
        } else {
            swap(nums, slow, fast);
            slow++;
            fast++;
        }
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

### 1.2 前后指针（左右指针）

#### 1.2.1 基础

##### 力扣 977. 有序数组的平方

![image-20220417133904332](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220417133904332.png)

本题由于负数的绝对值可能相对较大，因此直接平方肯定是不行的。

可以用一个新数组记录，然后使用左右指针指向两边，平方后比较大小，大的放在新数组最后面，然后左边前进或者右边后退。

本题数据量较小，平方不会超过 int 的范围，因此可以直接乘。

```java
public int[] sortedSquares(int[] nums) {
    int n = nums.length;
    int l = 0, r = n - 1;
    int[] ans = new int[n];
    int idx = n - 1;
    while (l <= r) {
        int sq1 = nums[l] * nums[l];
        int sq2 = nums[r] * nums[r];
        if (sq1 > sq2) {
            l++;
        } else {
            r--;
        }
        ans[idx--] = Math.max(sq1, sq2);
    }
    
    return ans;
}
```

##### 剑指 Offer 21. 调整数组顺序使得奇数位于偶数前面

![image-20220629164222296](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220629164222296.png)

本题是典型的左右指针题，我们让一个指针指向左端，另一个指针指向右端。

从左端开始，如果碰到奇数，直接左指针往右走；如果碰到偶数，则和右指针的值交换以后，右指针往左走。

代码实现如下：

```java
public int[] exchange(int[] nums) {
    int left = 0, right = nums.length - 1;

    while (left < right) {
        if (nums[left] % 2 != 0) {
            left++;
        } else {
            swap(left, right, nums);
            right--;
        }
    }

    return nums;
}
```

##### 力扣 11. 盛水最多的容器

![image-20220421103832660](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220421103832660.png)

本题的难点在于矩形的长宽都会改变，但是在宽确定的情况下，高度取决于两端最小的那端。因此，我们使用两个指针不断收缩宽，然后更新最大的矩形面积即可。

收缩时要注意贪心技巧，要让下一次得到的面积更大，就要让更小的那边有机会变得更大才行：

```java
public int maxArea(int[] height) {
    int start = 0, end = height.length - 1;
    int max = 0;
    while (start < end) {
        // end - start 是宽
        // Math.min(height[start], height[end]) 是高
        max = Math.max(max, Math.min(height[start], height[end]) * (end - start));
        if (height[start] > height[end]) {
            end--;
        } else {
            start++;
        }
    }
    return max;
}
```

#### 1.2.2 二分查找实现

二分查找是一个重要的算法思想，通过一前一后两个指针来缩短搜索所需要的时间。

##### 力扣 704. 二分查找

![image-20220407104208003](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220407104208003.png)

本题就是实现一个基本的二分查找，下面直接给出代码，但是需要注意细节：

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;
}
```

下面是有关二分查找的注意事项：

1. 为什么 mid 要像上面那样计算？

   因为数组很大的时候，`(right + left)` 有可能超出 int 的范围，这样算保证不会超范围。

2. 为什么循环条件是 `left <= right`，而不是 `<`？

   因为 right 的初始值是数组最后一个元素的索引，说明搜索区间是闭区间 `[left, right]`，如果 `left == right` 时就结束了，那么就会漏掉一种情况，导致搜索不完全。

3. 为什么 right 和 left 的更新需要加上或减去 1，而其他人写的算法有些是 right 直接等于 mid？

   还是区间问题，这里是闭区间，因此更新时 mid 处已经被搜索过，应该去除它。 

##### 力扣 34. 在排序数组中查找元素的第一个和最后一个位置

![image-20220407120306152](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220407120306152.png)

本题很明显提示使用二分，但是和普通的二分不太相同。

本题是需要搜索一个元素第一次出现的位置和最后一次出现的位置，由于它是有序的，因此该元素如果出现多次，必然是连在一起的。

如果该元素不存在，则需要返回两个 -1；如果该元素只出现一次，则返回两个相同的数（下标）。

那么我们该如何利用二分查找搜索元素第一次出现的位置呢？这个位置我们一般也叫做左边界，代码如下：

```java
private int leftBorder(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        // 继续向左寻找边界
        if (nums[mid] >= target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    if (left >= nums.length || nums[left] != target) {
        return -1;
    }
    return left;
}
```

* 精髓在于 `nums[mid] == target` 时，`right = mid - 1` 这一步处理。

  这表示**虽然找到了该元素，但是该元素有可能出现在众多相同元素的中间位置，因此还要往左边收缩找到最左边的位置**。

* 为什么返回 left？

  最后退出循环时，left 其实有以下含义：

  1. 返回的这个值是 `nums` 中大于等于 `target` 的最小元素索引。
  
  2. 返回的这个值是 `target` 应该插入在 `nums` 中的索引位置。
  2. 返回的这个值是 `nums` 中小于 `target` 的元素个数。
  
  这三个解释是等价的。

* 如何处理边界情况？

  注意，刚刚我们已经说过返回的 left 是 `nums` 中大于等于 `target` 的最小元素索引，那么，只需要检测 left 是否超范围，并且检测 `nums[left]` 是否为 target 即可。

右侧边界则是对称处理：

```java
private int rightBorder(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    if (right < 0 || nums[right] != target) {
        return -1;
    }
    return right;
}
```

主函数：

```java
public int[] searchRange(int[] nums, int target) {
    return new int[] {leftBorder(nums, target), rightBorder(nums, target)};
}
```

##### 剑指 Offer 04. 二维数组中的查找 & 力扣 240. 搜索二维矩阵Ⅱ

![image-20220623081249978](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220623081249978.png)

本题是把二分搜索拓展到了二维数组，我们可以**以左下角或右上角为支点**。

比如，我们的目标是 5，以右上角 15 为支点，15 比 5 大，那么肯定就在 15 的左边，15 所在的列肯定不可能，因此直接把 15 这一列砍掉。

接下来，我们又从新矩阵的右上角，也就是 11 为支点，11 又比 5 大，因此继续砍掉 11 这一列。

接下来，7 又比 5 大，砍掉 7 这一列。

接下来，4 比 5 小了，因此 4 这一行都不可能，直接砍掉这一行。

砍掉之后。矩阵就是这样的了：

```
[
	[2, 5],
	[3, 6],
	[10, 13],
	[18, 21]
]
```

此时，再以左上角为支点，我们发现它就等于 5，因此找到了。

事实上，这就是二分搜索的二维版本，思想是一模一样的，代码实现如下：

```java
public boolean findNumberIn2DArray(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0) {
        return false;
    }

    int row = matrix.length, col = matrix[0].length;

    int curRow = 0, curCol = col - 1;
    while (curRow < row && curCol >= 0) {
        int curNum = matrix[curRow][curCol];
        if (curNum > target) {
            curCol--;
        } else if (curNum < target) {
            curRow++;
        } else {
            return true;
        }
    }

    return false;
}
```

#### 1.2.3 滑动窗口

滑动窗口就是维护一个窗口，不断滑动，然后更新答案。

模板如下：

```java
public void slidingWindow(String s, String t) {
    Map<Character, Integer> need = new HashMap<>();
    Map<Character, Integer> window = new HashMap<>();
    
    // 使用目标串初始化 need
    for (char c : t.toCharArray) {
        need.put(c, need.getOrDefault(0, 1) + 1);
    }
    
    // 左右指针
    int left = 0, right = 0;
    // 有效数目的统计
    int valid = 0; 
    
    // right 没到末尾之前
    while (right < s.length()) {
        // 右滑
        char cur = s.charAt(right);
        right++;
        
        // 此处，根据添加的 cur 进行窗口内数据的一系列更新
        // ...
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // 缩小窗口
            char del = s[left];
            left++;
            
            // 此处，根据移除的 del 进行窗口内数据的一系列更新
            // ...
        }
    }
}
```

下面使用这个模板写三道题。

##### 力扣 76 最小覆盖子串

![image-20220409131920440](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409131920440.png)

先看解法代码，再在讲解细节：

 ```java
 public String minWindow(String s, String t) {
     Map<Character, Integer> need = new HashMap<>();
     Map<Character, Integer> window = new HashMap<>();
 
     for (char c : t.toCharArray()) {
         need.put(c, need.getOrDefault(c, 0) + 1);
     }
 
     int left = 0, right = 0;
     // 此处 valid 代表窗口内字符种类
     int valid = 0;
 	
     // 记录子串的起始位置和长度
     int start = 0, len = Integer.MAX_VALUE;
     while (right < s.length()) {
         char cur = s.charAt(right);
         right++;
 
         // 如果 cur 字符被需要
         if (need.containsKey(cur)) {
             window.put(cur, window.getOrDefault(cur, 0) + 1);
 
             // 如果窗口内 cur 的数目和 need 的字符数目相等，说明该类字符已经全了
             if (window.get(cur).equals(need.get(cur))) {
                 valid++;
             }
         }
 
         // 如果有效字符种类达到了 need，可以尝试收缩窗口
         while (valid == need.size()) {
             if (right - left < len) {
                 start = left;
                 len = right - left;
             }
             
             char del = s.charAt(left);
             left++;
 
             if (need.containsKey(cur)) { 
                 if (window.get(cur).equals(need.get(cur))) {
                     valid--;
                 }
                 window.put(cur, window.get(cur) - 1);
             }
         }
     }
     
     return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
 }
 ```

1. 我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个窗口。

   > 理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。
   >
   > 因为这样初始化 `left = right = 0` 时区间 `[0, 0)` 中没有元素，但只要让 `right` 向右移动（扩大）一位，区间 `[0, 1)` 就包含一个元素 `0` 了。如果你设置为两端都开的区间，那么让 `right` 向右移动一位后开区间 `(0, 1)` 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 `[0, 0]` 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。

2. 我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3. 此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4. 重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。

这题困难题都秒杀了，下面的题目更是不在话下。

##### 力扣 209 长度最小的子数组

![image-20220417151546831](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220417151546831.png)

本题是数组求和问题，同时又要求长度最小的子数组（不是序列），因此滑动窗口是适用的，而又涉及到数组求和，因此前缀和也是可以用于优化时间复杂度的的。

具体来说，还是维护一个窗口，窗口内的和达到了 target 就可以收缩了，没达到就继续扩张；但是由于有前缀和数组，因此不需要额外的容器作为窗口，只需维护边界指针即可。

```java
class Solution {
    private int[] preSum;

    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        preSum = new int[n + 1];
        preSum[0] = 0;
        for (int i = 1; i <= n; ++i) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }

        int left = 0, right = 0;
        int minLen = Integer.MAX_VALUE;

        while (right < n) {
            right++;

            while (sum(left, right) >= target) {
                minLen = Math.min(right - left, minLen);

                left++;
            }
        } 
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }

    private int sum(int left, int right) {
        return preSum[right] - preSum[left];
    }
}
```

##### 力扣 904 水果成篮

![image-20220417152437461](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220417152437461.png)

本题也是很明显的滑动窗口，因为一碰到不属于已采摘的水果种类就要停止，因此题目要找的是一段连续的序列。

本题的窗口维护比较有技巧性，因为必须保证窗口内的水果种类不能超过两种，同时又要允许已存在的水果种类的水果进入窗口，这样就可以通过窗口大小直接算出窗口内的水果数量。

除此之外，在收缩窗口时需要正确的收缩，保证窗口内只剩下一种水果且数量最多，因此采取了很巧妙的办法维护窗口，详情见注释。

```java
public int totalFruit(int[] fruits) {
    Deque<Integer> window = new ArrayDeque<>();

    int valid = 0;
    int left = 0, right = 0;
    int n = fruits.length;
    int maxCnt = 0;

    while (right < n) {
        int cur = fruits[right];
        right++;

        // 始终保证窗口内元素种类不超过 2，因此如果窗口已经存在的元素可以直接进入窗口
        if (window.contains(cur)) {
            window.offerLast(cur);
        } else {
            // 不包含时，判断 valid 是否大于等于 2，如果还不大于 2 可以直接进入窗口
            // 否则就要收缩
            if (valid >= 2) {
                // 先统计数量
                maxCnt = Math.max(window.size(), maxCnt);

                // 窗口最左侧的元素
                int del = fruits[left];
                // 如果窗口包含它，则不断删除它
                while (window.contains(del)) {
                    Integer deleted = window.pollFirst();
                    // 如果删掉的元素不是最初要删除的，则更换删除目标
                    // 最终要保证窗口内留下最多的，且为同一种的水果
                    if (del != deleted) {
                        del = deleted;
                    }
                    left++;
                }
                valid--;
            }
            valid++;
            window.offerLast(cur);
        }
    }

    return Math.max(window.size(), maxCnt);
}
```

##### 力扣 567 字符串的排列

![image-20220409133250160](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409133250160.png)

这题甚至只要包含就可以，那么我们碰到完全包括的情况就直接返回 true 就可以了。

但是注意一点，这里说必须要是子串，则在满足包含的情况下还需要满足**窗口长度和 s1 一致才能保证是子串**。

```java
 public boolean checkInclusion(String s1, String s2) {
     Map<Character, Integer> need = new HashMap<>();
     for (char c : s1.toCharArray()) {
         need.put(c, need.getOrDefault(c, 0) + 1);
     }
     
     Map<Character, Integer> window = new HashMap<>();
     int left = 0, right = 0;
     int valid = 0;
     
     while (right < s2.length()) {
         char cur = s2.charAt(right);
         right++;
         
         if (need.containsKey(cur)) {
             window.put(cur, window.getOrDefault(cur, 0) + 1);
             if (window.get(cur).equals(need.get(cur))) {
                 valid++;
             }
         }
         
         while (right - left >= s1.length() && valid == need.size()) {
             if (right - left == s1.length()) {
                 return true;
             }
             
             char del = s2.charAt(left);
             left++;
             
             if (need.containsKey(del)) {
                 if (need.get(del).equals(window.get(del))) {
                     valid--;
                 }
                 window.put(del, window.get(del) - 1);
             }
         }
     }
     return false;
 }
```

##### 力扣 438 找到字符串中的所有字母异位词

![image-20220409135430714](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409135430714.png)

本题和上一题类似，不同之处在于需要记录每一个子串的开始位置。

```java
public List<Integer> findAnagrams(String s, String p) {
    Map<Character, Integer> need = new HashMap<>();
    for (char c : p.toCharArray()) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }

    Map<Character, Integer> window = new HashMap<>();
    int left = 0, right = 0;
    int valid = 0;
    List<Integer> ans = new ArrayList<>();
    while (right < s.length()) {
        char cur = s.charAt(right);
        right++;

        if (need.containsKey(cur)) {
            window.put(cur, window.getOrDefault(cur, 0) + 1);
            if (window.get(cur).equals(need.get(cur))) {
                valid++;
            }
        }

        while (right - left >= p.length() && valid == need.size()) {
            if (right - left == p.length()) {
                ans.add(left);
            }

            char del = s.charAt(left);
            left++;

            if (need.containsKey(del)) {
                if (window.get(del).equals(need.get(del))) {
                    valid--;
                }

                window.put(del, window.get(del) - 1);
            }
        }
    }
    
    return ans;
}
```

##### 剑指 Offer 48. 最长不含重复字符的子字符串 & 力扣 3 无重复字符的最长子串

![image-20220703105229553](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703105229553.png)

本题没有特别指定的目标，仅要求不重复，因此从头开始滑，碰到不重复的就右滑，碰到重复的就左滑直到重复的字符被移除：

```java
public int lengthOfLongestSubstring(String s) {
    Deque<Character> window = new LinkedList<>();

    int left = 0, right = 0;
    int len = 0;
    while (right < s.length()) {
        char cur = s.charAt(right);
        right++;

        // 如果窗口为空或者不包含当前字符，直接加入
        if (window.isEmpty() || !window.contains(cur)) {
            window.addLast(cur);
            len = Math.max(right - left, len);
            continue;
        }

        // 收缩
        while (window.contains(cur)) {
            window.removeFirst();
            left++;
        }
        window.addLast(cur);
    }

    return len;
}
```

#### 1.2.4 n 数之和问题

n 数之和问题的难点在于去重，什么时候去重，怎么样去重都是要考虑的细节问题。

##### 力扣 15 三数之和

![image-20220412094703867](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412094703867.png)

本题的思路是对数组进行排序，然后利用双指针计算三数之和，中间要注意去重。

去重细节详见注释，一定要注意去重的时机以及方法：

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> ans = new ArrayList<>();

    if (nums == null || nums.length < 3) {
        return ans;
    }

    Arrays.sort(nums);

    for (int i = 0; i < nums.length; ++i) {
        // 剪枝：由于 nums 是排序了的，我们的思路是从当前元素开始前一个作为左指针，最后一个作为右指针
        // 如果当前元素就 > 0 了，那么后面的左右指针一定也 > 0，相加就不可能为 0
        if (nums[i] > 0) {
            break;
        }

        // 去重：如果当前元素等于上一个元素，则可以跳过
        if (i - 1 >= 0 && nums[i - 1] == nums[i]) {
            continue;
        }

        int left = i + 1, right = nums.length - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                ans.add(List.of(nums[i], nums[left], nums[right]));

                // 去重
                while (left + 1 <= right && nums[left + 1] == nums[left]) {
                    left++;
                }

                left++;

                while (right - 1 >= left && nums[right - 1] == nums[right]) {
                    right--;
                }

                right--;
            } else if (sum > 0) {
                right--;
            } else {
                left++;
            }
        }
    }

    return ans;
}
```

##### 力扣 18 四数之和

![image-20220412125204839](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412125204839.png)

本题其实和上一题类似，但是由于双指针只能兼顾两个数（前一个和最后一个），因此需要两层循环：

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> ans = new ArrayList<>();

    if (nums == null || nums.length < 4) {
        return ans;
    }

    Arrays.sort(nums);

    for (int i = 0; i < nums.length; ++i) {
        // 去重
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

        for (int j = i + 1; j < nums.length; ++j) {
            // 再去重
            if (j > i + 1 && nums[j] == nums[j - 1]) {
                continue;
            }

            int left = j + 1, right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[j] + nums[left] + nums[right];

                if (sum == target) {
                    ans.add(List.of(nums[i], nums[j], nums[left], nums[right]));

                    while (left + 1 < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    
                    left++;

                    while (right - 1 > left && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    
                    right--;
                }  else if (sum > target) {
                    right--;
                } else {
                    left++;
                }
            }
        }
    }

    return ans;
}
```

## 2. 前缀和

前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和。

前缀和的定义为：存在一个数组 `preSum`，使得每一个下标 i 对应的值都是原数组前 i 个元素的和。即：`preSum[i] = preSum[i - 1] + arr[i - 1]`。

示例：

![image-20220408091720443](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408091720443.png)

前缀和数组的长度总是比原数组多 1，前 0 号索引只占位，没有实际作用。

如果我想求索引区间 `[1, 4]` 内的所有元素之和，那么就可以通过 `preSum[5] - preSum[1]` 得出。即给出任意两个合法下标 i, j，其中 i <= j，那么数组区间 [i, j] 内所有元素的和就是 `preSum[j + 1] - preSum[i]`。

除了一维数组有前缀和之外，还有二维数组前缀和，示意图如下：

![image-20220408091905934](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408091905934.png)

现在要求红色框的和，计算方式就是绿色框 - 蓝色框 - 黄色框 + 粉色框。

对应到代码实现，首先就是前缀和的计算方式，二维数组的前缀和定义为从 (0,0) 到右下角 (x,y) 的矩阵内所有元素的和，对应代码为：`preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + arr[i - 1][j - 1] `。

给定左上角 (x1, y1)，右下角 (x2, y2)，满足 x1 <= x2, y1 <= y2，那么该矩阵的和为：`preSum[x2 + 1][y2 + 1] - preSum[x1][y2 + 1] - preSum[x2 + 1][y1] + preSum[x1][y1]`。

### 力扣 303 区域和检索 - 数组不可变

![image-20220408093025108](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408093025108.png)

这题是很简单的前缀和应用，直接在构造函数中构造前缀和数组，然后再求和时通过前缀和计算即可：

```java
class NumArray {
    private int[] preSum;

    public NumArray(int[] nums) {
        preSum = new int[nums.length + 1];
        for (int i = 1; i <= nums.length; ++i) {
            preSum[i] += preSum[i - 1] + nums[i - 1];
        }
    }

    public int sumRange(int left, int right) {
        return preSum[right + 1] - preSum[left];
    }
}
```

### 力扣 304 二维区域和检索 - 矩阵不可变

![image-20220408094010507](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408094010507.png)

这题就是二维前缀和的应用，和前面一题代码结构类似：

```java
class NumMatrix {
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        preSum = new int[matrix.length + 1][matrix[0].length + 1];

        for (int i = 1; i <= matrix.length; ++i) {
            for (int j = 1; j <= matrix[0].length; ++j) {
                preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1];
    }
}
```

### 力扣 506 和为 K 的子数组

![image-20220408094105795](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408094105795.png)

本题是前缀和的应用，注意是子数组。

思路为：使用一个 Map 记录前缀和出现的次数，使用 sum 计算当前总和，ans 记录答案，如果 sum - k 已经在 Map 中出现过了，则取出次数加到答案中，然后更新 Map

```java
public int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> preSum = new HashMap<>();
    preSum.put(0, 1);
    
    int sum = 0, ans = 0;
    for (int i = 1; i <= nums.length; ++i) {
        sum += nums[i - 1];
        
        int target = sum - k;
        if (map.containsKey(target)) {
            ans += map.get(target);
        }
        
        map.put(sum, map.getOrDefault(sum, 0) + 1);
    }
    
    return ans;
}
```

### 力扣 528 按权重随机选择

![image-20220408105559025](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408105559025.png)

本题要实现一个按照权重的随机算法，即 w[i] 高的，选中 i 的概率也要高。

假设给你输入的权重数组是 `w = [1,3,2,1]`，我们想让概率符合权重，那么可以抽象一下，根据权重画出这么一条彩色的线段：

![image-20220408110532798](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408110532798.png)

我们生成从 1 到线段总长的随机数，然后根据其落下的位置，返回其下标就可以了。

仔细一看，这不就是前缀和数组吗？那么搜索下标怎么办，我们可以找规律，落在绿色的区域应该返回 0，红色区域应该返回 1，...，则我们发现这是要寻找左侧边界，正好可以使用二分。

本题就是综合二分和前缀和来完成的算法：

```java
class Solution {
    private int[] preSum;

    private Random rand;

    public Solution(int[] w) {
        preSum = new int[w.length + 1];
        preSum[0] = 0;
        for (int i = 1; i <= w.length; ++i) {
            preSum[i] = w[i - 1] + preSum[i - 1];
        }

        rand = new Random();
    }
    
    public int pickIndex() {
        int target = rand.nextInt(preSum[preSum.length - 1]) + 1;
        return leftBorder(preSum, target) - 1;
    }

    private int leftBorder(int[] nums, int target) {
        int left = 0, right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return left;
    }
}
```

## 3. 差分

差分和前缀和的思想类似，它有一个数组记录当前元素和前一个元素的差值。

前缀和的适用场景是**原始数组不会被修改的情况下，频繁查询某个区间的累加和**。

而差分正好相反，它的适用场景是**频繁对原始数组的某个区间的元素进行增减**。

首先我们构造一个差分数组：

```java
int[] diff = new int[nums.length];

diff[0] = nums[0];
for (int i = 1; i < nums.length; ++i) {
    diff[i] = nums[i] - nums[i - 1];
}
```

如下图所示：

![image-20220408102030505](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408102030505.png)

现在问题来了，差分怎么运用在频繁更改数组元素的场景下呢？

首先需要知道的是，我们可以根据 diff 反推出 nums 的内容：

```java
int[] res = new int[diff.length]; // 已知 diff

// 根据差分数组构造结果数组
res[0] = diff[0];
for (int i = 1; i < diff.length; i++) {
    res[i] = res[i - 1] + diff[i];
}
```

现在，我们想对数组中 [i, j] 范围的内的元素都 + 3，使用差分数组就只需要让 diff[i] + 3，然后让 diff[j +1] - 3 即可，其原因很简单，让 diff[i] + 3 后，就相当于让 [i, n - 1] 所有的元素都 + 3，而让 diff[j +1] - 3 后，就相当于让 [j + 1, n - 1] 所有的元素都 - 3，这样修正以后，就等价于 [i, j] 之间的元素 + 3 了。

从 + 3 后的数组反推 diff 也是一样的。

于是，我们可以得到一个差分工具类：

```java
class Difference {
    private int[] diff;
    
    public Difference(int[] nums) {
        diff = new int[nums.length];
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; ++i) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }
    
    // 给区间 [i, j] 的所有元素 + val，val 可以是负数
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }
    
    public int[] result() {
        int[] ans = new int[diff.length];
        ans[0] = diff[0]
        for (int i = 1; i < diff.length; ++i) {
            ans[i] = ans[i - 1] + diff[i];
        }
        
        return ans;
    }
}
```

### 力扣 1094 拼车

![image-20220408103402882](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408103402882.png)

根据题意，在一趟行程 `trip[i] = [numPassengersi, fromi, toi]` 中，乘客的数量至少是 numPassengersi，因此我们只需要遍历所有行程，然后对 from，to 的区间内加上 numPassengersi，最后一遍遍历检索有没有超出容量的即可。

那么，利用差分可以轻松做到这件事，而且本题数据量最大为 1000，因此可以直接使用一个 1000 大小的数组构建差分。

代码如下：

```java
public boolean carPooling(int[][] trips, int capacity) {
	int[] nums = new int[1001];
    
    Difference diff = new Difference(nums);
    
    for (int[] trip : trips) {
        // trip[2] 是乘客下车的地方，可以接受新乘客，因此 - 1
        diff.increment(trip[1], trip[2] - 1, trip[0]);
    }
    
    int[] res = diff.result();
    
    for (int n : res) {
        if (n > capacity) {
            return false;
        }
    }
    
    return true;
}
```

### 力扣 1109 航班预订系统

![image-20220408105330635](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408105330635.png)

本题的示例直观的展现了我们要对数组频繁加，使用差分可以秒杀：

```java
public int[] corpFlightBookings(int[][] bookings, int n) {
    int[] nums = new int[n];

    Difference diff = new Difference(nums);

    for (int[] booking : bookings) {
        diff.increment(booking[0] - 1, booking[1] - 1, booking[2]);
    }

    return diff.result();
}
```

## 4. 二分查找的应用

二分搜索会实现了，但是应用也是一个难题。很多时候，题目是不明显的，这时就需要靠你自己抽象出来。

二分查找的适用范围是一个非严格单调增（单调减也可以）的序列，如果是严格单调增，则是最普通的二分；否则是搜索左边界或右边界。

那么题目不明显的情况下，如何使用二分搜索呢？

**首先，你要从题目中抽象出一个自变量 `x`，一个关于 `x` 的函数 `f(x)`，以及一个目标值 `target`**。

同时，`x, f(x), target` 还要满足以下条件：

**1、`f(x)` 必须是在 `x` 上的单调函数（单调增单调减都可以）**。

**2、题目是让你计算满足约束条件 `f(x) == target` 时的 `x` 的值**。

### 力扣 35 搜索插入位置

![image-20220407105048696](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220407105048696.png)

这题很明显的提示你使用二分搜索：

![image-20220407105106782](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220407105106782.png)

但是和普通二分查找不一样的是，在数据不存在时我们不能返回 -1，而是需要返回其应该插入位置。

首先注意，数组中插入元素是要后移其他元素的。

然后，我们思考一下二分查找中的循环结束条件，此时 left = right + 1，而它的前一次搜索是 left == right，也就是只有一个数：

* 如果前一次搜索的数 > 目标
  * 如果到了数组最左边，此时 right = mid - 1 变为负数，left 是 0，left 就是要插入的位置（比所有元素都小）。
  * 如果在中间位置，此时 right = mid - 1，此时 right 的位置上的元素比 target 小，left 的位置上的元素比 target 大，因此插入到 left 这个位置刚好。
* 如果前一次搜索的数 < 目标
  * 如果到了数组最右边，此时 left = mid + 1，超过了 right，也超过了数组的最大下标，left 就是要插入的位置（比所有元素都大）。
  * 如果在中间位置，此时 left = mid + 1，此时 right 的位置上的元素比 target 小，left 的位置上的元素比 target 大，因此插入到 left 这个位置刚好。

综上，如果没有搜索到，返回 left 即可：

```java
public int searchInsert(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return left;
}
```

### 力扣 69 x 的平方根

![image-20220416165303983](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220416165303983.png)

### 力扣 367 有效的完全平方数



### 力扣 875 爱吃香蕉的珂珂

![image-20220408112432051](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408112432051.png)

假设当前吃香蕉的速度为 h，怎么计算吃掉所有香蕉的时间？

代码实现如下：

```java
int hours = 0;

for (int pile : piles) {
    hours += pile / speed;

    if (pile % speed > 0) {
        hours++;
    }
}
```

我们发现，随着 speed 变大，那么 hours 会变小（或者不变），这就是一个非严格递减的函数，因此我们可以使用二分搜索。

我们把上面计算小时的代码封装为一个函数：

```java
// f(speed) 随 speed 增加而减少
private int f(int[] piles, int speed) {
    int hours = 0;

    for (int pile : piles) {
        hours += pile / speed;

        if (pile % speed > 0) {
            hours++;
        }
    }

    return hours;
}
```

题目要求找能满足条件情况下的最小速度，因此本题是寻找左侧边界：

```java
public int minEatingSpeed(int[] piles, int h) {
    int left = 1, right = 10_0000_0000;  // 根据题目数据范围得到

    while (left <= right) {
        int mid = left + (right - left) / 2;

        // 如果达到了，就找最小的速度
        if (f(piles, mid) <= h) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return left;
}
```

### 力扣 1011 在 D 天内送达包裹的能力

![image-20220408125219761](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408125219761.png)

本题和上一题其实是类似的，对于一个容量 capacity，我们计算一下需要的时间，注意是每一天都能够以 capacity 运输：

```java
private int f(int[] weights, int capacity) {
    int days = 0;

    for (int i = 0; i < weights.length; ) {
        int curCap = capacity;
        
        while (i < weights.length) {
            if (curCap >= weights[i]) {
                curCap -= weights[i];
            } else {
                break;
            }
            i++;
        }
        days++;
    }

    return days;
}
```

然后二分，本题要求返回最低，因此也是左侧边界搜索：

```java
public int shipWithinDays(int[] weights, int days) {
    int left = 0, right = 1;

    for (int weight : weights) {
        left = Math.max(left, weight);
        right += weight;
    }

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (f(weights, mid) <= days) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

```

### 力扣 154 寻找旋转排序数组中的最小值 II & 剑指 Offer 11.旋转数组的最小数字

![image-20220624085358222](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220624085358222.png)

本题最简单的方法当然是一遍遍历，找到最小值，时间复杂度 $O(n)$，但是事情没有这么简单，这题在剑指 Offer 上是简单题，在力扣上是一道困难题，因此，我们需要采用时间复杂度更小的办法。

观察本题数组规律，原数组是**递增的**，经过**旋转**才得到输入数组，举个例子：数组 `[1, 2, 3, 4, 5]` 经过旋转，可以得到 `[4, 5, 1, 2, 3]`，那么我们发现旋转点就是 4，旋转后的数组中有一段是递增的，而另一段也是递增的，我们称之为左递增数组和右递增数组，则**左递增数组的最小值一定大于等于右递增数组的最大值**。

当然，也可以完全不旋转，此时旋转后的数组就和原数组是一样的了。

当然，也存在有多个相同值的情况，比如：`[0, 1, 2, 2, 2]`，经过旋转后就变为：`[2, 2, 2, 0, 1]`，`[2, 2, 2]` 这一段并不是严格递减的。

事实上，利用上面讲过的左右递增数组的性质，我们可以使用二分搜索，取 `mid = left + (right - left) / 2`，那么：

1. 如果 `nums[mid] > nums[right]`，则说明 mid 处于左递增数组中，最小值一定在 mid 右边，执行 `left = mid + 1`。
2. 如果 `nums[mid] < nums[right]`，则说明 mid 处于右递增数组中，最小值一定在 mid 左边，也很有可能就是 mid，执行 `right = mid`。
3. 如果 `nums[mid] == nums[right]`，则此时情况有些复杂，说明 `nums[left] ~ nums[mid]` 的值完全相等或 ` nums[mid] ~ nums[right]` 的所有值相等，此时可以直接放弃二分查找，直接执行线性查找，因此我们执行 `right--`，直接缩小一个范围。

代码实现如下：

```java
public int minArray(int[] numbers) {
    int left = 0, right = numbers.length - 1;

    if (numbers[left] == numbers[right]) {
        int min = numbers[left];
        for (int i = left + 1; i <= right; ++i) {
            if (numbers[i] < min) {
                min = numbers[i];
            }
        }
        return min;
    } else if (numbers[left] < numbers[right]) {
        return numbers[left];
    } else {
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (numbers[mid] > numbers[right]) {
                left = mid + 1;
            } else if (numbers[mid] < numbers[right]) {
                right = mid;
            } else {
                right--;
            }
        }

        return numbers[left];
    }
}
```

## 5. 遍历二维数组

正常遍历二维数组并不难，但是有些题目玩的比较花。

### 力扣 48 旋转图像

![image-20220409141850203](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409141850203.png)

本题正常来说一般人还真想不到，顺时针应该是这样的：

![image-20220409142428223](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409142428223.png)

本题不允许使用额外空间，就意味着要自己写旋转，这个过程是非常麻烦的，一不小心就会出错。

本题的巧妙解法是**我们可以先将 `n x n` 矩阵 `matrix` 按照左上到右下的对角线进行镜像对称**：

![image-20220409143212195](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409143212195.png)

**然后再对矩阵的每一行进行反转**：

![image-20220409143225605](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409143225605.png)

**发现结果就是 `matrix` 顺时针旋转 90 度的结果**。

代码实现：

```java
public void rotate(int[][] matrix) {
    for (int i = 0; i < matrix.length; ++i) {
        for (int j = i; j < matrix.length; ++j) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    for (int[] row : matrix) {
        reverse(row);
    }
}

private void reverse(int[] row) {
    int left = 0, right = row.length - 1;
    while (left <= right) {
        int temp = row[left];
        row[left] = row[right];
        row[right] = temp;

        left++;
        right--;
    }
}
```

### 剑指 Offer 29.顺时针打印矩阵 & 力扣 54 螺旋数组

![image-20220630103818285](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220630103818285.png)

本题没有技巧可言，需要的就是细心的控制边界，只要细心，就不会错。

```java
public int[] spiralOrder(int[][] matrix) {
    if (matrix.length == 0 || matrix[0].length == 0) {
        return new int[] {};
    }

    int l = 0, r = matrix[0].length - 1;
    int t = 0, b = matrix.length - 1;

    int end = matrix.length * matrix[0].length;
    int start = 0;
    int[] ans = new int[end];
    while (start < end) {
        // 输出上边
        for (int i = l; i <= r; ++i) {
            if (start >= end) {
                break;
            }
            ans[start++] = matrix[t][i];
        }
        t++;

        // 输出右边
        for (int i = t; i <= b; ++i) {
            if (start >= end) {
                break;
            }
            ans[start++] = matrix[i][r];
        }
        r--;

        // 输出下边
        for (int i = r; i >= l; --i) {
            if (start >= end) {
                break;
            }
            ans[start++] = matrix[b][i];
        }
        b--;

        // 输出左边
        for (int i = b; i >= t; --i) {
            if (start >= end) {
                break;
            }
            ans[start++] = matrix[i][l];
        }
        l++;
    }

    return ans;
}
```

### 力扣 59 螺旋数组Ⅱ

![image-20220409144017241](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409144017241.png)

和上一题类似：

```java
public int[][] generateMatrix(int n) {
    int l = 0, r = n - 1, t = 0, b = n - 1;
    int[][] mat = new int[n][n];
    int num = 1, tar = n * n;
    while(num <= tar){
        for (int i = l; i <= r; i++) {
            mat[t][i] = num++; 
        }
        t++;

        for (int i = t; i <= b; i++) {
            mat[i][r] = num++;
        }
        r--;

        for (int i = r; i >= l; i--) {
            mat[b][i] = num++; 
        }
        b--;

        for (int i = b; i >= t; i--) {
            mat[i][l] = num++; 
        }
        l++;
    }
    return mat;
}
```

## 6. 其他经典数组题

### 剑指 Offer 03.数组中重复的数字

![image-20220622073144751](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220622073144751.png)

本题是一个比较简单的题，但是本题需要根据面试的实际情况来考虑使用何种方法。

如果本题时间复杂度要求低，那么我们可以采取先排序，再遍历的方式，时间复杂度 $O(nlogn)$。

如果本题对时间复杂度有要求，那么我们可以采取哈希表的方式，一遍遍历找出来，时间复杂度 $O(n)$，但是空间复杂度也为 $O(n)$。

如果本题不仅对时间复杂度有要求，还对空间复杂度有要求，那么就要考虑新方法了，我们注意观察，发现数组的元素大小被限制在了 0 ~ 数组长度这个区间内，而且题目只是要求找出一个重复的数字，数组中也至少有一个数字重复，那么我们可以对数组中的元素进行归位，**如果在遍历过程中，发现本该属于自己的位置被与自己相同的元素占了，那么我们就认为它是重复的**。

代码实现：

```java
public int findRepeatNumber(int[] nums) {
    int n = nums.length;

    for (int i = 0; i < n; ) {
        // 如果发现自己没归位
        if (i != nums[i]) {
            // 如果自己的位置上已经有一个相同的元素，那么自己重复了
            if (nums[i] == nums[nums[i]]) {
                return nums[i];
            } 
            // 否则，利用交换使得自己归位
            swap(i, nums[i], nums);
        } else {
            i++;
        }
    }

    return -1;
}

private void swap(int i, int j, int[] nums) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

### 剑指 Offer 66. 构建乘积数组

![image-20220706112812829](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706112812829.png)

本题最简单的方法就是双重循环，外层循环控制访问 a 数组元素，内层循环计算除自己之外的乘积，时间复杂度 $O(n^2)$。

我们可以两遍遍历的方法计算，一次只计算一个方向上的乘积，两遍就可以完全计算出来，时间复杂度 $O(n)$。

具体实现如下：

```java
public int[] constructArr(int[] a) {
    int n = a.length;

    int[] ans = new int[n];

    int cur = 1;
    for (int i = 0; i < n; ++i) {
        ans[i] = cur;
        cur *= a[i];
    }

    cur = 1;
    for (int i = n - 1; i >= 0; --i) {
        ans[i] *= cur;
        cur *= a[i];
    }

    return ans;
}
```

这是十分巧妙的计算方式，第一遍遍历时，cur 依次从 1 开始，a[0] 到 a[n - 1] 依次乘了个遍，而 ans[i] 每轮都等于 cur，这个方法的巧妙之处用文字是说不清楚的，还是建议自己模拟一遍。
