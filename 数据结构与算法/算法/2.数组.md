[TOC]

# 数组

## 1. 双指针

数组题也可以使用双指针，而且一般有前后指针和快慢指针两种。

### 1.1 快慢指针

#### 力扣 27. 移除元素

![image-20220719105515362](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719105515362.png)

本题力扣对这个数组的处理是：

![image-20220719110240606](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719110240606.png)

这意味着在不使用额外空间的情况下，我们必须把要删除的元素移到数组后面。

本题依然可以使用快慢指针，快指针去探路，慢指针维护所有不需要删除的元素。

如果一直没碰到要删除的元素 val，那么就一直执行 `nums[slow++] = nums[fast++]` 就好了，这样慢指针和快指针是并列往前走，直到末尾或者快指针碰到了要删除的元素。

快指针如果碰到了要删除的元素 val，就自己单独往前走直到碰到一个非 val 的值为止，此时说明快指针和慢指针之间全部都是需要移除的元素，此时再执行 `nums[slow++] = nums[fast++]`，那么从 0 到慢指针之间的元素都是不用被删除的元素。

重复上述步骤，直到 fast 走到末尾。

代码实现如下：

```java
public int removeElement(int[] nums, int val) {
    int n = nums.length;
    int slow = 0, fast = 0;

    while (fast < n) {
        if (nums[fast] == val) {
            fast++;
            continue;
        }
        nums[slow++] = nums[fast++];
    }

    return slow;
}
```

#### 力扣 26. 删除有序数组中的重复项

![image-20220719110723861](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719110723861.png)

本题力扣对数组的处理和上一题类似，因此我们要把重复的元素移到数组后面。

本题依然可以使用快慢指针：设置两个指针 fast 和 slow，让 fast 指针去前面探路，**slow 指针维护不重复的数组项**，当发现 slow 和 fast 不相同时，slow++，然后就把 fast 指针的值赋给 slow，这样 fast 到最后时，arr[0 ~ slow] 数组就是一个无重复元素的数组。

最后需要注意的是返回不能像上面那题那样直接返回 slow，因为 slow 在这里是当前不重复元素的最后一个，而上面的 slow 是下一个。

代码实现如下：

```java
public int removeDuplicates(int[] nums) {
    int n = nums.length;
    int slow = 0, fast = 0;

    while (fast < n) {
        if (nums[slow] == nums[fast]) {
            fast++;
        } else {
            slow++;
            nums[slow] = nums[fast];
            fast++;
        }
    }

    return slow + 1;
}
```

#### 力扣 283. 移动零

![image-20220719113128604](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719113128604.png)

[力扣 27. 移除元素](#力扣 27. 移除元素)的简化版本，规定要删除的元素是 0。

注意最后把末尾抹平为 0 即可。

代码实现如下：

```java
public void moveZeroes(int[] nums) {
    int n = nums.length;
    int slow = 0, fast = 0;

    while (fast < n) {
        if (nums[fast] == 0) {
            fast++;
            continue;
        }
        nums[slow++] = nums[fast++];
    }

    while (slow < n) {
        nums[slow++] = 0;
    }
}
```

#### 力扣 287. 寻找重复数

![image-20220714161352187](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220714161352187.png)

本题如果可以修改数组，那么可以考虑使用[剑指 Offer 03.数组中重复的数字](#剑指 Offer 03.数组中重复的数字)的方法，时间复杂度 $O(n)$，空间复杂度 $O(1)$。

但是本题要求不修改数组，就不能使用上面的方法了。

本题可以看做是数组版本的环形链表问题，为什么这么说呢？数的取值范围在 [1, n] 范围，但是包含 n + 1 个数，而且题目说了只有一个数重复，说明范围内每个数都至少出现过一次。

这种情况下，我们把 i 和 nums[nums[i]] 做一个映射，也就是如果当前处于 i 位置，值为 nums[i]，那么我下一步就要跳到 nums[nums[i]] 处。

这么做会导致什么结果呢？数组会成一个环，比如 [1, 3, 5, 2, 6, 2, 4]：

* 一开始位于 0，0 -> nums[0] = 1
* 接下来跳到 1，1 -> nums[1] = 3
* 接下来跳到 3，3 -> nums[3] = 2
* 接下来跳到 2，2 -> nums[2] = 5
* 接下来跳到 5，5 -> nums[5] = 2
* 接下来跳到 2，你会发现开始重复了

那么，如果没有重复元素，这么做会怎么样呢，比如 [1, 3, 5, 2, 6, 4]：

* 一开始位于 0，0 -> nums[0] = 1
* 接下来跳到 1，1 -> nums[1] = 3
* 接下来跳到 2，2 -> nums[2] = 5
* 接下来跳到 5，5 -> nums[5] = 4
* 接下来跳到 4，4 -> nums[4] = 6
* 接下来跳到 6，你回复发现 6 超过了数组范围，因此直接结束了

为什么没重复就不会成环？因为没有重复时，数组内最大的数为 n，而数组长度就是 n，那么总有一个数能够和 n 建立映射关系，只要到了这个数，这个数再到 n，由于 n 不在范围呢，就跳出了。

那为什么有重复就会成环呢？因为有重复时，数组内最大的数还是 n，但是数组长度就是 n + 1，那么怎么样都不会跳出去的。而且，有两个一模一样的数 i 意味着有两个不同的数会和 i 建立映射，那么只要来到这两个不同的数这里，就要跳到 i 处，这只能是成环了，且这两个不同的数里有一个一定在环里。

那么本题是不是就可以看作环形链表找入口的问题了？

代码实现如下：

```java
public int findDuplicate(int[] nums) {
    int n = nums.length;

    int slow = 0, fast = 0;
    while (true) {
        fast = nums[nums[fast]];
        slow = nums[slow];

        if (slow == fast) {
            fast = 0;
            while (nums[slow] != nums[fast]) {
                slow = nums[slow];
                fast = nums[fast];
            }
            return nums[slow];
        }
    }
}
```

### 1.2 前后指针（左右指针）

#### 1.2.1 基础

##### 力扣 977. 有序数组的平方

![image-20220719114015150](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719114015150.png)

本题虽然数组已经按非递减顺序排序了，但是由于负数的绝对值可能相对较大，因此平方后它会更大，所以直接对整个数组的每个元素都平方肯定是不行的，还额外需要一次排序，时间复杂度 $O(n\log n)$。

但是本题通常要求是 $O(n)$ 的解法，因此我们必须考虑如何一遍遍历搞定。

由于本题没有限制空间复杂度，因此可以用一个新数组记录。

我们设置左右两个指针指向原数组两边，由于存在负数，因此平方后的数组可以看做是一个凹下去的图形，最大的数分布在左右两边，中间是最小的数。那我们就只需要操控左右指针来比较大小，较大的数放在新数组最后面，然后左边前进或者右边后退即可。

本题数据量较小，平方不会超过 int 的范围，因此可以直接乘。

代码实现如下：

```java
public int[] sortedSquares(int[] nums) {
    int n = nums.length;
    int[] ans = new int[n];
    int left = 0, right = n - 1;
    int ansIdx = n - 1;
    while (ansIdx >= 0) {
        if (nums[left] * nums[left] > nums[right] * nums[right]) {
            ans[ansIdx--] = nums[left] * nums[left];
            left++;
        } else {
            ans[ansIdx--] = nums[right] * nums[right];
            right--;
        }
    }
    return ans;
}
```

##### 剑指 Offer 21. 调整数组顺序使得奇数位于偶数前面

![image-20220629164222296](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220629164222296.png)

本题是典型的左右指针题，我们让一个指针指向左端，另一个指针指向右端。

从左端开始，如果碰到奇数，直接左指针往右走；如果碰到偶数，则和右指针的值交换以后，右指针往左走。

代码实现如下：

```java
public int[] exchange(int[] nums) {
    int left = 0, right = nums.length - 1;

    while (left < right) {
        if (nums[left] % 2 != 0) {
            left++;
        } else {
            swap(left, right, nums);
            right--;
        }
    }

    return nums;
}
```

##### 力扣 11. 盛水最多的容器

![image-20220421103832660](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220421103832660.png)

本题的难点在于矩形的长宽都会改变，但是在宽确定的情况下，高度取决于两端最小的那端。因此，我们使用两个指针不断收缩宽，然后更新最大的矩形面积即可。

收缩时要注意贪心技巧，要让下一次得到的面积更大，就要让更小的那边有机会变得更大才行：

```java
public int maxArea(int[] height) {
    int start = 0, end = height.length - 1;
    int max = 0;
    while (start < end) {
        // end - start 是宽
        // Math.min(height[start], height[end]) 是高
        max = Math.max(max, Math.min(height[start], height[end]) * (end - start));
        if (height[start] > height[end]) {
            end--;
        } else {
            start++;
        }
    }
    return max;
}
```

##### 力扣 581. 最短无序连续子数组

![image-20220718120150418](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718120150418.png)

本题可以把数组分为三段，前后两段都是升序的，中间一段是无序的。

如下图所示：

![image-20220718120227722](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220718120227722.png)

中段有一个特点，就是最大值一定小于右段的最小值，最小值一定大于左段的最大值。

那么我们利用左右指针，左指针往右找到维护一个 max 变量为遍历到的最大值，通过这个 max 我们能找到中段的右边界。怎么找呢？由于左段一直是递增的，所以在进入中段之前 max 的最后一个取值就是左段的最大值；而由于任何一个中段的元素都比左段最大值大，因此中段很快会执行一次更新，但是在碰到中段最大值之后就会停止更新一段时间，直到最终在进入右段之前 max 的值都会是上图的红线；一旦进入右段，max 值又会不断更新。因此在中段其实是有一段时间 max 值不会更新，此时遍历到的每一个元素都有可能是中段的右边界。

那么要求中段的左边界，我们只需要维护一个最小值，做对称处理即可。

代码实现如下：

```java
public int findUnsortedSubarray(int[] nums) {
    int n = nums.length;
    int max = nums[0], min = nums[n - 1];
    int left = 0, right =  -1;
    for (int i = 1, j = n - 2; i < n && j >= 0; ++i, --j) {
        if (max > nums[i]) {
            right = i;
        } else {
            max = nums[i];
        }

        if (min < nums[j]) {
            left = j;
        } else {
            min = nums[j];
        }
    }

    return right - left + 1;
}
```

#### 1.2.2 二分查找实现

二分查找是一个重要的算法思想，通过一前一后两个指针来缩短搜索所需要的时间。

##### 力扣 704. 二分查找

![image-20220719100243154](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719100243154.png)

本题就是实现一个基本的二分查找，下面直接给出代码，然后我们再讲解需要注意的细节：

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;
}
```

细节：

1. 为什么 mid 要像上面那样计算？

   因为数组很大的时候，`(right + left)` 有可能超出 int 的范围，这样算保证不会超范围。

2. 为什么循环条件是 `left <= right`，而不是 `<`？

   因为 right 的初始值是数组最后一个元素的索引，说明搜索区间是闭区间 `[left, right]`，如果 `left == right` 时就结束了，那么就会漏掉一种情况，导致搜索不完全。

3. 为什么 right 和 left 的更新需要加上或减去 1，而其他人写的算法有些是 right 直接等于 mid？

   还是区间问题，这里是闭区间，因此更新时 mid 处已经被搜索过，应该去除它。 

##### 力扣 34. 在排序数组中查找元素的第一个和最后一个位置

![image-20220719100218220](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719100218220.png)

本题很明显提示使用二分，但是和普通的二分不太相同。

本题是需要搜索一个元素第一次出现的位置和最后一次出现的位置，由于它是有序的，因此该元素如果出现多次，必然是连在一起的。

如果该元素不存在，则需要返回两个 -1；如果该元素只出现一次，则返回两个相同的数（下标）。

那么我们该如何利用二分查找搜索元素第一次出现的位置呢？这个位置我们一般也叫做左边界，代码如下：

```java
private int leftBorder(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        // 继续向左寻找边界
        if (nums[mid] >= target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    if (left >= nums.length || nums[left] != target) {
        return -1;
    }
    return left;
}
```

细节：

* 精髓在于 `nums[mid] == target` 时，`right = mid - 1` 这一步处理。

  这表示**虽然找到了该元素，但是该元素有可能出现在众多相同元素的中间位置，因此还要往左边收缩找到最左边的位置**。

* 为什么返回 left？

  最后退出循环时，left 其实有以下含义：

  1. **返回的这个值是 `nums` 中大于等于 `target` 的最小元素索引。**

  2. **返回的这个值是 `target` 应该插入在 `nums` 中的索引位置。**
  2. **返回的这个值是 `nums` 中小于 `target` 的元素个数。**

  这三个解释是等价的。

* 如何处理边界情况？

  注意，刚刚我们已经说过返回的 left 是 `nums` 中大于等于 `target` 的最小元素索引，那么，只需要检测 left 是否超范围，并且检测 `nums[left]` 是否为 target 即可。

右侧边界则是对称处理：

```java
private int rightBorder(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    if (right < 0 || nums[right] != target) {
        return -1;
    }
    return right;
}
```

主函数：

```java
public int[] searchRange(int[] nums, int target) {
    return new int[] {leftBorder(nums, target), rightBorder(nums, target)};
}
```

##### 剑指 Offer 53 - I. 在排序数组中查找数字 I

![image-20220707163923940](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220707163923940.png)

本题大可以使用哈希表统计，时间复杂度 $O(n)$。

但是本题还有更好的解法，就是二分搜索左右边界，然后答案就是右边界 - 左边界 + 1，时间复杂度 $O(\log n)$。

代码实现如下：

```java
public int search(int[] nums, int target) {
    int l = leftBorder(nums, target);
    int r = rightBorder(nums, target);

    if (l == -1 || r == -1) {
        return 0;
    }

    return r - l + 1;
}

private int leftBorder(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        } 
    }

    if (left >= nums.length || nums[left] != target) {
        return -1;
    }
    return left;
}

private int rightBorder(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        } 
    }

    if (right < 0 || nums[right] != target) {
        return -1;
    }
    return right;
}
```

##### 剑指 Offer 04. 二维数组中的查找 & 力扣 240. 搜索二维矩阵Ⅱ

![image-20220623081249978](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220623081249978.png)

本题是把二分搜索拓展到了二维数组，我们可以**以左下角或右上角为支点**。

比如，我们的目标是 5，以右上角 15 为支点，15 比 5 大，那么肯定就在 15 的左边，15 所在的列肯定不可能，因此直接把 15 这一列砍掉。

接下来，我们又从新矩阵的右上角，也就是 11 为支点，11 又比 5 大，因此继续砍掉 11 这一列。

接下来，7 又比 5 大，砍掉 7 这一列。

接下来，4 比 5 小了，因此 4 这一行都不可能，直接砍掉这一行。

砍掉之后。矩阵就是这样的了：

```
[
	[2, 5],
	[3, 6],
	[10, 13],
	[18, 21]
]
```

此时，再以左上角为支点，我们发现它就等于 5，因此找到了。

事实上，这就是二分搜索的二维版本，思想是一模一样的，代码实现如下：

```java
public boolean findNumberIn2DArray(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0) {
        return false;
    }

    int row = matrix.length, col = matrix[0].length;

    int curRow = 0, curCol = col - 1;
    while (curRow < row && curCol >= 0) {
        int curNum = matrix[curRow][curCol];
        if (curNum > target) {
            curCol--;
        } else if (curNum < target) {
            curRow++;
        } else {
            return true;
        }
    }

    return false;
}
```

#### 1.2.3 滑动窗口

滑动窗口就是维护一个窗口，不断滑动，然后更新答案。

模板如下：

```java
public void slidingWindow(String s, String t) {
    Map<Character, Integer> need = new HashMap<>();
    Map<Character, Integer> window = new HashMap<>();
    
    // 使用目标串初始化 need
    for (char c : t.toCharArray) {
        need.put(c, need.getOrDefault(0, 1) + 1);
    }
    
    // 左右指针
    int left = 0, right = 0;
    // 有效数目的统计
    int valid = 0; 
    
    // right 没到末尾之前
    while (right < s.length()) {
        // 右滑
        char cur = s.charAt(right);
        right++;
        
        // 此处，根据添加的 cur 进行窗口内数据的一系列更新
        // ...
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // 缩小窗口
            char del = s[left];
            left++;
            
            // 此处，根据移除的 del 进行窗口内数据的一系列更新
            // ...
        }
    }
}
```

这个窗口模板足够复杂，可以应付大多数题目。少数题目其实不需要这么复杂的窗口，此时维护左右两个变量即可，再次也可以只维护一个 `Deque` 作为窗口。

##### 力扣 76 最小覆盖子串

![image-20220409131920440](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409131920440.png)

先看解法代码，再在讲解细节：

 ```java
 public String minWindow(String s, String t) {
     Map<Character, Integer> need = new HashMap<>();
     Map<Character, Integer> window = new HashMap<>();
 
     for (char c : t.toCharArray()) {
         need.put(c, need.getOrDefault(c, 0) + 1);
     }
 
     int left = 0, right = 0;
     // 此处 valid 代表窗口内字符种类
     int valid = 0;
 	
     // 记录子串的起始位置和长度
     int start = 0, len = Integer.MAX_VALUE;
     while (right < s.length()) {
         char cur = s.charAt(right);
         right++;
 
         // 如果 cur 字符被需要
         if (need.containsKey(cur)) {
             window.put(cur, window.getOrDefault(cur, 0) + 1);
 
             // 如果窗口内 cur 的数目和 need 的字符数目相等，说明该类字符已经全了
             if (window.get(cur).equals(need.get(cur))) {
                 valid++;
             }
         }
 
         // 如果有效字符种类达到了 need，可以尝试收缩窗口
         while (valid == need.size()) {
             if (right - left < len) {
                 start = left;
                 len = right - left;
             }
             
             char del = s.charAt(left);
             left++;
 
             if (need.containsKey(cur)) { 
                 if (window.get(cur).equals(need.get(cur))) {
                     valid--;
                 }
                 window.put(cur, window.get(cur) - 1);
             }
         }
     }
     
     return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
 }
 ```

1. 我们在字符串 `s` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个窗口。

   > 理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。
   >
   > 因为这样初始化 `left = right = 0` 时区间 `[0, 0)` 中没有元素，但只要让 `right` 向右移动（扩大）一位，区间 `[0, 1)` 就包含一个元素 `0` 了。如果你设置为两端都开的区间，那么让 `right` 向右移动一位后开区间 `(0, 1)` 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 `[0, 0]` 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。

2. 我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `t` 中的所有字符）。

3. 此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `t` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4. 重复第 2 和第 3 步，直到 `right` 到达字符串 `s` 的尽头。

这题困难题都秒杀了，下面的题目更是不在话下。

##### 力扣 904. 水果成篮

![image-20220719143024340](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719143024340.png)

本题也是很明显的滑动窗口，题目要找一段最长的子数组，且这个子数组里包含的元素只有两种。

由于本题只能采摘两种水果，因此我们可以仅仅用两个变量维护窗口，当 right 所指的元素是两种水果中的一种，我们就让 right 继续向前；否则，说明遇到了不同类型的水果，则把 left 提前到 right 的左边一个，然后找到最左边的 left，保持其中一种水果为当前 left 所指，然后另一种水果为当前 right 所指。

比如 [1 1 1 2 2 3 4] 这个用例，当 right 到最后一个 2 时，此时篮子里还是 1 和 2 两种水果，因此 right 继续向前，碰到 3，此时碰到了新水果，left 就从 right - 1 开始往前找到第一个 2，同时 1 要从篮子里剔除，转而装 3 这种水果。

代码实现如下：

```java
public int totalFruit(int[] fruits) {
    int n = fruits.length;
    int left = 0, right = 0;
    int ans = 0;

    int basket1 = fruits[left], basket2 = fruits[right];
    while (right < n) {
        if (fruits[right] == basket1 || fruits[right] == basket2) {
            ans = Math.max(ans, right - left + 1);
            right++;
        } else {
            left = right - 1;
            basket1 = fruits[left];
            while (left >= 1 && fruits[left - 1] == basket1) {
                left--;
            }

            basket2 = fruits[right];
            ans = Math.max(ans, right - left + 1);
        }
    }

    return ans;
}
```

##### 力扣 567 字符串的排列

![image-20220409133250160](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409133250160.png)

这题甚至只要包含就可以，那么我们碰到完全包括的情况就直接返回 true 就可以了。

但是注意一点，这里说必须要是子串，则在满足包含的情况下还需要满足**窗口长度和 s1 一致才能保证是子串**。

```java
 public boolean checkInclusion(String s1, String s2) {
     Map<Character, Integer> need = new HashMap<>();
     for (char c : s1.toCharArray()) {
         need.put(c, need.getOrDefault(c, 0) + 1);
     }
     
     Map<Character, Integer> window = new HashMap<>();
     int left = 0, right = 0;
     int valid = 0;
     
     while (right < s2.length()) {
         char cur = s2.charAt(right);
         right++;
         
         if (need.containsKey(cur)) {
             window.put(cur, window.getOrDefault(cur, 0) + 1);
             if (window.get(cur).equals(need.get(cur))) {
                 valid++;
             }
         }
         
         while (right - left >= s1.length() && valid == need.size()) {
             if (right - left == s1.length()) {
                 return true;
             }
             
             char del = s2.charAt(left);
             left++;
             
             if (need.containsKey(del)) {
                 if (need.get(del).equals(window.get(del))) {
                     valid--;
                 }
                 window.put(del, window.get(del) - 1);
             }
         }
     }
     return false;
 }
```

##### 力扣 438 找到字符串中的所有字母异位词

![image-20220409135430714](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409135430714.png)

本题和上一题类似，不同之处在于需要记录每一个子串的开始位置。

```java
public List<Integer> findAnagrams(String s, String p) {
    Map<Character, Integer> need = new HashMap<>();
    for (char c : p.toCharArray()) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }

    Map<Character, Integer> window = new HashMap<>();
    int left = 0, right = 0;
    int valid = 0;
    List<Integer> ans = new ArrayList<>();
    while (right < s.length()) {
        char cur = s.charAt(right);
        right++;

        if (need.containsKey(cur)) {
            window.put(cur, window.getOrDefault(cur, 0) + 1);
            if (window.get(cur).equals(need.get(cur))) {
                valid++;
            }
        }

        while (right - left >= p.length() && valid == need.size()) {
            if (right - left == p.length()) {
                ans.add(left);
            }

            char del = s.charAt(left);
            left++;

            if (need.containsKey(del)) {
                if (window.get(del).equals(need.get(del))) {
                    valid--;
                }

                window.put(del, window.get(del) - 1);
            }
        }
    }
    
    return ans;
}
```

##### 剑指 Offer 48. 最长不含重复字符的子字符串 & 力扣 3 无重复字符的最长子串

![image-20220703105229553](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703105229553.png)

本题没有特别指定的目标，仅要求不重复，因此从头开始滑，碰到不重复的就右滑，碰到重复的就左滑直到重复的字符被移除：

```java
public int lengthOfLongestSubstring(String s) {
    Deque<Character> window = new LinkedList<>();

    int left = 0, right = 0;
    int len = 0;
    while (right < s.length()) {
        char cur = s.charAt(right);
        right++;

        // 如果窗口为空或者不包含当前字符，直接加入
        if (window.isEmpty() || !window.contains(cur)) {
            window.addLast(cur);
            len = Math.max(right - left, len);
            continue;
        }

        // 收缩
        while (window.contains(cur)) {
            window.removeFirst();
            left++;
        }
        window.addLast(cur);
    }

    return len;
}
```

##### 剑指 Offer 57 - II. 和为s的连续正数序列

![image-20220709143211504](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220709143211504.png)

本题没什么特殊想法的话就可以使用滑动窗口，直观且简洁。

求和时，我们可以维护一个 curSum 变量，也可以使用等差数列的求和公式。

代码实现如下：

```java
public int[][] findContinuousSequence(int target) {
    List<int[]> list = new ArrayList<>();
    int left = 1, right = 1;

    while (right < target) {
        right++;

        while (left <= right && sum(left, right) > target) {
            left++;
        }

        if (sum(left, right) == target && left != right) {
            int[] temp = new int[right - left + 1];
            for (int i = left; i <= right; ++i) {
                temp[i - left] = i;
            }
            list.add(temp);
        }
    }

    int[][] ans = new int[list.size()][];
    for (int i = 0; i < list.size(); ++i) {
        ans[i] = list.get(i);
    }
    return ans;
}

private int sum(int left, int right) {
    return (left + right) * (right - left + 1) / 2;
}
```

#### 1.2.4 n 数之和问题

n 数之和问题的难点在于去重，什么时候去重，怎么样去重都是要考虑的细节问题。

##### 力扣 15 三数之和

![image-20220412094703867](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412094703867.png)

本题的思路是对数组进行排序，然后利用双指针计算三数之和，中间要注意去重。

去重细节详见注释，一定要注意去重的时机以及方法：

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> ans = new ArrayList<>();

    if (nums == null || nums.length < 3) {
        return ans;
    }

    Arrays.sort(nums);

    for (int i = 0; i < nums.length; ++i) {
        // 剪枝：由于 nums 是排序了的，我们的思路是从当前元素开始前一个作为左指针，最后一个作为右指针
        // 如果当前元素就 > 0 了，那么后面的左右指针一定也 > 0，相加就不可能为 0
        if (nums[i] > 0) {
            break;
        }

        // 去重：如果当前元素等于上一个元素，则可以跳过
        if (i - 1 >= 0 && nums[i - 1] == nums[i]) {
            continue;
        }

        int left = i + 1, right = nums.length - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                ans.add(List.of(nums[i], nums[left], nums[right]));

                // 去重
                while (left + 1 <= right && nums[left + 1] == nums[left]) {
                    left++;
                }

                left++;

                while (right - 1 >= left && nums[right - 1] == nums[right]) {
                    right--;
                }

                right--;
            } else if (sum > 0) {
                right--;
            } else {
                left++;
            }
        }
    }

    return ans;
}
```

##### 力扣 18 四数之和

![image-20220412125204839](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220412125204839.png)

本题其实和上一题类似，但是由于双指针只能兼顾两个数（前一个和最后一个），因此需要两层循环：

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> ans = new ArrayList<>();

    if (nums == null || nums.length < 4) {
        return ans;
    }

    Arrays.sort(nums);

    for (int i = 0; i < nums.length; ++i) {
        // 去重
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

        for (int j = i + 1; j < nums.length; ++j) {
            // 再去重
            if (j > i + 1 && nums[j] == nums[j - 1]) {
                continue;
            }

            int left = j + 1, right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[j] + nums[left] + nums[right];

                if (sum == target) {
                    ans.add(List.of(nums[i], nums[j], nums[left], nums[right]));

                    while (left + 1 < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    
                    left++;

                    while (right - 1 > left && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    
                    right--;
                }  else if (sum > target) {
                    right--;
                } else {
                    left++;
                }
            }
        }
    }

    return ans;
}
```

### 1.3 区间问题

#### 力扣 252 会议室

> 注：本题是力扣收费题，所以没有图片了，靠文字形式。

给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 `[[s1,e1],[s2,e2],...] (si < ei)`，请你判断一个人是否能够参加这里面的**全部**会议。

```
示例 1:
输入: [[0,30],[5,10],[15,20]]
输出: false

示例 2:
输入: [[7,10],[2,4]]
输出: true
```

本题要看一个人是否能够参加全部会议，就要看会议是否有交叉，没有交叉就课题否则不行。

对于这种区间问题，通常的解决办法都是确定某一个维度后，再考虑另一个维度。

因此，我们按照会议的开始时间排序，如果开始时间一样再按结束时间排序，再依次检查后一个区间的起始和前一个区间的结束是否交叉。

代码实现如下：

```java
public boolean canAttendMeetings(int[][] intervels) {
  	Arrays.sort(intervels, (a, b) -> {
      	return a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0];
    });
  
  	for (int i = 1; i < intervels.length; ++i) {
      	if (intervels[i][0] < intervels[i - 1][1]) {
          	return false;
        }
    }
  	return true;
}
```

#### 力扣 253 会议室 II

>注：本题是力扣收费题，所以没有图片了，靠文字形式。

给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si < ei)， 为避免会议冲突，同时要考虑充分利用会议室资源，请你计算**至少需要**多少间会议室，才能满足这些会议安排。

```
示例 1:
输入: [[0, 30],[5, 10],[15, 20]]
输出: 2

示例 2:
输入: [[7,10],[2,4]]
输出: 1
```

本题类似于上一题，但是本题要求使用最少的会议室安排这些会议，说明会议室必须重用。

那么，只要不交叉，那么这些不交叉会议都可以安排在一间会议室。

本题可以使用优先队列来帮助我们

## 2. 前缀和

前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和。

前缀和的定义为：存在一个数组 `preSum`，使得每一个下标 i 对应的值都是原数组前 i 个元素的和。即：`preSum[i] = preSum[i - 1] + arr[i - 1]`。

示例：

![image-20220408091720443](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408091720443.png)

前缀和数组的长度总是比原数组多 1，前 0 号索引只占位，没有实际作用。

如果我想求索引区间 `[1, 4]` 内的所有元素之和，那么就可以通过 `preSum[5] - preSum[1]` 得出。即给出任意两个合法下标 i, j，其中 i <= j，那么数组区间 [i, j] 内所有元素的和就是 `preSum[j + 1] - preSum[i]`。

除了一维数组有前缀和之外，还有二维数组前缀和，示意图如下：

![image-20220408091905934](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408091905934.png)

现在要求红色框的和，计算方式就是绿色框 - 蓝色框 - 黄色框 + 粉色框。

对应到代码实现，首先就是前缀和的计算方式，二维数组的前缀和定义为从 (0,0) 到右下角 (x,y) 的矩阵内所有元素的和，对应代码为：`preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + arr[i - 1][j - 1] `。

给定左上角 (x1, y1)，右下角 (x2, y2)，满足 x1 <= x2, y1 <= y2，那么该矩阵的和为：`preSum[x2 + 1][y2 + 1] - preSum[x1][y2 + 1] - preSum[x2 + 1][y1] + preSum[x1][y1]`。

### 力扣 303 区域和检索 - 数组不可变

![image-20220408093025108](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408093025108.png)

这题是很简单的前缀和应用，直接在构造函数中构造前缀和数组，然后再求和时通过前缀和计算即可：

```java
class NumArray {
    private int[] preSum;

    public NumArray(int[] nums) {
        preSum = new int[nums.length + 1];
        for (int i = 1; i <= nums.length; ++i) {
            preSum[i] += preSum[i - 1] + nums[i - 1];
        }
    }

    public int sumRange(int left, int right) {
        return preSum[right + 1] - preSum[left];
    }
}
```

### 力扣 304 二维区域和检索 - 矩阵不可变

![image-20220408094010507](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408094010507.png)

这题就是二维前缀和的应用，和前面一题代码结构类似：

```java
class NumMatrix {
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        preSum = new int[matrix.length + 1][matrix[0].length + 1];

        for (int i = 1; i <= matrix.length; ++i) {
            for (int j = 1; j <= matrix[0].length; ++j) {
                preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1];
    }
}
```

### 力扣 209. 长度最小的子数组

![image-20220719115447536](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719115447536.png)

本题是数组求和问题，同时又要求长度最小的子数组，因此可以是应用滑动窗口，而又涉及到数组求和，因此前缀和也是可以用于优化时间复杂度的。

具体来说，还是维护一个滑动窗口，窗口内的和达到了 target 就可以收缩了，没达到就继续扩张；但是由于有前缀和数组，因此不需要额外的容器作为窗口，只需维护边界指针即可。

```java
private int[] preSum;

public int minSubArrayLen(int target, int[] nums) {
    int n = nums.length;
    preSum = new int[n + 1];
    preSum[0] = 0;
    for (int i = 1; i <= n; ++i) {
        preSum[i] = preSum[i - 1] + nums[i - 1];
    }

    int left = 0, right = 0;
    int ans = Integer.MAX_VALUE;
    while (right < n) {
        right++;
      	// 注意这里，求出的和是 nums[0, right) 左闭右开区间的和，因此下面求长度的时候记得还要额外 - 1
        int sum = preSum[right] - preSum[left];

        while (sum >= target) {
            ans = Math.min(ans, right - left + 1 - 1);
            left++;
            
            sum = preSum[right] - preSum[left];
        }
    }

    return ans == Integer.MAX_VALUE ? 0 : ans;
}
```

### 力扣 506 和为 K 的子数组

![image-20220408094105795](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408094105795.png)

本题是前缀和的应用，注意是子数组。

思路为：使用一个 Map 记录前缀和出现的次数，使用 sum 计算当前总和，ans 记录答案，如果 sum - k 已经在 Map 中出现过了，则取出次数加到答案中，然后更新 Map

```java
public int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> preSum = new HashMap<>();
    preSum.put(0, 1);
    
    int sum = 0, ans = 0;
    for (int i = 1; i <= nums.length; ++i) {
        sum += nums[i - 1];
        
        int target = sum - k;
        if (map.containsKey(target)) {
            ans += map.get(target);
        }
        
        map.put(sum, map.getOrDefault(sum, 0) + 1);
    }
    
    return ans;
}
```

### 力扣 528 按权重随机选择

![image-20220408105559025](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408105559025.png)

本题要实现一个按照权重的随机算法，即 w[i] 高的，选中 i 的概率也要高。

假设给你输入的权重数组是 `w = [1,3,2,1]`，我们想让概率符合权重，那么可以抽象一下，根据权重画出这么一条彩色的线段：

![image-20220408110532798](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408110532798.png)

我们生成从 1 到线段总长的随机数，然后根据其落下的位置，返回其下标就可以了。

仔细一看，这不就是前缀和数组吗？那么搜索下标怎么办，我们可以找规律，落在绿色的区域应该返回 0，红色区域应该返回 1，...，则我们发现这是要寻找左侧边界，正好可以使用二分。

本题就是综合二分和前缀和来完成的算法：

```java
class Solution {
    private int[] preSum;

    private Random rand;

    public Solution(int[] w) {
        preSum = new int[w.length + 1];
        preSum[0] = 0;
        for (int i = 1; i <= w.length; ++i) {
            preSum[i] = w[i - 1] + preSum[i - 1];
        }

        rand = new Random();
    }
    
    public int pickIndex() {
        int target = rand.nextInt(preSum[preSum.length - 1]) + 1;
        return leftBorder(preSum, target) - 1;
    }

    private int leftBorder(int[] nums, int target) {
        int left = 0, right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return left;
    }
}
```

## 3. 差分

差分和前缀和的思想类似，它有一个数组记录当前元素和前一个元素的差值。

前缀和的适用场景是**原始数组不会被修改的情况下，频繁查询某个区间的累加和**。

而差分正好相反，它的适用场景是**频繁对原始数组的某个区间的元素进行增减**。

首先我们构造一个差分数组：

```java
int[] diff = new int[nums.length];

diff[0] = nums[0];
for (int i = 1; i < nums.length; ++i) {
    diff[i] = nums[i] - nums[i - 1];
}
```

如下图所示：

![image-20220408102030505](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408102030505.png)

现在问题来了，差分怎么运用在频繁更改数组元素的场景下呢？

首先需要知道的是，我们可以根据 diff 反推出 nums 的内容：

```java
int[] res = new int[diff.length]; // 已知 diff

// 根据差分数组构造结果数组
res[0] = diff[0];
for (int i = 1; i < diff.length; i++) {
    res[i] = res[i - 1] + diff[i];
}
```

现在，我们想对数组中 [i, j] 范围的内的元素都 + 3，使用差分数组就只需要让 diff[i] + 3，然后让 diff[j +1] - 3 即可，其原因很简单，让 diff[i] + 3 后，就相当于让 [i, n - 1] 所有的元素都 + 3，而让 diff[j +1] - 3 后，就相当于让 [j + 1, n - 1] 所有的元素都 - 3，这样修正以后，就等价于 [i, j] 之间的元素 + 3 了。

从 + 3 后的数组反推 diff 也是一样的。

于是，我们可以得到一个差分工具类：

```java
class Difference {
    private int[] diff;
    
    public Difference(int[] nums) {
        diff = new int[nums.length];
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; ++i) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }
    
    // 给区间 [i, j] 的所有元素 + val，val 可以是负数
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }
    
    public int[] result() {
        int[] ans = new int[diff.length];
        ans[0] = diff[0]
        for (int i = 1; i < diff.length; ++i) {
            ans[i] = ans[i - 1] + diff[i];
        }
        
        return ans;
    }
}
```

### 力扣 1094 拼车

![image-20220408103402882](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408103402882.png)

根据题意，在一趟行程 `trip[i] = [numPassengersi, fromi, toi]` 中，乘客的数量至少是 numPassengersi，因此我们只需要遍历所有行程，然后对 from，to 的区间内加上 numPassengersi，最后一遍遍历检索有没有超出容量的即可。

那么，利用差分可以轻松做到这件事，而且本题数据量最大为 1000，因此可以直接使用一个 1000 大小的数组构建差分。

代码如下：

```java
public boolean carPooling(int[][] trips, int capacity) {
	int[] nums = new int[1001];
    
    Difference diff = new Difference(nums);
    
    for (int[] trip : trips) {
        // trip[2] 是乘客下车的地方，可以接受新乘客，因此 - 1
        diff.increment(trip[1], trip[2] - 1, trip[0]);
    }
    
    int[] res = diff.result();
    
    for (int n : res) {
        if (n > capacity) {
            return false;
        }
    }
    
    return true;
}
```

### 力扣 1109 航班预订系统

![image-20220408105330635](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408105330635.png)

本题的示例直观的展现了我们要对数组频繁加，使用差分可以秒杀：

```java
public int[] corpFlightBookings(int[][] bookings, int n) {
    int[] nums = new int[n];

    Difference diff = new Difference(nums);

    for (int[] booking : bookings) {
        diff.increment(booking[0] - 1, booking[1] - 1, booking[2]);
    }

    return diff.result();
}
```

## 4. 二分查找的应用

二分搜索会实现了，但是应用也是一个难题。

二分查找的适用范围是一个非严格单调增（单调减也可以）的序列，如果是严格单调增，则是最普通的二分；否则是搜索左边界或右边界，**注意左边界的实际意义**。

但是很多时候，题目是不明显的，这时就需要靠你自己抽象出来。那么题目不明显的情况下，如何使用二分搜索呢？

**首先，你要从题目中抽象出一个自变量 `x`，一个关于 `x` 的函数 `f(x)`，以及一个目标值 `target`**。

同时，`x, f(x), target` 还要满足以下条件：

**1、`f(x)` 必须是在 `x` 上的单调函数（单调增单调减都可以）**。

**2、题目是让你计算满足约束条件 `f(x) == target` 时的 `x` 的值**。

### 力扣 35. 搜索插入位置

![image-20220719094920534](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719094920534.png)

这题强制要求你使用 $O(\log n)$ 的算法，很明显的提示你使用二分搜索。

但是和普通二分查找不一样的是，在数据不存在时我们不能返回 -1，而是需要返回其应该插入位置，也就是 left，left 的实际意义我们之前也讲过，这里就不再叙述了。

代码实现如下：

```java
public int searchInsert(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return left;
}
```

### 力扣 69. x 的平方根

![image-20220719102834790](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719102834790.png)

本题只需要求出一个数 n 的平方根的整数部分，因此它的平方根一定在 0 ~ n 之间，就相当于从 0 ~ n 的有序数组里找一个数 x，使得 `x * x <= n`，但是 `(x + 1) * (x + 1) > n`。

这不就是二分查找吗？我们直接写代码即可，但是要注意如果 x 太大，搜索过程中的 mid * mid 有可能超出 int 的返回，所以我们反向思考，使用除法判断。而因为使用了除法，就要注意被除数不能是 0，因此要注意边界条件。

代码实现如下：

```java
public int mySqrt(int x) {
    if (x == 0) {
        return 0;
    }

    int left = 1, right = x;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (mid > x / mid) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return right;
}
```

### 力扣 367. 有效的完全平方数

![image-20220719103337253](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220719103337253.png)

本题可以直接使用上一题的函数，求出平方根的整数部分后，如果整数部分乘起来恰好等于该数，那么就是完全平方数，否则就不是。

代码实现如下：

```java
public boolean isPerfectSquare(int num) {
    int n = mySqrt(num);
    return n * n == num;
}

public int mySqrt(int x) {
    if (x == 0) {
        return 0;
    }

    int left = 1, right = x;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (mid > x / mid) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return right;
}
```

### 剑指 Offer 53 - II. 0～n-1中缺失的数字

![image-20220707143937368](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220707143937368.png)

本题和[力扣 35. 搜索插入位置](#力扣 35. 搜索插入位置)几乎是一模一样的。

首先，题目告诉你**有序**数组里缺了一个元素，而且告诉你数组的元素是连续的，这不就是搜索一个单独拎出来的元素的插入位置吗？

由于数组是连续的数，因此如果正常情况下，下标和值是对应的。因此，每次的 mid 就是二分搜索的 target。

代码实现如下：

```java
public int missingNumber(int[] nums) {
    int left = 0, right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > mid) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

### 力扣 875 爱吃香蕉的珂珂

![image-20220408112432051](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408112432051.png)

假设当前吃香蕉的速度为 h，怎么计算吃掉所有香蕉的时间？

代码实现如下：

```java
int hours = 0;

for (int pile : piles) {
    hours += pile / speed;

    if (pile % speed > 0) {
        hours++;
    }
}
```

我们发现，随着 speed 变大，那么 hours 会变小（或者不变），这就是一个非严格递减的函数，因此我们可以使用二分搜索。

我们把上面计算小时的代码封装为一个函数：

```java
// f(speed) 随 speed 增加而减少
private int f(int[] piles, int speed) {
    int hours = 0;

    for (int pile : piles) {
        hours += pile / speed;

        if (pile % speed > 0) {
            hours++;
        }
    }

    return hours;
}
```

题目要求找能满足条件情况下的最小速度，因此本题是寻找左侧边界：

```java
public int minEatingSpeed(int[] piles, int h) {
    int left = 1, right = 10_0000_0000;  // 根据题目数据范围得到

    while (left <= right) {
        int mid = left + (right - left) / 2;

        // 如果达到了，就找最小的速度
        if (f(piles, mid) <= h) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return left;
}
```

### 力扣 1011 在 D 天内送达包裹的能力

![image-20220408125219761](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220408125219761.png)

本题和上一题其实是类似的，对于一个容量 capacity，我们计算一下需要的时间，注意是每一天都能够以 capacity 运输：

```java
private int f(int[] weights, int capacity) {
    int days = 0;

    for (int i = 0; i < weights.length; ) {
        int curCap = capacity;
        
        while (i < weights.length) {
            if (curCap >= weights[i]) {
                curCap -= weights[i];
            } else {
                break;
            }
            i++;
        }
        days++;
    }

    return days;
}
```

然后二分，本题要求返回最低，因此也是左侧边界搜索：

```java
public int shipWithinDays(int[] weights, int days) {
    int left = 0, right = 1;

    for (int weight : weights) {
        left = Math.max(left, weight);
        right += weight;
    }

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (f(weights, mid) <= days) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

```

### 剑指 Offer 11.旋转数组的最小数字 & 力扣 154. 寻找旋转排序数组中的最小值 II 

![image-20220709173045482](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220709173045482.png)

本题最简单的方法当然是一遍遍历，找到最小值，时间复杂度 $O(n)$，但是事情没有这么简单，这题在剑指 Offer 上是简单题，在力扣上是一道困难题，因此，我们需要采用时间复杂度更小的办法。

观察本题数组规律，原数组是**递增的**，经过**旋转**才得到输入数组，举个例子：数组 `[1, 2, 3, 4, 5]` 经过旋转，可以得到 `[4, 5, 1, 2, 3]`，那么我们发现旋转点就是 4，旋转后的数组中有一段是递增的，而另一段也是递增的，我们称之为左递增数组和右递增数组，则**左递增数组的最小值一定大于等于右递增数组的最大值**。

当然，也可以完全不旋转，此时旋转后的数组就和原数组是一样的了。

当然，也存在有多个相同值的情况，比如：`[0, 1, 2, 2, 2]`，经过旋转后就变为：`[2, 2, 2, 0, 1]`，`[2, 2, 2]` 这一段并不是严格递减的。

事实上，利用上面讲过的左右递增数组的性质，我们可以使用二分搜索，取 `mid = left + (right - left) / 2`，那么：

1. 如果 `nums[mid] > nums[right]`，则说明 mid 处于左递增数组中，最小值一定在 mid 右边，执行 `left = mid + 1`。
2. 如果 `nums[mid] < nums[right]`，则说明 mid 处于右递增数组中，最小值一定在 mid 左边，也很有可能就是 mid，执行 `right = mid`。
3. 如果 `nums[mid] == nums[right]`，则此时情况有些复杂，说明 `nums[left] ~ nums[mid]` 的值完全相等或 ` nums[mid] ~ nums[right]` 的所有值相等，此时可以直接放弃二分查找，直接执行线性查找，因此我们执行 `right--`，直接缩小一个范围。

代码实现如下：

```java
public int minArray(int[] numbers) {
    int left = 0, right = numbers.length - 1;

    if (numbers[left] == numbers[right]) {
        int min = numbers[left];
        for (int i = left + 1; i <= right; ++i) {
            if (numbers[i] < min) {
                min = numbers[i];
            }
        }
        return min;
    } else if (numbers[left] < numbers[right]) {
        return numbers[left];
    } else {
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (numbers[mid] > numbers[right]) {
                left = mid + 1;
            } else if (numbers[mid] < numbers[right]) {
                right = mid;
            } else {
                right--;
            }
        }

        return numbers[left];
    }
}
```

### 力扣 33. 搜索旋转排序数组

![image-20220709173332650](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220709173332650.png)

本题有上一题的基础的话，应该很快就想得到。

具体来说，要分 nums[mid] 在左递增数组还是右递增数组：

* nums[mid] == target，此时直接返回 mid
* nums[mid] >= nums[left]，此时 mid 处于左递增数组：
  * nums[mid] < target，此时 target 肯定不在左递增数组了，执行 left = mid + 1
  * nums[mid] > target，此时不能确定在左递增数组还是在右递增数组，继续分类：
    * target > nums[left]：此时确定了在左递增数组，执行 right = mid - 1
    * target == nums[left]：直接返回 left
    * target < nums[left]：执行 left = mid + 1
* nums[mid] < nums[left]，此时 mid 处于右递增数组：
  * nums[mid] > target，此时 target 肯定不在右递增数组了，执行 right = mid - 1
  * nums[mid] < target，此时不能确定在左递增数组还是在右递增数组，继续分类：
    * target > nums[right]：此时确定了不在右递增数组，执行 right = mid - 1
    * target == nums[right]：直接返回 left
    * target < nums[right]：执行 left = mid + 1

代码实现如下：

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        }

        if (nums[left] <= nums[mid]) {
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                if (target > nums[left]) {
                    right = mid - 1;
                } else if (target == nums[left]) {
                    return left;
                } else {
                    left = mid + 1;
                }
            }
        } else {
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                if (target > nums[right]) {
                    right = mid - 1;
                } else if (target < nums[right]) {
                    left = mid + 1;
                } else {
                    return right;
                }
            }
        }
    }

    return -1;
}
```

## 5. 遍历二维数组

正常遍历二维数组并不难，但是有些题目玩的比较花。

### 力扣 48 旋转图像

![image-20220409141850203](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409141850203.png)

本题正常来说一般人还真想不到，顺时针应该是这样的：

![image-20220409142428223](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409142428223.png)

本题不允许使用额外空间，就意味着要自己写旋转，这个过程是非常麻烦的，一不小心就会出错。

本题的巧妙解法是**我们可以先将 `n x n` 矩阵 `matrix` 按照左上到右下的对角线进行镜像对称**：

![image-20220409143212195](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409143212195.png)

**然后再对矩阵的每一行进行反转**：

![image-20220409143225605](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409143225605.png)

**发现结果就是 `matrix` 顺时针旋转 90 度的结果**。

代码实现：

```java
public void rotate(int[][] matrix) {
    for (int i = 0; i < matrix.length; ++i) {
        for (int j = i; j < matrix.length; ++j) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    for (int[] row : matrix) {
        reverse(row);
    }
}

private void reverse(int[] row) {
    int left = 0, right = row.length - 1;
    while (left <= right) {
        int temp = row[left];
        row[left] = row[right];
        row[right] = temp;

        left++;
        right--;
    }
}
```

### 剑指 Offer 29.顺时针打印矩阵 & 力扣 54. 螺旋数组

![image-20220630103818285](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220630103818285.png)

本题没有技巧可言，需要的就是细心的控制边界，只要细心，就不会错。

```java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> ans = new ArrayList<>();
    int top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1;
    int start = 1, end = matrix.length * matrix[0].length;

    while (start <= end) {
        for (int i = left; i <= right; ++i) {
            if (start > end) {
                break;
            }
            ans.add(matrix[top][i]);
            start++;
        }
        top++;

        for (int i = top; i <= bottom; ++i) {
            if (start > end) {
                break;
            }
            ans.add(matrix[i][right]); 
            start++;
        }
        right--;

        for (int i = right; i >= left; --i) {
            if (start > end) {
                break;
            }
            ans.add(matrix[bottom][i]);
            start++;
        }
        bottom--;

        for (int i = bottom; i >= top; --i) {
            if (start > end) {
                break;
            }
            ans.add(matrix[i][left]);
            start++;
        }
        left++;
    }

    return ans;
}
```

### 力扣 59 螺旋数组Ⅱ

![image-20220720100322590](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220720100322590.png)

和上一题类似：

```java
public int[][] generateMatrix(int n) {
    int start = 1, end = n * n;
    int[][] ans = new int[n][n];

    int top = 0, bottom = n - 1, left = 0, right = n - 1;
    while (start <= end) {
        for (int i = left; i <= right; ++i) {
            ans[top][i] = start++;
        }
        top++;

        for (int i = top; i <= bottom; ++i) {
            ans[i][right] = start++;
        }
        right--;

        for (int i = right; i >= left; --i) {
            ans[bottom][i] = start++;
        }
        bottom--;

        for (int i = bottom; i >= top; --i) {
            ans[i][left] = start++;
        }
        left++;
    }

    return ans;
}
```

## 6. 其他经典数组题

### 剑指 Offer 03. 数组中重复的数字

![image-20220622073144751](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220622073144751.png)

本题是一个比较简单的题，但是本题需要根据面试的实际情况来考虑使用何种方法。

如果本题时间复杂度要求低，那么我们可以采取先排序，再遍历的方式，时间复杂度 $O(nlogn)$。

如果本题对时间复杂度有要求，那么我们可以采取哈希表的方式，一遍遍历找出来，时间复杂度 $O(n)$，但是空间复杂度也为 $O(n)$。

如果本题不仅对时间复杂度有要求，还对空间复杂度有要求，那么就要考虑新方法了，我们注意观察，发现数组的元素大小被限制在了 0 ~ 数组长度这个区间内，而且题目只是要求找出一个重复的数字，数组中也至少有一个数字重复，那么我们可以对数组中的元素进行归位，**如果在遍历过程中，发现本该属于自己的位置被与自己相同的元素占了，那么我们就认为它是重复的**。

代码实现：

```java
public int findRepeatNumber(int[] nums) {
    int n = nums.length;

    for (int i = 0; i < n; ) {
        // 如果发现自己没归位
        if (i != nums[i]) {
            // 如果自己的位置上已经有一个相同的元素，那么自己重复了
            if (nums[i] == nums[nums[i]]) {
                return nums[i];
            } 
            // 否则，利用交换使得自己归位
            swap(i, nums[i], nums);
        } else {
            i++;
        }
    }

    return -1;
}

private void swap(int i, int j, int[] nums) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

### 剑指 Offer 66. 构建乘积数组

![image-20220706112812829](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706112812829.png)

本题最简单的方法就是双重循环，外层循环控制访问 a 数组元素，内层循环计算除自己之外的乘积，时间复杂度 $O(n^2)$。

我们可以两遍遍历的方法计算，一次只计算一个方向上的乘积，两遍就可以完全计算出来，时间复杂度 $O(n)$。

具体实现如下：

```java
public int[] constructArr(int[] a) {
    int n = a.length;

    int[] ans = new int[n];

    int cur = 1;
    for (int i = 0; i < n; ++i) {
        ans[i] = cur;
        cur *= a[i];
    }

    cur = 1;
    for (int i = n - 1; i >= 0; --i) {
        ans[i] *= cur;
        cur *= a[i];
    }

    return ans;
}
```

这是十分巧妙的计算方式，第一遍遍历时，cur 依次从 1 开始，a[0] 到 a[n - 1] 依次乘了个遍，而 ans[i] 每轮都等于 cur，这个方法的巧妙之处用文字是说不清楚的，还是建议自己模拟一遍。
