# 链表

## 虚拟头结点

如果是需要返回一个链表头结点的题，一般都可以使用虚拟头结点简化操作，让虚拟头结点连接到真实头结点，框架如下：

```java
ListNode dummy = new ListNode(-1, head);

// ...

return dummy.next;
```

这是因为原本链表的头节点可能发生改变，需要额外的操作，使用虚拟头节点不仅可以简化操作，而且可以统一逻辑。

### 力扣 2 两数相加

![image-20220426104452124](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220426104452124.png)

通过虚拟头节点可以简化操作：

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode();
	ListNode cur = dummy;
    int carry = 0;
    
    // 只有 l1，l2，进位 都不存在时，才可以退出循环
    while (l1 != null || l2 != null || carry > 0) {
        int val = carry;
        
        if (l1 != null) {
            val += l1.val;
            l1 = l1.next;
        }
        
        if (l2 != null) {
            val += l2.val;
            l2 = l2.next;
        }
        
        carry = val / 10;
        val = val % 10;
        cur.next = new ListNode(val);
        cur = cur.next;
    }
    
	return dummy.next;
}
```

### 力扣 21 & 23 合并两个有序链表 & 合并 K 个升序链表

![image-20220405115539370](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220405115539370.png)

利用虚拟头节点构造一个新的链表，配合优先队列，每次找最小的，如果它的 next 不为 null，就再次加入优先队列中。

```java
public ListNode mergeKLists(ListNode[] lists) {
    PriorityQueue<ListNode> queue = new PriorityQueue<>((a, b) -> a.val - b.val);
    ListNode dummy = new ListNode();
    ListNode head = dummy;

    if (lists == null || lists.length == 0) {
        return dummy.next;
    }

    for (ListNode node : lists) {
        if (node != null) {
            queue.add(node);
        }
    }

    while (!queue.isEmpty()) {
        ListNode cur = queue.poll();
        head.next = cur;
        if (cur.next != null) {
            queue.offer(cur.next);
        }
        head = head.next;
    }

    return dummy.next;
}
```

会做 23 的话可以直接秒掉 21。

### 力扣 24 两两交换链表中的节点

![image-20220417132543581](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220417132543581.png)

本题和前面的题目类似，因为涉及到头节点可能会改变的情况，因此使用虚拟头节点可以简化操作。

注意，**如果一轮操作中涉及到多个节点，一定要确保每一个节点都不为空才能操作**。

```java
public ListNode swapPairs(ListNode head) {
    ListNode dummyHead = new ListNode(-1, head);
    ListNode pre = dummyHead;
    ListNode cur = head;
    while (cur != null && cur.next != null) {
        ListNode next = cur.next.next;
        
        pre.next = cur.next;
        cur.next.next = cur;
        cur.next = next;

        pre = cur;
        cur = cur.next;
    }

    return dummyHead.next;
}
```

### 力扣 203 移除链表元素

![image-20220417132154468](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220417132154468.png)

本题如果不使用虚拟头节点，就需要考虑删除的是头节点的情况，比较麻烦，而使用虚拟头节点的话，就可以使用通用的逻辑处理。

```java
public ListNode removeElements(ListNode head, int val) {
    ListNode dummyHead = new ListNode(-1, head);
    ListNode cur = dummyHead.next;
    ListNode pre = dummyHead;

    while (cur != null) {
        if (cur.val == val) {
            pre.next = cur.next;
        } else {
            pre = cur;
        }
        cur = cur.next;
    }

    return dummyHead.next;
}
```

### 力扣 707 设计链表

![image-20220413093351932](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220413093351932.png)

本题使用双向链表，维护一个虚拟头和虚拟尾节点，可以大大的简化插入删除操作。

```java
class MyLinkedList {
    private static class Node {
        public Node next;
        public Node prev;
        public int val;

        public Node(Node prev, Node next, int val) {
            this.next = next;
            this.prev = prev;
            this.val = val;
        }
    }

    private Node dummyHead;
    private Node dummyTail;
    private int size;

    public MyLinkedList() {
        dummyHead = new Node(null, null, -1);
        dummyTail = new Node(dummyHead, null, -1);

        dummyHead.next = dummyTail;
        size = 0;
    }
    
    public int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }

        int cnt = index;
        Node cur = dummyHead.next;
        while (cnt-- > 0) {
            cur = cur.next;
        }

        return cur.val;
    }
    
    public void addAtHead(int val) {
        Node node = new Node(dummyHead, dummyHead.next, val);
        dummyHead.next.prev = node;
        dummyHead.next = node;

        size++;
    }
    
    public void addAtTail(int val) {
        Node node = new Node(dummyTail.prev, dummyTail, val);
        dummyTail.prev.next = node;
        dummyTail.prev = node;

        size++;
    }
    
    public void addAtIndex(int index, int val) {
        if (index < 0 || index > size) {
            return;
        }

        if (index == 0) {
            addAtHead(val);
            return;
        }

        if (index == size) {
            addAtTail(val);
            return;
        }

        int cnt = index;
        Node cur = dummyHead.next;
        while (cnt-- > 0) {
            cur = cur.next;
        }

        Node node = new Node(cur.prev, cur, val);
        cur.prev.next = node;
        cur.prev = node;

        size++;
    }
    
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }

        int cnt = index;
        Node cur = dummyHead.next;
        while (cnt-- > 0) {
            cur = cur.next;
        }

        cur.next.prev = cur.prev;
        cur.prev.next = cur.next;

        size--;
    }
}
```

## 双指针

双指针一般分为快慢指针和前后指针，链表涉及的通常是快慢指针。

快慢指针一般通过对**步长的控制**或者让快指针**先走几步**来达到想要的效果，一般快指针达到某个条件时，慢指针就走到了想要的位置。

### 力扣 83 删除排序链表中的重复元素

![image-20220406113254874](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220406113254874.png)

本题和数组去重双指针法类似，如果发现 fast 不等于 slow，就直接让 slow 指向 fast，最后 slow 断开与剩下的元素的连接即可：

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) {
        return head;
    }

    ListNode fast = head, slow = head;

    while (fast != null) {
        if (fast.val != slow.val) {
            slow.next = fast;
            slow = slow.next;
        }
        fast = fast.next;
    }

    slow.next = null;

    return head;
}
```

### 力扣 19 删除链表倒数第 N 个结点

![image-20220405115635314](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220405115635314.png)

找到倒数第 N - 1 个就好了，然后让该结点的 next 指向 next 的 next。

怎么找 N - 1 个呢？很简单，快指针先走 N + 1 步，然后两个指针一起走，快指针走到结尾时慢指针就走到了 N - 1 的位置。

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(-1, head);
    ListNode slow = dummy;
    ListNode fast = dummy;

    int cnt = 0;
    // 注意要找到是倒数 n - 1，要让快指针多走一步
    while (fast != null && cnt < n + 1) {
        cnt++;
        fast = fast.next;
    }

    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }

    slow.next = slow.next.next;

    return dummy.next;
}
```

### 力扣 876 链表的中间结点

![image-20220404113137906](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220404113137906.png)

快指针走两步，慢指针走一步，快指针走到尾以后，慢指针就来到了中点。

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head, fast = head;
		
        // 包含奇数和偶数两种情况
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        return slow;
    }
}
```

### 力扣 142 环形链表Ⅱ

![image-20220404111556664](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220404111556664.png)

这题也可以控制步长，快指针走两步，慢指针走一步，可以证明，它们一定相遇。

假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

![image-20220404112635206](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220404112635206.png)

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的整数倍。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：

![image-20220404112748453](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220404112748453.png)

所以，相遇之后，head 往后走，slow 也往后走，它们碰到时，就是入口。

```java
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
		
        // 碰到了
        if (slow == fast) {
            ListNode pHead = head;
            ListNode pFast = fast;
			
            // head 和 fast 都以 1 步的步长走
            while (pHead != pFast) {
                pFast = pFast.next;
                pHead = pHead.next;
            }
            return pFast;
        }
    } 

    return null;
}
```

### 力扣 160 相交链表

![image-20220404114040643](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220404114040643.png)

一种简单的方法是，计算长度，让长的那方先走 diff（长度差）步，然后一起走，碰到了就是相交的地方。

也可以让 A 走到尾部以后，连接到 B，转换成环形链表来做。

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    int lenA = getLength(headA);
    int lenB = getLength(headB);
    int diff = lenA - lenB;
    ListNode pA = headA;
    ListNode pB = headB;

    if (diff > 0) {
        while (diff > 0) {
            pA = pA.next;
            diff--;
        }
    } else {
        while (diff < 0) {
            pB = pB.next;
            diff++;
        }
    }

    while (pA != null && pB !=null) {
        if (pA == pB) {
            break;
        } else {
            pA = pA.next;
            pB = pB.next;
        }
    }

    return pA;
}

private int getLength(ListNode head) {
    int cnt = 0;
    while (head != null) {
        head = head.next;
        cnt++;
    }
    return cnt;
}
```

## 递归

### 力扣 206 反转链表

![image-20220405115520241](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220405115520241.png)

本题的迭代法很容易：

```java
public ListNode reverseList(ListNode head) {
    ListNode pre = null, cur = head, next = head;
    
    while (cur != null) {
        next = cur.next;
        
        cur.next = pre;
        
        pre = cur;
        cur = next;
    }
    
    return pre;
}
```

重点在于递归版，这类题目都可以使用递归解决并且能够反映递归的精髓。

递归三要素：

1. 明确递归函数的作用
2. 找到跳出递归的条件。
3. 根据递归逻辑在递归函数内部调用递归函数。

在这里，首先我们明确函数的作用，就是反转从 head 开始的链表，返回新的头结点：

```java
// 反转从 head 开始的链表，返回新的头结点
public ListNode reverseList(ListNode head) {
    //  ...
}
```

那么，我们的递归结束条件就是**只有一个结点或根本没有结点的时候，不用反转**。

```java
// 反转从 head 开始的链表，返回新的头结点
public ListNode reverseList(ListNode head) {
    //  本身为空或者下一个为空则不用反转，直接返回
    if (head == null || head.next == null) {
        return head;
    }
    
    // ...
}
```

接下来，就是根据递归逻辑调用递归函数本身了，因为我们的函数作用是反转然后返回新的头结点，所以我们可以直接反转后面 n - 1 个结点：

```java
public ListNode reverseList(ListNode head) {
    //  本身为空或者下一个为空则不用反转，直接返回
    if (head == null || head.next == null) {
        return head;
    }

    // last 接收反转后的头
    ListNode last = reverseList(head.next);
    
    // ...
}
```

本质上，我们要**把递归视作一个完整的大过程，而不要深入进去，要相信大过程写对了，递归就能正确的工作**。

这样一来，head.next 及其之后的结点全部反转好了，只剩下 head 没有反转：

![image-20220405120825362](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220405120825362.png)

我们只需要让 head.next 的 next 指针指向 next，再让 head.next 指向 null 就完成了：

```java
public ListNode reverseList(ListNode head) {
    //  本身为空或者下一个为空则不用反转，直接返回
    if (head == null || head.next == null) {
        return head;
    }

    // last 接收反转后的头
    ListNode last = reverseList(head.next);
    // head 的 下一个结点的 next 指回 head
    head.next.next = head;
    // head 的 next 指向空
    head.next = null;

    // 返回新头
    return last;
}
```

这就是递归。

### 力扣 92 反转链表Ⅱ

![image-20220405120958476](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220405120958476.png)

首先我们实现一个比它稍微简单一点的功能，反转从 head 开始的 n 个结点，这和上一题的差别仅在于上一题要反转 head 后的所有结点，这里只需要反转其后 n 个。

依然是递归实现，递归三部曲：

1. 递归函数的作用就是反转从 head 开始的 n 个结点，返回新头结点。

   ```java
   private ListNode reverseN(ListNode head, int n) {
       // ...
   }
   ```

2. 结束条件，如果 n == 1，是不是就不用反转了？因此结束条件就是 n == 1，此时需要一个额外的变量记录当前结点的后一个结点，因为 n 之后还有节点，要让头结点连接上它才行。

   ```java
   private ListNode successor;
   
   private ListNode reverseN(ListNode head, int n) {
       if (n == 1) {
           successor = head.next;
           return head;
       }
       
       // ...
   }
   ```

3. 根据递归逻辑在递归函数内部调用递归函数。

   和上面的逻辑类似，把递归视作大过程，反转从 head.next 开始的 n - 1 个结点即可。

   ```java
   private ListNode successor;
   
   private ListNode reverseN(ListNode head, int n) {
       if (n == 1) {
           successor = head.next;
           return head;
       }
       
      	ListNode last = reverseN(head.next, n - 1);
       
       head.next.next = head;
       head.next = successor;
       
       return last;
   }
   ```

实现了这个功能后，就可以实现本题了，当 left == 1 时，不就是反转前 N 个结点吗？这就是递归的终止条件：

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    if (left == 1) {
        return reverseN(head, right);
    }

    // ...
}
```

接下来根据递归逻辑，把 head.next 视作新的链表，反转对应的部分，然后 head.next 指向反转后的新链表头就完成了：

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    if (left == 1) {
        return reverseN(head, right);
    }

    head.next = reverseBetween(head.next, left - 1, right - 1);
    return head;
}
```

### 力扣 25 K 个一组反转链表

![image-20220405130254328](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220405130254328.png)

这题其实也是部分反转，所以我们可以先把上面的代码复制一份拿来用。

本题大过程依然使用递归：

1. 函数作用就是从 head 开始 k 个一组反转链表，不足 k 的就不反转。

   ```java
   public ListNode reverseKGroup(ListNode head, int k) {
       // ...
   }
   ```

2. 递归结束条件其实已经在题目中说明了，就是不足 k 个就不反转：

   ```java
   public ListNode reverseKGroup(ListNode head, int k) {
       if (head == null) {
           return head;
       }
   
       // 找到 k 个后的第一个节点，用 end 记录
       ListNode begin = head, end = head;
      	// 反转总是从 1 开始，left 不必记录，但是 right 需要自己计算
       int right = 0;
       for (int i = 0; i < k; ++i) {
           // 不足 k 个，不反转
           if (end == null) {
               return head;
           }
           end = end.next;
           right++;
       }
       
       // ...
   }
   ```

3. 递归逻辑。

   接下来就很简单了，反转了前 k 个以后，获得了新的头，接下来以 end 作为下一步反转的头即可，最后返回新头：

   ```java
   public ListNode reverseKGroup(ListNode head, int k) {
       if (head == null) {
           return head;
       }
   
       // 找到 k 个后的第一个节点，用 end 记录
       ListNode begin = head, end = head;
       int right = 0;
       for (int i = 0; i < k; ++i) {
           if (end == null) {
               return head;
           }
           end = end.next;
           right++;
       }
   
       // 翻转 [begin, end)
       ListNode newHead = reverseBetween(begin, 1, right);
       
       // begin 已经被翻到后面了，begin.next 递归翻转
       begin.next = reverseKGroup(end, k);
       return newHead;
   }
   ```


### 力扣 234 回文链表

![image-20220405131406940](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220405131406940.png)

这题需要综合上面的技巧，首先找到链表中点，然后从中点开始反转链表，然后利用双指针，从头开始和从中间开始比较，完整代码如下：

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode slow = head, fast = head;

        // 找到链表中点
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        // 如果 fast.next 没有指向 null，说明 fast 是最后一个，此时链表长度是奇数
        // slow 需要再走一步才能到开始比较的地方
        if (fast != null && fast.next != null) {
            slow = slow.next;
        }

        // 从 slow 开始翻转
        slow = reverse(slow);

        while (slow != null) {
            if (head.val != slow.val) {
                return false;
            }
            slow = slow.next;
            head = head.next;
        }

        return true;
    }

    private ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        ListNode newHead = reverse(head.next);
        
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

