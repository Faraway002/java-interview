# 动态规划

**首先，动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求**最长**递增子序列呀，**最小**编辑距离等等。

既然是要求最值，核心问题是什么呢？

* **求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。
* 动态规划的穷举有点特别，因为这类问题**存在重叠子问题**，如果**暴力穷举的话效率会极其低下**，所以需要备忘录或者 DP table 来优化穷举过程，避免不必要的计算。
* 同时，正儿八经的动态规划问题一定会**具备最优子结构**，这样才能通过子问题的最值得到原问题的最值。
* 虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的状态转移方程**，才能正确地穷举。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划的三要素，在实际的算法问题中，**写出状态转移方程是最困难的**。

动态规划问题的解决思路：

1. **明确 base case**
2. **明确状态 **
3. **明确选择 **
4. **明确 dp 数组的含义**

最后，明确了上面这些东西之后，状态转移方程差不都也就浮出水面了，**写出状态转移方程**即可。

按上面的套路走，最后的结果就可以套这个框架：

```java
int[][][...] dp = // 定义 dp 数组，确定其含义以及状态

// 初始化 base case
dp[0][0][...] = base
// 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            // 这是一个做选择的过程
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

## 入门

### 剑指 Offer 10-Ⅰ. 斐波那契数列 & 力扣 509. 斐波那契数

![image-20220707114732111](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220707114732111.png)

本题虽然简单，但是有一个从常规解法到动态规划解法的演变过程，这个思想是需要深入理解的。

1. 暴力解法。由于斐波那契数列定义上就是递归的，因此可以递归解决：

   ```java
   public int fib(int N) {
       if (N == 1 || N == 2) {
           return 1;
       }
       return fib(N - 1) + fib(N - 2);
   }
   ```

   我们也知道这样写代码虽然简洁易懂，但是十分**低效**。

   假设 N = 20，画出这个递归问题的递归树：

   ![image-20220409092908312](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220409092908312.png)

   观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 `f(18)` 被计算了两次，而且你可以看到，以 `f(18)` 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 `f(18)` 这一个节点被重复计算，所以这个算法极其低效。

   这就是动态规划问题的第一个性质：**重叠子问题**。下面，我们想办法解决这个问题。

2. 带备忘录的递归算法。

   我们使用一个数组，记录已经算过的子问题，这就是备忘录的思想。

   ```java
   public int fib(int N) {
       // 备忘录全初始化为 0
       int[] memo = new int[N + 1];
       
       return helper(memo, N);
   }
   
   private int helper(int[] memo, int n) {
       // base case
       if (n == 0 || n == 1) {
           return n;
       }
       // 已经计算过，不用再计算了
       if (memo[n] != 0) {
           return memo[n];
       }
       memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
       
       return memo[n];
   }
   ```

   实际上，带备忘录的递归算法，把一棵存在巨量冗余的递归树通过**剪枝**，改造成了一幅不存在冗余的递归图，极大减少了子问题的个数。

3. `dp` 数组的迭代（递推）解法。

   有了上一步备忘录的启发，我们可以把这个备忘录独立出来成为一张表，通常叫做 DP table，在这张表上完成**自底向上**的推算，而刚刚的备忘录递归函数是自顶向下的。

   ```java
   private int fib(int N) {
       if (N == 0) {
           return 0;
       }
       int[] dp = new int[N + 1];
       // base case
       dp[0] = 0; 
       dp[1] = 1;
       // 状态转移
       for (int i = 2; i <= N; i++) {
           dp[i] = dp[i - 1] + dp[i - 2];
       }
   
       return dp[N];
   }
   ```

本题的状态转移方程：

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/fib.png)

`f(n)` 的函数参数会不断变化，所以你把参数 `n` 想做一个状态，这个状态 `n` 是由状态 `n - 1` 和状态 `n - 2` 转移（相加）而来，这就叫状态转移，仅此而已。

细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。

所以，可以进一步优化，把空间复杂度降为 $O(1)$，这也就是我们最常见的计算斐波那契数的算法。

代码实现如下：

```java
private static final int MOD = 10_0000_0007;

public int fib(int n) {
    if (n <= 1) {
        return n;
    }

    int a = 0;
    int b = 1;

    for (int i = 2; i <= n; ++i) {
        int temp = b;
        b = (b + a) % MOD;
        a = temp;
    }

    return b;
}
```

这一般是**动态规划问题的最后一步优化，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试缩小 DP table 的大小，只记录必要的数据，从而降低空间复杂度**。

### 剑指 Offer 10-Ⅱ. 青蛙跳台阶问题 & 力扣 70. 爬楼梯

![image-20220628110633999](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628110633999.png)

要到达最后一层，我们可以从倒数第一层向上再爬一层得到，也可以从倒数第二层向上再爬两层得到，这个关系为：`dp[i] = dp[i - 1] + dp[i - 2]`。

我们仔细一看，这不就是斐波那契数列吗，可以直接秒杀：

```java
private static final int MOD = 10_0000_0007;

public int numWays(int n) {
    if (n <= 1) {
        return 1;
    }

    int a = 1;
    int b = 1;

    for (int i = 2; i <= n; ++i) {
        int temp = b;
        b = (b + a) % MOD;
        a = temp;
    }

    return b;
}
```

### 力扣 1137 第 N 个泰波那契数

![image-20220502143849441](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220502143849441.png)

不多说了，直接打表秒杀：

```java
public int tribonacci(int n) {
    if (n <= 1) {
        return n;
    }

    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 1;

    for (int i = 3; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}
```

### 力扣 746 使用最小花费爬楼梯

![image-20220502143957360](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220502143957360.png)

本题是爬楼梯的升级版，爬楼梯有一定花费，因此需要做出选择。

题目告诉我们，可以从 0 或 1 开始，因此这就是我们的基础，因为到达这两个台阶不需要任何花费。

由于每次可以向上爬 1 到 2 级，因此当前状态 i 仍然会从 i - 1 或 i - 2 转移而来，具体怎么转移，就要选择两个里面最小的那个。

整体代码如下：

```java
public int minCostClimbingStairs(int[] cost) {
    int n = cost.length;

    // dp[i] 表示到达第 i 层的最小花费
    int[] dp = new int[n + 1];
    
    // 到达 0 和 1 层不需要花费
    dp[0] = 0;
    dp[1] = 0;
    
    for (int i = 2; i <= n; ++i) {
        // 可以爬两级或者一级，选其中最小的那个
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }

    return dp[n];
}
```

### 剑指 Offer 46. 把数字翻译成字符串

![image-20220707120601219](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220707120601219.png)

本题可以使用回溯法，但是效率比较低。

假设当前数字为 num[0 ~ i]，则如果 num[i - 1]num[i] 组成的数处于 10 ~ 25 的范围内，那么它们就可以作为一个整体被翻译，当然，它们也可以被拆分为两个独立的数翻译，因此翻译方式取决于 num[0 ~ i - 1] 和 num[0 ~ i - 2] 的翻译方式的和。

这就是我们的状态转移方程，因此可以使用动态规划。

代码实现如下：

```java
public int translateNum(int num) {
    String numStr = String.valueOf(num);
    int n = numStr.length();

    // dp[i] 表示以 numStr[i] 结尾的字符串有 dp[i] 种翻译方式
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; ++i) {
        int curNum = Integer.parseInt(numStr.substring(i - 2, i));
        if (curNum >= 10 && curNum <= 25) {
            dp[i] = dp[i - 1] + dp[i - 2];
        } else {
            dp[i] = dp[i - 1];
        }
    }

    return dp[n];
}
```

### 剑指 Offer 14- I. 剪绳子 & 力扣 341 整数拆分

![image-20220703110115978](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703110115978.png)

设一根绳子长度为 $n$，当 $n >= 2$ 时，可以拆分成至少两根绳子。令 $k$ 是拆分出的第一根绳子的长度，则剩下的部分是 $n-k$，$n−k$ 可以不继续拆分，或者继续拆分成至少两根绳子，这也是我们状态转移的依据。

四部曲：

1. 明确 base case：从本题定义上看，0 和 1 不能拆分，2 开始才可以拆分为 2 个 1，因此这就是 base case。
2. 明确状态：本题状态就是绳子长度 n。
3. 明确选择：我们刚刚也说过了，这里不重复叙述。
4. 明确 dp 数组的含义：`dp[i]` 表示正整数 i 被拆分后得到的最大乘积。

状态转移方程：

* 如果当前正整数 i 被拆分出 j 这段，且 (i - j) 这段不继续拆分，则 `dp[i] = Math.max(dp[i], (i - j) * j)`
* 如果当前正整数 i 被拆分出 j 这段，且 (i - j) 这段继续拆分，则 `dp[i] = Math.max(dp[i], dp(i - j) * j)`

代码实现如下：

```java
public int cuttingRope(int n) {
    int[] dp = new int[n + 1];
    dp[2] = 1;

  	for (int i = 3; i <= n; ++i) {
    		for (int j = 2; j < i; ++j) {
      		dp[i] = Math.max(dp[i], Math.max(dp[i - j] * j, (i - j) * j));
    		}
  	}

  	return dp[n];
}
```

### 力扣 322 零钱兑换

![image-20220416104223407](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220416104223407.png)

斐波那契数列严格来说不算动态规划问题，因为没有涉及到最优子结构，本题就会涉及到最优子结构了。

**要符合最优子结构，子问题间必须互相独立**。

举个例子说明什么叫独立：假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。

回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 `amount = 11` 时的最少硬币数（原问题），如果你知道凑出 `amount = 10` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互限制，是互相独立的。

既然知道本题具有最优子结构，那么就可以动态规划四部曲了：

1. **明确 base case**：这个很简单，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

2. **明确状态**：由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的状态就是目标金额 `amount`。

3. **明确选择**：目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的选择。

4. **明确 `dp` 函数的定义**：一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的状态；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即目标金额，题目要求我们计算凑出目标金额所需的最少硬币数。

   **`dp` 数组的定义：当目标金额为 `i` 时，至少需要 `dp[i]` 枚硬币凑出**。

```jAVA
public int coinChange(int[] coins, int amount) {
    if (amount == 0) {
        return 0;
    }

    // 初始化 dp 数组为 amount + 1，这是因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    
	// base case
    dp[0] = 0;

    for (int i = 1; i <= amount; ++i) {
        for (int coin : coins) {
            // 状态转移
            if (i - coin >= 0) {
                dp[i] = Math.min(dp[i - coin] + 1, dp[i]);
            }
        }
    }

    return dp[amount] == amount + 1 ? -1 : dp[amount];
}
```

## 路径问题

### 力扣 62 不同路径

![image-20220505141722060](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220505141722060.png)

本题可以使用回溯，但是需要遍历整棵树才能统计出来共有多少条路径，复杂度很高。

动态规划四部曲：

1. 明确 base case：本题如果只有一行或一列，那么就只有一条路径。
2. 明确状态：本题的结果很明显取决于终点的位置，也就是行和列两个状态。
3. 明确选择：题目明确给出，机器人每次只能向下或者向右移动一步。
4. 明确 dp 数组的含义：`dp[i][j]` 表示以 i 和 j 为终点不同路径的数量。

状态转移方程：`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

```java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];

    for (int i = 0; i < m; ++i) {
        dp[i][0] = 1;
    }

    for (int i = 0; i < n; ++i) {
        dp[0][i] = 1;
    }

    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    return dp[m - 1][n - 1];
}
```

### 力扣 63 不同路径Ⅱ

![image-20220508101450811](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220508101450811.png)

这题是上一题的升级版，我们的大体思路都是类似的，唯一不同的地方在于转移时和设置 base case 时的条件处理：

* 对于 base case，如果开头就是障碍物，直接返回 0；如果只有一行或一列，且其中有一个障碍物，那么障碍物后面的格子都无法达到。
* 对于转移，如果碰到了障碍物，我们是无法往这边走的，直接跳过。

代码如下：

```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    int[][] dp = new int[m][n];

    if (obstacleGrid[0][0] == 1) {
        return 0;
    }

    for (int i = 0; i < m; ++i) {
        // base case 碰到障碍物，后面的都达不到
        if (obstacleGrid[i][0] == 1) {
            break;
        }
        dp[i][0] = 1;
    }

    for (int i = 0; i < n; ++i) {
        // base case 碰到障碍物，后面的都达不到
        if (obstacleGrid[0][i] == 1) {
            break;
        }
        dp[0][i] = 1;
    }

    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            // 转移时碰到障碍物，跳过
            if (obstacleGrid[i][j] == 1) {
                continue;
            }
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    return dp[m - 1][n - 1];
}
```

### 剑指 Offer 47. 礼物的最大价值

![image-20220703103204501](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703103204501.png)

本题其实和上两题类似的，都只能由两个方向转移而来，因此不详细叙述了。

代码实现如下：

```java
public int maxValue(int[][] grid) {
    if (grid.length == 0 || grid[0].length == 0) {
        return 0;
    }

    int[][] dp = new int[grid.length][grid[0].length];

    dp[0][0] = grid[0][0];

    for (int i = 1; i < grid[0].length; ++i) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
    }

    for (int i = 1; i < grid.length; ++i) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }

    for (int i = 1; i < grid.length; ++i) {
        for (int j = 1; j < grid[0].length; ++j) {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }

    return dp[grid.length - 1][grid[0].length - 1];
}
```

### 力扣 931 下降路径最小和

![image-20220503100913228](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220503100913228.png)

本题可以回溯，但是要求的是最小值，意味着要遍历整棵树，复杂度很高。

回溯不行一般最终解法都是 dp，我们考虑动态规划的做法。

我们设一个二维 dp 数组，表示下降到 `matrix[i][j]` 时的最小和。

状态转移方程很容易得到：对于 `matrix[i][j]`，只有可能从 `matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]` 这三个位置转移过来，因此转移方程为：`dp[i][j] = 三个之中的最小值 + matrix[i][j]`。

辅助函数，求三个数的最小值：

```java
private int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```

本题完整代码如下：

```java
public int minFallingPathSum(int[][] matrix) {
    int n = matrix.length;

    if (n == 1) {
        return matrix[0][0];
    }

    int[][] dp = new int[n][n];
    int ans = Integer.MAX_VALUE;

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (i == 0) {
                dp[i][j] = matrix[i][j];
            } else if (j == 0) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j];
            } else if (j == n - 1) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j];
            } else {
                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1], dp[i - 1][j - 1]) + matrix[i][j];
            }

            if (i == n - 1) {
                ans = Math.min(dp[i][j], ans);
            }
        }
    }

    return ans;
}

private int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```

本题是需要遍历整个 dp table 才能得到答案的题目，由于第一行的选择很多，我们不能只选其中一个，也不能盲目的去选最小的，因为你不能保证选了最小的以后最后得到的路径就一定是最小的。

从此题，我们可以得到动态规划题的两种形式：

1. 打出 dp table 以后能够从 dp table 的最后一个元素（或某个特定的位置）直接得到结果的。
2. 需要遍历整个 dp table 才能得到答案的。

本题还有一个点比较重要，就是 **base case 和 dp 初始值可能不是一成不变的，要灵活的根据题意设置这些值**。 

## 子序列问题

子序列问题是常见的算法问题，而且并不好解决。

首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举你都不一定会，更别说求解相关的算法问题了；而且，子序列问题很可能涉及到两个字符串，如果没有一定的处理经验，真的不容易想出来。

一般来说，这类问题都是让你求一个**最长子序列**，因为最短子序列就是一个字符，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 $O(n^2)$**。

原因很简单，一个字符串的子序列有多少种可能？至少是指数级的，这种情况下，必须使用动态规划技巧避免重复运算。

本节还会包含一些子数组子串的问题，因为子串和子数组也算作特殊的子序列。

子序列问题通常有两种 dp 数组：

1. 一维数组，dp[i] 表示以 i 结尾的序列的最大（小）xxx
2. 二维数组，二维数组通常用在两个字符串上，当然，也可以用在一个字符串上
   * 用在两个字符串上时，通常是 s1 以 i，s2 以 j 结尾
   * 用在一个字符串上时，通常是以 i 开头，j 结尾。

除了 dp 之外，还经常用到双指针的技巧，表示开头或结尾。

### 剑指 Offer 42. 连续子数组的最大和 & 力扣 53. 最大子数组和

![](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220501112112411.png)

动态规划四部曲：

1. 明确 base case：单个元素也被视为一个子数组，最大和就是它本身。
2. 明确状态：状态就是当以当前元素结尾时，子数组的最大和。
3. 明确选择：如果当前元素在当前子数组之后，且加入当前元素不会使得整个数组比当前元素小（这种情况大多发生在前面全是负数，然后出现了一个正数的情况），如果加入当前元素后还比当前元素小，说明前面负数负的太多，不如从自己这里重新开始。
4. 明确 dp 数组的定义：dp[i] 表示以 i（下标）结尾的子数组的最大和，这时要得到答案，就要遍历 dp 数组了。

状态转移方程：`dp[i] = Math.max(nums[i], nums[i] + dp[i - 1])`

```java
public int maxSubArray(int[] nums) {
    int n = nums.length;

    if (n == 1) {
        return nums[0];
    }

    int[] dp = new int[n];
    // base case
    dp[0] = nums[0];
    int ans = nums[0];
    for (int i = 1; i < n; ++i) {
        dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
        ans = Math.max(ans, dp[i]);
    }

    return ans;
}
```



### 最长回文子序列问题

最长回文子序列（Longest Palindromic Subsequence，LPS）是一个经典的动态规划问题，给你一个字符串，找出其中的最长回文子序列。

#### 力扣 516 最长回文子序列

![image-20220502094016153](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220502094016153.png)

本题就是一个经典的子序列问题，我们也可以用回溯枚举所有的子序列，然后判断每一个子序列是否为回文串，找出最长的那个，这个方法需要遍历整棵树，时间复杂度和空间复杂度都很高。

这时候就需要使用动态规划了，四部曲：

1. **明确 base case**：每单个字符可以被视作一个回文子序列。
2. **明确状态**：本题子序列的长度取决于开头和结尾两个位置，因此状态有两个，需要二维的 dp 数组。
3. **明确选择**：当开头和结尾的字符相等时，我们同时选择两个；否则，就看开头/结尾和当前最长回文子串组成的串能不能构成更长的回文串。
4. **明确 `dp` 数组的定义**：`dp[i][j]` 表示以 i 开头，j 结尾的最长回文子串。

状态转移方程：

* 如果 `s.charAt(i) == s.charAt(j)`：`dp[i][j] = dp[i + 1][j - 1] + 2`
* 否则：`dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])`

```java
public int longestPalindromeSubseq(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];
    
    // base case
    for (int i = 0; i < n; ++i) {
        dp[i][i] = 1;
    }

	for (int i = n - 1; i >= 0; i--) {
        // j 和 i 反向
        for (int j = i + 1; j < n; j++) {
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = 2 + dp[i + 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[0][n - 1];
}
```

>**dp 数组的遍历方向如何确定？**
>
>对于这个问题，只需要把握住两点：
>
>1. **遍历的过程中，所需的状态必须是已经计算出来的**。
>2. **遍历结束后，存储结果的那个位置必须已经被计算出来**。
>
>以本题为例，`dp[i][j]` 需要从 `dp[i + 1][j - 1]`、`dp[i + 1][j]` 和 `dp[i][j - 1]` 转移而来，那么本题肯定是从后往前遍历。

> **为什么有时候没有看到 base case 的设置？**
>
> 这是因为 base case 通常是 0, false 这样的默认值，在构造数组时已经默认给了这些值，因此不需要显式设置。
>
> 以本题为例，本题 base case 的值是 1，肯定要显式设置的。

> **为什么有时候 dp 数组的长度会比字符串长度 + 1？**
>
> 理论上，你怎么定义都可以，只要根据定义处理好 base case 就可以。
>
> 以 322 零钱兑换问题为例，本题的 dp 数组长度就比 amount 要多 1，这是因为遍历过程会涉及到 dp[amount]，长度肯定是要 + 1 的。

#### 力扣 1312 让字符串成为回文串的最少插入次数

![image-20220502102704788](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220502102704788.png)

本题是 516 的变形，本题要求把一个字符串变成回文串需要添加的最小字符数，那么就可以求出它的最长回文子串，然后用长度减去最长回文子串的长度，就是需要添加的最小字符数。

```java
public int minInsertions(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];

    for (int i = 0; i < n; ++i) {
        dp[i][i] = 1;
    }

    for (int i = n - 1; i >= 0; --i) {
        for (int j = i + 1; j < n; ++j) {
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = 2 + dp[i + 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }

    return n - dp[0][n - 1];
}
```

### 最长递增子序列问题

最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 $O(N^2)$，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。

#### 力扣 300 最长递增子序列

![image-20220416105034161](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220416105034161.png)

1. **明确 base case**：这个很简单，显然单个数组元素算一个递增子序列，因此最基本的 case 就是每一个以当前元素结尾的最小的递增子序列长度为 1。
2. **明确状态**：状态就是当以当前元素结尾时，最长的递增子序列长度。
3. **明确选择**：如果你选择把当前元素比之前最长的递增子序列最后一个元素大，那么可以加入，并且长度 + 1；否则不能加入。
4. **明确 `dp` 数组的定义**：`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度。

状态转移方程：对于任意 j，有 i > j >= 0，如果 nums[i] > nums[j]，则 dp[i] = dp[j] + 1。然后，dp[i] 的最终值应该是 dp[j] 里最大的那个 + 1，因此：`dp[i] = Math.max(dp[i], dp[j] + 1);`

```java
public int lengthOfLIS(int[] nums) {
    // dp[i] 表示以 num[i] 结尾的最长递增子序列的长度
    int[] dp = new int[nums.length];
    // base case
    Arrays.fill(dp, 1);
    int ans = 1;

    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            // 保证递增
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
                ans = Math.max(ans, dp[i]);
            }
        }
    }

    return ans;
}
```

##### 二分法解决 LIS 问题

这个解法的时间复杂度为 $O(NlogN)$，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。

首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/poker1.jpeg)

**处理这些扑克牌要遵循以下规则**：

* 只能把点数小的牌压到点数比它大的牌上；
* 如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；
* 如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。

比如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的）。

![img](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/poker2.jpeg)

为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q）

按照上述规则执行，可以算出最长递增子序列，**牌的堆数就是最长递增子序列的长度**。

我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是**有序**吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。

```java
int lengthOfLIS(int[] nums) {
    int[] top = new int[nums.length];
    // 牌堆数初始化为 0
    int piles = 0;
    for (int i = 0; i < nums.length; i++) {
        // 要处理的扑克牌
        int poker = nums[i];

        // 搜索左侧边界的二分查找
        int left = 0, right = piles - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (top[mid] >= poker) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // 没找到合适的牌堆，新建一堆
        if (left == piles) {
            piles++;
        }
        // 把这张牌放到牌堆顶
        top[left] = poker;
    }
    // 牌堆数就是 LIS 长度
    return piles;
}
```

证明略，有兴趣可以去了解一下。

#### 力扣 674 最长连续递增序列

![image-20220502104307322](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220502104307322.png)

本题应该叫做最长递增子数组更为合适，它和 LIS 问题的区别就在于连续二字。

动态规划四部曲：

1. 明确 base case：单个元素也被视为最长连续递增序列，长度为 1。
2. 明确状态：状态就是当以当前元素结尾时，最长连续递增序列的长度。
3. 明确选择：如果当前元素在当前最长连续递增序列之后，且比递增序列大的最后一个元素大，则可以选择，否则不选择。
4. 明确 dp 数组的定义：dp[i] 表示以 i（下标）结尾的最长连续递增序列的长度。

状态转移方程：

* 如果 `nums[i] > nums[i - 1]`，则 `dp[i] = dp[i - 1] + 1`

```java
public int findLengthOfLCIS(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    int ans = 1;
    for (int i = 1; i < n; ++i) {
        if (nums[i] > nums[i - 1]) {
            dp[i] = dp[i - 1] + 1;
        }
        ans = Math.max(dp[i], ans);
    }

    return ans;
}
```

本题可以视作一种贪心的思想：如果当前元素能够让当前序列继续保持递增，就选择它；否则，直接抛弃当前序列，从当前元素开始，优化后代码如下：

```java
public int findLengthOfLCIS(int[] nums) {
    int n = nums.length;
    int ans = 1;
    int start = 0;
    for (int i = 1; i < n; ++i) {
        if (nums[i] <= nums[i - 1]) {
            start = i;
        }
        ans = Math.max(i - start + 1, ans);
    }

    return ans;
}
```

#### 力扣 354 俄罗斯套娃信封问题

![image-20220416111112969](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220416111112969.png)

本题的难点有两个：

1. 把该问题抽象为 LIS 问题。

   根据题意，只有一个信封宽高都严格大于另一个信封的宽高时，才允许放入。

   那么我们就要先把一个维度定下来，比如我们先按照 w 升序排序，再按照 h 降序排序，就会得到：

   <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220416111814327.png" alt="image-20220416111814327" style="zoom: 67%;" />

   那么我们只要找 h 维度的最长递增子序列，就可以得到能够套娃的信封。

   <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220416112142972.png" alt="image-20220416112142972" style="zoom:67%;" />

   因为 w 是递增的，h 是降序的，同一 w 的情况下，h 越大的排在前面，这样就保证了 h 小的不会被选中。

   ```java
   public int maxEnvelopes(int[][] envelopes) {
       int n = envelopes.length;
       int[] dp = new int[n];
       Arrays.fill(dp, 1);
   
       Arrays.sort(envelopes, (a, b) -> a[0] - b[0] == 0 ? b[1] - a[1] : a[0] - b[0]);
   
       int[] height = new int[n];
       for (int i = 0; i < n; i++) {
           height[i] = envelopes[i][1];
       }
           
       return lengthOfLIS(height);
   }
   ```

2. 使用 $O(NlogN)$ 的时间复杂度的 LIS 解法解决本题。

   本题的最难的地方就在于此，普通的动态规划解法会在部分用例超时，因此必须采用二分的方式解决本题。

   ```java
   private int lengthOfLIS(int[] nums) {
       int n = nums.length;
       int[] top = new int[n];
       int piles = 0;
   
       for (int num : nums) {
           int left = 0, right = piles - 1;
           while (left <= right) {
               int mid = left + (right - left) / 2;
               if (top[mid] >= num) {
                   right = mid - 1;
               } else {
                   left = mid + 1;
               } 
           }
   
           if (left == piles) {
               piles++;
           }
           top[left] = num;
       }
   
       return piles;
   }
   ```

### 最长公共子序列问题

最长公共子序列（Longest Common Subsequence，LCS）是一道经典的动态规划题目，给你输入两个字符串 `s1` 和 `s2`，请你找出他们俩的最长公共子序列。

#### 力扣 1143 最长公共子序列

![image-20220416142221453](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220416142221453.png)

本题的暴力解法就是穷举所有的子序列，找到最大的那个，很明显，这样做复杂度太高了。

对于子序列问题，我们之前讲过要么使用二维 dp，要么使用一维 dp，这里涉及到两个字符串，所以需要使用二维 dp。

动态规划四部曲：

1. 明确 base case：如果一个字符串长度为 0，那么它和另一个字符串就没有任何公共子序列
2. 明确状态：两个字符串的公共子序列取决于两边结尾的字符，因此状态有两个
3. 明确选择：如果两个字符串当前指针指向的字符相等，则可以同时选择，让长度 + 1；否则，选择其中一个看看能不能组成更长的子序列。
4. 明确 dp 数组的含义：`dp[i][j]` 表示对于 s1[1..i] 和 s2[1..j]，它们的 LCS 长度是 `dp[i][j]`

状态转移方程：

* 如果 `s1.charAt(i) == s2.charAt(j)`：`dp[i][j] = 1 + dp[i - 1][j - 1]`
* 否则：`dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j])`

```java
public int longestCommonSubsequence(String s1, String s2) {
    int m = s1.length(), n = s2.length();

    // dp[i][j] 的含义是：对于 s1[1..i] 和 s2[1..j]，它们的 LCS 长度是 dp[i][j]
    // 这里用 0 表示空串
    int[][] dp = new int[m + 1][n + 1]; 

    // base case 是 dp[0][x] dp[x][0] 都为 0

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            // 状态转移
            // 当字符相同时，可以从当前 lcs 长度 + 1
            // 不同时，取两边的最大值
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[m][n];
}
```

#### 力扣 583 两个字符串的删除操作

![image-20220503094358145](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220503094358145.png)

本题是在 1143 lcs 问题的基础上做的，其实很简单，找到 lcs，然后用长度减去即可。

```java
public int minDistance(String word1, String word2) {
    int l = lcs(word1, word2);
    return word1.length() + word2.length() - 2 * l;
}

private int lcs(String s1, String s2) {
    int n = s1.length(), m = s2.length();

    int[][] dp = new int[n + 1][m + 1];

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[n][m];
}
```

#### 力扣 712 两个字符串的最小 ASCII 删除和

![image-20220503094919567](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220503094919567.png)

本题和 583 类似，但是需要灵活的变通，首先题目要求的是删除的 ASCII 和最小，那么我们找 ASCII 最大的公共子序列就好了，用总和减去这个最大和就是答案。

其次，怎么找 ASCII 和最大的公共子序列呢？反正我们求出字串之后也要求它的和，不如我们的 dp 数组就保存这个和，那么我们只要对 lcs 的代码做简单的修改就解决了：

```java
public int minimumDeleteSum(String s1, String s2) {
    int n = s1.length(), m = s2.length();

    int[][] dp = new int[n + 1][m + 1];

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + s1.charAt(i - 1);
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    int sum = 0;
    for (char ch : s1.toCharArray()) {
        sum += ch;
    }

    for (char ch : s2.toCharArray()) {
        sum += ch;
    }

    return sum - 2 * dp[n][m];
}
```

#### 力扣 392 判断子序列

![image-20220504092344902](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220504092344902.png)

本题的解法很多，首先最容易想到的就是双指针，碰到相同的就两个指针一起往前走，不同的就在 t 上继续往前走，到最后如果 s 匹配完毕则是子串，否则不是。

这个方法时间复杂度 $O(N)$，空间复杂度 $O(1)$。

本题还可以视为 LCS 问题，找出 s 和 t 的最长公共子序列，判断 s 是否就是这个最长公共子序列就可以了。

```java
public boolean isSubsequence(String s, String t) {
	int n = s.length(), m = t.length();
    
    int[][] dp = new int[n + 1][m + 1];
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (s.charAt(i - 1) == t.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[n][m] == n;
}
```

##### 拓展要求

对于本题的拓展要求来说，使用二分查找的效率更高。

具体来说，我们存储主串中每个字符出现的下标，组成多个列表，比如：

![image-20220504093946819](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220504093946819.png)

假设 s 是 "abc"，并且已经匹配了 ab，也就是说，t 的指针指向了 4，按照双指针的解法，我们可以让 t 的指针继续推进；而使用二分，我们可以搜索 c 出现的下标中比当前位置大的第一个位置，也就是使用左侧边界的二分搜索。

```java
public boolean isSubsequence(String s, String t) {
    Map<Character, List<Integer>> map = new HashMap<>();

    int n = s.length(), m = t.length();
    for (int i = 0; i < m; ++i) {
        List<Integer> list = map.getOrDefault(t.charAt(i), new ArrayList<>());
        list.add(i);
        map.put(t.charAt(i), list);
    }

    int j = 0;
    for (int i = 0; i < n; ++i) {
        List<Integer> list = map.get(s.charAt(i)); 
        if (list == null) {
            return false;
        }

        int pos = leftBorder(list, j);
        if (pos == list.size()) {
            return false;
        } else {
            j = list.get(pos) + 1;
        }
    }
    return true;
}

private int leftBorder(List<Integer> list, int target) {
    int lo = 0, hi = list.size() - 1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        if (list.get(mid) >= target) {
            hi = mid - 1;
        } else {
            lo = mid + 1;
        }
    } 
    return lo;
}
```

### 力扣 115 不同的子序列

![image-20220504105114729](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220504105114729.png)



### 力扣 72 编辑距离

![image-20220416142028482](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220416142028482.png)

本题是一道很难的题，但是解法却又很清晰，是经典的动态规划题目。

一般涉及这样两个字符串的问题，通常是二维 dp 加双指针解决，动态规划四部曲：

1. 明确 base case：本题如果有一个串是空串，那么另一个串要变为空串只能全部删除（或者空串全部添加）。

   从这里也可以看出，删除和添加操作其实是等价的，因此**我们把操作限定在一个串上，另一个不动，也能得到结果，而且使得问题更简化**。

2. 明确状态：本题状态就是以不同位置字符结尾的编辑距离也会不一样，因此状态有两个。

3. 明确选择：因为题目提供了三种操作，我们的选择也就要从这三种操作中选择，选择其中能使得编辑距离最短的那个。

4. 明确 dp 数组含义：`dp[i][j]` 表示 s1[1...i]，s2[1...j] 的最短编辑距离。注意我们又把 dp 数组偏移了，这是因为在这里空串是有意义的，因此必须偏移。

状态转移方程：

* 如果 `s1.charAt(i) == s2.charAt(j)`，此时前面的最短编辑距离已经求出，这里我们直接跳过，不用做任何操作就可以使得最小，即 `dp[i][j] = dp[i - 1][j - 1]`
* 如果 `s1.charAt(i) != s2.charAt(j)`，此时就要考虑做三种操作（假设把操作限定在 s1 上）：
  * 做删除操作，此时 s1 删除了一个字符，s2 不用动，那么当前编辑距离就等于 i - 1 和 j 的最小编辑距离（删除一个字符后才和 j 匹配上）再加上本次操作，即`dp[i][j] = dp[i - 1][j] + 1 `
  * 做增加操作，此时 s1 增加了一个字符，s2 不用动，那么当前编辑距离就等于 i 和 j - 1 的最小编辑（添加一个字符后才和 j 匹配上）距离再加上本次操作，即`dp[i][j] = dp[i][j - 1] + 1 `
  * 做替换操作，由于替换肯定是把字符替换为相同的字符，此时编辑距离就等于 i - 1 和 j - 1 的最小编辑距离再加上本次操作，即`dp[i][j] = dp[i - 1][j - 1] + 1 `

```java
public int minDistance(String s1, String s2) {
    int n = s1.length(), m = s2.length();

    int[][] dp = new int[n + 1][m + 1];

    for (int i = 1; i <= n; ++i) {
        dp[i][0] = i;
    }

    for (int i = 1; i <= m; ++i) {
        dp[0][i] = i;
    }

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1);
            }
        }
    }

    return dp[n][m];
}

private int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```

## 背包问题

背包问题也是一个经典的动态规划问题，给你一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性。其中第 `i` 个物品的重量为 `wt[i]`，价值为 `val[i]`，现在让你用这个背包装物品，最多能装的价值是多少？

这个题目中的物品不可以分割，**要么装进包里，要么不装**，不能说切成两块装一半，这也就是 0-1 背包这个名词的来历。

解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，也就是使用动态规划的解决办法，四部曲：

1. 明确 base case：当物品没得选或者当背包没有容量时，价值都为 0
2. 明确状态：状态有两个，一个是当前背包的容量，另一个是可供选择的物品
3. 明确选择：对于任意一件物品来说，选择只有装或者不装
4. 明确 dp 数组的含义：`dp[i][w]` 的定义如下：对于前 `i` 个物品，当前背包的容量为 `w`，这种情况下可以装的最大价值是 `dp[i][w]`

状态转移方程：

* 如果把物品 i 装进了背包，那么 `dp[i][w] = dp[i - 1][w - wt[i]] + val[i]`
* 如果没有把物品 i 装入背包，那么 `dp[i][w] = dp[i - 1][w]`

我们结合具体题目来展示代码。

### 子集背包问题

#### 力扣 416 分割等和子集

![image-20220508100843552](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220508100843552.png)



## 打家劫舍问题

## 买卖股票问题

## 经典动态规划问题

### 剑指 Offer 19.正则表达式匹配 & 力扣 10 正则表达式匹配

![image-20220629114502910](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220629114502910.png)

如果学过编译原理的话，可以考虑采用 NFA，但是代码量会比较大。

本题难点在于 * 的处理，* 可以匹配 0 个或多个字符，所以我们首先不考虑 *。

如果没有 *，则：

* 如果模式串当前字符是普通字符，则取决于主串字符和模式串字符是否相等。
* 如果模式串当前字符是 '.'，则无论主串是任何字符，它都可以匹配。

那么带上 *，就要考虑多一些了，因为 * 表示它前一个字符的 0 个或多个，因此它们实际上是一个整体：

* 如果这个整体不能匹配，则相当于模式串直接少了两个字符，就看这两个字符之前的部分能否和主串匹配。
* 如果这个整体至少能够匹配一个字符，则需要继续向前匹配，看它能否匹配主串中的多个字符。

我们看到，经过上面的分析，实际上就是一个穷举选择的过程，因此我们考虑使用动态规划，四部曲：

1. 明确 base case：如果主串是空串，模式串不是，则不能匹配；反过来也是一样的。但是，空串和空串是可以匹配的。
2. 明确状态：状态就是主串和模式串当前的位置。
3. 明确选择：选择刚刚已经说过了，这里先略过。
4. 明确 dp 数组的含义：`dp[i][j]` 表示 `dp[1~i][1~j]` 是否匹配。

状态转移方程见代码，代码实现如下：

```java
public boolean isMatch(String s, String p) {
    int sLen = s.length();
    int pLen = p.length();

    // dp[i][j] 表示 dp[1~i][1~j] 是否匹配
    boolean[][] dp = new boolean[sLen + 1][pLen + 1];

    for (int i = 0; i <= sLen; ++i) {
        for (int j = 0; j <= pLen; ++j) {
            // 空串和非空串肯定不匹配
            if (j == 0) {
                dp[i][j] = (i == 0);
            } else {
                // * 要和它前面那个字符看做是一个整体
                if (p.charAt(j - 1) == '*') {
                    // 不匹配任何字符，则相当于直接少掉两个字符
                    if (j >= 2) {
                        dp[i][j] |= dp[i][j - 2];
                    }

                    // 主串当前字符和模式串 * 前一个字符匹配，则继续往前匹配，看看是否还能匹配多个
                    if (i >= 1 && j >= 2 && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) {
                        dp[i][j] |= dp[i - 1][j];
                    }
                } else {
                    if (i > 0 && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.')) {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                }
            }
        }

    }

    return dp[sLen][pLen];
}
```

### 力扣 64 最小路径和

![image-20220504102153013](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220504102153013.png)

说实话，本题第一眼我想到的是回溯，代码如下：

```java
private final int[][] DIRS = {{1, 0}, {0, 1}};

private int ans = Integer.MAX_VALUE;

public int minPathSum(int[][] grid) {
    dfs(grid, 0, 0, 0);
    return ans;
}

private void dfs(int[][] grid, int i, int j, int curSum) {
    int M = grid.length;
    int N = grid[0].length;

    if (i < 0 || j < 0 || i >= M || j >= N) {
        return;
    }

    if (i == M - 1 && j == N - 1) {
        ans = Math.min(curSum + grid[i][j], ans);
    }

    for (int[] dir : DIRS) {
        dfs(grid, i + dir[0], j + dir[1], curSum + grid[i][j]);
    }
}
```

但是很可惜，这种解法会超时，这是因为回溯没有消除重叠子问题，导致了大量的重复计算，但是正确性是毋庸置疑的。

想要消除重叠子问题，就得动态规划，四部曲：

1. 明确 base case：如果只有一个格子，那么就不用往下走了；如果只有一行，那么只能从左边转移到右边；如果只有一列，那么只能从上面转移到下面。
2. 明确状态：本题状态有两个，也就是所处的行和列
3. 明确选择：本题转移方程题目已经给出了，就是从上面或左边转移而来，那么我们只需要选其中小的那个即可
4. 明确 dp 数组的含义：`dp[i][j]` 表示以 (i, j) 为右下角时的最小路径和

状态转移方程：`dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]`

代码实现如下：

```java
public int minPathSum(int[][] grid) {
    int row = grid.length, col = grid[0].length;

    int[][] dp = new int[row][col];

    // base case
    dp[0][0] = grid[0][0];
    for (int i = 1; i < col; ++i) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
    }
    for (int j = 1; j < row; ++j) {
        dp[j][0] = dp[j - 1][0] + grid[j][0];
    }

    // 状态转移
    for (int i = 1; i < row; ++i) {
        for (int j = 1; j < col; ++j) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }

    return dp[row - 1][col - 1];
}
```

### 力扣 174 地下城游戏

### 剑指 Offer 49. 丑数 & 力扣 264 丑数Ⅱ

![image-20220703105545681](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220703105545681.png)

本题如果正向思维（遍历，判断数是否为丑数）的话，时间复杂度就很高了。

本题可以逆向思维，从 base case 开始，生成丑数，这正是动态规划的思想。

每一个丑数都由一个已知的丑数乘上丑数因子而来，这就是我们状态转移方程的依据。

但是本题有一个问题，比如 1 乘上 2 3 5 之后，得到 2 3 5，然后从 2 开始，但是我们发现 2 * 2 实际上是小于 1 * 5 的，这就导致**小的丑数有可能生成在大丑数后面**。

为了防止这种情况发生，则我们每次生成丑数时应该选择当前最小的。

具体实现，我们使用三个指针，一开始同时指向开头，也就是 base case。

然后，三个指针分别负责乘以 2 3 5，但是只选择最小的那个作为下一个丑数的取值，此时，生成了这个丑数的指针 + 1，其他指针不动。

这样一来，我们就保证了能够生成更大丑数的指针留在原地不动，保证不会错过任何一个丑数。

代码实现如下：

```java
public int nthUglyNumber(int n) {
    int[] dp = new int[n];

    dp[0] = 1;

    // 三个指针分别负责 * 2，* 3，* 5
    int a = 0, b = 0, c = 0;
    for (int i = 1; i < n; ++i) {
        dp[i] = Math.min(Math.min(dp[a] * 2, dp[b] * 3), dp[c] * 5);

        if (dp[i] == dp[a] * 2) {
            a++;
        }

        if (dp[i] == dp[b] * 3) {
            b++;
        }

        if (dp[i] == dp[c] * 5) {
            c++;
        }
    }


    return dp[n - 1];
}
```

### 剑指 Offer 46. 把数字翻译成字符串

![image-20220707113546816](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220707113546816.png)



### 力扣 312 戳气球

### 力扣 517 自由之路

### 力扣 787 K 站中转内最便宜的航班

### 力扣 877 石子游戏

### 力扣 887 鸡蛋掉落
