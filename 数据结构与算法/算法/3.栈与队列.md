[TOC]

# 栈与队列

栈与队列是经常使用的数据结构，栈可以被用于模拟递归，也就是函数调用的过程，通常可以实现迭代版的 DFS；而队列经常用于 BFS。

## 基础

### 力扣 232 用栈实现队列 & 剑指 Offer 09.用两个栈实现队列

![image-20220419212619310](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220419212619310.png)

本题限制只能用栈的标准操作。

仔细思考队列的性质，是先进先出。只用一个栈是无法实现这一功能的，必须使用至少两个栈（题目也正是这么要求的），我们称之为 s1 和 s2。

入队时，就往 s1 那边入栈，s2 保持空；出队时，由于最先入栈的元素也要最先出，而最先入栈的元素被压在最底下，因此要把 s1 中的元素都弹出去到 s2，现在 s2 顶部的元素就是要出队的元素。

现在入队时，依然往 s1 那边入栈，出站时先从 s2 出，直到 s2 空，重复上面的步骤即可。

```java
class MyQueue {
    private Deque<Integer> stackIn = new ArrayDeque<>();
    private Deque<Integer> stackOut = new ArrayDeque<>();

    public MyQueue() {

    }
    
    public void push(int x) {
        stackIn.push(x);
    }
    
    public int pop() {
        transferTo();
        return stackOut.pop();
    }
    
    public int peek() {
        transferTo();
        return stackOut.peek();
    }
    
    public boolean empty() {
        return stackIn.isEmpty() && stackOut.isEmpty();
    }

    private void transferTo() {
        if (!stackOut.isEmpty()) {
            return;
        }

        while (!stackIn.isEmpty()) {
            stackOut.push(stackIn.pop());
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

### 力扣 225 用队列实现栈

![image-20220419213749477](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220419213749477.png)

本题既可以使用一个队列实现，也可以使用两个队列实现。

使用一个队列时，入栈就是入队；出栈时，把队尾元素前面的所有元素重新塞到队尾，让队尾元素排到队头，这样就可以取出了。

使用两个队列时，设为 q1 和 q2，入栈时，先入 q1；出栈时，把 q1 的元素依次出队然后依次入队到 q2，只留下一个元素，这个元素就是要出栈的元素。

这次入栈时，就要在 q2 入，出栈时就要把 q2 的元素移到 q1，留下一个元素。

```java
class MyStack {
    private Queue<Integer> queue1 = new ArrayDeque<>();
    private Queue<Integer> queue2 = new ArrayDeque<>();

    public MyStack() {

    }

    public void push(int x) {
        if (queue1.isEmpty()) {
            queue2.offer(x);
        } else {
            queue1.offer(x);
        }
    }

    public int pop() {
        if (queue1.isEmpty()) {
            while (queue2.size() != 1) {
                queue1.offer(queue2.poll());
            }
            return queue2.poll();
        } else {
            while (queue1.size() != 1) {
                queue2.offer(queue1.poll());
            }
            return queue1.poll();
        }
    }

    public int top() {
        int ret = -1;
        if (queue1.isEmpty()) {
            while (queue2.size() != 1) {
                queue1.offer(queue2.poll());
            }
            ret = queue2.peek();
            queue1.offer(queue2.poll());
        } else {
            while (queue1.size() != 1) {
                queue2.offer(queue1.poll());
            }
            ret = queue1.peek();
            queue2.offer(queue1.poll());
        }

        return ret;
    }

    public boolean empty() {
        return queue1.isEmpty() && queue2.isEmpty();
    }
}
```

### 力扣 20 有效的括号

![image-20220419220816199](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220419220816199.png)

本题是经典的栈的应用，使用一个栈记录所有的左括号，如果碰到右括号，则查看栈中的左括号的类型是否和当前右括号匹配。

```java
private Map<Character, Character> bracketMap = new HashMap<>();

{
    bracketMap.put(')', '(');
    bracketMap.put(']', '[');
    bracketMap.put('}', '{');
}

public boolean isValid(String s) {
    char[] chs = s.toCharArray();

    Deque<Character> stack = new ArrayDeque<>();
    for (char ch : chs) {
        if (ch == '(' || ch == '[' || ch == '{') {
            stack.push(ch);
        } else {
            if (stack.isEmpty()) {
                return false;
            }

            if (bracketMap.get(ch) != stack.pop()) {
                return false;
            }
        }
    }

    return stack.isEmpty();
}
```

### 力扣 1047 删除字符串中所有相邻重复项

![image-20220419221506644](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220419221506644.png)

本题依然是用栈模拟，如果当前字符和栈顶元素相同，就出栈，否则入栈，最后统计栈内剩余字符：

```java
public String removeDuplicates(String s) {
    Deque<Character> stack = new ArrayDeque<>();

    char[] chs = s.toCharArray();

    int idx = 0;
    while (idx < chs.length) {
        if (stack.isEmpty()) {
            stack.push(chs[idx]);
        } else {
            if (stack.peek() == chs[idx]) {
                stack.pop();
            } else {
                stack.push(chs[idx]);
            }
        }
        idx++;
    }

    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()) {
        sb.append(stack.pop());
    }
    return sb.reverse().toString();
}
```

### 力扣 844 比较含退格的字符串

![image-20220419214508601](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220419214508601.png)

本题最优解可能是使用双指针，但是代码比较复杂，本题用栈是最合适的，使用栈可以完美的模拟输入\退格的操作。

```java
public boolean backspaceCompare(String s, String t) {
    String ss = getTrueString(s);
    String ts = getTrueString(t);

    return ss.equals(ts);
}

private String getTrueString(String s) {
    char[] chs = s.toCharArray();

    Deque<Character> st = new ArrayDeque<>();

    for (char ch : chs) {
        if (ch != '#') {
            st.push(ch);
        } else {
            if (st.isEmpty()) {
                continue;
            }
            st.pop();
        }
    }

    StringBuilder sb = new StringBuilder();
    while (!st.isEmpty()) {
        sb.append(st.pop());
    }

    return sb.reverse().toString();
}
```

### 力扣 150 逆波兰表达式求值

![image-20220419222225548](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220419222225548.png)

本题使用一个栈记录数字，当碰到操作符时，就从栈中弹出两个数然后运算，把运算结果重新放到栈中。只要这个表达式是合法的，最后栈中一定只剩下一个数，弹出它返回即可。

下面的代码巧妙的利用了 Java 的错误处理机制简化代码：

```java
public int evalRPN(String[] tokens) {
    Deque<Integer> nums = new LinkedList<>();

    for (String token : tokens) {
        try {
            int num = Integer.parseInt(token);
            nums.push(num);
        } catch (NumberFormatException e) {
            Integer num2 = nums.pop();
            Integer num1 = nums.pop();
            nums.push(op(num1, num2, token.charAt(0)));
        }
    }

    return nums.pop();
}

private int op(int num1, int num2, char op) {
    if (op == '+') {
        return num1 + num2;
    } else if (op == '-') {
        return num1 - num2;
    } else if (op == '*') {
        return num1 * num2;
    } else {
        return num1 / num2;
    }
}
```

### 力扣 224 & 227 基本计算器 & 基本计算器Ⅱ

![image-20220420103647762](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220420103647762.png)

![image-20220420103704412](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220420103704412.png)

个人认为 227 才能称得上是困难难度，但是 227 不包含括号，224 不包含乘除，因此都不是完全体。

接下来我们讲解的算法可以一次性解决这些问题，实现真正的计算器。

基本的思路是**使用双栈**，一个记录操作数，一个记录操作符。

有几个细节需要注意：

- 由于第一个数可能是负数，为了减少边界判断。一个小技巧是先往 `nums` 添加一个 0
- 为防止 `()` 内出现的首个字符为运算符，将所有的空格去掉，并将 `(-` 替换为 `(0-`，`(+` 替换为 `(0+`
- 由于操作数并不仅限于个位数，因此需要读取一整个数直到碰到符号或到末尾为止。
- 运算符之间存在优先级，当碰到运算符时我们不能立马将其进入符号栈：
  * 如果栈空，可以直接进入。
  * 如果栈不空，则检查栈顶的符号优先级，如果栈顶符号优先级更高或者是同优先级，就让它先行计算。
- 如果是 `(`，则直接进入符号栈。
- 如果是 `)`，则要进行运算直到碰到左括号。
- 输入的表达式可能包含空格，需要先行去除。

完整代码如下，使用这段代码可以过这两题：

```java
public int calculate(String s) {
    Deque<Integer> nums = new ArrayDeque<>();
    nums.push(0);
    Deque<Character> ops = new ArrayDeque<>();

    s = s.replaceAll(" ", "");

    for (int i = 0; i < s.length(); ++i) {
        char ch = s.charAt(i);
        
        // 是数，压入操作数栈
        if (Character.isDigit(ch)) {
            int num = ch - '0';
            while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {
                num = (s.charAt(i + 1) - '0') + num * 10;
                i++;
            }
            nums.push(num);
        } else {
            // 是左括号，直接入栈
            if (ch == '(') {
                ops.push(ch);
            } else if (ch == ')') {
                // 是右括号，进行运算直到碰到左括号
                while (ops.peek() != '(') {
                    calc(nums, ops);
                }
                ops.pop();
            } else {
                // 如果符号前面还是符号，压入一个 0 处理
                if (i > 0 && (s.charAt(i - 1) == '(' || s.charAt(i - 1) == '+' || s.charAt(i - 1) == '-')) {
                    nums.push(0);
                }

                // 把能运算的先按照运算符优先级进行运算
                while (!ops.isEmpty() && ops.peek() != '(') {
                    char preOp = ops.peek();
                    if (getPriority(ch) <= getPriority(preOp)) {
                        calc(nums, ops);
                    } else {
                        break;
                    }
                }
                ops.push(ch);
            }
        }
    }

    // 最后操作符栈不空的话还要继续运算
    while (!ops.isEmpty()) {
        calc(nums, ops);
    }

    return nums.pop();
}

/**
 * 从操作数栈弹出两个数，从操作符栈弹出一个操作符进行运算，把运算结果压回操作数栈中
 * 
 * @param nums 操作数栈
 * @param ops 操作符栈
 */
private void calc(Deque<Integer> nums, Deque<Character> ops) {
    char op = ops.poll();
    int num2 = nums.poll(), num1 = nums.poll();
    int res;
    if (op == '+') {
        res = num1 + num2;
    } else if (op == '-') {
        res = num1 - num2;
    } else if (op == '*') {
        res = num1 * num2;
    } else {
        res = num1 / num2;
    }
    nums.push(res);
}

/**
 * 获取运算符优先级
 * 
 * @param op 运算符
 */
private int getPriority(char op) {
    if (op == '+' || op == '-') {
        return 1;
    } else {
        return 2;
    }
}
```

## 优先队列

### 力扣 347 前 K 个高频元素

![image-20220420124413256](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220420124413256.png)

使用 Map 统计频率，然后使用优先队列进行排序即可。

```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();

    for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }

    PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((e1, e2) -> e2.getValue() - e1.getValue());

    queue.addAll(map.entrySet());

    int[] ans = new int[k];

    for (int i = 0; i < k; ++i) {
        ans[i] = queue.poll().getKey();
    }

    return ans;
}
```

### 力扣 692 前 K 个高频单词

![image-20220420124539687](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220420124539687.png)

和上一题类似：

```java
public List<String> topKFrequent(String[] words, int k) {
    Map<String, Integer> map = new HashMap<>();
    for (String word : words) {
        map.put(word, map.getOrDefault(word, 0) + 1);
    }

    PriorityQueue<Map.Entry<String, Integer>> queue = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue() == 0 ? a.getKey().compareTo(b.getKey()) : b.getValue() - a.getValue());
    queue.addAll(map.entrySet());

    List<String> ans = new ArrayList<>();
    while (k-- > 0) {
        ans.add(queue.poll().getKey());
    }

    return ans;
}
```

### 力扣 451 根据字符出现频率排序

![image-20220420124551605](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220420124551605.png)

同上。

```java
public String frequencySort(String s) {
    Map<Character, Integer> map = new HashMap<>();
    for (char ch : s.toCharArray()) {
        map.put(ch, map.getOrDefault(ch, 0) + 1);
    }

    PriorityQueue<Map.Entry<Character, Integer>> queue = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());
    queue.addAll(map.entrySet());
    char[] ans = new char[s.length()];
    int idx = 0;
    while (!queue.isEmpty()) {
        Map.Entry<Character, Integer> cur = queue.poll();
        int cnt = cur.getValue();
        while (cnt-- > 0) {
            ans[idx++] = cur.getKey();
        }
    }

    return new String(ans);
}
```

### 力扣 973 最接近原点的 K 个点

![image-20220420112110194](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220420112110194.png)

同上。

```java
public int[][] kClosest(int[][] points, int k) {
    PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> getDistance(a) - getDistance(b));
    for (int[] point : points) {
        queue.add(point);
    }

    int[][] ans = new int[points.length][2];
    int idx = 0;
    while (k-- > 0) {
        ans[idx++] = queue.poll();
    }

    return Arrays.copyOf(ans, idx);
}

private int getDistance(int[] point) {
    int x = point[0];
    int y = point[1];

    return x * x + y * y;
}
```

## 单调栈

单调栈是在栈的基础上额外添加一个限制条件，即从栈顶到栈底的元素是递增（或递减）的。

具体进栈过程如下：

- 对于单调递增栈，若当前进栈元素为 `e`，从栈顶开始遍历元素，把小于 `e` 或者等于 `e` 的元素弹出栈，直接遇到一个大于 `e` 的元素或者栈为空为止，然后再把 `e` 压入栈中。
- 对于单调递减栈，则每次弹出的是大于 `e` 或者等于 `e` 的元素。

模板如下：

```java
Stack<Integer> stack = new Stack<>();

// 假设这个数组中的元素要被放入单调递增栈
int[] arr = ;//...
for (int num : arr) {
    if (stack.empty() || stack.peek() >= num) {
        // 也可以存放下标，方便记录位置
        stack.push(num);
    } else {
        while (!stack.empty() && stack.peek() < num) {
            stack.pop();
        }
		stack.push(num);        
    }
}
```

单调栈并不是用来专门存储数据的，很多时候它都是用来解决问题，通常是找下一个更小的或者下一个更大的元素之类的题目。

### 力扣 739 每日温度

![image-20220421101352487](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220421101352487.png)

本题的正常解法是双重循环，寻找比当前元素大的元素，然后更新答案数组。

要想一遍遍历完成，就要借助单调递减栈保存下标，如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。

**如果单调栈需要弹出了，就意味着找到了比栈顶元素更大的温度**，此时可以更新答案数组。

```java
public int[] dailyTemperatures(int[] temperatures) {
    Deque<Integer> st = new ArrayDeque<>();
    int n = temperatures.length;
    int[] ans = new int[n];

    for (int i = 0; i < n; ++i) {
        while (!st.isEmpty() && temperatures[st.peek()] < temperatures[i]) {
            ans[st.peek()] = i - st.peek();
            st.pop();
        }
        st.push(i);
    }

    while (!st.isEmpty()) {
        ans[st.pop()] = 0;
    }

    return ans;
}
```

### 力扣 496 下一个更大元素 Ⅰ

![image-20220421184646456](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220421184646456.png)

本题也是找下一个最大元素，看起来本题是两个数组，实际上是一个，因为 nums1 是 nums2 的子集。

我们可以利用哈希表 + 单调栈，记录 nums2 的情况，碰到比当前元素大的元素就建立一个映射。

```java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    Deque<Integer> st = new ArrayDeque<>();
    Map<Integer, Integer> map = new HashMap<>();
    int[] ans = new int[nums1.length];

    for (int i = 0; i < nums2.length; ++i) {
        while (!st.isEmpty() && nums2[i] > st.peek()) {
            map.put(st.pop(), nums2[i]);
        }
        st.push(nums2[i]);
    }

    for (int i = 0; i < nums1.length; ++i) {
        ans[i] = map.getOrDefault(nums1[i], -1);
    }

    return ans;
}
```

### 力扣 503 下一个更大元素 Ⅱ

![image-20220421184653685](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220421184653685.png)

本题和上一题不一样的是，本题要在整个数组上搜索，而且是循环搜索。

一个常用的技巧是把数组扩充为原来的两倍，元素也复制一份，这样搜索到数组最后一个元素时就不会出现 -1 这种情况。

实际上，我们根本不需要对数组进行实际的扩充，我们可以利用取余运算。

比如 1 2 1 这个示例，我们不需要实际的扩充，只要增加遍历的长度，当遍历下标 3 时，实际上在遍历 3 % 3，也就是 0 这个下标。

代码实现：

```java
public int[] nextGreaterElements(int[] nums) {
    Deque<Integer> st = new ArrayDeque<>();
    int n = nums.length;
    int[] ans = new int[n];
    Arrays.fill(ans, -1);

    for (int i = 0; i < n * 2 - 1; i++) {
        while (!st.isEmpty() && nums[st.peek()] < nums[i % n]) {
            ans[st.pop()] = nums[i % n];
        }
        st.push(i % n);
    }

    return ans;
}
```

## 单调队列

类似于单调栈，就是一个队列，只是使用了一点巧妙的方法，使得**队列中的元素全都是单调递增（或递减）的**。

单调队列主要解决滑动窗口中的最值问题。

### 力扣 239 滑动窗口的最大值

![image-20220422091018738](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220422091018738.png)

这题目字面意义上很简单，就是维护一个窗口，求窗口内的最大值。

无非就是右边进，左边出，比之前的滑动窗口题还要简单。那么为什么这题是 hard？这是因为只维护窗口然后在窗口内遍历寻找最值会超时。

```java
static class MyQueue extends ArrayDeque<Integer> {
    @Override
    public Integer peek() {
        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> b - a);
        queue.addAll(this);
        return queue.peek();
    }
}

public int[] maxSlidingWindow(int[] nums, int k) {
    int left = 0, right = k - 1;

    Queue<Integer> queue = new MyQueue();
    for (int i = left; i < right; ++i) {
        queue.offer(nums[i]);
    }

    int[] ans = new int[nums.length];
    int ansIdx = 0;
    while (right < nums.length) {
        queue.offer(nums[right]);
        ans[ansIdx++] = queue.peek();
        queue.poll();
        left++;
        right++;
    }

    return Arrays.copyOf(ans, ansIdx);
}
```

本题使用了优先队列，我们知道，堆排序的最坏时间复杂度都是 O(nlogn)，连这样的代码都会超时，说明我们必须使用 O(n) 甚至 O(logn) 的算法。

现在就要使用我们的单调队列了，和单调栈类似，单调队列是从队头到队尾的递增或递减的队列，因此入队时，需要把之前不符合条件的从队尾出队；出队时，直接出队队头即可，我们总是保证队头是最大或最小的那个。但是这样可能会导致窗口内有元素不在队列中，所以需要一个简单的判断。

实现：

```java
class MonotonicQueue {
    Deque<Integer> q = new ArrayDeque<>();

    public void offer(int n) {
        // 将小于 n 的元素全部删除
        while (!q.isEmpty() && q.peekLast() < n) {
            q.pollLast();
        }
        // 然后将 n 加入尾部
        q.addLast(n);
    }

    public int peek() {
        return q.getFirst();
    }

    public void poll(int n) {
        if (n == q.getFirst()) {
            q.pollFirst();
        }
    }
}
```

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    MonotonicQueue window = new MonotonicQueue();
    List<Integer> res = new ArrayList<>();

    for (int i = 0; i < nums.length; i++) {
        if (i < k - 1) {
            // 先填满窗口的前 k - 1
            window.offer(nums[i]);
        } else {
            // 窗口向前滑动，加入新数字
            window.offer(nums[i]);
            // 记录当前窗口的最大值
            res.add(window.peek());
            // 移出旧数字
            window.poll(nums[i - k + 1]);
        }
    }

    int[] arr = new int[res.size()];
    for (int i = 0; i < res.size(); i++) {
        arr[i] = res.get(i);
    }
    return arr;
}
```

