# 数学专题

本专题专门记载一些需要数学技巧的题。

## 力扣 191 位 1 的个数 & 剑指 Offer 15.二进制中 1 的个数

![image-20220628112440255](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628112440255.png)

本题最容易想到的就是每一位都和 1 与以下，记录 1 的个数：

```java
public int hammingWeight(int n) {
		int cnt = 0;
    while (n != 0) {
      	cnt += n & 0x1;
        n >>>= 1;
    }
    return cnt;
}
```

这种方法最容易想到，时间复杂度 $O(n)$。

我们还有更简洁的方法，考虑这样一个二进制数：

![image-20220628113321312](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628113321312.png)

我们把它 - 1 之后，得到：

![image-20220628113437398](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628113437398.png)

现在，它们相与之后，我们就可以把原来的最后一位 1 消除了：

![image-20220628113552245](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628113552245.png)

这样有多少个 1，我们就只需要执行这么多次操作，就可以稍微缩短时间复杂度：

```java
public int hammingWeight(int n) {
  	int res = 0;
  	while (n != 0) {
    		n = n & (n - 1);
    		res++;
  	}
  	return res;
}
```

#### 力扣 50 Pow(x, n) & 剑指 Offer 16. 数值的整数次方

![](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220628113850732.png)

本题最笨的方法肯定是执行 n 次循环，时间复杂度 $O(n)$。

本题实际上有一个叫做快速幂的技巧：

快速幂指的是利用整数的二进制表示，对于任何十进制数字 n，其二进制可以表示为 $b_m...b_3b_2b_1$，则有：

二进制转十进制：$n = 1 * b_1 + 2 * b_2 + 4 * b_3 + ... + 2^{m-1} * b_m$

则 x 的 n 次方就表示为：$x^n = x^{1 * b_1 + 2 * b_2 + 4 * b_3 + ... + 2^{m-1} * b_m} = x^{1b_1}x^{2b_2}x^{4b_3}...x^{2^{m-1}b_m}$

根据上面的推导，可以把求 $x^n$ 转换为两个问题：

* 计算 $x^1, x^2, x^4, ..., x^{2^{m-1}}$ 的值
* 获取二进制各位的值

我们知道，n 还有可能是负数，此时就是 x 的倒数的 n 次方，我们只需要把 x 倒过来，n 变成负数即可。

需要注意，-2147483648 取反会超出 int 的范围，因此需要使用 long。

代码实现：

```java
public double myPow(double x, int n) {
    if (n == 0) {
        if (x == 0) {
            return Double.NaN;
        }
        return 1;
    }

    long nn = n;

    double res = 1;

    if (nn < 0) {
        x = 1.0 / x;
        nn = -nn;
    }

    while (nn > 0) {
        if ((nn & 1) == 1) {
            res *= x;
        }
        x *= x;
        nn >>= 1;
    }

    return res;
}
```



