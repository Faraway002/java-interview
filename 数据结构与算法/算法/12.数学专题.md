# 数学专题

本专题专门记载一些需要数学技巧的题。

## 剑指 Offer 14- II. 剪绳子 II

![image-20220629101008643](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220629101008643.png)

本题和 14-1 微小的区别就在于答案需要取模，这意味着什么呢？难道用动态规划的做法无法解决吗？

答案是不能，本题数据非常大，使用动态规划需要有一个抉择的过程，而取余后抉择函数（max）就无法工作了，而不取余则会超出数据能表示的最大范围。当然，你也可以选择使用 `BigInteger`，但是时间效率就比较低了。

本题最高效的方法是贪心，可以证明：**当所有绳段长度相等时，乘积最大**，且**每段长度为 3 时，乘积最大**。

证明：

设绳长为 n，并且把绳子切割为 a 段，则有：
$$
n = n_1 + n_2 + ... + n_a
$$
本题就等价于要求：
$$
max(n_1 * n_2 * n_3 * ... * n_a)
$$
由基本不等式，得：
$$
\frac{(n_1 + n_2 + ... + n_a)}{a} \geq \sqrt[a]{n_1n_2n_3...n_a}
$$
这个不等式要成立，则需满足 $n_1 = n_2 = n_3 = ... = n_a$

所以，想要 $max(n_1 * n_2 * n_3 * ... * n_a)$，就要切割为长度相等的段。

那么这个段该是多长呢？现在我们来求它：

我们把绳子切割为 a 段，因此有：$n = ax$，乘积则为：$x^a$，也就是：
$$
x^{\frac{n}{x}}
$$
即：
$$
(x^{\frac{1}{x}})^n
$$
由于 n 是确定的，则问题转换为求 $x^{\frac{1}{x}}$ 的极大值。

设 $y = x^{\frac{1}{x}}$，则两边同时求对数，得到：
$$
\ln y = \frac{1}{x} \ln x
$$
对 x 求导，得到：
$$
\frac{1}{y} \dot{y} = \frac{1}{x^2} - \frac{1}{x^2}\ln x \newline
= \frac{1 - \ln x}{x^2} \newline
$$
整理得：
$$
\dot y = \frac{1 - \ln x}{x^2}x^{\frac{1}{x}}
$$
令 $\dot y$ = 0，则 $1 - \ln x$ = 0，得 x 为 e。

则 x 应该取最接近 e 的整数 3。

则我们可以按照以下规则切分：

1. 最优：3，把绳子尽可能切分为多个长度为 3 的片段。
2. 次优：2，若最后一段绳子为 2，则保留。
3. 最差：1，若最后一段绳子为 1，则应该把一份 3 * 1 替换为 2 * 2。

那么，其实剩下长度**小于等于 4 时，就不用继续拆分了**（3 保留，2 也保留，3 * 1 转移 2 * 2，也就是 4）。

代码实现如下：

```java
private static final int MOD = 10_0000_0007;

public int cuttingRope(int n) {
    if (n == 2) {
        return 1;
    }

    if (n == 3) {
        return 2;
    }

    long ans = 1;
    while (n > 4) {
        ans *= 3;
        ans %= MOD;

        n -= 3;
    }

    return (int) (ans * n % MOD);
}
```

## 力扣 191 位 1 的个数 & 剑指 Offer 15.二进制中 1 的个数

![image-20220628112440255](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628112440255.png)

本题最容易想到的就是每一位都和 1 与以下，记录 1 的个数：

```java
public int hammingWeight(int n) {
		int cnt = 0;
    while (n != 0) {
      	cnt += n & 0x1;
        n >>>= 1;
    }
    return cnt;
}
```

这种方法最容易想到，时间复杂度 $O(n)$。

我们还有更简洁的方法，考虑这样一个二进制数：

![image-20220628113321312](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628113321312.png)

我们把它 - 1 之后，得到：

![image-20220628113437398](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628113437398.png)

现在，它们相与之后，我们就可以把原来的最后一位 1 消除了：

![image-20220628113552245](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628113552245.png)

这样有多少个 1，我们就只需要执行这么多次操作，就可以稍微缩短时间复杂度：

```java
public int hammingWeight(int n) {
  	int res = 0;
  	while (n != 0) {
    		n = n & (n - 1);
    		res++;
  	}
  	return res;
}
```

## 剑指 Offer 16. 数值的整数次方 & 力扣 50. Pow(x, n)

![](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220628113850732.png)

本题最笨的方法肯定是执行 n 次循环，时间复杂度 $O(n)$。

本题实际上有一个叫做快速幂的技巧：

快速幂指的是利用整数的二进制表示，对于任何十进制数字 n，其二进制可以表示为 $b_m...b_3b_2b_1$，则有：

二进制转十进制：$n = 1 * b_1 + 2 * b_2 + 4 * b_3 + ... + 2^{m-1} * b_m$

则 x 的 n 次方就表示为：$x^n = x^{1 * b_1 + 2 * b_2 + 4 * b_3 + ... + 2^{m-1} * b_m} = x^{1b_1}x^{2b_2}x^{4b_3}...x^{2^{m-1}b_m}$

根据上面的推导，可以把求 $x^n$ 转换为两个问题：

* 计算 $x^1, x^2, x^4, ..., x^{2^{m-1}}$ 的值
* 获取二进制各位的值

我们知道，n 还有可能是负数，此时就是 x 的倒数的 n 次方，我们只需要把 x 倒过来，n 变成负数即可。

需要注意，-2147483648 取反会超出 int 的范围，因此需要使用 long。

代码实现：

```java
public double myPow(double x, int n) {
    if (n == 0) {
        if (x == 0) {
            return Double.NaN;
        }
        return 1;
    }

    long nn = n;

    double res = 1;

    if (nn < 0) {
        x = 1.0 / x;
        nn = -nn;
    }

    while (nn > 0) {
        if ((nn & 1) == 1) {
            res *= x;
        }
        x *= x;
        nn >>= 1;
    }

    return res;
}
```



