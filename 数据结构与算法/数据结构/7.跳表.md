# 跳表

跳表（SkipList，全称跳跃表）是用于有序元素序列快速搜索查找的一个数据结构。跳表是一个随机访问的数据结构，实质是一种可以进行二分查找的有序链表。

**跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。**跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL 树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。

下面这张图展示了一个经典的跳表结构：

![image-20220306111333257](https://cdn.jsdelivr.net/gh/Faraway002/typora/imagesimage-20220306111333257.png)

我们都知道，链表的痛点就是查询太慢了，不能随机访问。在计算机科学中，查询慢通常都可以通过加索引来即解决，即空间换时间。

我们在完整的链表上面再添加几层索引，就可以使用类似二分查找的方式来加快查找进度。

比如上面的图中，我们需要查找 8 这个元素，那么我们首先在第一级索引中查找，发现 7 小于 8，因此在第二级索引中的 7 的右边查找。此时又发现 10 比 8 大，因此要找的节点一定在最后一层中 7 的右边，10 的左边。

跳表的性质：

1. 由很多层结构组成
2. 每一层都是一个有序的链表
3. 最底层的链表包含所有元素
4. 如果一个元素出现在第 i 层，那么它也一定会出现在第 i + 1 层
5. 每个节点包含两个指针，一个指向同一层的下一个节点，一个指向下一层的值相同的节点

## 跳表的原理实现

跳表的基础是链表，跳表中链表的节点定义如下：

```java
private static class Node<T> {
    T data;
    Node<T> next;
    Node<T> down;

    public Node(T data) {
        this.data = data;
    }
}
```

### 查找节点

设置一个临时节点 p，它指向 head，跳表的查找过程如下，当 p 不为 null 时：

1. 从 p 节点出发，**如果当前节点的值与查询的值相等**，那么返回当前节点。
2. 如果不相等，且**右侧为 null**，那么只能向下搜索。
3. 如果不相等，且**右侧不为 null**，并且**右侧节点值小于待查询的值**，那么说明同级还可向右。
4. 如果不相等，且**右侧不为 null**，但是**右侧节点值大于待查询的值** ，那么说明不可向右了，向下继续搜索。

代码实现如下：

```java
public Node<T> find(T value) {
    Node<T> p = head;

    while (p != null) {
        if (p.data.compareTo(value) == 0) {
            return p;
        } else {
            if (p.next == null || p.next.data.compareTo(value) > 0) {
                p = p.down;
            } else {
                p = p.next;
            }
        }
    }

    return null;
}
```

### 插入节点

插入节点首先要查找到节点应该插入的位置，这个过程类似于搜索。

插入还需要考虑是否要为当前插入节点建立一个索引，以及这个索引应该插入到哪几层中。

我们无法维护一个完全理想的索引结构，因为它耗费的代价太高。但我们使用**随机化**的方法去判断是否向上层插入索引，插入完毕后再次使用随机数判断是否向上插入索引。运气好这个值可能是多层索引，运气不好只插入最底层。但是索引也不能不限制高度，我们一般会设置索引最高值如果大于这个值就不往上继续添加索引了。

步骤如下：

1. 首先通过上面查找的方式，找到**待插入的左节点**。插入的话最底层肯定是需要插入的，所以通过链表插入节点。
2. 插入完这一层，需要考虑上一层是否插入，首先判断当前索引层级，如果大于最大值那么就停止；否则设置一个随机数以 1/2 的概率向上插入一层索引。
3. 重复 2 的操作，直到概率没有达到或者索引层数大于最大索引层。



## 跳表的简易实现

为了方便，头节点一般不存储数据，而为了方便比较，