# 文件系统

## 前置知识：硬盘及其工作原理

现代的硬盘大致有两种：传统的**机械硬盘（HDD）**与**固态硬盘（SSD）**。HDD 采用磁性碟片来存储，因此也通常被叫做**磁盘**，而 SSD 采用闪存颗粒来存储。

**HDD 相比于 SSD 来说造价更低，但是性能也更差**，这是由它们的原理决定的。同时这也意味着同价格内 HDD 的容量更大，因此大部分计算机会选择使用更快但是更小的 SSD 作为操作系统盘，即把操作系统和其他软件都放在 SSD 里以提高性能，而其他数据则放在更大更便宜的 HDD 中。

通常情况下，HDD 的寿命更长，也更稳定，SSD 的寿命通常比 HDD 段，且有掉盘（系统突然不能识别 SSD）的风险。

### 机械硬盘

机械硬盘是由**盘片**组成的，每个盘片都有两面，我们称之为**表面**，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的**主轴**，它使得盘片以固定的**旋转速率**旋转，通常是 5400 ~ 15000 转/分钟（RPM）。

机械硬盘通常有多个盘片叠加，并封装在一个密闭的容器内，下图展示了一个典型的磁盘表面结构：

![image-20220323153834724](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323153834724.png)

每个表面是由一组称为**磁道**的同心圆组成的，每个磁道被划分为一组**扇区**，每个扇区包含相等数量的数据位（通常是 512 字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些**间隙**隔开，这些间隙并不存储数据位，而用来存储标识扇区的格式化位。

**柱面**是所有盘片表面上到主轴中心距离相等的磁道的集合：

![image-20220323154302435](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323154302435.png)

磁盘还有一个驱动器和传动臂，驱动器控制传动臂，传动臂上有**读写头**。通过沿着半径轴前后移动这个传动臂，驱动器可以将读写头定位在盘面的任何磁道上，**每当读写头经过一个磁道上的位，读写头就可以感知到这个位的值，也可以修改这个位的值**。如果有多个盘片，则有多个读写头。

那么，对数据的访问时间应该由这三部分组成：

* **寻道时间**：为了读取某个目标扇区的内容，传动臂首先要将读写头定位到包含该扇区的磁道上，这个时间被称为寻道时间。

  现代磁盘驱动器的寻道时间通常在毫秒级别。

* **旋转时间**：一旦读写头定位到了期望的磁道，则需要等待盘面旋转直到期望的扇区转到读写头的下方。这个步骤的性能依赖于磁盘的转速。

* **传送时间**：当目标扇区的第一个位来到读写头的下方时，就可以开始读写数据了，这个时间就是传送时间。

想要定位一个数据也很简单，使用`(盘面, 磁道, 扇区)`三元组就可以定位到一个数据。

但是从操作系统的角度来看，以扇区为单位存取数据效率比较低，因此大多数文件系统会把多个扇区视为一个**逻辑块（数据块）**，**以逻辑块为单位读写数据**。在 Linux 上，一个逻辑块的大小是 4 KB，也就是 8 个扇区为一个块，这大大的提高了磁盘存取数据的效率。

### 磁盘调度算法

磁盘调度算法是为了提高访问磁盘的性能，一般是通过优化磁盘的访问请求顺序实现的。

和进程调度不同的是，对于一个 I/O 请求，**操作系统能够大概估计所花费的时间，因此可以使用贪心策略**。

#### 最短寻道时间优先

最短寻道时间（Shortest-Seek-Time-First，SSTF）的思想是：优先选择从当前磁头位置所需**寻道时间最短**的请求。

看下面的例子：

![image-20220323211835575](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323211835575.png)

这个例子中，读写头初始位于内圈磁道的 30 扇区中，请求读取 21 和 2 两个扇区，分别位于中间磁道和外圈磁道，那么根据 SSTF，会优先选择离内圈磁道最近的中间的磁道（此时的寻道时间最短），然后读取 21，再来到外圈磁道读取 2。

但是**这个算法可能会导致饥饿**，如果在读写头来到 2 扇区之前有 22，23，13 扇区（都位于中间磁道）的请求来到，则 2 会被排在最后，这是因为相比于 2，中间磁道中的扇区都不需要额外耗费时间来寻道。甚至，有可能永远也无法轮到 2 扇区。

#### 电梯

**SSTF 产生饥饿的原因在于：读写头有可能只在一个磁道内来回移动**。

为了防止这个问题的出现，我们让读写头从最外圈移动至最内圈，然后从最内圈移动到最外圈，实现一轮一轮的**扫描（Scan）**，并且有额外规定：**如果某个扇区所在的磁道已经在本轮扫描中读取过了，那么它就不会被处理，而是等待下一轮**。

这种算法很类似于电梯的工作方式：总是在一个方向上移动，直到该方向上没有请求为止，然后就改变方向。因此这个算法也被称为**电梯算法**。

电梯算法并不是最好的调度算法，具体来说，它们忽视了旋转，我们需要一个能够综合考虑旋转和寻道的调度算法。

#### 最短定位时间优先

最短定位时间优先（Shortest Positioning Time First，SPTF）是一个综合考虑了旋转和寻道的调度算法，**它通过估算当前读写头到请求的扇区的所需时间来排序，找出最短定位时间的扇区**。

看下面的示例：

![image-20220323213502961](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323213502961.png)

在这个例子中，如果这个磁盘的寻道成本远高于旋转成本，则会选择先读取 16；翻过了，如果这个磁盘的旋转成本更高，则会选择先读取磁道 8。

### 固态硬盘

固态硬盘是一种基于**闪存**的存储技术，它的速度比一般的机械硬盘要快得多。

一个 SSD 封装有闪存芯片和闪存翻译层，闪存芯片就相当于 HDD 的驱动器，而闪存翻译层用于将请求翻译为对底层物理设备的访问。示意图如下：

![image-20220323155644527](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323155644527.png)

一个闪存由 B 个块的序列组成，每个块由 P 页组成，页的大小通常是 512 字节 ~ 4 KB，一块通常有 32 ~ 128 页。

**数据都是以页为单位读写的，只有在一页所属的块被整个擦除后，才能写这一页**。不过，一旦一个块被擦除了，块中的每一页都可以不需要再进行擦除就写一次，在大约经过 10w 次这样的过程后，块就会磨损然后损坏，就不能再使用了。

## 文件系统概述

我们在[前置知识](#前置知识：硬盘及其工作原理)中了解到硬盘，知道硬盘读写数据的原理。但是我们需要为硬盘中的存储数据追踪界限，才能保证这块数据是上次存储的，这是一个非常麻烦的事情，操作系统为数据的存储提供了一种抽象——文件。

**文件**是由进程创建的逻辑信息单元，我们可以把文件视为独立的地址空间，内部含有 n 个字节的序列。和进程的地址空间不同的是，文件是持久化存储的，这意味着如果你没有修改文件，那么无论何时读取该文件时读取到的内容总是一样的。

文件由操作系统进行管理，有关文件的构造、命名、访问、使用和保护等主题都是操作系统需要考虑的，从总体上看，**操作系统中负责处理文件的子系统称为文件系统**，和其他子系统不一样，文件系统是纯软件，操作系统并不会借助任何硬件来使得文件系统在某些方面更好的工作。由于在构建文件系统方面具有很大的灵活性，因此人们构建了许多不同的文件系统。所有这些文件系统都有不同的数据结构，在某些方面优于或逊于同类系统。

**虽然存在各式各样的文件系统，但是文件系统需要实现的功能应该是差不多的**，至于内部如何实现则取决于具体实现。**操作系统应该允许多种文件系统并存，并且给用户提供统一的接口**。

## 虚拟文件系统

文件系统的种类众多，而操作系统希望**对用户提供一个统一的接口**，于是在用户层与文件系统层引入了中间层，这个中间层就称为**虚拟文件系统（Virtual File System，VFS）**。

> **Windows 上的文件系统**
>
> VFS 是 Unix 系列操作系统提出的，Windows 并不遵守这个规则。
>
> Windows 中的主要文件系统是 `NTFS`，但不是说 Windows 只有 NTFS，它还有一些其他的例如旧的 `FAT -32` 或`FAT -16` 驱动器或分区，其中包含仍需要的数据，闪存驱动器，旧的 CD-ROM 或 DVD（每个都有自己的独特文件系统）。
>
> Windows 通过指定不同的盘符来处理这些不同的文件系统，比如 `C:`，`D:` 等。

VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样用户不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。VFS 在操作系统的位置如下图所示：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/vfs.png" alt="vfs" style="zoom:80%;" />

Linux 支持的文件系统比较多，根据存储位置的不同，可以把文件系统分为三类：

- 磁盘文件系统：最常用的文件系统类型，它把数据存储在磁盘中，比如著名的 Ext 2/3/4、Windows 上的 NTFS 等都是这类文件系统。
- 内存文件系统：这类文件系统的数据不是存储在硬盘的，而是存储在物理内存中，我们经常用到的 `/proc` 和 `/sys` 文件系统都属于这一类，读写这类文件，实际上是读写内存中相关的数据。
- 网络文件系统：用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。

任何文件系统要想被操作系统使用，就要**挂载**到操作系统的总文件系统树中，这样做的好处就是操作系统能够统一多个文件系统到一棵树中，让管理更加的方便。比如 Linux 刚启动时，就会把一个文件系统（通常是 Ext 系列文件系统）挂载到根目录上。

**任何文件系统想要被挂载，都需要先向 VFS 注册，并且符合 VFS 的规范**。

## 文件系统实现

### 文件系统分布

**对于实际的文件系统实现来说，它们一般存储在硬件中**。以磁盘为例，大部分的磁盘能够划分出一到多个分区，叫做**磁盘分区**（disk partitioning）或者是磁盘分片，每个分区都有独立的文件系统。整个磁盘的逻辑结构如下图所示：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/1515111-20200325130910338-746877753.png" alt="img" style="zoom:75%;" />

磁盘最前面的扇区是 MBR 引导扇区，相信你已经在[操作系统的加载过程](./0.计算机组成原理概述.md#操作系统的加载过程)中了解到了 MBR 是什么。在 MBR 之后有一个分区表，记录着磁盘是如何分区的，给出了每个分区的起始位置和终止位置。

之后就是磁盘中的每一个分区，一般由如下几个结构组成：

* 引导块：引导块用于加载并启动分区中的操作系统，为了一致性，每个分区都会从引导块开始，**即使引导块不包含操作系统**。

  引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。

* 超级块：**超级块包含文件系统的所有关键参数**，通常包括：

  - 文件系统的大小
  - 文件系统中的数据块数量
  - 指示文件系统状态的标志

  超级块的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。**在计算机启动或者文件系统首次使用时，超级块会被读入到内存中**。

* 空闲空间管理所需要的数据结构：类似于内存的空闲空间管理，磁盘也需要有数据结构来记录磁盘中的空闲空间，便于创建新文件写入新数据。

  通常来说，有好几种不同的算法来管理空闲空间，我们将在之后详细的讲解这些算法。

* inode：inode 是**文件的索引节点**，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、**数据在磁盘的位置**等等。

  **inode 是文件的唯一标识**，它们之间一一对应。

* 数据块区：我们在之前提到过文件系统以数据块（多个扇区）为单位读写数据，因此数据块区就是真实存储文件数据的地方。

### 空闲空间管理

如果要存储一个新的文件，则需要在磁盘上选择一块合适的空间存放，这就涉及到空闲空间管理，常见的几种方式有：

- 空闲表法
- 空闲链表法
- 位图法

需要额外说明的是，inode 块也分配在磁盘上，因此也需要对空闲 inode 进行管理，方法是一致的。

#### 空闲表法

空闲表法就是**为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数**，注意，这个方式是连续分配的。如下图：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324172228956.png" alt="image-20220324172228956" style="zoom:80%;" />

当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止；当删除一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。

这种方法仅当有少量的空闲区时才有较好的效果。因为，**如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低**。另外，这种分配技术适用于建立连续文件。

#### 空闲链表法

上一种方法的显著缺点就是表可能会很大，我们可以利用空闲块本身的部分空间来管理空闲块，即**每一个空闲块里有一个指针指向下一个空闲块**，这样也能很方便的找到空闲块并管理起来。

![image-20220324172715029](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324172715029.png)

这种技术只要在主存中保存一个指针，令它指向第一个空闲块即可，占用空间很小。但是**缺点**也很明显：**不能随机访问**。

**空闲表法和空闲链表法都不适合用于大型文件系统。**

#### 位图法

**位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。**

**当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配**。

这是最常用且占用空间最小的方法，Linux 就采用了这种方法管理空闲空间。

### 文件

文件系统中最关键的抽象就是文件，**文件是 n 个字节的序列**。

在 Linux 上，有一句名言：**一切皆文件**。正如其字面意思，Linux 上的一切都被抽象为文件，但是由于本质不同，处理方式也不同，因此文件也分为不同的类型。

在 Linux 上一般有如下几种文件类型：

* 普通文件：普通文本文件或二进制文件。Linux 中以 `-` 来标识其文件属性。
* 目录文件：将文件的名称和它的索引节点号结合在一起的一张表。Linux 中以 `d` 来标识其文件属性。
* 设备文件：每一种 I/O 设备都对应一个设备文件。具体来说，又分为两种：
  * 块设备文件：存储数据以供系统存取的接口设备，最常见的就是硬盘。Linux 中以 `b` 来标识其文件属性。
  * 字符设备文件：串行端口的接口设备，比如键盘、鼠标等。Linux 中以 `c` 来标识其文件属性。
* 管道文件：主要用于进程间通信，又称 FIFO 文件。Linux 中以 `p` 来标识其文件属性。
* 链接文件：又称符号链接文件，提供了共享文件的方法。Linux 中以 `l` 来标识其文件属性。
* 套接字文件：通常使用在网络通信中，客户端和服务器是通过套接字来通信的。Linux 中以 `s` 来标识其文件属性。

> **Linux 上的文件信息**
>
> Linux 会使用 10 个字符简略的描述一个文件的信息，其格式为：`文件类型（一个字符）` + 所有者权限（三个字符） + 所有者所在用户组的其他用户权限（三个字符） + 其他用户的权限（三个字符）。
>
> 比如 `-rwxrwxrwx`，第一个字符是 `-`，表示这是一个普通文件，`r` 表示可读，`w` 表示可写，`x` 表示可执行。
>
> 如果 rwx 中某个权限缺失，就会被 `-` 代替，比如 `-rw-rw-rw-`。

#### 文件存储

文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：

- 连续空间存放方式
- 非连续空间存放方式

其中，非连续空间存放方式又可分为：**链表方式**和**索引方式**。

##### 连续空间存放

连续空间存放方式顾名思义，**文件存放在磁盘连续的物理空间中**。这种模式下，文件的数据都是紧密相连，**读写效率很高**，因为一次磁盘寻道就可以读出整个文件。

> 这种方式下很类似于编程语言中的数组，可以类比数组进行理解。

使用连续存放的方式有一个**前提：必须先知道一个文件的大小**，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。这时文件的 inode 就必须存储文件的**起始块**以及其**长度**。

![image-20220324160015912](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324160015912.png)

连续空间存放的方式虽然读写效率高，**但是容易产生磁盘空间碎片**，并且**文件长度不易扩展**。举个例子：

下图中如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放：

![image-20220324160133919](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324160133919.png)

当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。

另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。

既然连续空间不行，那么就只能使用非连续的空间了。

##### 非连续空间存放方式

###### 链表方式

链表的方式存放是**离散的，不用连续的**，于是就可以**消除磁盘碎片**，可大大提高磁盘空间的利用率，同时**文件的长度可以动态扩展**。

根据实现的方式的不同，链表可分为**隐式链接**和**显式链接**两种形式。

* 隐式链接：实现方式是 **inode 中记录第一块和最后一块的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置**。

  ![image-20220324161117181](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324161117181.png)

  这就很类似于编程中的双向链表。起始块相当于头节点，末尾块相当于尾节点。

  这种方式的缺点在于**无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间**。

  隐式链接分配的**稳定性较差**，系统在运行过程中由于软件或者硬件错误**导致链表中的指针丢失或损坏，会导致文件数据的丢失。**

* 显式链接：如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足，这就是显式链接。

  显示链接在内存中维护一张表，把用于链接文件数据块的指针记录下来，称之为**文件分配表**。

  ![2](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/123123.png)

  由于查找记录的过程是在内存中进行的，因而不仅显著地**提高了检索速度**，而且**大大减少了访问磁盘的次数**。但也正是整个表都存放在内存中的关系，它的主要的缺点是**不适用于大磁盘**。

###### 索引方式

索引的实现是为每个文件创建一个**索引数据块**，里面存放的是**指向文件数据块的指针列表**。就相当于把

另外，**inode 需要包含指向索引数据块的指针**，这样就可以通过 inode 知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。

创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。

![image-20220324163447337](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324163447337.png)

索引的方式优点在于：

- 文件的创建、增大、缩小很方便；
- 不会有碎片的问题；
- 支持顺序读写和随机读写；

由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以**缺陷之一就是存储索引带来的开销**。

###### 组合方式

如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存放。

* **链表 + 索引**：这种组合称为**链式索引块**，它的实现方式是**在索引数据块留出一个存放下一个索引数据块的指针**，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。

  ![image-20220324163904137](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324163904137.png)

* **索引 + 索引**：也就是多级索引：

  ![image-20220324163847058](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324163847058.png)

#### 文件命名

文件命名是一个很重要的功能，对于用户来说，他们是直接通过文件名和文件打交道，进程也需要通过文件名来访问文件。

许多操作系统的命名规则是`文件名.拓展名`，**一个文件的拓展名可以体现一个文件的类型**，甚至一个文件可以有多个拓展名，比如 `index.html.zip`  表示 `index.html` 的网页文件已经被压缩为 `zip` 的压缩包。

在 Windows 操作系统中拓展名可以帮助操作系统识别文件类型，但是 **Linux 操作系统中的拓展名只是一种约定，而并非强制要求**。但是软件有可能强制要求文件的拓展名符合其要求，比如部分 C 语言编译器可能要求源代码文件必须是 `c` 拓展名，如果是纯文本的 `txt` 拓展名则不予以编译，即使文件内容是符合 C 语言语法的代码。

#### 文件访问

早期的操作系统只有一种访问方式：**序列访问（sequential access）**。在这些系统中，**进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序访问它们**。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。

在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为**随机访问文件（random access file）**。许多应用程序都需要这种方式。

随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。

#### 文件描述符

我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表**文件描述符（file descriptor，fd）**，所以说文件描述符是打开文件的标识。

操作系统在打开文件表中维护着打开文件的状态和信息：

- 文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的。
- 文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目。
- 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取。
- 访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求。

### 目录

文件系统通常提供**目录（directories）**或者叫做**文件夹（folders）**用于记录文件的位置。在 Linux 中，一切皆文件，目录也是如此，但是目录是除普通文件之外最常用的抽象，因此它比较特殊。

目录系统最简单的形式是有一个能够包含所有文件的目录，这种目录被称为**根目录（root directory）**，由于根目录的唯一性，所以其名称并不重要。示意图如下：

![image-20220323195825850](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323195825850.png)

这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。

#### 层次目录系统

现代计算机通常含有成千上万个文件，如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了层次目录系统，也叫做**目录树**。通过这种方式，可以用很多目录把文件进行分门别类的存放。如下图所示：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/1515111-20200325130832757-1632045200.png" alt="img" style="zoom:80%;" />

现代文件系统都是通过这种形式组织文件和目录的。

#### 路径

当以目录树的形式来组织文件时，需要有一种方式来指明文件。**路径**就是用来指明文件的，**它是从某个位置到指定文件的一个字符串**。

路径中的目录和目录，目录和文件之间需要以目录分隔符分隔，在不同的操作系统上，目录分隔符是不同的，比如 Windows 上是 `\`，Unix 上是 `/`，而其他操作系统上可能是 `>`。

常见的路径的表示方式有两种：

* 绝对路径：绝对路径是从根目录开始，到指定文件的路径。比如 `/usr/bin/gcc`，表示 Unix 下根目录下的 usr 文件夹下的 bin 文件夹下的 gcc 程序。

  注意，Unix 文件路径中的第一个 `/` 表示根目录，而后的 `/` 都表示一层目录，也就是分隔符。

  Windows 下的绝对路径一定是以盘符 + `:` 开头，就相当于 Linux 的根目录，其他部分除了分隔符的字符不一样之外，其他的都类似，比如 `C:\Users\Administorator\1.txt`。

* 相对路径：相对路径是相对于当前目录而言的。比如当前目录是 a，a 目录下还有 b 目录，b 目录下有一个 1.c 的 C 语言源文件，那么可以通过 `b/1.c` 访问。

  在相对路径中，有一些特殊符号具有特殊的含义：

  * `.`：表示当前目录，刚才的 `b/1.c` 等价于 `./b/1.c`。
  * `..`：表示上一级目录，刚才的 `b/1.c` 等价于 `../a/b/1.c`。

相对路径通常情况下更加方便和简洁，在开发通用的应用程序时，一般不会使用绝对路径，因为不同的计算机上目录树一般是不一样的。

#### 目录的存储

和普通文件不同的是，**普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。**

在目录文件的块中，最简单的保存格式就是**列表**，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。

如下图所示：

![image-20220324215947973](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324215947973.png)

通常，第一项是 `.`，表示当前目录，第二项是 `..`，表示上一级目录，接下来就是一项一项的文件名和 inode。

如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。

于是，保存目录的格式改成**哈希表**，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。

Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。

目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，**把当前使用的文件目录利用目录项缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度**。

### 目录项

**目录项（dentry）用于描述文件的逻辑属性**，只存在于内存中，并没有实际对应的磁盘上的描述，更确切的说是存在于内存的目录项缓存，为了提高查找性能而设计。

注意，**不管是文件夹还是最终的文件，都是属于目录项，所有的目录项在一起构成一颗庞大的目录树**。

> 目录项和目录不是同一个东西，目录是一种文件，保存在磁盘中；而目录项是一种保存在内存中的数据结构。

**目录项相当于缓存**，如果用户频繁的访问一个文件，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的文件时，只需从内存读就可以，大大提高了文件系统的效率。

下图展示了目录项，inode（索引节点）以及文件真实数据的关系：

![image-20220324213623992](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324213623992.png)

### 软链接与硬链接

有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过**硬链接（Hard Link）** 和**软链接（Symbolic Link）** 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。

* **硬链接是多个目录项中的 inode 指针指向一个文件**，也就是指向同一个 inode，但是 **inode 是不可能跨越文件系统的**，每个文件系统都有各自的 inode 数据结构和列表，所以**硬链接是不可用于跨文件系统的**。由于多个目录项都是指向一个 inode，那么**只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。**

  ![image-20220324220734282](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324220734282.png)

* **软链接相当于重新创建一个文件**，这个文件有**独立的 inode**，但是这个**文件的内容是另外一个文件的路径**，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以**软链接是可以跨文件系统的**，甚至**目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。**

  ![image-20220324220831555](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324220831555.png)

