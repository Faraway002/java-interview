[TOC]

# 文件系统

## 1. 前置知识：硬盘及其工作原理

现代的硬盘大致有两种：传统的**机械硬盘（HDD）**与**固态硬盘（SSD）**。HDD 采用磁性碟片来存储，因此也通常被叫做**磁盘**，而 SSD 采用闪存颗粒来存储。

**HDD 相比于 SSD 来说造价更低，但是性能也更差**，这是由它们的原理决定的。同时这也意味着同价格内 HDD 的容量更大，因此大部分计算机会选择使用更快但是更小的 SSD 作为操作系统盘，即把操作系统和其他软件都放在 SSD 里以提高性能，而其他数据则放在更大更便宜的 HDD 中。

通常情况下，HDD 的寿命更长，也更稳定，SSD 的寿命通常比 HDD 段，且有掉盘（系统突然不能识别 SSD）的风险。

### 1.1 机械硬盘

机械硬盘是由**盘片**组成的，每个盘片都有两面，我们称之为**表面**，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的**主轴**，它使得盘片以固定的**旋转速率**旋转，通常是 5400 ~ 15000 转/分钟（RPM）。

机械硬盘通常有多个盘片叠加，并封装在一个密闭的容器内，下图展示了一个典型的磁盘表面结构：

![image-20220323153834724](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323153834724.png)

每个表面是由一组称为**磁道**的同心圆组成的，每个磁道被划分为一组**扇区**，每个扇区包含相等数量的数据位（通常是 512 字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些**间隙**隔开，这些间隙并不存储数据位，而用来存储标识扇区的格式化位。

**柱面**是所有盘片表面上到主轴中心距离相等的磁道的集合：

![image-20220323154302435](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323154302435.png)

磁盘还有一个驱动器和传动臂，驱动器控制传动臂，传动臂上有**读写头**。通过沿着半径轴前后移动这个传动臂，驱动器可以将读写头定位在盘面的任何磁道上，**每当读写头经过一个磁道上的位，读写头就可以感知到这个位的值，也可以修改这个位的值**。如果有多个盘片，则有多个读写头。

那么，对数据的访问时间应该由这三部分组成：

* **寻道时间**：为了读取某个目标扇区的内容，传动臂首先要将读写头定位到包含该扇区的磁道上，这个时间被称为寻道时间。

  现代磁盘驱动器的寻道时间通常在毫秒级别。

* **旋转时间**：一旦读写头定位到了期望的磁道，则需要等待盘面旋转直到期望的扇区转到读写头的下方。这个步骤的性能依赖于磁盘的转速。

* **传送时间**：当目标扇区的第一个位来到读写头的下方时，就可以开始读写数据了，这个时间就是传送时间。

想要定位一个数据也很简单，使用`(盘面, 磁道, 扇区)`三元组就可以定位到一个数据。

但是从操作系统的角度来看，以扇区为单位存取数据效率比较低，因此大多数文件系统会把多个扇区视为一个**逻辑块（数据块）**，**以逻辑块为单位读写数据**。在 Linux 上，一个逻辑块的大小是 4 KB，也就是 8 个扇区为一个块，这大大的提高了磁盘存取数据的效率。

### 1.2 磁盘调度算法

磁盘调度算法是为了提高访问磁盘的性能，一般是通过优化磁盘的访问请求顺序实现的。

和进程调度不同的是，对于一个 I/O 请求，**操作系统能够大概估计所花费的时间，因此可以使用贪心策略**。

#### 1.2.1 最短寻道时间优先

最短寻道时间（Shortest-Seek-Time-First，SSTF）的思想是：优先选择从当前磁头位置所需**寻道时间最短**的请求。

看下面的例子：

![image-20220323211835575](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323211835575.png)

这个例子中，读写头初始位于内圈磁道的 30 扇区中，请求读取 21 和 2 两个扇区，分别位于中间磁道和外圈磁道，那么根据 SSTF，会优先选择离内圈磁道最近的中间的磁道（此时的寻道时间最短），然后读取 21，再来到外圈磁道读取 2。

但是**这个算法可能会导致饥饿**，如果在读写头来到 2 扇区之前有 22，23，13 扇区（都位于中间磁道）的请求来到，则 2 会被排在最后，这是因为相比于 2，中间磁道中的扇区都不需要额外耗费时间来寻道。甚至，有可能永远也无法轮到 2 扇区。

#### 1.2.2 电梯

**SSTF 产生饥饿的原因在于：读写头有可能只在一个磁道内来回移动**。

为了防止这个问题的出现，我们让读写头从最外圈移动至最内圈，然后从最内圈移动到最外圈，实现一轮一轮的**扫描（Scan）**，并且有额外规定：**如果某个扇区所在的磁道已经在本轮扫描中读取过了，那么它就不会被处理，而是等待下一轮**。

这种算法很类似于电梯的工作方式：总是在一个方向上移动，直到该方向上没有请求为止，然后就改变方向。因此这个算法也被称为**电梯算法**。

电梯算法并不是最好的调度算法，具体来说，它们忽视了旋转，我们需要一个能够综合考虑旋转和寻道的调度算法。

#### 1.2.3 最短定位时间优先

最短定位时间优先（Shortest Positioning Time First，SPTF）是一个综合考虑了旋转和寻道的调度算法，**它通过估算当前读写头到请求的扇区的所需时间来排序，找出最短定位时间的扇区**。

看下面的示例：

![image-20220323213502961](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323213502961.png)

在这个例子中，如果这个磁盘的寻道成本远高于旋转成本，则会选择先读取 16；翻过了，如果这个磁盘的旋转成本更高，则会选择先读取磁道 8。

### 1.3 固态硬盘

固态硬盘是一种基于**闪存**的存储技术，它的速度比一般的机械硬盘要快得多。

一个 SSD 封装有闪存芯片和闪存翻译层，闪存芯片就相当于 HDD 的驱动器，而闪存翻译层用于将请求翻译为对底层物理设备的访问。示意图如下：

![image-20220323155644527](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323155644527.png)

一个闪存由 B 个块的序列组成，每个块由 P 页组成，页的大小通常是 512B ~ 4KB，一块通常有 32 ~ 128 页。

**数据都是以页为单位读写的，只有在一页所属的块被整个擦除后，才能写这一页**。不过，一旦一个块被擦除了，块中的每一页都可以不需要再进行擦除就写一次，在大约经过 10w 次这样的过程后，块就会磨损然后损坏，就不能再使用了。

## 2. 文件系统实现

### 2.1 概述

我们在[前置知识](#前置知识：硬盘及其工作原理)中了解到硬盘，知道硬盘读写数据的原理。但是我们需要为硬盘中的存储数据追踪界限，才能保证这块数据是上次存储的，这是一个非常麻烦的事情，操作系统为数据的存储提供了一种抽象——文件。

**文件**是由进程创建的逻辑信息单元，我们可以把文件视为独立的地址空间，内部含有 n 个字节的序列。和进程的地址空间不同的是，文件是持久化存储的，这意味着如果你没有修改文件，那么无论何时读取该文件时读取到的内容总是一样的。

文件由操作系统进行管理，有关文件的构造、命名、访问、使用和保护等主题都是操作系统需要考虑的，从总体上看，**操作系统中负责处理文件的子系统称为文件系统**，和其他子系统不一样，**文件系统是纯软件，操作系统并不会借助任何硬件来使得文件系统在某些方面更好的工作**。由于在构建文件系统方面具有很大的灵活性，因此人们构建了许多不同的文件系统。所有这些文件系统都有不同的数据结构，在某些方面优于或逊于同类系统。

**虽然存在各式各样的文件系统，但是文件系统需要实现的功能应该是差不多的**，至于内部如何实现则取决于具体实现。**操作系统应该允许多种文件系统并存，并且给用户提供统一的接口**。

### 2.2 一切皆文件

Linux 最经典的一句话是：**一切皆文件**，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。

Linux 文件系统会为每个文件分配两个数据结构：**索引节点（index node）和目录项（directory entry）**，它们主要用来记录文件的元信息和目录层次结构。

- 索引节点（inode）：用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、**数据在磁盘的位置**等等。

  索引节点是文件的**唯一**标识，它们之间一一对应，也同样都会被存储在硬盘中，所以**索引节点同样占用磁盘空间**。

- 目录项（dentry）：用来记录文件的名字、**inode 指针**以及与其他目录项的层级关联关系。**多个目录项关联起来，就会形成目录结构**，但它与索引节点不同的是，**目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存**。

由于 inode 唯一标识一个文件，而目录项记录着文件的名称，所以**目录项和 inode 的关系是多对一**，也就是说，一个文件可以有多个别称。

> **区分：目录与目录项**
>
> * 目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。
>
> * 目录项是内核一个数据结构，缓存在内存。
>
> 由于目录也是文件，因此目录也有属于自己的目录项。
>
> 设计**目录项**的是为了**缓存**，如果查询目录频繁从磁盘读，效率会很低，所以**内核会把已经读过的目录用目录项这个数据结构缓存在内存**，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。

#### 2.2.1 文件类型

在 Linux 上，一般有如下几种文件类型：

* 普通文件：普通文本文件或二进制文件。Linux 中以 `-` 来标识其文件属性。
* 目录文件：将文件的名称和它的索引节点号结合在一起的一张表。Linux 中以 `d` 来标识其文件属性。
* 设备文件：每一种 I/O 设备都对应一个设备文件。具体来说，又分为两种：
  * 块设备文件：存储数据以供系统存取的接口设备，最常见的就是硬盘。Linux 中以 `b` 来标识其文件属性。
  * 字符设备文件：串行端口的接口设备，比如键盘、鼠标等。Linux 中以 `c` 来标识其文件属性。
* 管道文件：主要用于进程间通信，又称 FIFO 文件。Linux 中以 `p` 来标识其文件属性。
* 链接文件：又称符号链接文件，提供了共享文件的方法。Linux 中以 `l` 来标识其文件属性。
* 套接字文件：通常使用在网络通信中，客户端和服务器是通过套接字来通信的。Linux 中以 `s` 来标识其文件属性。

Linux 会使用 10 个字符简略的描述一个文件的信息，其格式为：`文件类型（一个字符）` + 所有者权限（三个字符） + 所有者所在用户组的权限（三个字符） + 其他用户的权限（三个字符）。

比如 `-rwxrwxrwx`，第一个字符是 `-`，表示这是一个普通文件，`r` 表示可读，`w` 表示可写，`x` 表示可执行。

如果 rwx 中某个权限缺失，就会被 `-` 代替，比如 `-rw-rw-rw-`。

#### 2.2.2 文件命名

文件命名是一个很重要的功能，对于用户来说，他们是直接通过文件名和文件打交道，进程也需要通过文件名来访问文件。

许多操作系统的命名规则是`文件名.拓展名`，**一个文件的拓展名可以体现一个文件的类型**，甚至一个文件可以有多个拓展名，比如 `index.html.zip`  表示 `index.html` 的网页文件已经被压缩为 `zip` 的压缩包。

在 Windows 操作系统中拓展名可以帮助操作系统识别文件类型，但是 **Linux 操作系统中的拓展名只是一种约定，而并非强制要求**。但是软件有可能强制要求文件的拓展名符合其要求，比如部分 C 语言编译器可能要求源代码文件必须是 `c` 拓展名，如果是纯文本的 `txt` 拓展名则不予以编译，即使文件内容是符合 C 语言语法的代码。

#### 2.2.3 文件描述符

从用户的角度看，用户无非就是在对文件做一些操作，包括读写、拷贝、删除、重命名等，这些要么需要修改文件的实际存储数据，要么需要修改 inode，这些**操作的前提都是需要打开一个文件**。

打开文件通常是通过 `open()` 系统调用实现的，我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表**文件描述符（file descriptor，fd）**，所以说文件描述符是打开文件的标识。

![image-20220706090917966](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706090917966.png)

操作系统在文件描述符中维护着打开文件的状态和信息：

- **文件指针**：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的。
- **文件打开计数器**：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目。
- **文件磁盘位置**：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取。
- **访问权限**：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求。

### 2.3 虚拟文件系统

文件系统的种类众多，而操作系统希望**对用户提供一个统一的接口**，于是在用户层与文件系统层引入了中间层，这个中间层就称为**虚拟文件系统（Virtual File System，VFS）**。

> **Windows 上的文件系统**
>
> VFS 是 Unix 系列操作系统提出的，Windows 并不遵守这个规则。
>
> Windows 中的主要文件系统是 `NTFS`，但不是说 Windows 只有 NTFS，它还有一些其他的例如旧的 `FAT -32` 或`FAT -16` 驱动器或分区，其中包含仍需要的数据，闪存驱动器，旧的 CD-ROM 或 DVD（每个都有自己的独特文件系统）。
>
> Windows 通过指定不同的盘符来处理这些不同的文件系统，比如 `C:`，`D:` 等。

VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样用户不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。VFS 在操作系统的位置如下图所示：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/vfs.png" alt="vfs" style="zoom:80%;" />

Linux 支持的文件系统比较多，根据存储位置的不同，可以把文件系统分为三类：

- 磁盘文件系统：最常用的文件系统类型，它把数据存储在磁盘中，比如著名的 Ext 2/3/4、Windows 上的 NTFS 等都是这类文件系统。
- 内存文件系统：这类文件系统的数据不是存储在硬盘的，而是存储在物理内存中，我们经常用到的 `/proc` 和 `/sys` 文件系统都属于这一类，读写这类文件，实际上是读写内存中相关的数据。
- 网络文件系统：用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。

任何文件系统要想被操作系统使用，就要**挂载**到操作系统的总文件系统树中，这样做的好处就是操作系统能够统一多个文件系统到一棵树中，让管理更加的方便。比如 Linux 刚启动时，就会把一个文件系统（通常是 Ext 系列文件系统）挂载到根目录上。

**任何文件系统想要被挂载，都需要先向 VFS 注册，并且符合 VFS 的规范**。

### 2.4 文件系统组成

**对于实际的文件系统实现来说，它们一般存储在硬件中**。以磁盘为例，大部分的磁盘能够划分出一到多个分区，叫做**磁盘分区**（disk partitioning）或者是磁盘分片，**每个分区都有独立的文件系统**。

以 Linux Ext2 文件系统为例，整个磁盘的逻辑结构如下图所示：

![image-20220706082248339](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706082248339.png)

* **引导块**：引导块用于加载并启动分区中的操作系统，为了一致性，**每个分区都会从引导块开始，即使引导块不包含操作系统**。

* **超级块**：包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。

  在计算机启动或者文件系统首次使用时，超级块会被读入到内存中。
  
* **块组描述符**：包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中所有块组的组描述符信息。

* **数据位图和 inode 位图**：用于表示对应的数据块或 inode 是空闲的，还是被使用中。

  > **位图**
  >
  > 位图可以理解为只包含 0 和 1 的数组，由于这个数组每一个元素都是一个位，因此占用的空间非常小，通常使用一个或多个整数就可以存放下来。
  >
  > 位图是文件系统管理空闲空间的有效方法，我们将在之后介绍。

* **inode 列表**：包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。

* **数据块**：包含文件的实际数据，是实际存储文件的地方。

#### 2.4.1 inode、dentry 和数据块的关系

三者关系如下：

![image-20220706084350881](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706084350881.png)

* 在操作系统启动时，操作系统会把必要的目录读取出来，缓存为目录项。之后，用户通过目录访问时，目录项缓存生效，速度就会比较快。
* 如果用户要访问某个文件，则通过目录项找到该目录下保存的文件目录项，之后再通过文件目录项的 inode 指针找到磁盘上的 inode。
* 找到磁盘上的 inode 之后，就会通过 inode 找到实际存储文件的数据块，然后读取出来。

> **数据块和扇区**
>
> 磁盘读写的最小单位是**扇区**，扇区的大小只有 `512B` 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。
>
> 所以，文件系统把多个扇区组成了一个**逻辑块**，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 `4KB`，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。

### 2.5 文件的存储方式

文件的存储方式就像我们编程时数据的存储一样，通常有两种：

1. **连续空间存放**
2. **非连续空间存放**

其中，非连续空间存放方式又可以分为**链表方式**和索引方式。

不同的存储方式，有各自的特点，也有不同的应用场景。

#### 2.5.1 连续空间存放

连续空间存放方式顾名思义，**文件存放在磁盘连续的物理空间中**。这种模式下，文件的数据都是紧密相连，**读写效率很高**，因为一次磁盘寻道就可以读出整个文件。

> **类比学习**
>
> 这种方式很类似于编程语言中的数组，可以类比数组进行理解。

使用连续存放的方式有一个**前提：必须先知道一个文件的大小**，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。这时文件的 inode 就必须存储文件的**起始块**以及其**长度**。

![image-20220324160015912](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324160015912.png)

连续空间存放的方式虽然读写效率高，**但是容易产生磁盘空间碎片**，并且**文件长度不易扩展**。举个例子：

下图中，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放：

![image-20220324160133919](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324160133919.png)

当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。

另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。

既然连续空间不行，那么就只能使用非连续的空间了。

#### 2.5.2 非连续空间存放

##### 2.5.2.1 链表方式

链表的方式存放是**离散的，不用连续的**，于是就可以**消除磁盘碎片**，可大大提高磁盘空间的利用率，同时**文件的长度可以动态扩展**。

根据实现的方式的不同，链表可分为**隐式链接**和**显式链接**两种形式。

* 隐式链接：实现方式是 **inode 中记录第一块和最后一块的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置**。

  ![image-20220324161117181](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324161117181.png)

  这就很类似于编程中的**双向链表**。起始块相当于头节点，末尾块相当于尾节点。

  这种方式的缺点在于**无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间**。

  隐式链接分配的**稳定性较差**，系统在运行过程中由于软件或者硬件错误**导致链表中的指针丢失或损坏，会导致文件数据的丢失**。

* 显式链接：如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足，这就是显式链接。

  显示链接在内存中维护一张表，把用于链接文件数据块的指针记录下来，称之为**文件分配表**，类似于哈希表的思想。

  ![2](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/123123.png)

  由于查找记录的过程是在内存中进行的，因而不仅显著地**提高了检索速度**，而且**大大减少了访问磁盘的次数**。但也正是整个表都存放在内存中的关系，它的主要的缺点是**不适用于大磁盘**。

##### 2.5.2.2 索引方式

索引的实现是为每个文件创建一个**索引数据块**，里面存放的是**指向文件数据块的指针列表**。就相当于把

另外，**inode 需要包含指向索引数据块的指针**，这样就可以通过 inode 知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。

创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。

![image-20220324163447337](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324163447337.png)

索引的方式优点在于：

- 文件的创建、增大、缩小很方便；
- 不会有碎片的问题；
- 支持顺序读写和随机读写；

由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以**缺陷之一就是存储索引带来的开销**。

##### 2.5.2.3 组合方式

如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存放。

* **链表 + 索引**：这种组合称为**链式索引块**，它的实现方式是**在索引数据块留出一个存放下一个索引数据块的指针**，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。

  ![image-20220324163904137](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324163904137.png)

* **索引 + 索引**：也就是多级索引：

  ![image-20220324163847058](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324163847058.png)

Linux 上的 Ext2/Ext3 文件系统就是使用的组合方式，如下图所示：

![image-20220706085910871](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220706085910871.png)

它是根据文件的大小，存放的方式会有所变化：

- 如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；
- 如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；
- 如果前面两种方式都不够存放大文件，则采用二级间接索引方式；
- 如果二级间接索引也不够存放大文件，这采用三级间接索引方式；

这种方式能很灵活地支持小文件和大文件的存放。

### 2.5 空闲空间管理

如果要存储一个新的文件，则需要在磁盘上选择一块合适的空间存放，这就涉及到空闲空间管理，常见的几种方式有：

- 空闲表法
- 空闲链表法
- 位图法

需要额外说明的是，inode 块也分配在磁盘上，因此也需要对空闲 inode 进行管理，方法是一致的。

#### 2.5.1 空闲表法

空闲表法就是**为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数**，注意，这个方式是连续分配的。如下图：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324172228956.png" alt="image-20220324172228956" style="zoom:80%;" />

当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止；当删除一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。

这种方法仅当有少量的空闲区时才有较好的效果。因为，**如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低**。因此，这种分配技术适用于建立连续文件。

#### 2.5.2 空闲链表法

上一种方法的显著缺点就是表可能会很大，我们可以利用空闲块本身的部分空间来管理空闲块，即**每一个空闲块里有一个指针指向下一个空闲块**，这样也能很方便的找到空闲块并管理起来。

![image-20220324172715029](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324172715029.png)

这种技术只要在主存中保存一个指针，令它指向第一个空闲块即可，占用空间很小。但是**缺点**也很明显：**不能随机访问**。

**空闲表法和空闲链表法都不适合用于大型文件系统。**

#### 2.5.3 位图法

**位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。**

**当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配**。

这是最常用且占用空间最小的方法，Linux 就采用了这种方法管理空闲空间。

### 2.6 目录

文件系统通常提供**目录（directories）**或者叫做**文件夹（folders）**用于记录文件的逻辑位置。在 Linux 中，一切皆文件，目录也是如此，但是目录比较特殊，因为目录通常需要和用户直接打交道；事实上，操作系统也会使用目录组织文件，使得文件更有条理性。

这就使得目录虽然是文件，但是它看起来更像文件的容器。

#### 2.6.1 层次目录系统

**目录通常被组织为一个多层次的复杂系统**。

目录系统最简单的形式是有一个能够包含所有文件的目录，这种目录被称为**根目录（root directory）**，示意图如下：

![image-20220323195825850](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220323195825850.png)

现代计算机通常含有成千上万个文件，如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了多级目录，根目录依然是最根本的目录，次级目录都被放在根目录下，更次级的目录又被放在这些次级目录下，层层递进。

这样组织起来的目录系统也叫做**目录树**，通过这种方式，可以用很多目录把文件进行分门别类的存放。如下图所示：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/1515111-20200325130832757-1632045200.png" alt="img" style="zoom:80%;" />

几乎所有的现代文件系统都是通过这种形式组织文件和目录的。

#### 2.6.2 路径

当以目录树的形式来组织文件时，需要有一种方式来指明文件。**路径**就是用来指明文件的，**它是从某个位置到指定文件的一个字符串**。

路径中的目录和目录，目录和文件之间需要以目录分隔符分隔，在不同的操作系统上，目录分隔符是不同的，比如 Windows 上是 `\`，Unix 上是 `/`，而其他操作系统上可能是 `>`。

常见的路径的表示方式有两种：

* 绝对路径：绝对路径是从根目录开始，到指定文件的路径。比如 `/usr/bin/gcc`，表示 Unix 下根目录下的 usr 文件夹下的 bin 文件夹下的 gcc 程序。

  注意，Unix 文件路径中的第一个 `/` 表示根目录，而后的 `/` 都表示一层目录，也就是分隔符。

  Windows 下的绝对路径一定是以盘符 + `:` 开头，就相当于 Linux 的根目录，其他部分除了分隔符的字符不一样之外，其他的都类似，比如 `C:\Users\Administorator\1.txt`。

* 相对路径：相对路径是相对于当前目录而言的。比如当前目录是 a，a 目录下还有 b 目录，b 目录下有一个 1.c 的 C 语言源文件，那么可以通过 `b/1.c` 访问。

  在相对路径中，有一些特殊符号具有特殊的含义：

  * `.`：表示当前目录，刚才的 `b/1.c` 等价于 `./b/1.c`。
  * `..`：表示上一级目录，刚才的 `b/1.c` 等价于 `../a/b/1.c`。
  
  事实上，除根目录外，每一个目录都隐含这两个目录项。

相对路径通常情况下更加方便和简洁，在开发通用的应用程序时，一般不会使用绝对路径，因为不同的计算机上目录树一般是不一样的。

#### 2.6.3 目录的内容

和普通文件不同的是，**普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息**。

在目录文件的块中，最简单的保存格式就是**列表**，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。

如下图所示：

![image-20220324215947973](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324215947973.png)

通常，第一项是 `.`，第二项是 `..`，接下来就是一项一项的文件名和 inode。

如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。

于是，保存目录的格式改成**哈希表**，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。

Linux 系统的 Ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。

目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，**把当前使用的文件目录利用目录项缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度**。

### 2.7 硬链接与软链接

有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过**硬链接（Hard Link）** 和**软链接（Symbolic Link）** 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。

* **硬链接是多个目录项中的 inode 指针指向一个文件**，也就是指向同一个 inode，但是 **inode 是不可能跨越文件系统的**，每个文件系统都有各自的 inode 数据结构和列表，所以**硬链接是不可用于跨文件系统的**。由于多个目录项都是指向一个 inode，那么**只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。**

  ![image-20220324220734282](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324220734282.png)

* **软链接相当于重新创建一个文件**，这个文件有**独立的 inode**，但是这个**文件的内容是另外一个文件的路径**，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以**软链接是可以跨文件系统的**，甚至**目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。**

  ![image-20220324220831555](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220324220831555.png)

