[TOC]

# 操作系统简介

## 1. 概述

操作系统（Operating System，OS）是计算机系统中的一个系统软件，是一些程序模块的集合——它们能以尽量有效、合理的方式组织和管理计算机的软硬件资源，合理的组织计算机的工作流程，控制程序的执行并向用户提供各种服务功能，使得用户能够灵活、方便、有效的使用计算机，使整个计算机系统能高效、顺畅地运行。

要做到这一点，操作系统主要利用一种通用的技术，我们称之为**虚拟化**（virtualization）。操作系统将物理资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。为了能够让用户知道操作系统可以做什么，操作系统还提供了一些应用程序编程接口（API），供用户调用。

一个操作系统至少包含以下几个模块的功能：

1. 操作系统接口
1. CPU 管理
2. 内存管理
3. 文件管理
4. 设备管理

我们常见的操作系统，比如 Windows 和 Linux，都包含了上面的功能，并且还提供其他很多功能，是当今世界上最流行的操作系统。

Linux 是开源操作系统，其设计符合 POSIX 标准，这是一个操作系统的设计标准，由 Unix 提出，只要操作系统符合该标准，就能运行 Unix 程序。正因如此，Linux 受到广大开发者们的喜爱。

## 2. 内核

现代操作系统的设计都包含了一个**内核**，并且以内核为主，可以说，**内核是操作系统的核心**，它作为一个中间人，与应用程序打交道，同时在底层与硬件设备打交道。

如下图所示：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220527091127652.png" alt="image-20220527091127652" style="zoom:80%;" />

当然，操作系统并不全是内核，还包括用户界面等其他系统软件，可以说，**操作系统 = 内核 + 系统软件**。

操作系统的内核也是一种应用程序，它在硬件通电时，由 bootloader 加载执行，随后整个操作系统就会运行起来，在前置知识中我们已经详细讲述了 OS 的启动流程。

## 3. 内核态与用户态

内核为了保护系统安全，对一些敏感操作是需要严格把控的，**用户应用程序不能随便执行敏感操作，但内核本身可以完成所有操作**。

这就涉及到一个权限管理，**内核具有最高权限，而用户则具有较低的权限**，具体体现在**内核把内存分为内核空间和用户空间**，内核运行在内核空间，这种状态叫做**内核态**；而普通的用户应用程序一般运行在用户空间，这种状态叫做**用户态**。

处于用户态的进程不能随便访问内核态，需要调用内核给它提供的 API，也叫做**系统调用**。通过系统调用，内核会把用户进程临时加载到内核空间，这通过调用一个名为陷阱的 CPU 指令来实现，因此我们说应用程序**陷入内核**中了。执行完毕以后，内核把进程送回用户空间。

权限管理依靠什么保证？软件能保证吗？答案是否，因此只能依靠 CPU 硬件来保证权限，那么它是怎么保证的呢？

我们知道 X86 的 CPU 具有段寄存器，将物理内存分为多个段，每个段都有一个段寄存器，且都有自己的特权级，**段寄存器的最后两位用来规定特权级，最小是 0，最大是 3，共四个特权级，Linux 只使用了其中的 0 和 3，0 表示内核态，3 表示用户态**。

**当一个进程访问一个段时，会进行特权级检查，如果 DPL（段的权限级别，Descriptor Privilege Level）>= CPL（当前进程的权限级别，Current Privilege Level），才能够访问段**。

运行在用户态的进程 CPL 毫无疑问是 3，而访问内核的时候，内核的代码段的 DPL 肯定是 0，不满足 DPL >= CPL 的条件，因此不允许访问。

那么用户态的进程要怎么样才能访问内核呢？这就要靠接下来要介绍的系统调用。

## 4. 系统调用

**操作系统为用户态运行的进程与硬件设备进行交互提供的一组接口，这组接口就是所谓的系统调用**。

从编程者的观点来看，传统的库函数和系统调用没有什么区别，都是类似函数的调用方式，但是本质上有很大区别，库函数可能只需要在用户态执行，而**每一个系统调用都在内核中执行**。

对于每一个系统调用，通常都有一个在内核实现的**内核函数**，名称以 `sys_` 开头，比如 getpid 对应的就是 sys_getpid，称作**服务例程**。系统调用在内部会调用这些服务例程，因此系统调用实质是用户进程进入内核的接口中间层。

Linux 还提供了 `syscall` 函数直接调用服务例程。

### 4.1 系统调用的实现

在内核中，每一个系统调用都有一个**系统调用号**，用于唯一标识系统调用，除此之外，还可以作为**系统调用表**的索引，来找到真正的系统调用服务例程。

当用户态的进程调用系统调用时：

1. 首先这个系统调用会把系统调用号压入 EAX 寄存器中，便于之后取出。
2. 然后执行一条中断指令（我们很快就要讲到中断相关知识），也叫陷阱指令，中断向量为 0x80。
3. 操作系统处理中断，知道这是用户进程在请求系统调用。随后，操作系统读取系统调用号，找到对应的系统调用服务例程。
4. 最后通过一个 `syscall_exit_work()` 函数返回。

我们稍微看一下源码：

```c
#define _syscall3(type,name,atype,a,btype,b,ctype,c) \
type name(atype a,btype b,ctype c) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
    : "=a" (__res) \
    : "0" (__NR_##name),"b" ((long)(a)),"c" ((long)(b)),"d" ((long)(c))); \
if (__res>=0) \
    return (type) __res; \
errno=-__res; \
return -1; \
}
```

这个部分是三个参数的系统调用的内联汇编，其重点是 `int $0x80`，这表示要触发中断号为 0x80 的中断。

入口参数有四个，其中第一个参数是 `__NR_##name`，这表示系统调用的名称，每一个系统调用都有一个系统调用号，以宏定义的形式定义了，部分系统调用号如下图：

![image-20220527094524860](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220527094524860.png)

返回值是 `=a`，也就是把返回值压入 EAX 寄存器。

早在进程调度程序初始化时，就已经设置好了 0x80 的处理程序：

```c
void sched_init(void) {
	// ...
    
    set_system_gate(0x80, &system_call);
}
```

这是一个宏：

```c
#define set_system_gate(n, addr) \
    _set_gate(&idt[n],15,3,addr)
```

IDT 是中断描述符表，里面有中断号和中断处理程序的对应关系，那么我们就能很快找到 0x80 的处理程序地址。

这个宏又调用了另一个宏：

```c
#define _set_gate(gate_addr, type, dpl, addr) \
__asm__ ("movw %%dx,%%ax\n\t" \
    "movw %0,%%dx\n\t" \
    "movl %%eax,%1\n\t" \
    "movl %%edx,%2" \
    : \
    : "i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
    "o" (*((char *) (gate_addr))), \
    "o" (*(4+(char *) (gate_addr))), \
    "d" ((char *) (addr)),"a" (0x00080000))
```

这里的汇编有点复杂，但是我们抓住重点：dpl 传入的是 3，也就是说 `int $0x80` 时 CPL 并没有改变，而是改变了 DPL。

## 5. 中断

如果用户的进程在系统调用时霸占 CPU，不愿回到用户态怎么办？从理论上看，这是有可能发生的，因为内核也是应用程序，在单核的 CPU 上任一时刻只有一个进程在运行，这意味着用户应用程序在运行时，操作系统实际上是没有运行的！这会导致操作系统对应用程序所有的限制都失效。所以必须要有一种硬件机制，能够让操作系统牢牢地把握住 CPU 的控制权。

这种硬件机制就是**中断**，准确的说是**时钟中断**，硬件中有一个时钟计时设备，每过一段时间它就产生一个信号，称之为中断信号，CPU 会收到该信号，并执行一段程序。这段程序在内存中的位置是固定的，也就是说，在操作系统启动时，可以把预先设置好的**中断处理程序**放在该处，每次收到时钟中断信号时，CPU 执行中断处理程序，将控制权交还给操作系统。

> **为什么要有中断？**
>
> 中断是计算机发展中一个重要的技术，它很大程度上解放了 CPU，提高了 CPU 的执行效率。
>
> 在中断出现之前，CPU 对 外部 I/O 设备采用的是轮询的方式进行服务，这使得 CPU 经常会等待某一个 I/O 设备上，如果它不响应，CPU 就在原地一直的等下去。这样就导致了其他 I/O 设备也在等待 CPU 的服务。
>
> 中断出现以后，硬件只需要在完成后发出中断信号，CPU 就能立即响应，极大的解放了 CPU。
>
> 随着计算机的发展，中断的适用范围也随之扩大了，出现了内部中断（由外部设备发起的叫做外部中断），内部中断是**为了解决机器运行时所出现的某些随机事件**及**编程方便**而出现的。

### 5.1 中断的类别

产生中断的地方叫做**中断源**，Intel x86 CPU 提供了 256 种可识别的中断源，为了让处理器更容易识别，给每个中断源都编了号，从 0 ~ 255，也叫做中断类型码，Intel 把中断类型码叫做一个向量，因此也叫做**中断向量**。

在 Linux 上，这 256 种中断向量是这样分配的：

* 编号 0～31 的向量：异常和非屏蔽中断。
* 编号 32 ~ 47 的向量：可屏蔽中断。
* 剩余的 48 ~ 255：软中断。但是 Linux 只使用了其中的几种，其中最出名的中断向量**编号为 0x80**（十进制 128），也就是著名的**系统调用中断**。

在这 256 种中断向量中，可以分为中断和异常两大类：

* 中断：一般是来自外部设备（除 CPU 以外的设备）的中断，分为可屏蔽中断以及非屏蔽中断。

  当外部设备产生一个中断信号后，中断信号经过中断控制器，通过中断线，最终达到 CPU 的中断引脚上，然后会修改 CPU 中的中断寄存器的值。CPU 立即停止当前正在执行的进程（但是保证指令是原子性的，也就是说，如果 CPU 正在执行某一条指令，那么 CPU 还是会执行完这条指令再去处理中断）去处理中断。

  * **可屏蔽中断**：此类中断通常来自外部 I/O 设备，如打印机，硬盘，网卡等。**并不会影响系统运行，可随时处理，甚至不处理，所以名为可屏蔽中断**。
  * **非屏蔽中断**：此类异常来自于计算机内部硬件，而与外部设备毫无关系。非屏蔽中断指的不是可以不用处理，而是不能不处理，因此 Intel 也**把非屏蔽中断作为异常的一种**来处理。

  我们发现，可屏蔽中断只有 15 个向量，但是外部设备并不止 15 种。事实上，CPU 确实只使用了 15 条**中断线**管理外部可屏蔽中断，这意味着许多设备需要**共享中断**；或者需要**申请中断线**（IRQ），共 15 条，编号从 IRQ0 ~ IRQ15。只有申请了 IRQ 的设备才可以发出中断。

  > **如何屏蔽中断？**
  >
  > 对于外部 I/O 请求的屏蔽可分为两种情况：
  >
  > 1. 从 CPU 的角度，也就是清除 eflag 的中断标志位（IF），当 IF = 0 时，禁止任何外部 I/O 的中断请求，即关中断
  > 2. 从中断控制器的角度，因为中断控制器中有一个 8 位的中断屏蔽寄存器（IMR），每位都对应的一条中断线，如果要禁用某条中断线，则把 IMR 相应的位置 1，要启用，则置 0。

* 异常：异常是 CPU 内部的中断。一般来说，指的是 CPU 内部出现的异常情况。又分为陷阱（Trap）、故障（Fault）和终止（Abort）

  * **陷阱**：是一种有意的，预先安排的异常事件，一般是在编写程序时故意设下的陷阱指令，而后执行到陷阱指令后，CPU 将会调用特定程序进行相应的处理，处理结束后返回到陷阱指令的下一条指令。最常见的陷阱就是系统调用。

  * **故障**：故障是在引起故障的指令被执行，但还没有执行结束时，CPU 检测到的一类的意外事件。出错时交由故障处理程序处理，如果能处理修正这个错误，就将控制返回到引起故障的指令即CPU重新执这条指令。如果不能处理就报错。最常见的故障就是缺页故障。

  * **终止**：执行指令的过程中发生了**致命错误，不可修复**，程序无法继续运行，只能终止，通常会是一些硬件的错误。终止处理程序不会将控制返回给原程序，而是直接终止原程序。

  在 Intel x86 处理器中，异常定义了 18 个，占用了 0 ~ 17 号中断向量，剩下的 18 ~ 31 由 Intel 保留为以后扩充使用。**Linux 必须为每一种异常提供一个专门的异常处理程序。**

  注意，当 CPU 执行一个异常处理程序时，不会为其他可屏蔽中断或异常提供服务，但是 CPU 可以将执行期间的中断请求缓存下来，处理完当前异常后再处理新的中断。

###  5.2 中断描述符表

**中断描述符表是一个 OS 在启动后就要第一时间设置好的表，它的作用是根据中断向量号找到对应的中断处理程序。**

> **中断处理程序与中断服务例程**
>
> 一条中断线对应一个中断处理程序，而一个中断处理程序再对应若干个中断服务例程。

在实模式中，CPU 把内存中从 0 开始的 1 kb 空间作为一个中断向量表。表中的每个表项占 4 个字节，由 2 个字节的段地址和 2 个字节的偏移量组成，这样构成的地址就是相应**中断处理程序的入口地址**。

但是在保护模式下，由 4 个字节的表项构成的中断向量表已经不能满足要求了。在保护模式下，中断向量表中的表项由 8 个字节组成。此时它也有了新的名字，即中断描述符表（Interrupt Descriptor Table，IDT）。

在保护模式下，中断描述符表在内存的位置不再局限于从地址 0 开始的位置，而是可以放在内存的任何位置。为了实现这个功能，CPU 中设计了一个中断描述符表寄存器 IDTR，用来存放中断描述符表在内存的起始位置。

### 5.3 中断的两部分处理

中断服务例程一般都是在中断请求关闭的条件下执行的,以避免嵌套而使中断控制复杂化。但是，中断是一个随机事件，它随时会到来，如果关中断的时间太长，CPU 就不能及时响应其他的中断请求，从而造成中断的丢失。

因此，**内核的目标就是尽可能快的处理完中断请求，尽其所能把更多的处理向后推迟**。例如，假设一个数据块已经达到了网线，当中断控制器接受到这个中断请求信号时，Linux 内核只是简单地标志数据到来了，然后让处理器恢复到它以前运行的状态，其余的处理稍后再进行（如把数据移入一个缓冲区，接受数据的进程就可以在缓冲区找到数据）。因此，**内核把中断处理分为两部分：前半部分（top half）和后半部分（bottom half），前半部分内核立即执行，而后半部分留着稍后处理**。

* 首先，一个快速的前半部分中断来处理硬件发出的请求，**它必须在一个新的中断产生之前终止**。

  通常地，除了在设备和一些内存缓冲区（如果你的设备用到了DMA，就不止这些）之间移动或传送数据，确定硬件是否处于健全的状态之外，这一部分做的工作很少。

  在这一阶段，CPU 会暂时屏蔽中断。

* 然后，就让一些与中断处理相关的有限个函数作为 后半部分来运行：
  * 允许一个普通的内核函数，而不仅仅是服务于中断的一个函数，能以后半部分的身份来运行。
  * 允许几个内核函数合在一起作为一个后半部分来运行。

> **软中断**
>
> 通常，我们把硬件引起的中断叫做硬中断，而**软件引起的中断叫做软中断**。
>
> 事实上，中断的两部分处理过程中，当上半部分的中断处理完成后，内核会发起一个软中断，把下半部分中断交由软中断处理程序处理。
