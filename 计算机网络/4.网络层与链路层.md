# 网络层与链路层

## 1. 网络层概述

网络层是 OSI 参考模型的第三层，它位于传输层和链路层之间，网络层的主要目的是实现两个端系统之间透明的数据传输。

网络层能够被分解为两个相互作用的部分，即**数据平面**和**控制平面**：

* 数据平面即网络层中每台路由器的功能，该功能决定**到达路由器输入链路之一的数据报（即网络层的分组）如何转发到该路由器的输出链路之一**。
* 控制平面即网络范围的逻辑，该控制平面功能**控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式**。

下图展示了一个简单网络，其中有 H1 和 H2 两台主机，在 H1 与 H2 之间的路径上有几台路由器：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710151310987.png" alt="image-20220710151310987" style="zoom:80%;" />

假设 H1 正在向 H2 发送信息，考虑这些主机与中间路由器的网络层所起的作用：

* H1 中的网络层取得来自于 H1 运输层的报文段，将每个报文段封装成一个数据报，然后向相邻路由器 R1 发送该数据报。
* 在接收方主机 H2，网络层接收来自相邻路由器 R2 的数据报，提取出运输层报文段，并将其向上交付给 H2 的运输层。

每台路由器的数据平面的主要作用是从其输入链路向其输出链路转发数据报；控制平面的主要作用是协调这些本地的每路由器转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送。

> 注意到图中所示路由器具有截断的协议栈，即没有网络层以上的部分，因为**路由器不运行我们已学习过的应用层和运输层协议**。

### 1.1 转发和路由选择：数据平面和控制平面

网络层的作用从表面上看极为简单，即**将分组从一台发送主机移动到一台接收主机**。为此，需要使用两种重要的网络层功能:

* **转发**：当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路。

  转发是在数据平面内唯一实现的功能。

* **路由选择**：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。

  计算这些路径的算法被称为**路由选择算法**（routing algorithm），路由选择在网络层的控制平面中实现。

我们必须区分，**转发是路由器的本地动作，通常是硬件实现，发生的时间尺度大概是几纳秒**；而**路由选择是从发送方到目的地的一个总体的网络范围处理过程，发生的时间尺度要长的多，通常是几秒，因此常用软件实现**。

每台路由器具有一张**转发表** (forwarding table) 。路由器检査到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引，通过这种方法来转发分组。这些值对应存储在转发表项中的值，指出了该分组将被转发的路由器的输出链路接口。

比如：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710152145347.png" alt="image-20220710152145347" style="zoom:80%;" />

上图中，一个首部宇段值为 0111 的分组到达路由器。路由器在它的转发表中索引，决定该分组的输出链路接口是接口 2，然后路由器在内部将该分组转发到接口 2。

你也许现在想知道路由器中的转发表是如何配置的。这是一个关键问题，它揭示了路由选择和转发间的重要相互作用关系：路由选择算法决定了插入路由器的转发表中的值。

路由选择算法可能是集中式的，也可能是分布式的，在任何一种情况下，都是**路由器接收路由选择协议报文，该报文被用于配置其转发表**。

> **区分链路层交换机以及路由器**
>
> 某些地方，你可能会看见链路层交换机这一术语，这其实属于**分组交换机**的一种。
>
> * 路由器是网络层的分组交换机，基于网络层字段中的值做转发决定
> * 链路层交换机是数据链路层的交换机，基于链路层字段中的值做转发决定

### 1.2 网络服务模型

我们现在考虑网络层能提供的某些可能的服务。这些服务可能包括：

* **确保交付**：该服务确保分组将最终到达其目的地。
* **具有时延上界的确保交付**：该服务不仅确保分组的交付，而且在特定的主机到主机时延上界内（例如在 100ms 内）交付。
* **有序分组支付**：该服务确保分组以它们发送的顺序到达目的地。
* **确保最小带宽**：这种网络层服务模仿在发送和接收主机之间的一条特定比特率（例如 1Mbps）的传输链路的行为。只要发送主机以低于特定比特率的速率传输比特（作为分组的组成部分），则所有分组最终会交付到目的主机。
* **安全性**：网络层能够在源加密所有数据报并在目的地解密这些分组，从而对所有运输层报文段提供机密性。

这只是网络层能够提供的部分服务的列表，有无数种可能的服务变种。

因特网的网络层提供了单一的服务，称为**尽力而为服务**。使用尽力而为服务，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付，既不能保证端到端时延，也不能保证有最小的带宽。

尽力而为服务看起来是**根本无服务**的一种委婉说法，事实上，有其他的网络体系结构中已经定义了超越因特网的尽力而为服务模型，比如 ATM 网络体系结构：

![image-20220710092125810](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710092125810.png)

尽管有这些研发良好的供选方案，但**因特网的基本尽力而为服务模型已被证明足够好，能够用于大量的应用**。

## 2. 路由器工作原理

下面是一个路由器体系结构图，路由器主要是由 4 个组件构成的：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710152835921.png" alt="image-20220710152835921" style="zoom:67%;" />

* 输入端口: 输入端口执行几项关键功能：

  * 它要执行**将一条输入的物理链路与路由器相连接**的物理层功能。
  * 它还要执行需要**与位于入链路远端的数据链路层交互**的数据链路层功能。
  * 它还要完成查找功能，正是在这里，**路由器通过查询转发表决定输出端口**，到达的分组通过路由器的交换结构将转发到输出端口。

* 交换结构: 交换结构**将路由器的输入端口与输出端口相连接**。这种交换结构完全包含在路由器中，即**它是一个网络路由器中的网络**。

* 输出端口: 输出端口**存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输入链路上传输这些分组**。

* 路由选择处理器: 路由选择处理器执行**控制平面功能**。在传统的路由器中，每台路由器都**执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表**。可以视作执行的是分布式的路由选择算法。

  但是如果是 SDN 路由器，那么它运行的就是一个集中式的路由选择算法，此时**路由选择处理器负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项**。

### 2.1 输入端口处理和基于目的地转发

下图显示了一个更详细的输入处理的视图：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710153341846.png" alt="image-20220710153341846" style="zoom:67%;" />

接下来我们考虑一个转发的实际情况，在 32 比特的 IP 地址的情况下，转发表的最暴力的实现是：针对每个目的地址生成一个表项。但是因为有超过 40 亿个可能的地址，选择这种方法总体上是不可行的。

事实上，大部分情况下路由器都只负责部分表项，比如：

![image-20220710153704108](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710153704108.png)

这个例子中，路由器显然不需要一个包含 40 亿个表项的转发表，我们可以有一个仅包括 4 个表项的转发表，如下图所示：

![image-20220710153831039](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710153831039.png)

使用这种风格的转发表，路由器用**分组目的地址的前缀（prefix）与该表中的表项进行匹配**；如果存在一个匹配项，则路由器向与该匹配项相关联的链路转发分组。

例如，假设分组的目的地址是 11001000 00010111 00010110 10100001，因为该地址的 21 比特前缀能够匹配该表的第一项，所以路由器向链路接口 0 转发该分组。如果一个前缀不匹配前 3 项中的 任何一项，则路由器向链路接口 3 转发该分组。

尽管听起来足够简单，但这里还是有重要的微妙之处，细心的同学可能已经注意到**一个目的地址可能与不止一个表项相匹配**。例如，地址 11001000 00010111 00011000 10101010 的前 24 比特与表中的第二项匹配，而该地址的前 21 比特与表中的第三项匹配。

**当有多个匹配时，路由器使用最长前缀匹配规则**（longest prefix matching rule），即在该表中寻找最长的匹配项，并向与最长前缀匹配相关联的链路接口转发分组。

> 之后我们会了解到使用最长前缀匹配的理由。

一旦通过查找确定了某分组的输出端口，则该分组就能够发送进入交换结构。在某些设计中，**如果来自其他输入端口的分组当前正在使用该交换结构，一个分组可能会在进入交换结构时被暂时阻塞**。因此，**一个被阻塞的分组必须要在输入端口处排队**，并等待稍后被及时调度以通过交换结构。

### 2.2 交换

交换结构位于一台路由器的核心部位, 因为正是通过这种交换结构, 分组才能实际地从一个输入端口交换到一个输出端口中。

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710160306157.png" alt="image-20220710160306157" style="zoom:50%;" />

### 2.3 输出端口处理

输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。这包括选择和取岀排队的分组进行传输，执行所需的链路层和物理层传输功能。

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710160400568.png" alt="image-20220710160400568" style="zoom:50%;" />

### 2.4 排队

事实上，在输入端口和输出端口处都可以形成分组队列。

排队的位置和程度（或者在输入端口排队，或者在输岀端口排队）将取决于流量负载、交换结构的相对速率和线路速率。

我们现在更为详细一点考虑这些队列，因为**随着这些队列的增长，路由器的缓存空间最终将会耗尽，并且当无内存可用于存储到达的分组时将会出现丢包**（packet loss）。我们在之前的学习中不止一次了解到丢包这个概念，事实上，丢包发生的地点之一就是路由器。

假定输入线路速度与输出线路速度是相同的，并且有 N 个输入端口和 N 个输出端口。为进一步简化讨论，假设所有分组具有相同的固定长度，分组以同步的方式到达输入端口。

这也就是说，在任何链路发送分组的时间等于在任何链路接收分组的时间，在这样的时间间隔内，在一个输入链路上能够到达 0 个或 1 个分组。

#### 2.4.1 输入排队

如果交换结构不能快得（相对于输入线路速度而言）使所有到达分组无时延地通过它传送，会发生什么情况呢？

在这种情况下，在输入端口也将岀现分组排队，因为到达的分组必须加入输入端口队列中，以等待通过交换结构传送到输出端口。

分组是按照 FCFS 策略，从一指定输入队列移动到其要求的输出队列中。**只要其输出端口不同，多个分组可以被并行传送**。然而，如果位于两个输入队列前端的两个分组是发往同一输出队列的，则其中的一个分组将被阻塞，且必须在输入队列中等待，因为交换结构一次只能传送一个分组到某指定端口。

#### 2.4.2 输出排队

我们接下来考虑在交换机的输出端口是否会出现排队。

假设到达 N 个输入端口的每个端口的分组，其目的地是相同的输出端口，在这种情况下，在向输出链路发送一个分组的时间内，就会有 N 个新分组到达该输出端口，因为输出端口在一个单位时间内只能传输一个分组，这 N 个到达分组必须排队经输岀链路传输。

而在正好传输排队等待 N 个分组之一的时间中，可能又到达 N 个分组，最后排队的分组越来越多，导致耗尽输出端口的可用内存。

## 3. IP 协议

IP 协议全称为 Internet Protocol，中文译名为网际协议。

IP 是整个 TCP/IP 协议簇的核心，也是构成互联网的基础，上可向运输层提供各种协议的信息，下可将 IP 数据包放到链路层，通过以太网、令牌环网络等各种技术来传送。

今天有两个版本的 IP 正在使用，我们首先研究广泛部署的 IP 版本 4，也叫做 IPv4；之后，我们将仔细考察 IP 版本 6，也叫做 IPv6，它已经被提议替代 IPv4。

IP 协议中最重要的就是**因特网编址**，这对理解因特网网络层如何工作是至关重要的，**掌握 IP 编址就是掌握因特网的网络层**。

### 3.1 IPv4 数据报格式

IPv4 数据报首部格式如下：

![image-20220710162703190](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710162703190.png)

IPv4 数据报首部中的关键字段如下：

* **版本**：这 4 比特规定了数据报的 IP 协议版本。

  不同的 IP 版本使用不同的数据报格式，IPv4 的格式就如上图所示，IPv6 我们之后再讲。

* **首部长度**：一个 IPv4 数据报可包含一些可变数量的选项，故需要用 4 比特来确定 IP 数据报中载荷实际开始的地方。

  **大多数 IP 数据报不包含选项,，所以一般的 IP 数据报具有 20 字节的首部**。

* **服务区分**：TOS 包含在 IPv4 首部中，以便使不同类型的 IP 数据报能相互区别开来。

* **总长度**：这是 IP 数据报的总长度（包括首部和数据），以字节计。

  因为该字段长为 16 bit，所以 IP 数据报的理论最大长度为 65535 字节。但是实际上，**数据报很少有超过 1500 字节的**，因为 1500 字节恰好能够容纳最大长度以太网帧的载荷字段。

* **标识、标志、片偏移**：这三个字段与 IP 分片有关。

  > IPv6 不允许在路由器上对分组分片。

* **生存时间**：该字段用来确保数据报不会永远在网络中循环。

  每当一台路由器处理数据报时，该字段的值减 1。若 TTL 字段减为 0，则该数据报必须丢弃。

* **协议**：该字段值指示了 IP 数据报的数据部分应交给哪个特定的运输层协议，因此该字段通常仅当一个 IP 数据报到达其最终目的地时才会有用。

* **首部校验和**：首部检验和用于帮助路由器检测收到的 IP 数据报中的比特错误。

  如果数据报首部中携带的检验和与计算得到的检验和不一致，则是检测岀差错，路由器一般会丢弃检测出错误的数据报。

  > **TCP 和 UDP 都有校验和，为什么 IP 也有一个校验和，是否重复了？**
  >
  > 答案当然是不重复，因为 IP 不一定就只运行在 TCP/IP 协议簇上，而在其他地方可能运输层就需要依靠 IP 的校验和。

* **源和目的 IP 地址**：当某源生成一个数据报时，它在源 IP 字段中插入它的 IP 地址，在目的 IP 地址字段中插入其最终目的地的地址。

  通常，源主机通过 DNS 来查找目的地的 IP 地址。

  > 如你所见，IP 地址可以说是 IP 首部里最重要的东西，我们将在之后详细讨论 IP 地址。

请注意，IP 数据报的实际数据通常是交给运输层，但是也可以承载其他类型的数据，如 ICMP 报文，我们将在之后详细介绍。

### 3.2 IPv4 数据分片

在下一章中我们将看到，并不是所有链路层协议都能承载相同长度的网络层分组。例如，以太网帧能够承载不超过 1500 字节的数据，而某些广域网链路的帧可承载不超过 576 字节的数据。

一个链路层帧能承载的最大数据量叫作最大传送单元（Maximum Transmission Unit，MTU）。因为每个 IP 数据报封装在链路层帧中从一台路由器传输到下一台路由器，故**链路层协议的 MTU 严格地限制着 IP 数据报的长度**。

对 IP 数据报长度具有严格限制并不是主要问题。问题在于在发送方与目的地路径上的每段链路可能使用不同的链路层协议，且每种协议可能具有不同的 MTU。比如一个 1500 的链路层帧来到另一条链路，发现这里的 MTU 是 576，此时，该如何将这个过大的 IP 分组挤进链路层帧的有效载荷字段呢?

解决办法是将 IP 数据报中的数据分片成两个或更多个较小的 IP 数据报，用单独的链路层帧封装这些较小的 IP 数据报，然后通过输出链路发送这些帧。

每个这些较小的数据报都称为片（fragment），片在其到达目的地运输层以前需要重新组装。IPv4 的设计者感到在路由器中重新组装数据报会给协议带来相当大的复杂性并且影响路由器的性能，因此 IPv4 的设计者决定将**数据报的重新组装工作放到端系统中**。

当一台目的主机从相同源收到一系列数据报时：

* 首先需要确定这些数据报中的某些是否是一些原来较大的数据报的片
* 如果某些数据报是这些片的话，则它必须进一步确定何时收到了最后一片
* 最后，它必须确定如何将这些接收到的片拼接到一起以形成初始的数据报

为了让目的主机能够执行重新组装的任务，IPv4 的设计者将**标识、标志和片偏移字段**放在 IP 数据报首部中：

* 当生成一个数据报时，发送主机在为该数据报设置源和目的地址的同时贴上标识号。当某路由器需要对一个数据报分片时，形成的每个数据报（即片）具有初始数据报的源地址、目的地址与标识号。当目的地从同一发送主机收到一系列数据报时，它能够检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。
* 由于 IP 是一种不可靠的服务，一个或多个片可能永远到达不了目的地。因此，为了让目的主机绝对地相信它已收到了初始数据报的最后一个片，**最后一个片的标志比特被设为 0，而所有其他片的标志比特被设为 1**。
* 另外，为了让目的主机确定是否丢失了一个片，且能按正确的顺序重新组装片，IPv4 使用偏移字段指定该片应放在初始 IP 数据报的哪个位置。

### 3.3 IPv4 编址

#### 3.3.1 接口

在正式介绍 IPv4 编址之前，我们还需要了解**接口**的概念：一台主机通常只有一条链路连接到网络；当主机中的 IP 想发送一个数据报时，它就在该链路上发送；主机与物理链路之间的边界叫作接口。

现在考虑一台路由器及其接口。因为路由器的任务是从链路上接收数据报并从某些其他链路转发出去，因此**路由器必须拥有两条或更多条链路与它连接**。路由器与它的任意一条链路之间的边界也叫作接口。所以，一台路由器实际上有多个接口，每个接口有其链路。

因为每台主机与路由器都能发送和接收 IP 数据报，**IP 要求每台主机和路由器接口拥有自己的 IP 地址**。

因此，从技术上讲，**一个 IP 地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联**。

#### 3.3.2 IP 地址

IP 地址用于唯一标识一个因特网接口，**每个 IP 地址长度为 32 bit**，也就是 32 个二进制数，因此总共有 $2^{32}$ 个（大约 40 亿）可能的 IP 地址。

这些地址通常按所谓的**点分十进制记法**，即：**地址中的每个字节用它的十进制形式书写，各字节间以句点隔开**。

比如：11000001 00100000 11011000 00001001 这个 IP 地址，它就等价于 193.32.216.9 这个点分十进制的写法。

细心的同学肯定有所疑问：现在地球有 70 多亿人口，手机至少有 70% 的人拥有，每台手机至少有一个 IP 地址，这样 IP 地址应该是不够的，更别提其他路由器，个人电脑等设备也需要 IP 地址了。

因此，现在有一种叫做 NAT 的技术，能够使得可连接计算机数超过 IPv4 地址数量的上限，我们后面再讨论这一问题。

##### 3.3.2.1 IP 地址分类

> 事先声明，这是一种过时的方式，我们讲这个主要是为了知识的完整性以及过度性。

互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了**分类地址**。

IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类：

![image-20220710173943415](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710173943415.png)

上图中的黄色部分称为**分类号**，用以区分 IP 地址类别。

这五大类地址又可以被划分为 A、B、C 类和 D、E 类。

###### 3.3.2.1.1 A、B、C 类地址

对于 A、B、C 类地址来说，地址主要分为两个部分，分别是**网络号和主机号**。

下表列出了 A、B、C 类地址的范围：

![image-20220710174219632](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710174219632.png)

这其中的最大主机个数是如何计算的呢？实际上这就取决于主机号，比如 C 类地址主机号只有 8 位，那么主机数就是 $2^8 - 2$，至于为什么要减去 2，这是因为有两个特殊的 IP 地址：

* 主机号全 0：指定某个网络。
* 主机号全 1：用于指定某个网络下的所有主机，用于广播。

因此在分配的过程中，应该去掉这两种情况。

> **广播是什么？**
>
> 广播地址用于在**同一个链路中相互连接的所有主机之间发送数据包**。
>
> 就类似于现实生活中的广播，比如商场里的广播通知所有听到的人有东西丢了，来前台认领。
>
> 广播地址可以分为本地广播和直接广播两种：
>
> - **在本网络内广播的叫做本地广播**。例如网络地址为 192.168.0.0（C 类）的情况下，广播地址是 192.168.0.255。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0（C 类）以外的其他链路上。
> - **在不同网络之间的广播叫做直接广播**。例如网络地址为 192.168.0.0（C 类）的主机向 192.168.1.255（C 类）的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0（C 类），从而使得所有 192.168.1.1 ~ 192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发） 。

###### 3.3.2.1.2 D、E 类地址

D 类和 E 类地址是没有主机号的，所以不可用于主机 IP。

D 类常被用于**多播**；E 类是预留的分类，暂时未使用。

![image-20220710175002240](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710175002240.png)

我们刚刚讲到广播，那么广播和多播有什么不同呢？

多播用于**将包发送给特定组内的所有主机**，因此也叫做组播。一个组指的是该网络内的一部分主机。

> 这里有一个很生动的例子，比如老师上课喊了一句起立，全班人都听到了，叫广播；老师上课喊了一句，最后一排的同学起立，全班人都听到了，但是只有最后一排的人对这句话感兴趣，并且做出响应，叫多播（组播）。

多播主要是为了弥补广播的遗憾，因为直接广播有一定风险，因此绝大多数路由器都不会为广播转发这个包，但是多播是受支持的。

多播使用的 D 类地址，其前四位是 `1110` 就表示是多播地址，而剩下的 28 位是多播的组编号。

从 224.0.0.0 ~ 239.255.255.255 都是多播的可用范围，其划分为以下三类：

- 224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域网中，路由器是不会进行转发的。
- 224.0.1.0 ~ 238.255.255.255 为用户可用的组播地址，可以用于 Internet 上。
- 239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。

###### 3.3.2.1.3 IP 分类的优缺点

IP 分类的最大**优点**就是**快而简单**，因为每类地址的分类号都是确定的，以 A 类地址解析为例：不管是路由器还是主机解析到一个 IP 地址时候，我们判断其 IP 地址的首位是否为 0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。

但是缺点也很明显：

* **同一网络下没有地址层次**，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就**缺少地址的灵活性**。
* 和**现实脱节**，这是最大的缺点：C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用；而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。

正由于这些缺点，现在 IP 分类已经不被使用了，取而代之的是更好的 CIDR 方案。

##### 3.3.2.2 无类别域间路由选择（CIDR）

无类别域间路由选择（Classless Inter Domain Routing，CIDR）这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，并且也具有点分十进制数形式 `a.b.c.d/x`，其中 x 指示了地址的第一部分中的比特数，这一部分叫做**前缀**，也叫**子网掩码**。

一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址，在这种情况下，该组织内部的设备的 IP 地址将共享共同的前缀，也就是形成了一个**子网**。

子网掩码具体是怎么用的呢？如果是人类来识别子网掩码，那么就是取这个 IPv4 地址的前 x 位，比如 `10.100.122.2/24`，它的子网掩码就是 `10.100.122.0`；对于计算机来说，要获得子网掩码，就提取出这个 x，然后将它转换为前面 x 位全 1，后面全 0 的 IP 地址，上面的例子中就是 `255.255.255.0`，然后再和原 IP 地址相与，得到子网掩码。

之所以要使用子网和子网掩码的概念，就是为了**通信的效率更高**，如果一个数据报到达一个路由器，路由器会检查其子网掩码是否和自己所在的子网的子网掩码相同，如果不是那就不用转发了，直接把它扔到下一个链路上去就好了。

###### 3.3.2.2.1 子网划分

为了获取一块 IP 地址用于一个组织的子网内，某网络管理员也许首先会与他的 ISP 联系，该 ISP 可能会从已分给它的更大地址块中提供一些地址。

例如，该 ISP 也许自己已被分配了地址块 200.23.16.0/20，该 ISP 可以依次将该地址块分成 8 个长度相等的连续地址块，为本 ISP 支持的最多达 8 个组织中的一个分配这些地址块中的一块，如下所示：

![image-20220710215550682](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710215550682.png)

这就叫做子网划分。

细心的同学应该已经注意到了，ISP 的地址又是怎么得到的呢？显然，必须还有一种方法供 ISP 本身得到一块地址，那么是否有一个全球性的权威机构，它具有管理 IP 地址空间并向各 ISP 和其他组织分配地址块的最终责任呢？确实有这样一个组织，叫做因特网名字和编号分配机构（Internet Corporation for Assigned Names and Numbers，ICANN）。

非营利的 ICANN 组织不仅分配 IP 地址，它还管理根 DNS 服务器，除此之外，它还有一项容易引起争论的工作，即分配域名与解决域名纷争。

ICANN 向区域性因特网注册机构（比如中国的 CNNIC）分配地址，这些机构一起形成了 ICANN 的地址支持组织，处理本区域内的地址分配/管理。

##### 3.3.2.3 DHCP——动态主机配置协议

现在，端系统所在的子网已经从 ISP 拿到了 IP 地址，子网就可以向子网内的接口分配 IP 地址了，这项任务原来也有手工分配的，但是现在大多数是交给动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）来完成。

**DHCP 允许主机自动获取一个 IP 地址**。网络管理员能够配置 DHCP，以使某给定主机每次与网络连接时能得到一个相同的 IP 地址，或者某主机将被分配一个临时的 IP 地址。

除了主机 IP 地址分配外，DHCP 还允许一台主机得知其他信息，例如它的子网掩码、它的第一跳路由器地址（称为默认网关）与它的本地 DNS 服务器的地址。

由于 DHCP 具有将主机连接进一个网络的网络相关方面的自动能力，故它又常被称为**即插即用协议**或**零配置协议**。这种能力对于网络管理员来说非常有吸引力，否则他将不得不手工执行这些任务。DHCP 还广泛地用于住宅因特网接入网、企业网与无线局域网中，其中的主机频繁地加入和离开网络。

DHCP 是一个 C/S 架构的**应用层**协议，**运行在 UDP 上**，客户通常是新到达的主机，它要获得包括自身使用的 IP 地址在内的网络配置信息，通常使用 68 端口。每个子网都具有至少一台 DHCP 服务器，专门用来给客户提供这些信息，服务器通常使用 67 端口。

DHCP 的流程如下：

- **DHCP 服务器发现**：一台新到达的主机的首要任务是发现一个要与其交互的 DHCP 服务器，这可以使用 **DHCP 发现报文**（DHCP discovery）实现。

  客户在 UDP 分组中向端口 67 发送该发现报文，该 UDP 分组封装在一个 IP 数据报中。但是由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP **广播**通信，其使用的广播目的地址是 255.255.255.255 并且使用 0.0.0.0 作为源 IP 地址。

  DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到网络中的所有设备。

- **DHCP 服务器提供**：DHCP 服务器收到 DHCP 发现报文时，用 **DHCP 提供报文**（DHCP offer）向客户端做出响应。

  该报文仍然使用 IP 广播地址 255.255.255.255（因为还是不知道客户的 IP 地址），该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 **IP 地址租用期**。

  > 客户端可能收到一个或多个服务器的 DHCP 提供报文，这是因为子网中可能不止一台 DHCP 服务器，客户端会从中选择一个最优的服务器。

- **DHCP 请求**：客户端会向上一步选中的服务器发送 **DHCP 请求报文**（DHCP request）进行响应，回显配置的参数。

- **DHCP ACK**：最后，服务端用 **DHCP ACK** 报文对 DHCP 请求报文进行响应，应答所要求的参数。

一旦客户收到 DHCP ACK 后，交互便完成了，并且该客户能够在租用期内使用 DHCP 分配的 IP 地址。因为客户可能在该租用期超时后还希望使用这个地址，所以 DHCP 还提供了一种机制以允许客户更新它对一个 IP 地址的租用。

##### 3.3.2.4 网络地址转换（NAT）

IPv4 的地址是非常紧缺的，在前面我们也提到可以通过无分类地址来减缓 IPv4 地址耗尽的速度，但是互联网的用户增速是非常惊人的，所以 IPv4 地址依然有被耗尽的危险。

于是，提出了一种**网络地址转换**（Network Address Transla­tion，NAT）的方法，再次缓解了 IPv4 地址耗尽的问题。

简单的来说，NAT 就是同个公司、家庭、教室内的主机（子网）对外部通信时，把子网内的私有的 IP 地址转换成互联网上通用的公有 IP 地址。

![image-20220710225903551](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710225903551.png)

那么，是不是有 N 个私有的 IP 地址，就得有 N 个公有的 IP 地址，这怎么就缓解了 IPv4 地址耗尽的问题呢？

确实是，这种一一对应的 NAT 转换没什么意义，但是绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的，因此 NAT 把 IP 地址 + 端口号一起进行转换，这叫做**网络地址与端口转换（NAPT）**。

怎么样一起转换呢？看下面的例子：

![image-20220710230240982](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710230240982.png)

图中有两个客户端 192.168.1.10 和 192.168.1.11 同时需要与服务器 183.232.231.172 进行通信，并且这两个客户端的本地端口都是 1025。

此时，**两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。**

于是，NAPT 路由器生成一个转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。

NAPT 最大的优点当然是解决了 IPv4 地址不足的问题，但是 NAPT 也不是完美的，它有如下缺点：

* 端口号本来用于进程寻址，而不是用于主机寻址的。这种违规用法对于运行在家庭网络中的服务器来说确实会引起问题。
* 外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。
* 转换表的生成与转换操作都会产生性能开销。
* 通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。

事实上，无论是 CIDR，还是 NAT，都是从 IPv4 到 IPv6 的一种过度，IPv6 从根本上解决了 IPv4 地址不足的问题，是未来的 IP 协议，但是由于 IPv4 使用的实在是太广泛了，转换起来需要很长时间，因此 IPv6 还未普及。

当然，也有别的技术来弥补 NAT 的不足，比如使用 **NAT 穿越技术，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目**，注意这些都是 NAT设备后的应用程序自动完成的。

### 3.4 IPv6

IPv4 的地址是 32 位的，大约可以提供 42 亿个地址，但是早在 2011 年 IPv4 地址就已经被分配完了。

但是 IPv6 的地址是 **128 位**的，这可分配的地址数量是大的惊人，甚至有人说，**IPv6 可以保证地球上的每粒沙子都能被分配到一个 IP 地址**。因此我们说，IPv6 是从根本上结局了 IP 地址不够的问题。

IPv6 除了有更多的地址之外，还有以下优点：

- IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配 IP 地址。
- IPv6 包头包首部长度采用固定的 40 字节，去掉了校验和，简化了首部结构，减轻了路由器负荷，大大**提高了传输的性能**。
- IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大**提升了安全性**。
- ......

但是，IPv4 和 IPv6 是不能相互兼容的，所以不但要我们电脑、手机之类的设备支持，还需要网络运营商对现有的设备进行升级，所以这可能是 IPv6 普及率比较慢的一个原因。

#### 3.4.1 IPv6 数据报格式

IPv6 首部如下图所示：

![image-20220710231314161](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710231314161.png)

* **版本**：该 4 比特字段用于标识 IP 版本号，毫无疑问，这里是 6。

  > 注意，如果你将这个字段的值设置为 4，也不能创建一个合法的 IPv4 数据报。（如果真能这样，那么大家就不用头痛 IPv4 到 IPv6 的迁移了）

* **通信量号**：该 8 比特字段与我们在 IPv4 中看到的 TOS 字段的含义相似。

* **流标号**：该 20 比特的字段用于标识一条数据报的流，能够对一条流中的某些数据报给出优先权，或者它能够用来对来自某些应用的数据报给岀更高的优先权，以优于来自其他应用的数据报。

* **有效数据长度**：该 16 比特值作为一个无符号整数，给出了 IPv6 数据报中跟在定长的 40 字节数据报首部后面的字节数量。

* **下一个首部**：该字段标识数据报中的内容需要交付给哪个协议（如 TCP 或 UDP)。该字段使用与 IPv4 首部中协议字段相同的值。

* **跳数限制**：转发数据报的每台路由器将对该字段的内容减 1。如果跳限制计数达到 0，则该数据报将被丢弃。

* **源地址和目的地址**：IPv6 地址。

IPv6 相比 IPv4 的首部改进：

- **取消了首部校验和字段。** 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。
- **取消了分片/重新组装相关字段。** 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。
- **取消选项字段。** 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的下一个首部指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 40 字节。

#### 3.4.2 IPv6 地址

IPv4 地址长度共 32 位，是以每 8 位作为一组，并用点分十进制的表示方式。

而 IPv6 地址长度是 128 位，是以**每 16 位作为一组**，每组用冒号 `:` 隔开，比如：

![image-20220710231935928](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710231935928.png)

如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号 `::` 隔开。但是，**一个 IPv6 地址中只允许出现一次两个连续的冒号**，如下图所示：

![image-20220710232014593](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710232014593.png)

#### 3.4.3 从 IPv4 到 IPv6 的迁移

我们现在了解了 IPv6 的技术细节，那么我们考虑一个非常实际的问题：基于 IPv4 的公共因特网如何迁移到 IPv6 呢?

现在最大的问题是：新型 IPv6 系统可以做成向后兼容的，即能发送、路由和接收 IPv4 数据报，但是反过来是不行的，IPv4 无法处理 IPv6 的数据报。

可以采取如下办法：

* 宣布一个标志日，即指定某个日期和时间，届时因特网的所有机器都关机并从 IPv4 升级到 IPv6。

  这是不可行的，上次重大的技术迁移（为得到可靠的运输服务，从使用 NCP 迁移到使用 TCP）出现在差不多 35 年以前。即使回到那时候，因特网很小且仍然由少数“奇才”管理着，现在互联网的体量如此之大，没有互联网是不行的。

* **建隧道**，建隧道依据的基本思想如下：假定两个 IPv6 节点要使用 IPv6 数据报进行交互，但它们是经由中间 IPv4 路由器互联的。我们将两台 IPv6 路由器之间的中间 IPv4 路由器的集合称为隧道。

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220710232455633.png" alt="image-20220710232455633" style="zoom:50%;" />

  这种方案在实践中已被证明可行。

## 4. 路由选择算法

在讨论完 IP 之后，我们的数据平面的讨论也就结束了，整个网络层还剩下一个控制平面。

本节我们将讨论**路由选择算法**，其目的是从发送方到接收方的过程中确定一条通过路由器网络的好的路径。

可以使用图来形式化描述路由选择问题。设图 G = (N, E) 是一个 N 个节点和 E 条边的集合，其中每条边是取自 N 的一对节点。

在网络层路由选择的环境中，图中的节点表示路由器，这是做出分组转发决定的点; 连接这些节点的边表示这些路由器之间的物理链路，如下图所示：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711163050339.png" alt="image-20220711163050339" style="zoom:50%;" />

一条边还有一个值表示它的开销。通常，一条边的开销可反映出对应链路的物理长度，它的链路速度，或与该链路相关的金钱上的开销。

**路由选择算法**的天然目标是**找岀从源到目的地间的最低开销路径**。

一般而言，路由选择算法的一种分类方式是根据该算法是集中式还是分布式来划分：

* **集中式路由选择算法**：这类算法用完整的、全局性的网络知识计算岀从源到目的地之间的最低开销路径。

  这就要求该算法在真正开始计算以前，要以某种方式获得这些信息。具有全局状态信息的算法常被称作链路状态（Link State, LS）算法，因为该算法必须知道网络中每条链路的开销。

* **分布式路由选择算法**：在这类算法中，路由器以迭代、分布式的方式计算出最低开销路径。

  没有节点拥有关于所有网络链路开销的完整信息，相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。然后，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。

### 4.1 链路状态路由选择算法（LS）

在链路状态算法中，网络拓扑和所有的链路开销都是已知的。实践中这是通过**让每个节点向网络中所有其他节点广播链路状态分组**来完成的，其中每个链路状态分组包含它所连接的链路的标识和开销。

我们下面要讲的 LS 算法是迪杰斯特拉（Dijkstra）算法，这是一个经典的单源最短路径算法。

Dijkstra 算法计算从源节点到网络中所有其他节点的最低开销路径，这是一个迭代算法，其性质是经算法的第 $k$ 次迭代后，可知道到 $k$ 个目的节点的最低开销路径，在到所有目的节点的最低开销路径之中，这 $k$ 条路径具有 $k$ 个最低开销。

我们定义以下符号：

* $D(v)$：到算法的本次迭代，从源节点 $u$ 到目的节点 $v$ 的最低开销路径的开销。
* $p(v)$：从源到 $v$ 沿着当前最低开销路径的前一节点。
* $N'$：节点子集；如果从源到 $v$ 的最低开销路径已确知，则 $v$ 在 $N'$ 中。

$c(x, y)$：$x$ 到 $y$ 的开销，$x$ 和 $y$ 必须相邻，否则值为 $+\infin$。

该集中式路由选择算法由一个初始化步骤和其后的循环组成，循环执行的次数与网络中节点个数相同。一旦终止，该算法就计算出了从源节点 $u$ 到网络中每个其他节点的最短路径。

算法描述如下：

```
Initialization:
		N' = {u}
		对所有节点 v
				if v 是 u 的邻居
						then D(v) = c(u, v)
				else D(v) = ∞
				
Loop
		找到不在 N' 中的 w 使得 D(w) 最小
		把 w 加入到 N'
		为 w 的每个邻居 v（且不在 N' 中）更新 D(v):
				D(v) = min{D(v), D(w) + c(w, v)}
Until N' = N
```

举个例子：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711163050339.png" alt="image-20220711163050339" style="zoom:50%;" />

使用下表展示，源节点为 u：

| 步骤 | $N'$   | $D(v), p(v)$ | $D(w), p(w)$ | $D(x), p(x)$ | $D(y), p(y)$ | $D(z), p(z)$ |
| ---- | ------ | ------------ | ------------ | ------------ | ------------ | ------------ |
| 0    | u      | 2, u         | 5, u         | 1, u         | ∞            | ∞            |
| 1    | ux     | 2, u         | 4, x         |              | 2, x         | ∞            |
| 2    | uxy    | 2, u         | 3, y         |              |              | 4, y         |
| 3    | uxyv   |              | 3, y         |              |              | 4, y         |
| 4    | uxyvw  |              |              |              |              | 4, y         |
| 5    | uxyvwz |              |              |              |              |              |

文字描述流程如下：

1. 初始化阶段：从 $u$ 到与其直接相连的邻居 $v、x、w$ 的当前已知最低开销路径分别初始化为 2、1 和 5；其他因为不直接和 $u$ 相邻，所以为 0。

   这里特别需要注意 $u \rightarrow w$ 的距离为 5，但是图中还有一条比它更短的路径。

2. 第一次迭代中，我们找到上一轮开销最低的节点，也就是 $x$，此时 $x$ 就被加入到 $N'$ 中，并且作为新的起点。

   从 $x$ 开始，又更新与它直接相邻的节点的距离，此时我们发现，$x$ 能够到 $y$ 了，且我们发现 $x$ 到 $w$ 的距离比上一轮得出的 5 小，因此更新一下距离和前置节点。

3. 第二次迭代中，节点 $v$ 与 $y$ 被发现具有最低开销路径，任意一个被加进去都可以，那我们选择加入 $y$，然后又是一轮更新。

4. ...

如此反复，当 LS 算法终止时，对于每个节点，我们都得到从源节点沿着它的最低开销路径的前一节点；对于每个前一节点，我们又有它的前一节点，以此方式我们可以构建从源节点到所有目的节点的完整路径。

### 4.2 距离向量路由选择算法（DV）

距离向量（Distance-Vector，DV）路由选择算法是一种迭代的，异步的和分布式的一种算法：

* 说它是分布式的，是因为每个节点都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将其计算结果分发给邻居。
* 说它是迭代的，是因为此过程一直要持续到邻居之间无更多信息要交换为止。
* 它是异步的，是因为它不要求所有节点相互之间步伐一致地操作。

在我们给岀 DV 算法之前，有必要讨论一下存在于最低开销路径的开销之间的一种重要关系。令 $d_x(y)$ 是从节点 $x$ 到节点 $y$ 的最低开销路径的开销。则该最低开销与著名的 Bellman-Ford 方程相关，即：
$$
d_x(y) = min_v\{c(x, y) + d_v(y)\}
$$
方程中的 $min_v$ 是对于 $x$ 的所有邻居的。

DV 算法的基本思想是：每个节点 $x$ 以 $D_x(y)$ 开始，对在 $N$ 中的所有节点 $y$，估计从 $x$ 到 $y$ 的最低开销路径的开销，令 $D_x = [D_x(y): y ∈ N]$ 是节点 $x$ 的距离向量，该向量是从 $x$ 到 $N$ 中所有其他节点 $y$ 的开销估计向量。使用 DV 算法，每个节点 $x$ 维护下列路由选择信息：

* 对于每个邻居 $v$，从 $x$ 直接相连邻居 $v$ 的开销为 $c(x, y)$。
* 节点 $x$ 的距离向量，即 $D_x = [D_x(y): y ∈ N]$ 包含了 $x$ 到 $N$ 中所有目的地 $y$ 的开销估计值。
* 它的每个邻居的距离向量，即对 $x$ 的每个邻居有 $D_v = [D_v(y): y ∈ N]$。

在该分布式、异步算法中，**每个节点不时地向它的每个邻居发送它的距离向量副本**。

当节点 $x$ 从它的任何一个邻居 $v$ 接收到一个新距离向量，它保存 $v$ 的距离向量，然后使用 Bellman-Ford 方程更新它自己的距离向量如下:
$$
D_x(y) = min_v\{c(x, v) + D_v(y)\}，对 N 中的每个节点
$$
如果节点 $x$ 的距离向量因这个更新步骤而改变，节点 $x$ 接下来将向它的每个邻居发送其更新后的距离向量，这继而让所有邻居更新它们自己的距离向量。

令人惊奇的是，只要所有的节点继续以异步方式交换它们的距离向量，每个开销估计 $D_x(y)$ 最终收敛到 $d_x(y)$，$d_x(y)$ 为从节点 $x$ 到节点 $y$ 的实际最低开销路径的开销。

### 4.3 因特网自治系统内部的路由选择（OSPF）

在我们至今为止的算法研究中，我们将网络只看作一个互联路由器的集合。但是实践中不是如此，有以下两个重要原因：

* 规模：随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高得不可实现。使用 LS 算法计算路由将会耗费巨量的内存，而使用 DV 算法将会难以收敛。
* 管理自治：因特网是 ISP 的网络，每个 ISP 都有自己的路由器网络。ISP 通常希望按自己的意愿运行路由器。

## 5. ICMP

因特网控制报文协议（Internet Control Message Protocol，ICMP）被主机和路由器用来彼此**沟通网络层的信息**。

ICMP 最典型的用途是差错报告，网络包在复杂的网络传输环境里，常常会遇到各种问题。例如，当运行一个 HTTP 会话时，你也许会遇到一些诸如“目的网络不可达”之类的错误报文，这种报文就来源于 ICMP。在某个位置，IP 路由器不能找到一条通往 HTTP 请求中所指定的主机的路径，该路由器就会向你的主机生成并发出一个 ICMP 报文以指示该错误。

**ICMP 通常被认为是 IP 的一部分，但从体系结构上讲它位于 IP 之上**，因为 ICMP 报文是承载在 IP 分组中的。这就是说，ICMP 报文是作为 IP 有效载荷承载的，就像 TCP 与 UDP 报文段作为 IP 有效载荷被承载那样。类似地，当一台主机收到一个指明上层协议为 ICMP 的 IP 数据报时，它分解出该数据报的内容给 ICMP，就像分解岀一个数据报的内容给 TCP 或 UDP 一样。

ICMP 报文有一个**类型**字段和一个**代码**字段，除此之外，**它还包含首次引起该 ICMP 报文的 IP 首部**，格式如下：

![image-20220711182256692](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711182256692.png)

我们注意到 ICMP 有类型的说法，事实上也的确如此，ICMP 可不仅仅就是用于差错报告的，详情看下表：

| ICMP 类型 | 代码 | 描述                          |
| --------- | ---- | ----------------------------- |
| 0         | 0    | Echo 回答（对 `ping` 的回答） |
| 3         | 0    | 目的网络不可达                |
| 3         | 1    | 目的主机不可达                |
| 3         | 2    | 目的协议不可达                |
| 3         | 3    | 目的端口不可达                |
| 3         | 6    | 目的网络未知                  |
| 3         | 7    | 目的主机未知                  |
| 4         | 0    | 源抑制（拥塞控制）            |
| 8         | 0    | Echo 请求                     |
| 9         | 0    | 路由器通告                    |
| 10        | 0    | 路由器发现                    |
| 11        | 0    | TTL 过期                      |
| 12        | 0    | IP 首部损坏                   |

我们大致可以把类型分为以下两类：

* 差错报文类：这类涉及到的类型号有 3、4、11、12
* 查询报文类：这类涉及到的类型号有 0、8、9、10

### 5.1 `ping` 的工作原理

我们尝尝使用 `ping` 命令来测试网络是否畅通，简称能否 `ping 通；并且，我们在上面看到 ICMP 类型为 0，编码为 0 时，描述是对 `ping` 的回答，难道 `ping` 的原理就是 ICMP 协议？

没错，**`ping` 的原理就是 ICMP 协议**，我们来看一下 `ping` 的工作流程：

* 源主机首先会构建一个 **ICMP Echo 请求**数据包，这个 ICMP 类型为 8。

  该请求包含一个**序号**字段，主要用于区分连续 `ping` 的时候发出的多个数据包。

  每发出一个请求数据包，序号会自动加 `1`。为了能够计算往返时间 `RTT`，它会在报文的数据部分插入发送时间。

  数据包大概长这个样子：

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711182720561.png" alt="image-20220711182720561" style="zoom:50%;" />

* 构造完毕之后，由 ICMP 协议将这个数据包连同要 `ping` 的 IP 地址一起交给 IP 层，IP 层设置协议字段为 1，表示是 ICMP 协议，然后构建出一个 IP 数据包。

  <img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711182842163.png" alt="image-20220711182842163" style="zoom: 50%;" />

* 接下来，需要加入 MAC 头。如果在本地 ARP 映射表中查找出目的 IP 地址所对应的 MAC 地址，则可以直接使用；如果没有，则需要使用 ARP 查询 MAC 地址。获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。

  ![image-20220711183341576](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711183341576.png)

  > 有同学肯定对一段很懵，什么是 MAC，ARP 又是什么？和链路层有关吗？是的，这些都和链路层有关，我们很快就会介绍，你可以先跳过这一节到下一节，然后读完下一节后再返回来看这里的内容。

* 对方收到数据包之后，会构建一个 **ICMP Echo 回答**数据包，这个 ICMP 类型为 0，**序号**为接收到的请求数据包中的序号，然后再发送出去给主机 A。

  ![image-20220711183635163](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711183635163.png)

接下来就是判断了，**如果在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达**。此时，源主机还会用当前时刻减去该数据包最初从源主机上发出的时刻，就得出 ICMP 数据包的**时间延迟**。

所以，你看到的 `ping` 命令的输出不仅包含它能否 `ping` 通，还包括一些延迟信息：

<img src="https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711183813886.png" alt="image-20220711183813886" style="zoom:67%;" />

## 6. 链路层简要说明

链路层涉及到的东西都比较底层，对于一般的程序员而言都用不上，因此我们重点讲解链路层的一些重要概念。

**链路层的基本服务是将数据报通过单一通信链路从一个节点移动到相邻节点**。但所提供的服务细节能够随着链路层协议的不同而变化。链路层协议能够提供的可能服务包括：

* **成帧**：在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其用链路层帧封装起来。

* **链路接入**：媒体访问控制（Medium Access Control, MAC）协议规定了帧在链路上传输的规则。

* **可靠交付**：当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报。

  然而，对于低比特差错的链路，包括光纤、同轴电缆和许多双绞铜线链路, 链路层可靠交付可能会被认为是一种不必要的开销。由于这个原因，许多有线的链路层协议不提供可靠交付服务。

* **差错检测和纠正**：当帧中的一个比特作为 1 传输时，接收方节点中的链路层硬件可能不正确地将其判断为 0,反之亦然。这种比特差错是由信号衰减和电磁噪声导 致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。

> **无线局域网和以太网**
>
> 无线局域网是最近发展的很火热的局域网技术，而以太网则是有线局域网中普遍使用的协议。
>
> 所以，通常来说一台 PC 既具有有线网卡，也具有无线网卡，每一个网卡都有一个独一无二的 MAC 地址（即将要介绍）。

### 6.1 MAC 地址

主机和路由器其上的**网络接口具有链路层地址**，我们通常称这个地址为 MAC 地址。

MAC 地址不像 IP 地址一样，它是实实在在的网络设备出身地址，它是由厂商写入网络设备的 BIOS 中，网络设备厂商也并不能随意的使用 MAC 地址，需要向 IEEE 申请，当然厂商申请需要付费。

MAC 地址的长度为 6 字节，也就是 48 位，通常写作 12 个十六进制数字，每 2 个十六进制数之间用冒号隔开，前 24 位代表了网络硬件制造商的编号，由 IEEE 分配，而后 24 位是由网络产品制造产商自行分配，这样就可以**保证世界上每个网络设备具有唯一的 MAC 地址**。比如一台电脑的网卡坏掉了之后，更换一块网卡之后 MAC 地址就会变。 

> 交换机不具有 MAC 地址，它所做的事仅仅是转发。

有一个特殊的 MAC 地址是 `FF:FF:FF:FF:FF:FF`，这是 MAC 中的广播地址。

#### 6.1.1 为什么需要 MAC 地址？它和 IP 地址有什么不一样？

举个例子大家就明白了：假如要去一个很远的地方旅行，制定了一个行程表，其间需先后乘坐飞机、地铁、公交车才能抵达目的地，为此你需要买飞机票，地铁票等。

飞机票和地铁票都是去往特定的地点的，每张票只能够在某一限定区间内移动，此处的区间内就如同通信网络中数据链路，在区间内移动相当于数据链路层，充当区间内两个节点传输的功能，区间内的出发点好比源 MAC 地址，目标地点好比目的 MAC 地址。

整个旅游行程表就相当于网络层，充当远程定位的功能，行程的开始好比源 IP，行程的终点好比目的 IP 地址。

![image-20220711194031421](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711194031421.png)

如果你只有行程表而没有车票，就无法搭乘交通工具到达目的地。相反，如果你有车票而没有行程表，恐怕也很难到达目的地。因为你不知道不知道该在哪里下车。

因此，只有两者兼备，既有某个区间的车票又有整个旅行的行程表，才能保证到达目的地。与此类似，**计算机网络中也同时需要数据链路层和网络层才能实现向最终目标地址的通信**。

还有重要一点，旅行途中我们虽然不断变化了交通工具，但是旅行行程的起始地址和目的地址始终都没变。其实，在网络中数据包传输中也是如此，**源 IP 地址和目标 IP 地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化**。

> 更重要的一点是，**网络的各层需要保持相对独立**，这是因为链路层承载的不一定就是 IP 层。
>
> 如果在链路层没有一个独立的寻址机制的话，假设我们就让链路层使用 IP 地址，那么如果对方使用的并非 IP 的网络层协议，那么链路层将无法很好的进行工作。
>
> 总之，为了使网络体系结构中各层次成为极为独立的构建模块，不同的层次需要有它们自己的寻址方案。

#### 6.1.2 MAC 帧的格式

MAC 帧（也叫以太网帧）的格式如下：

![image-20220711234640268](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711234640268.png)

我们重点关注其中的目标 MAC 地址和源 MAC 地址，以及类型。

在 MAC 头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

### 6.2 地址解析（ARP）协议

因为同时存在网络层地址和链路层地址，所以需要在它们之间进行转换。对于因特网而言，这是**地址解析协议**（Address Resolution Protocol, ARP）的任务。

在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过路由表确定 IP 数据包的下一跳路由器或主机。然而，网络层的下一层是数据链路层，所以我们还要知道下一跳的 MAC 地址。

由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 **ARP 协议**，求得下一跳的 MAC 地址。

每台主机或路由器在其内存中具有一个 ARP 表（ARP table），这张表包含 IP 地址到 MAC 地址的映射关系。该 ARP 表也包含 一个寿命（TTL）值，它指示了从表中删除每个映射的时间，一个表项通常的过期时间是 20 分钟。

如下图所示：

![image-20220711195207777](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711195207777.png)

现在，假设我们要向目的主机发送一个数据报，发送主机需要获得给定 IP 地址的目的主机的 MAC 地址，如果发送方的 ARP 表具有该目的节点的表项，这个任务是很容易完成的。

但是，如果 ARP 表里没有该项，又该怎么办呢？这种情况下，我们的 ARP 协议就要登场了，它的工作流程如下：

- 主机会通过**广播发送 ARP 请求**，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。
- 当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，**如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机**。
- 如果发送方获得了这个 ARP 响应中的 MAC 地址，则会在 ARP 表中新建一个表项，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。

由于不涉及更上层的协议，但是涉及 IP 协议，想必大家应该也猜到了，**ARP 是属于 IP 层的协议**。

#### 6.2.1 RARP

ARP 协议是已知 IP 地址求 MAC 地址，而 **RARP 协议正好和 ARP 相反**，它是**已知 MAC 地址求 IP 地址**。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。

通常这需要架设一台 `RARP` 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：

- 该设备会发送一条类似”我的 MAC 地址是 XXXX，请告诉我，我的I P 地址应该是什么“的请求信息。
- RARP 服务器接到这个消息后返回一条类似“MAC 地址为 XXXX 的设备，你的 IP 地址为 XXXX”的信息给这个设备。

* 最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP 地址。

  > 整个过程看着是不是有点像 DHCP？

示意图如下：

![image-20220711195639284](https://cdn.jsdelivr.net/gh/Faraway002/typora/images/image-20220711195639284.png)
