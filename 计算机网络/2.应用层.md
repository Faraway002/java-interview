# 应用层

现如今，越来越多的应用程序利用网络进行通信，这些应用有 Web 浏览器、远程登录、电子邮件、文件传输、文件下载等，应用层的协议正是进行这些行为活动的规则和标准。

![image-20220328215815268](https://fastly.jsdelivr.net/gh/Faraway002/typora/imagesimage-20220328215815268.png)

应用层协议定义了在不同端系统上的应用程序进程如何相互传递报文。一般来说，会定义如下内容：

- 交换的报文类型：是请求报文还是响应报文。
- 报文字段的解释：对报文中各个字段的详细描述。
- 报文字段的语义：报文各个字段的含义是什么。
- 进程何时、以什么方式发送报文以及响应。

## 应用层协议原理

### 应用层体系结构

一般来说，应用层有两种主流体系结构

- 客户 - 服务器体系结构 （Client - Server，C/S）

  客户 - 服务器体系结构是应用十分广泛的，在客户 - 服务器体系结构中，有一个总是打开的主机称为**服务器（Server）**，它提供来自于**客户（client）**的服务。

  我们最常见的服务器就是 Web 服务器，Web 服务器服务于来自**浏览器**的请求，由于 Web 服务器和浏览器在 C/S 中使用的十分频繁，因此它有一个单独的架构名称，也就是我们常说的 B/S（Broswer - Server）。

- 对等体系结构（P2P）

  在 P2P 体系结构中，应用程序在两个主机之间直接通信，这些主机被称为**对等方**，对等网络的每个用户端既是一个客户端，也有服务器的功能。常见的 P2P 体系结构的应用有**文件共享、视频会议、网络电话**等。

  P2P 一个最大的特点就是**扩展性**，因为 P2P 网络的一个重要的目标就是让所有的客户端都能提供资源、获取资源，共享带宽，存储空间等。因此，当有更多节点加入且对系统请求增多，整个系统的容量也增大，这是具有一组固定服务器的客户 - 服务器结构不具备的。

### 进程间通信

网络的实质就是进程间通信，因此网络可以被看做是一种进程间的通信机制。在同一操作系统上的进程有很多种方式进行通信，详见[进程管理](../操作系统/2.进程管理.md#进程间通信（IPC）)，我们将着重介绍网络通信这种方式。

操作系统提供了**套接字（Socket）** API 供应用程序使用，通过使用套接字，应用程序可以向网络推送报文，同时也可以获取报文。这种方式很像 I/O，实际上也确实是如此，网络通信本质上就是操作系统对网卡设备进行 I/O，因此**套接字也被视为文件的一种，可对其进行像对文件一样的打开、读写和关闭等操作**。

![image-20220328220852835](https://fastly.jsdelivr.net/gh/Faraway002/typora/imagesimage-20220328220852835.png)

在使用套接字时，我们可以指定一个要使用的传输层协议，比如 TCP 或 UDP，但无论如何，套接字都需要一种机制来标识进程，在同一个操作系统上可以使用 PID，但是不同操作系统上就不一样了，为此，需要为套接字提供一个**IP 地址 + 端口号**，来唯一标识一台主机上的进程。

2. **IP 地址**是一个 32 bit 的量，能够唯一标识一台**主机**。
2. **端口号**是操作系统中为**网络应用程序**分配的一个整数。操作系统已经预先为许多应用程序分配了端口号，比如 Web 服务器通常分配了 80 端口，邮件服务器使用 25 端口等等。

#### 如何选择运输服务

在应用层协议向套接字推出报文时，套接字会根据传输层协议向目标发送报文段，在接收方的应用程序中，也**要使用相同的传输层协议套接字才能够接收并解析该报文段**，上交给应用层协议。

所以，**应用层协议一般都会基于一种传输层协议而构建**，应用层需要依赖传输层提供的一些服务。

一般来说，应用层所希望的服务有如下几类：

1. 可靠数据传输。如前所述，分组可能会丢失，数据丢失可能会造成灾难性的后果。因此应用层希望运输层能够做一些工作以确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。

   当然，并非所有的应用程序都希望具有可靠数据传输，可靠数据传输需要额外的时间和资源来确保，这对于一些实时性和速度要求较高的应用程序可能无法接受，比如视频电话，你可能不能接受对方的脸不清晰，但是你一定不能接受的是对方说话卡顿。  

2. 吞吐量。部分应用希望运输层协议能够以某种特定的速率提供确保的可用吞吐量。

3. 定时。**定时能够确保网络中两个应用程序的收发是否能够在指定的时间内完成**，这也是应用程序选择运输服务需要考虑的一个因素，比如在实时的网络游戏中，如果一个数据包迟迟发不出去，对面都推塔了你可能还卡在半路上。

4. 安全。部分应用希望运输协议能够加密由发送进程传输的所有数据，在接受主机方交付之前应该能够解密这些数据。

因特网的运输层协议有 TCP 和 UDP 两种，我们将在运输层详细的讨论它们。

这两种协议中，**TCP 提供可靠数据传输，也可以使用 SSL 加强安全性**；而 **UDP 则不提供任何可靠数据传输**。无论是 TCP 还是 UDP，都不做定时和吞吐量的保证。

下表列出了一些常见的应用程序选择的协议：

|     应用     | 应用层协议 | 支撑的运输协议 |
| :----------: | :--------: | :------------: |
|   电子邮件   |    SMTP    |      TCP       |
| 远程终端访问 |   Telnet   |      TCP       |
|     Web      |    HTTP    |      TCP       |
|   文件传输   |    FTP     |      TCP       |
|  流式多媒体  |    HTTP    |      TCP       |
|  因特网电话  |  SIP、RTP  |   TCP 或 UDP   |

## Web 和 HTTP

Web 是一个引起公众注意的因特网应用，它极大地改变了人们与工作环境内外交流的方式。它将因特网从只是很多数据网之一的地位提升为仅有的一个数据网。

Web 将互联网中的信息以**超文本**的形式展现，用来显示 Web 结果的客户端被称为 Web 浏览器，通过浏览器，我们无需关注想要访问的内容在哪个服务器上，我们只需要知道我们想访问的内容就可以了。

![image-20220328222010546](https://fastly.jsdelivr.net/gh/Faraway002/typora/imagesimage-20220328222010546.png)

Web 包含了三个重要的组成部分：

* URL，定义了访问信息的手段和位置
* HTML，定义了信息的表现形式
* HTTP，定义了信息的访问规范

### URL 和 URI

URI 的全称是 Uniform Resource Identifier，中文名称是统一资源标识符，它能够唯一地标记互联网上的资源。

URL 的全称是 Uniform Resource Locator，中文名称是统一资源定位符，它实际上是 URI 的一个子集。

URI 不仅包括 URL，还包括 URN（统一资源名称），它们之间的关系如下：

![image-20220328222633490](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/imagesimage-20220328222633490.png)

URI 已经不局限于标识互联网资源，它可以作为所有资源的识别码。

#### URL

一个标准的 URL 由 protocol（协议）、hostname（主机）、port（端口号）、path（访问路径）、query（请求参数）、anchor（锚）几个部分组成。

比如：

```
http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
```

1. protocol 是 URL 中的协议部分，这里是 http 协议。常见的协议还有：jdbc、https、ftp 等。
2. hostname 是主机部分，这里是 `www.example.com`。也可以直接向一个 IP 地址请求，但是这种情况很少见。
3. port 是端口号，HTTP 在操作系统具有默认端口号 80，所以可以省略不写。这里是 8080，一般的 Web 服务器都使用 8080。
4. path 是请求路径，使用 hostname + port 定位主机后，就可以用 path 访问该主机上的文件系统了。这里是 `/path/to/myfile.html`，表示该服务器上的 web 根目录下的 path 文件夹下的 to 文件夹下的 myfile.html 文件。
5. query 是请求参数，以 `?` 开头，key=value 的形式，`&` 分隔。这里是：`?key1=value1&key2=value2`。
6. anchor 为该网页内部的锚点，锚点名称通过 HTML 的标签的 id 属性定义。在这里没有使用锚点。

> **URL 重写**
>
> 绝大部分 Web 服务器都提供了 URL 重写功能。URL 重写指的是截取请求的 URL，对 URL 进行修改的过程。
>
> 比如你在浏览器输入 www.360buy.com，最后你会发现你访问的是 www.jd.com。这个过程就经过了一个 URL 重写。
>
> 绝大部分 Web 框架都提供了 URL 重写的功能，在 Java 中 URL 重写大多和 Session 的实现方式有关，也有 SpringMVC 框架提供矩阵变量，详情参见 JavaWeb 技术之 Session 以及 SpringMVC 教程。

### HTML

HTML 是 Hyper Text Markup Language，超文本标记语言，使用该语言，可以通过标签（标记）的形式来描述一个 Web 页面的框架和内容，还可以插入其他 URL，以此联通所有的 Web 页面和超文本内容。

首先介绍一下超文本的概念，超文本指的是在 Web 页面中不仅可以包含普通的文本，还可以包含图片，视频的超出文本范畴的内容，因此叫做超文本。

使用 HTML 编写的一个文件称作 Web 页面，浏览器能够解析 HTML 的语法并将其渲染展示出来。

与 HTML 相伴的技术还有 CSS 和 JavaScript：

1. CSS，Cascading Style Sheets，层叠样式表。使用该技术，可以修饰 HTML，使其有更好看的外观。

2. JavaScript，是一种脚本语言。使用该脚本语言，可以使 HTML 具有和用户交互的能力，并且可以主动向服务器发起动作。

HTML、CSS 和 JavaScript 一起组成了现在丰富多彩的 Web 页面。

### HTTP

**HTTP 是 Web 的主要应用层协议，可以说它是 Web 的核心**，也是使用的最广泛的应用层协议，全称为**超文本传输协议（Hyper Text Transfer Protocol）**。

**HTTP 由两个程序实现：一个客户程序和一个服务器程序。**客户程序和服务器程序运行在不同的端系统中，通过交换 HTTP 报文进行会话。HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式。

对于每一个 Web 对象（一个 HTML 文件或超文本对象），都通过一个 URL 进行索引。浏览器会通过 URL 向服务器发起 HTTP 请求，服务器找到该资源后，返回一个 HTTP 响应。也就是说，**请求的每一个 Web 对象都有一对 HTTP 请求/响应**。

**HTTP 使用 TCP 作为其运输协议**，发起请求时，本质上建立了一条 TCP 连接，套接字提供了 TCP 接口，因此客户端和服务器都持有一个 TCP 套接字。客户把请求报文推送到套接字，套接字就会完成运输的过程，并且在收到响应后，自动解析将响应送到用户处。

由于 TCP 提供可靠数据传输，因此 HTTP 不用担心它的报文会丢失，至于真的发生了丢失该如何解决，那是 TCP 要做的事情。从这里也可以看出网络分层的好处。

此外，HTTP 是一个**无状态协议**，服务器发送资源给客户以后，并**不存储任何关于客户的信息**。即便客户在很短的时间内多次请求，服务器也不会认识客户是谁。这一点保证了 HTTP 的高性能和简单性，但是却给其他需求带来了不便，因此在后面我们会谈到，有其他技术弥补这个缺陷。

最后，**HTTP 是明文传输的**，这意味着传输过程中的信息很可能会被拦截并被他人查看，这也有其他技术弥补。

#### HTTP 请求/响应过程简述

让我们通过一个例子来探讨一下 HTTP 的请求响应过程，我们假设访问的 URL 地址为 `http://www.someSchool.edu/someDepartment/home.index`，当我们输入网址并点击回车时，浏览器内部会进行如下操作

- DNS服务器会首先进行域名的映射，找到访问 `www.someSchool.edu` 所在的地址，然后HTTP 客户端进程在 80 端口发起一个到服务器 `www.someSchool.edu` 的 TCP 连接（80 端口是 HTTP 的默认端口）。在客户和服务器进程中都会有一个**套接字**与其相连。
- HTTP 客户端通过它的套接字向服务器发送一个 HTTP 请求报文。该报文中包含了路径 `someDepartment/home.index` 的资源，我们后面会详细讨论 HTTP 请求报文。
- HTTP 服务器通过它的套接字接受该报文，进行请求的解析工作，并从其存储器中检索出对象 `www.someSchool.edu/someDepartment/home.index`，然后把检索出来的对象进行封装，封装到 HTTP 响应报文中，并通过套接字向客户进行发送。
- HTTP 服务器随即通知 TCP 断开 TCP 连接，实际上是需要等到客户接受完响应报文后才会断开 TCP 连接。
- HTTP 客户端接受完响应报文后，TCP 连接会关闭。HTTP 客户端从响应中提取出报文中是一个 HTML 响应文件，并检查该 HTML 文件，然后循环检查报文中其他内部对象。
- 检查完成后，HTTP 客户端会把对应的资源通过显示器呈现给用户。

至此，键入网址再按下回车的全过程就结束了。上述过程描述的是一种简单的请求-响应全过程，真实的请求-响应情况可能要比上面描述的过程复杂很多。

#### 持续连接和非持续连接

在许多因特网应用程序中，客户和服务器在一个相当长的时间范围内通信，其中客户发出一系列请求并且服务器对每个请求进行响应。这一系列请求可以以规则的间隔周期性地或者间断性地一个接一个发出。

这里就有一个问题，每个请求/响应对是经一个单独的 TCP 连接发送，还是所有的请求及其响应经相同的 TCP 连接发送呢？

* 采用前一种方法，该应用程序被称为使用非持续连接
* 采用后一种方法，该应用程序被称为使用持续连接

事实上，HTTP 既能够使用非持续连接，也能够使用持续连接，尽管 HTTP 在其默认方式下使用持续连接，HTTP 客户和服务器也能配置成使用非持续连接。

假如有一个包含十个 Web 图像的 HTML 页面，共 11 个 Web 对象，此时就有 11 个请求/响应对。用户在请求该页面时，如果使用非持续连接，则在很短的时间内，HTTP 就要建立 11 次连接，虽然浏览器可以并行的建立连接，时间开销不会很大，但是消耗的资源是很大的。

更好的办法是，预先开启 5-10 个 HTTP 持续连接。在这种情况下，不仅消耗的时间少了，而且在请求的关键时刻不用耗费额外资源去创建新连接。

我们知道，HTTP 本质上是通过建立 TCP 连接来传输报文的。引入一个新概念：往返时间（RTT），它表示一个请求报文从客户到服务器，服务器再发送回一个响应报文直到客户接收所经历的时间。

TCP 具有一个三次握手的过程，第三次握手时才开始请求（详见 TCP），所以实际上 HTTP 真正开始请求之前，还需要一个 RTT，如下图所示：

![image-20220120100520475](C:\Users\94585\AppData\Roaming\Typora\typora-user-images\image-20220120100520475.png)

如果采用非持续连接，则需要额外的 10 个 RTT，无论是客户端还是服务器都无法接受这个开销。

在采用 HTTP/1.1 持续连接的情况下，服务器在发送响应后保持该 TCP 连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。特别是，一个完整的 Web 页面可以用单个持续 TCP 连接进行传送。更有甚者，位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户时，可以在单个持续 TCP 连接上进行。这些请求可以一个接一个地发出，而不必等待对未决请求（流水线）的回答。

一般来说，如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，HTTP 服务器就关闭该连接。

#### HTTP 报文格式

HTTP 的报文主要由四大部分组成：

- **起始行（start line）**：描述请求或响应的基本信息。
- **头部字段（header）**：使用 key-value 形式更详细地说明报文。
- **空行（blank line）**：空行是必须存在的，介于头部和消息正文之间，即使消息正文为空，也需要空行。
- **消息正文（entity）**：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

起始行和头部字段一般统称为请求/响应头。

请求报文和响应报文都遵循了这个基本的格式。

##### 请求报文

HTTP 请求报文格式如下：

![image-20220328225433167](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220328225433167.png)

其中，`cr` +  `lf` 的含义为一个回车。

###### 请求行

请求行是 HTTP 请求报文的第一行，包含三个内容：

1. **请求方法**。

   HTTP/1.1 规定了八种请求方法，如下表所示：

   ![img](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/1418466-20180810112625596-2103906128.png)

   其中最常用的是 GET 和 POST 方法，我们详细展示它们的区别：

   1. GET 是获取资源，而 POST 则是提交资源。

   2. GET 的请求参数附在 URL 后，而 POST 则在实体体中。

   3. GET 请求可以被浏览器缓存，而 POST 则不行。

   4. GET 请求参数的长度是有限的（URL 最长为 2048 个字符），而 POST 则无限制。

   5. GET 请求参数只允许部分字符，而 POST 可以传输二进制的数据（比如上传文件）。

   6. GET 请求会发送一个 TCP 数据包，而 POST 是两个。

      GET 方式的请求，浏览器会把 header 和 data 一并发送出去，服务器响应 200；而**对于 POST，浏览器先发送 header，服务器响应 100（continue），浏览器再发送 data，服务器响应 200**。

   除此之外，最重要的一个区别是：**GET 是幂等且安全的，而 POST 不能保证安全也并不一定是幂等的**。

   > **幂等和安全**
   >
   > 在这里，**安全**的含义是**请求方法不会破坏服务器上的资源**；**幂等指的是多次执行相同的操作，结果都是相同的。**
   >
   > * **GET 方法就是安全且幂等的**，因为它是**只读**操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以**可以对 GET 请求的数据做缓存。
   > * **POST** 因为是**提交数据**的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求**。

   > **GET 中的 URL 编码**
   >
   > 我们通常使用的百度搜索，会把我们搜索的内容附在 URL 上（GET 请求）：
   >
   > ![image-20220120103849322](C:\Users\94585\AppData\Roaming\Typora\typora-user-images\image-20220120103849322.png)
   >
   > 而 GET 请求参数只允许 ASCII 字符，很明显汉字并不是 ASCII 字符，这是怎么回事呢？并且，我们搜索关键字中的空格在 URL 栏中显示成了 `%20`，到底发生了什么？
   >
   > 事实上，浏览器为了显示美观，把原始的 URL 美化了，真实的 URL 是这样的：https://www.baidu.com/s?ie=utf-8&mod=1&isbd=1&isid=9baf1f520000c5ad&ie=utf-8&f=8&rsv_bp=1&rsv_idx=2&tn=baiduhome_pg&wd=URL%20%E4%B8%AD%E6%96%87&rsv_spt=1&oq=URL%2520%25E4%25B8%25AD%25E6%2596%2587&rsv_pq=9baf1f520000c5ad&rsv_t=5cb8ad37%2FcPM3jZWiAE7o20bFYiHzoO0sZVsdCGhI0s1a8b02buFUn3htGFFC3dlxq12&rqlang=cn&rsv_enter=0&rsv_dl=tb&rsv_btype=t&bs=URL%20%E4%B8%AD%E6%96%87&rsv_sid=undefined&_ss=1&clist=8b55bd64985f63be%098b75ddc4d2fcea3e%09f7687ee6395e089f%09f7687ee6395e089f&hsug=&f4s=1&csor=6&_cr1=36526
   >
   > 可以看到，所有的中文字符都不存在了，变成了 `%XX` 这样的字符。
   >
   > 事实上，URL 把字符归类为三种：
   >
   > 1. 保留字符。有这些保留字符：`: / ? # [ ] @ ! $ & ' ( ) * + , ; =`。
   > 2. 非保留字符。`a-z`、`A-Z`、`0-9`、`-`、`_`、`.` 以及 `~`。
   > 3. 其他字符。比如中文字符。
   >
   > 由于其他字符和保留字符的存在，URL 要求对 URL 进行编码（encoding）。要求是：
   >
   > 1. 保留字符必须编码。
   > 2. 非保留字符不能编码。
   > 3. 其他字符强烈建议编码。
   > 4. 原则上只编码 URL 的请求参数及其之后的部分。并且仅编码一次，解码也只需要一次。
   >
   > 编码的原理很简单：把一个字符对应的 Unicode 编码的十六进制表示取出来，然后在前面放上 % 即可。

2. URL，是完整 URL 中的 path 部分。

3. 版本，是使用的 HTTP 协议的版本。

###### 首部行

首部行为客户端和服务器处理请求和响应的所需要的信息，**本质上是一个个 Key: Value 形式的键值对，每一个键值对称为首部字段**。

首部行可以声明很多内容，被分为四种类型，HTTP/1.1 规定了 47 种标准的首部字段：

1. 通用首部行。如下所示：

   | 首部字段名        | 说明                       |
   | ----------------- | -------------------------- |
   | Cache-Control     | 控制缓存的行为             |
   | Connection        | 连接的管理                 |
   | Date              | 创建报文的日期时间         |
   | Pragma            | 报文指令                   |
   | Trailer           | 报文末端的首部一览         |
   | Transfer-Encoding | 指定报文主体的传输编码方式 |
   | Upgrade           | 升级为其他协议             |
   | Via               | 代理服务器的相关信息       |
   | Warning           | 错误通知                   |

2. 请求首部行。如下所示：

   | 首部字段名          | 说明                                          |
   | ------------------- | --------------------------------------------- |
   | Accept              | 用户代理可处理的媒体类型                      |
   | Accept-Charset      | 优先的字符集                                  |
   | Accept-Encoding     | 优先的内容编码                                |
   | Accept-Language     | 优先的语言（自然语言）                        |
   | Authorization       | Web认证信息                                   |
   | Expect              | 期待服务器的特定行为                          |
   | From                | 用户的电子邮箱地址                            |
   | Host                | 请求资源所在服务器                            |
   | If-Match            | 比较实体标记（ETag）                          |
   | If-Modified-Since   | 比较资源的更新时间                            |
   | If-None-Match       | 比较实体标记（与 If-Match 相反）              |
   | If-Range            | 资源未更新时发送实体 Byte 的范围请求          |
   | If-Unmodified-Since | 比较资源的更新时间（与If-Modified-Since相反） |
   | Max-Forwards        | 最大传输逐跳数                                |
   | Proxy-Authorization | 代理服务器要求客户端的认证信息                |
   | Range               | 实体的字节范围请求                            |
   | Referer             | 对请求中URI的原始获取方                       |
   | TE                  | 传输编码的优先级                              |
   | User-Agent          | HTTP客户端程序的信息                          |

3. 响应首部行，如下所示：

   | 首部字段名         | 说明                         |
   | ------------------ | ---------------------------- |
   | Accept-Ranges      | 是否接受字节范围请求         |
   | Age                | 推算资源创建经过时间         |
   | ETag               | 资源的匹配信息               |
   | Location           | 令客户端重定向至指定URI      |
   | Proxy-Authenticate | 代理服务器对客户端的认证信息 |
   | Retry-After        | 对再次发起请求的时机要求     |
   | Server             | HTTP服务器的安装信息         |
   | Vary               | 代理服务器缓存的管理信息     |
   | WWW-Authenticate   | 服务器对客户端的认证信息     |

4. 实体首部行，如下所示：

   | 首部字段名       | 说明                         |
   | ---------------- | ---------------------------- |
   | Allow            | 资源可支持的HTTP方法         |
   | Content-Encoding | 实体主体适用的编码方式       |
   | Content-Language | 实体主体的自然语言           |
   | Content-Length   | 实体主体的大小（单位：字节） |
   | Content-Location | 替代对应资源的URI            |
   | Content-MD5      | 实体主体的报文摘要           |
   | Content-Range    | 实体主体的位置范围           |
   | Content-Type     | 实体主体的媒体类型           |
   | Expires          | 实体主体过期的日期时间       |
   | Last-Modified    | 资源的最后修改日期时间       |

除了上述首部字段，还可以有其他的首部字段，甚至可以自定义首部字段，比如为了实现 Cookie 而设置的 `Cookie` 首部字段等。

###### 实体体

实体体一般只在 POST 请求中使用。它本质上和 URL 的 query 没有区别，可以看作是 POST 方式的请求参数。

##### 响应报文

HTTP 响应报文的格式如下：

![image-20220328230434777](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220328230434777.png)

###### 状态行

状态行包括使用的 HTTP 协议的版本，状态码以及状态短语。

其中最重要的就是状态码，状态短语和状态码是绑定的。

以下是 HTTP 的状态码的简要说明：

![image-20220120114655406](C:\Users\94585\AppData\Roaming\Typora\typora-user-images\image-20220120114655406.png)

详细的 HTTP 状态码和状态短语：

| 状态码 | 短语                            | 中文描述                                                     |
| :----- | :------------------------------ | :----------------------------------------------------------- |
| 100    | Continue                        | 继续。客户端应继续其请求                                     |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于 GET 与 POST 请求                          |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分 GET 请求                      |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替 |
| 302    | Found                           | 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看         |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的 HTTP 状态码                                     |
| 307    | Temporary Redirect              | 临时重定向。与 302 类似。使用 GET 请求重定向                 |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带 Content-Length 的请求信息     |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息 |
| 414    | Request-URI Too Large           | 请求的 URI 过长（URI 通常为网址），服务器无法处理            |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

###### 首部行

首部行和请求报文中的首部行是相同的，**响应中的首部行主要涉及通用的首部行以及响应首部行**。

###### 实体体

实体体是响应的主要部分，比如请求的 HTML 页面代码就在实体体中。

#### HTTP 内容协商

在 HTTP 中，内容协商是一种用于在同一 URL 上提供资源的不同表示形式的机制。

内容协商机制是指**客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源**。

内容协商会以响应资源的语言、字符集、编码方式等作为判断的标准。

![image-20220424151220799](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220424151220799.png)

内容协商主要涉及到的是请求的首部行，主要的几种类型是 `Accept`、`Accept-Charset`、`Accept-Encoding`、`Accept-Language`、`Content-Type` 和 `Content-Language`。

* `Accept`：该首部行会通告客户端自己能够接受的 MIME 类型。

  > **MIME**
  >
  > MIME（Multipurpose Internet Mail Extensions）是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。
  >
  > MIME 通常有如下类型：
  >
  > * 文本文件：text/html、text/plain、text/css、application/xhtml+xml、application/xml
  > * 图片文件：image/jpeg、image/gif、image/png
  > * 视频文件：video/mpeg、video/quicktime
  > * 应用程序二进制文件：application/octet-stream、application/zip
  >
  > 一般 MIME 属性还会配合 `q` 来使用，`q` 标识权重，权重高的会优先使用。
  >
  > 比如：
  >
  > ```http
  > Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 1
  > ```

* `Accept-Charset`：`Accept-Charset` 属性规定服务器处理表单数据所接受的**字符编码**，允许你指定一系列字符集，服务器必须支持这些字符集，从而得以正确解释表单中的数据。

* `Accept-Encoding`：表示 HTTP 标头会标明客户端希望服务端返回的内容编码，**这通常是一种压缩算法**。Accept-Encoding 也是属于内容协商的一部分，使用并通过客户端选择 Content-Encoding 内容进行返回。

* `Accept-Language`：`Accept-Language` 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等)，以及自然语言集的相对优先级。可一次指定多种自然语言集。和 `Accept` 首部字段一样，按权重值 `q` 来表示相对优先级。

* `Content-Type`：`Content-Type` 用于指示资源的 MIME 类型。作为响应，`Content-Type` 告诉客户端**返回内容的内容类型**实际上是什么。

  `Content-type` 有两种值︰`MIME` 类型和字符集编码，例如：

  ```http
  Content-Type: text/html; charset=UTF-8
  ```

* `Content-Encoding`：`Content-Encoding` 实体标头用于**压缩媒体类型**，它让客户端知道如何进行解码操作，从而使客户端获得 `Content-Type` 标头引用的 MIME 类型。表示如下：

  ```http
  Content-Encoding: gzip
  Content-Encoding: compress
  Content-Encoding: deflate
  Content-Encoding: identity
  Content-Encoding: br
  Content-Encoding: gzip, identity
  Content-Encoding: deflate, gzip
  ```

从介绍中我们可以看出，`Content` 开头的是响应中的首部行，其他的都是请求中的首部行，这其实是有一个对应关系的：

![image-20220424154418927](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220424154418927.png)

#### HTTP 缓存技术

对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对请求-响应的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话性能可以得到提升。

HTTP 协议的头部有不少是针对缓存的字段。总体来说，HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。

##### 强制缓存

强制缓存指的是**只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存**，决定是否使用缓存的**主动性在于浏览器这边**。

如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存：

![img](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/1cb6bc37597e4af8adfef412bfc57a42.png)

强缓存是利用下面这两个 HTTP 响应首部行实现的，它们都用来表示资源在客户端缓存的有效期：

- `Cache-Control`， 是一个相对时间
- `Expires`，是一个绝对时间

如果 HTTP 响应头部同时有 `Cache-Control` 和 `Expires` 字段的话，**`Cache-Control` 的优先级高于 `Expires`** 。

`Cache-Control` 选项更多一些，设置更加精细，所以建议使用 `Cache-Control` 来实现强缓存。具体的实现流程如下：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 `Cache-Control`，`Cache-Control` 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 `Cache-Control` 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 `Cache-Control`。

##### 协商缓存

当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 `304`，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。

![image-20220424155700984](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220424155700984.png)

上图就是一个协商缓存的过程，所以**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现。

* 第一种：请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现，这两个字段的意思是：
  * 响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
  * 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 `Last-Modified` 声明，则再次发起请求的时候带上 `Last-Modified` 的时间，服务器收到请求后发现有 `If-Modified-Since` 则与被请求资源的最后修改时间进行对比（`Last-Modified`），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

* 第二种：请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段，这两个字段的意思是：
  * 响应头部中 `Etag`：唯一标识响应资源；
  * 请求头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 `Etag`，则再次向服务器发起请求时，会将请求头 `If-None-Match` 值设置为 `Etag` 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

如果 HTTP 响应头部同时有 `Etag` 和 `Last-Modified` 字段的时候，`Etag` 的优先级更高，也就是先会判断 `Etag` 是否变化了，如果 `Etag` 没有变化，然后再看 `Last-Modified`。

注意，**协商缓存这两个字段都需要配合强制缓存中 `Cache-Control` 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

#### HTTP CORS 跨域

CORS 的全称是 `Cross-Origin Resource Sharing`（CORS），中文译为**跨域资源共享**，它是一种机制。是一种什么机制呢？它是一种让运行在一个域（origin）上的 Web 应用被准许访问来自不同源服务器上指定资源的机制。

在搞懂这个机制前，你需要先了解什么是域（origin）：域也叫源，同源是指**协议+域名+端口**三者相同，即便两个不同的域名指向同一个 ip 地址，也不属于同源。**浏览器默认遵守同源策略，会对不同源的做出限制**，比如 ajax 请求不能发送。

**跨域是指突破浏览器的同源策略**。最常见的跨域是在前后端分离的应用中，前端使用代理访问后端，由于前后端的端口不一致导致不能发送请求到后端。

**解决跨域的最常见办法是使用跨域资源共享 CORS**，CORS 要求服务器和浏览器共同支持。

在浏览器中，请求被分为简单请求和复杂请求。

1. 简单请求。同时满足以下两大条件，就是简单请求：
   1. 请求方法是以下三种方法之一：
      - HEAD
      - GET
      - POST
   2. HTTP 报文的首部行不超出以下几种字段：
      - `Accept`
      - `Accept-Language`
      - `Content-Language`
      - `Last-Event-ID`
      - `Content-Type`：只限于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`
2. 复杂请求。不是简单请求的请求就是复杂请求。

CORS 对简单请求和复杂请求有不同的处理方式：

* **对于简单请求，浏览器直接允许跨域发送**，会在请求报文中带上 `Origin` 的首部行，用于说明本次请求来源于哪里。

  响应时，服务器会多出几个首部行：`Access-Control-Allow-Origin`、`Access-Control-Allow-Credentials`、`Access-Control-Expose-Headers`。

  1. `Access-Control-Allow-Origin` 的值要么是 `Origin` 的值，要么是 `*`。这个首部行表示**所接受的域名**，`*` 表示所有域名。该首部行是必须的。

  2. `Access-Control-Allow-Credentials` 是可选的，取值是布尔值，表示**是否允许 Cookie**。

     不允许时不会设置为 false，而是直接删除该首部行，所以只要它出现了，取值一般就是 true。

  3. `Access-Control-Expose-Headers` 是可选的，用于**限制 AJAX 对象可以拿到的首部行字段**。

     在 CORS 请求中，`XMLHttpRequest` 对象的 `getResponseHeader()` 方法只能拿到 6 个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在 `Access-Control-Expose-Headers` 里面指定。

* 而对于**复杂请求**，首先会进行一个**预检**。**预检请求的方式是 OPTIONS**，首部行除了简单请求也包含的 `Origin` 外，还有：

  1. `Access-Control-Request-Method`：是必须的，用于**列出浏览器的 CORS 请求会用到哪些 HTTP 方法**。
  2. `Access-Control-Request-Headers`：可选的，**指定浏览器 CORS 请求会额外发送的头信息字段**。

  对于这个预检请求的回应，它除了包含简单请求包含的请求行外，还可能有：

  1. `Access-Control-Allow-Methods`：必须的，它的值是逗号分隔的一个字符串，表明**服务器支持的所有跨域请求的方法**。
  2. `Access-Control-Allow-Headers`：如果浏览器请求报文首部行包括 `Access-Control-Request-Headers`，则 `Access-Control-Allow-Headers` 字段是必需的。它也是一个逗号分隔的字符串，表明**服务器支持的所有头信息字段**。
  3. `Access-Control-Max-Age`：可选，用来指定本次**预检请求的有效期**。

  预检完成之后，就是正常的请求/响应。

#### HTTP 断点续传

HTTP 可以支持文件的部分下载，通过保留已获得的信息，此功能允许恢复先前的操作，从而节省带宽和时间。

![image-20220424161637645](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220424161637645.png)

支持断点续传的服务器通过发送 `Accept-Ranges` 标头广播此消息，一旦发生这种情况，客户端可以通过发送缺少范围的 `Ranges` 标头来恢复下载。

![image-20220424161720789](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220424161720789.png)

* `Range`：用于请求报文中，`Range` 指示服务器应返回文档指定部分的资源，可以一次请求一个 `Range` 来返回多部分，服务器会将这些资源返回各个文档中。如果服务器成功返回，那么将返回 206 响应﹔如果 `Range` 范围无效，服务器返回 `416 Range Not Satisfiable` 错误。

  服务器还可以忽略 `Range`标头，并且返回 200 作为响应。

  比如：

  ```http
  Range: bytes=0-499, -500
  ```

  这表示请求的前 500 个字节以及最后 500 个字节。

* `Content-Range`：用于响应头，指定整个实体中的一部分的插入位置，它也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。

  比如：

  ```http
  Content-Range: bytes 200-1000/67589
  ```

  这表示从所有的 67589 个字节中返回 200 ~ 1000 个字节的内容。

#### Cookie 和 Session

**Cookie 和 Session 都是解决 HTTP 无状态的技术。**

##### Cookie

HTTP 协议中的 Cookie 包括 **Web Cookie** 和**浏览器 Cookie**，它是服务器发送到 Web 浏览器的一小块数据。**服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。**

通常，Cookie 用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态就需要用到 Cookie。

Cookie 技术有 4 个组件：

1. 在 HTTP 响应报文中的一个 Cookie 首部行
2. 在 HTTP 请求报文中的一个 Cookie 首部行
3. 在用户端系统中保留有一个 Cookie 文件，并由用户的浏览器进行管理
4. 位于 Web 站点的一个后端数据库。

Cookie 本质上是键值对，在响应中使用首部行 `Set-Cookie: key1=value1;key2=value2;...keyn=valuen` 设置 Cookie，而在请求中使用 `Cookie: key=value` 附带 Cookie 请求。

Cookie 的原理如下：

1. 在用户向服务器发送第一个请求后，服务器发送响应，附带一个 `Set-Cookie` 首部行。

   `Set-Cookie` 的值由服务器产生，表示要求浏览器设置 Cookie。这个值对应数据库中的某一条记录。

2. 浏览器收到 `Set-Cookie` 以后，浏览器就为该站点生成一个 Cookie 文件，存放 `Set-Cookie` 中的内容。

3. 下次再次请求该站点时，浏览器添加 `Cookie` 首部行，即请求时带上 Cookie。

4. 服务器读取该 Cookie ，根据 Cookie 中携带的数据来响应数据。

> **Cookie 的安全问题**
>
> Cookie 是保存在浏览器中的，其内容也无需经过认证就可以直接查看，这意味着 Cookie 是存在安全隐患的。
>
> 现在很多浏览器提供了禁用 Cookie 的选项，用户可以自主选择是否要启用 Cookie。
>
> 对于服务端来说，如果用户选择禁用 Cookie，就必须使用其他方法来代替 Cookie，比如 Session，但是 Session 的其中一种实现方式又依靠 Cookie，这时就必须通过其他手段保证 Session 的正常使用。

###### 会话 Cookie 和持久性 Cookie

* 如果 Cookie 中不包含到期日期，则浏览器将其视为会话 Cookie，会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。
* 如果 Cookie 包含有效期 ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。

比如下面就是一个持久性 Cookie：

```HTTP
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

##### Session

Session 和 Cookie 的原理很相似：**在用户第一次访问服务器后，服务器会生成一个 SessionId，用于标识用户，服务器会保存这个 Session**。在之后的请求中，用户每次请求都带上 SessionId，服务器总是能够识别出来，然后从保存的 Session 中取出数据。

Session 的实现方式有两种：

1. Cookie。通过在 Cookie 中设置 SessionId，就可以实现 Session。

2. URL 重写。此方法根据编程语言的不同实现方式也不一样。以 Java 为例，通过在 URL 中添加**矩阵变量** jsessionid 来实现。比如：

   ![image-20220124103528343](C:\Users\94585\AppData\Roaming\Typora\typora-user-images\image-20220124103528343.png)

   > **矩阵变量**
   >
   > 一般的请求参数以 `?` 开头，`&` 分隔。
   >
   > 而矩阵变量以 `;` 分隔，可以附在 URL 的任意部分后，本质上属于 URL 的一部分。

##### 异同

Session 和 Cookie 都是为了解决无状态而产生的技术，它们之中有一些区别：

1. **存储位置不同**。Session 是由服务器保存，而 Cookie 则是由浏览器保存。

2. **存储容量不同**。Session 的容量无限制，而 Cookie 则是有 4KB 内存的限制，且一个站点一般最多只能有 20 个 Cookie。

3. **安全性不同**。Cookie 在浏览器上任何人都可见，而 Session 保存在服务器上，安全有保障。

   为此，Cookie 和 Session 都有生存时间这个属性，可以设置，表示过了这段时间之后，Cookie 和 Session 就失效了。

4. **对服务器压力不同**。在高并发的站点上，Cookie 由于是浏览器保存，和客户端关系不大，开销小。而 Session 则是存储在服务器上，每一个用户都有一个 Session，开销很大。

### HTTP 的优缺点与发展历程

HTTP 经过许多次更新，现在已经来到了 HTTP/3，使用的最广泛的还是 HTTP/2 和 HTTP/1.1，HTTP 肯定是一代一代在优化的，新版本的 HTTP 会优化老版本的缺点，但是每一代 HTTP 都不是完美的，因此，针对不同的版本的 HTTP，我们有必要了解其优缺点，可以更有针对性的做出优化。

#### HTTP/1.1

HTTP/1.1 是使用的最广泛的版本之一，它的优点很明显：

1. **简单**。HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。

2. **无状态**。因为服务器没有记忆能力，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的CPU和内存用来对外提供服务。

3. **灵活且易于扩展**。HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。

   同时 HTTP 由于是工作在应用层，它的**下层可以随意变化**。比如 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。

4. **应用广泛且跨平台**。互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财等等，HTTP 的应用遍地开花，同时天然具有**跨平台**的优越性。

5. **性能**。这里的性能是相较于 1.0 来说的，早期 HTTP/1.0 性能上是一个很大的问题，每发起一个请求，都要新建一次 TCP 连接，开销很大。

   HTTP/1.1 **使用了 TCP 长连接**（也就是我们之前提到的持续连接）以改善性能，多个请求/响应复用一个 TCP 连接，性能得到了提高。

   除此之外，HTTP/1.1 由于使用了长连接，因此**支持管道传输**，即在同一个 TCP 连接里面，客户端可以同时发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，**减少了整体的响应时间。**但是服务器**必须按照接收请求的顺序发送对这些管道化请求的响应**。

当然，它也有不少的缺点：

1. **无状态**。无状态是双刃剑，在完成有关联性的操作时会非常麻烦。

2. **明文传输**。明文传输也是双刃剑，虽然简单，但是缺点也是显而易见的，就是**不安全**，可以被监听和被窥探。因为无法判断通信双方的身份，不能判断报文是否被更改过。

3. **性能**。性能虽然相比于 1.0 提升了，但是还是比较差，具体来说，会有**队头阻塞**的情况。

   队头阻塞指的是**当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据**。

   刚刚我们说到支持同时发送多个请求，请求没有阻塞，但是**响应时会阻塞，从而导致整个请求看起来是阻塞了**。

4. **头部冗长**。请求 / 响应头部未经压缩就发送，首部附带的信息越多，包越大，整体延迟也就越大。而且，每次互相发送相同的首部，造成的浪费较多。

5. **没有请求优先级控制**。

6. 请求只能从客户端开始，**服务器只能被动响应**。

#### HTTPS

HTTPS 是为了解决 HTTP 的明文传输而诞生的，它在 HTTP 和 TCP 之间添加了一层 SSL/TLS 协议，默认端口号为 443。

HTTP 的明文传输会导致如下风险：

* **窃听风险**：HTTP 的明文传输的内容很容易被获取到，比如通信链路上可以获取通信内容，用户的账号容易被盗窃等。
* **篡改风险**：获取到 HTTP 明文传输的内容后还有可能被篡改，比如强制植入垃圾⼴告等。
* **冒充风险**：比如冒充淘宝网站，用户的财产安全可能受到威胁。

SSL/TLS 协议提供了信息加密、校验机制以及身份证书，用来保证 HTTP 的安全。**要使得网站支持 HTTPS，就要向 CA（证书权威机构）申请证书，表明你的网站可信。**

具体来说，HTTPS 使用了**混合加密**来实现信息的机密性，使用了**摘要算法**来实现信息的完整性，同时因为有**证书**，解决了冒充的风险。

##### 网络安全概念简述

1. **明文**：明文指的是未被加密过的原始数据。

2. **密文**：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。

3. **密钥**：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。

4. **对称加密**：又叫做**私钥加密**，即信息的发送方和接收方使用同一个密钥去加密和解密数据。

   对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密。

   * **加密过程**：明文 + 加密算法 + 私钥 => 密文
   * **解密过程**：密文 + 解密算法 + 私钥 => 明文
   
   由于加密和解密共用一个密钥，因此是个人私有的（算法是公开的，因此密钥肯定不能公开），也叫做私钥，这种方式也叫做对称加密。
   
5. **非对称加密**：也叫做**公钥加密**，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。

   而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。**私钥自己保存，不能对外泄露**；**公钥则是公开的，任何人都可以获得该密钥**。

   加密时需要用公钥加密，而解密则需要私钥。

   * **加密过程**：明文 + 加密算法 + 公钥 => 密文
   * **解密过程**：密文 + 解密算法 + 私钥 => 明文
   
   由于加密和解密使用了两个不同的密钥，这就是被称之为“非对称”的原因。
   
6. **常见加密算法**：根据加密的特点，分为**对称加密算法**和**非对称加密算法**，还存在不需要密钥的**散列算法**。

   对称加密算法：DES、3DES、AES

   非对称加密算法：RSA、DSA

   散列算法：SHA-1、MD5

   对这几种算法的比较如下所示：

   | 名称 | 密钥位数         | 速度 | 安全性 | 资源消耗 |
   | ---- | ---------------- | ---- | ------ | -------- |
   | DES  | 56 位            | 较快 | 低     | 中       |
   | 3DES | 112 位或 168 位  | 慢   | 中     | 高       |
   | AES  | 128、192、256 位 | 快   | 高     | 低       |

   | 名称 | 成熟度 | 速度 | 安全性 | 资源消耗 |
   | ---- | ------ | ---- | ------ | -------- |
   | RSA  | 高     | 中   | 高     | 中       |
   | DSA  | 高     | 慢   | 高     | 高       |

   | 名称  | 速度 | 安全性 |
   | ----- | ---- | ------ |
   | MD5   | 快   | 中     |
   | SHA-1 | 慢   | 高     |

##### 混合加密

HTTPS 采用的是**对称加密**和**非对称加密**结合的**混合加密**方式：

* 在通信建立前采用**非对称加密**的方式交换会话秘钥（即将要使用的对称加密的密钥），后续就不再使用非对称加密。
* 在通信过程中全部使用**对称加密**的会话秘钥的方式加密明文数据。

这是由于加密算法的性能和特点所致，在使用安全性高的非对称加密交换密钥后，就不必担心密钥泄露的风险，之后都可以使用性能高的对称加密。

整个过程如下图所示：

![image-20220124125404358](C:\Users\94585\AppData\Roaming\Typora\typora-user-images\image-20220124125404358.png)

##### 摘要算法

**摘要算法**用来实现**完整性**，能够为数据生成独一无二的**指纹**，用于校验数据的完整性，解决了篡改的风险。

客户端在发送明文之前会通过摘要算法算出明文的**指纹**，发送的时候把**指纹 + 明文**一同加密成密文后，发送给服务器。

服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的**指纹**和当前算出的**指纹**做比较，若**指纹**相同，说明数据是完整的。这很类似于运输层中的校验和。

整个过程如下图所示：

![image-20220124125538516](C:\Users\94585\AppData\Roaming\Typora\typora-user-images\image-20220124125538516.png)

##### 数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用⾃⼰的私钥解密。

这里就存在问题，如何保证公钥不被篡改和信任度？

这里就需要借助第三方权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

整个过程如下图所示：

![image-20220124125708741](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220124125708741.png)

##### SSL/TLS 协议的基本流程

SSL/TLS 协议基本流程：

1. 客户端向服务器索要并验证服务器的公钥。
2. 双方协商生产会话秘钥。
3. 双方采用会话秘钥进行加密通信。

1、2 步就是 SSL/TLS 的建立过程也叫做**握手**，握手的全流程如下（包含 TCP 三次握手）：

![img](https://img-blog.csdnimg.cn/img_convert/cf6df904729f4f3d5427ddd47efcb04e.png)

使用 WireShark 抓包的结果：

![image-20220424173914131](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220424173914131.png)

1. `Client Hello`

   首先，由客户端向服务器发起加密通信请求，也就是 `Client Hello` 请求。

   在这一步，客户端主要向服务器发送以下信息：

   * 客户端支持的 SSL/TLS 协议版本（`Version`），如 TLS 1.2 版本。
   * 客户端生产的随机数（`Client Random`），后面用于生产会话秘钥。
   * 客户端支持的密码套件列表（`Cipher Suites`），如 RSA 加密算法。

2. `Sever Hello`

   服务器收到客户端请求后，向客户端发出响应，也就是 `Sever Hello`。服务器回应的内容有如下内容：

   * 确认 SSL/TLS 协议版本，如果浏览器不支持，则关闭加密通信。
   * 服务器生产的随机数（`Server Random`），后面用于生产会话秘钥。
   * 确认的密码套件列表，如 RSA 加密算法。
   * 服务器的数字证书。

3. 客户端并不会立即回应，而是**首先要验证证书的安全性**。

4. 客户端回应

   如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

   * 一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。
   * **加密通信算法改变通知**，表示随后的信息都将用会话秘钥加密通信。
   * 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

   上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，**各自生成**本次通信的会话秘钥。

5. 服务器的最后回应

   服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的会话秘钥。然后，向客户端发生最后的信息：

   * **加密通信算法改变通知**，表示随后的信息都将用会话秘钥加密通信。
   * **服务器握手结束通知**，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用会话秘钥加密内容，是**对称加密**。

> SSL 和 TLS 是同一个东西，不加以区分。

#### HTTP/2 

HTTP/2 是基于 HTTPS 和 HTTP/1.1 的，所以 HTTP/2 的安全性有了保障。

![image-20220424170013131](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220424170013131.png)

相比于 HTTP/1.1，HTTP/2 做了许多优化：

1. **头部压缩**。如果你同时发出多个请求，它们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。

   这就是 HTTP/2 提出的 **HPACK 算法：在客户端和服务器维护一张头部信息表，为每一个表项生成索引，之后就只需要传输索引**。

2. **二进制帧**。HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式**的报文，并且统称为帧。

   原来的请求行和请求头被封装为**头信息帧**，实体体被封装为**数据帧**：

   ![image-20220124140201918](C:\Users\94585\AppData\Roaming\Typora\typora-user-images\image-20220124140201918.png)

   这样做虽然开发者难以识别报文内容，但是计算机程序却很容易识别出来，增加了数据传输的效率。

3. **数据流**。HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的响应。因此，必须要对数据包做标记，指出它属于哪个响应。

   每个请求或响应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。**不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream**，但是同一个 Stream 的包需要保持有序。

   客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。

4. **多路复用**。HTTP/2 是可以在**一个 TCP 连接中并发多个请求或回应，而不用按照顺序一一对应**。移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就**不会再出现队头阻塞问题**，降低了延迟，大幅度提高了连接的利用率。

   举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是可以先回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。

5. **服务器主动推送**。HTTP/2 还在一定程度上改善了传统的请求/响应⼯作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。

   举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送（Server Push）。

   这和 WebSocket 的主动推送还是有所不同的。

   > **WebSocket**
   >
   > WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行**双向数据传输**。

   HTTP/2 虽然支持服务器推送资源到客户端，但那不是应用程序可以感知的，**主要是让浏览器提前缓存静态资源**，所以我们不能指望 HTTP/2 可以像 WebSocket 建立双向实时通信。

但是，HTTP/2 仍然存在缺点，只不过问题不在 HTTP 层面，而在 TCP 层面：TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，**那么当前 1 个字节数据没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据**，这就是 HTTP/2 队头阻塞问题。

所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**，造成资源浪费。

#### HTTP/3

HTTP/2 的问题已经不是 HTTP 能解决的问题了，问题出现在 TCP 上，因此 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

![image-20220424173732724](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220424173732724.png)

UDP 是尽力交付协议，不管交付的顺序，也不管丢包的情况，所以不会出现 HTTP/1.1 和 HTTP/2 的队头阻塞问题。

可是 UDP 是不可靠传输，缺少了可靠传输的这一部分该怎么办呢？有人基于 UDP，发明了 QUIC 协议，它也属于运输层，可以做到像 TCP 的可靠传输。

具体细节就不详细展示了，现在的问题在于 QUIC 协议不够普及，导致 HTTP/3 也无法普及。因此使用的最多的协议还是 HTTP/1.1 和 HTTP/2。

#### Web 缓存

Web 缓存也叫做**代理服务器（proxy server）**，它是代表 HTTP 服务器来满足用户需求的网络实体。Web 缓存器有自己的磁盘存储空间，并会在存储空间内保存最近请求过的对象，如下图所示：

![image-20220329134329538](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220329134329538.png)

Web 缓存可以在用户的浏览器中进行配置，一旦配置后，用户首先访问的就不是初始服务器了，需要先访问代理服务器判断请求的对象是否存在，如果代理服务器没有，再由代理服务器来请求初始服务器把对象返回给客户，同时在自己的磁盘空间保存对象。

代理服务器的优点：

- 代理服务器可以大大减少对客户请求的响应时间，能够更快给用户响应。
- 代理服务器可以减少一个机构接入链路到网络的通信量，降低网络带宽，降低运营商成本。
- 代理服务器可以分担初始服务器的压力，改善应用程序的性能。

## CDN

几乎所有的大型网站都会使用**内容分发网（Content Distribution Network, CDN）**。CDN 管理分布在多个地理位置上的服务器，在每个服务器上缓存各种视频、音频、文件等。依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，**使用户就近获取所需内容，降低网络拥塞**，提高用户访问响应速度和命中率。

CDN 可以是专用 CDN，即它由内容提供商自己所拥有；另一种 CDN 是第三方 CDN，它代表多个内容提供商分发内容。

工作流程如下图所示：

![image-20220329135055893](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/image-20220329135055893.png)

当用户想要访问指定网站的内容时：

- 首先发起对本地 DNS 的查询，本地 DNS 会将请求中继到网站 DNS 服务器，网站的 DNS 服务器会返回给本地 DNS  一个网站 CDN 权威服务器的地址。
- 本地 DNS 服务器会发送第二个请求给网站 CDN 权威服务器，希望获取网站内容分发服务器的地址，网站 CDN 会把 CDN 内容分发服务器的地址发送给本地 DNS 服务器。
- 本地 DNS 服务器会把网站 CDN 内容分发服务器的地址发送给用户。
- 用户知道网站 CDN 内容分发服务器的地址后，无需额外操作，直接和网站 CDN 内容分发服务器建立 TCP 连接，并且发出 HTTP GET 请求。

## DNS

在互联网的主机使用**主机名（域名）**作为自己的标识，比如百度的域名是 www.baidu.com，谷歌的域名是 www.google.com，但是这是方便我们人类记忆的，计算机并不喜欢这样的标识，计算机更喜欢 **IP 地址**来标识一台主机。

那么，从主机名到 IP 地址需要有一个转换，这个转换就由 DNS（Domain Name System）来提供，它是一个由分层的 DNS 服务器实现的**分布式数据库**；它还是一个使得主机能够查询分布式数据库的**应用层协议**。DNS 协议运行在 UDP 之上，使用 53 端口。

DNS 并不是一个直接和用户打交道的应用层协议，DNS 是为因特网上的用户应用程序以及其他软件提供一种核心功能，它通常为其他应用层协议所使用，这些协议包括 HTTP、SMTP 和 FTP，将用户提供的主机名解析为 IP 地址。

### DNS 流程简述

假设运行在用户主机上的某些应用程序（如 Web 浏览器或邮件阅读器） 需要将主机名转换为 IP 地址：

* 这些应用程序将调用 DNS 的客户端，并指明需要被转换的主机名。
* 用户主机上的 DNS 收到后，会使用 UDP 通过 53 端口向网络上发送一个 DNS 查询报文，经过一段时间后，用户主机上的 DNS 会收到一个主机名对应的 DNS 回答报文。

因此，从用户主机的角度来看，DNS 就像是一个黑盒子，其内部的操作你无法看到。但是实际上，实现 DNS 这个服务的黑盒子非常复杂，它由分布于全球的大量 DNS 服务器以及定义了 DNS 服务器与查询主机通信方式的应用层协议组成。

DNS 最早的一种简单设计只是在因特网上使用一个 DNS 服务器。该服务器会包含所有的映射。这是一种集中式的设计，这种设计并不适用于当今的互联网，因为互联网有着数量巨大并且持续增长的主机，这种集中式的设计会存在以下几个问题

- 单点故障，如果 DNS 服务器崩溃，那么整个网络随之瘫痪。
- 通信容量，单个 DNS 服务器不得不处理所有的 DNS 查询，这种查询级别可能是上百万上千万级
- 远距离集中式数据库(distant centralized database)，单个 DNS 服务器不可能邻近所有的用户，假设在美国的 DNS 服务器不可能临近让澳大利亚的查询使用，其中查询请求势必会经过低速和拥堵的链路，造成严重的时延。
- 维护，维护成本巨大，而且还需要频繁更新。

所以 DNS 不可能集中式设计，它完全没有可扩展能力，因此采用**分布式设计**。

### 分布式，层次数据库

分布式设计首先解决的问题就是 DNS 服务器的扩展性问题，DNS 使用了大量的 DNS 服务器，它们的组织模式一般是层次方式，并且**分布在全世界范围内**。没有一台 DNS 服务器能够拥有因特网上所有主机的映射，相反，这些映射分布在所有的 DNS 服务器上。

大致来说有三种 DNS 服务器：根 DNS 服务器、 顶级域 DNS 服务器和权威 DNS 服务器。这些服务器的层次模型如下图所示：

![img](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/BTCLbq.png)

假设现在一个 DNS 客户端想要知道 www.amazon.com 的 IP 地址，那么上面的域名服务器是如何解析的呢？

* 首先，客户端会与根服务器之一进行关联，它将返回顶级域名 `com` 的 DNS 服务器的 IP 地址。
* 随后，该客户则与顶级域名服务器通信，它将为 amazon.com 返回权威 DNS 服务器的 IP 地址。
* 最后，该客户与 amazom.com 权威服务器通信，返回其 IP 地址。

我们现在来讨论一下上面域名服务器的层次系统

- 根 DNS 服务器：有 400 多个根域名服务器遍及全世界，这些根域名服务器由 13 个不同的组织管理。
- 顶级域 DNS 服务器，对于每个顶级域名比如 com、org、net、edu 和 gov 和所有的国家级域名 uk、fr、ca 和 jp 都有顶级域 DNS 服务器或服务器集群。
- 权威 DNS 服务器，在因特网上具有公共可访问的主机，如 Web 服务器和邮件服务器，这些主机的组织机构必须提供可供访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构的权威 DNS 服务器收藏了这些 DNS 记录。

一般域名服务器的层次结构主要是以上三种，除此之外，还有另一类重要的 DNS 服务器，它是本地 DNS 服务器。

严格来说，本地 DNS 服务器并不属于上述层次结构，但是本地 DNS 服务器又是至关重要的。每个 ISP 都有一台或多台本地 DNS 服务器，当主机发出 DNS 请求后，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次系统中。

## P2P

P2P 的全称是 Peer-to-Peer，是一种分布式体系结构的计算机网络。在 P2P 体系中，所有的计算机和设备都被称为对等体，他们互相交换工作。对等网络中的每个对等方都等于其他对等方。网络中没有特权对等体，也没有主管理员设备。

从某种意义上说，对等网络是计算机世界中最平等的网络。每个对等方都相等，并且每个对等方具有与其他对等方相同的权利和义务。对等体同时是客户端和服务器。

实际上，对等网络中可用的每个资源都是在对等之间共享的，而无需任何中央服务器。P2P 网络中的共享资源可以是诸如处理器使用率，磁盘存储容量或网络带宽等。

P2P 的主要目标是共享资源并帮助计算机和设备协同工作，提供特定服务或执行特定任务。如前面说到的，P2P 用于共享各种计算资源，例如网络带宽或磁盘存储空间。 但是，对等网络最常见的例子是 Internet 上的文件共享。 对等网络非常适合文件共享，因为它们允许连接到它们计算机等同时接收文件和发送文件。

`BitTorrent`（磁力链接）是 P2P 使用的主要协议。

## 其他常见应用层协议

### TELNET

TELNET 又称为远程登录，是一种应用层协议，它为用户提供了在本地机器上就能够操控远程主机工作的能力。例如下面这幅图所示

![img](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/BTCbKs.png)

主机 A 可以直接通过 TELNET 协议访问主机 B。

TELNET 利用 TCP 的一条连接，通过一条连接向主机发送文字命令并在主机上执行。

使用 TELNET 协议进行远程登录时需要满足一下几个条件

- 必须知道远程主机的 IP 地址或者域名
- 必须知道登录标识和口令

TELNET 远程登录一般使用 23 端口

#### SSH

TELNET 有一个非常明显的缺点，那就是在主机和远程主机的发送数据包的过程中是**明文传输**，未经任何安全加密，这样的后果是容易被互联网上不法分子嗅探到数据包来搞一些坏事，为了数据的安全性，我们一般使用 SSH 进行远程登录。

SSH 是**加密的远程登录系统**。使用 SSH 可以加密通信内容，即时数据包被嗅探和抓取也无法破解所包含的信息，除此之外，SSH 还有一些其他功能

- SSH 可以使用更强的认证机制
- SSH 可以转发文件
- SSH 可以使用端口转发功能

**端口转发（Port forwarding）**是 SSH 为网络安全通信使用的一种方法。SSH 可以利用端口转发技术来传输其他 TCP/IP 协议的报文，当使用这种方式时，SSH 就为其他服务在客户端和服务器端建立了一条安全的传输管道。

**端口转发是指将特定端口号所收到的消息转发到指定 IP 地址和端口号的一种机制**。

### FTP

FTP（File Transfer Protocol，文件传输协议）是应用层协议之一。FTP 协议包括两个组成部分，分为 FTP 服务器和 FTP 客户端，其中 FTP 服务器用来存储文件，用户可以使用 FTP 客户端通过 FTP 协议访问位于 FTP 服务器上的资源。

**由于 FTP 传输效率非常高，一般用来在网络上传输大的文件。**

![img](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/BTCIPS.png)

默认情况下 FTP 协议使用 TCP 端口中的 20 和 21 这两个端口，其中 20 用于传输数据，21 用于传输控制信息。FTP TCP 21 号端口上进行文件传输时，每次都会建立一个用于数据传输的 TCP 连接，数据传输完毕后，传输数据的这条连接也会被断开，在控制用的连接上继续进行命令或应答的处理。

![img](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/BTCo8g.png)

### SMTP

SMTP 是 Simple Mail Transfer Protocol，它是应用层协议，用于传输电子邮件。

邮件系统通常含有一个邮件服务器，每个接收方在其中的邮件服务器上会有一个**邮箱**存在，由用户的邮箱管理和维护发送给他的报文。

![img](https://fastly.jsdelivr.net/gh/Faraway002/typora/images/BTCT2Q.png)
